# 2 "lex.mll"
    
    let rcsid = "$Id: lex.nw,v 1.9 2006-03-08 22:33:10 nr Exp $"

    exception Error of string
    let error msg = raise (Error msg)
    
    (*s: prolog *)
    module T = Parse
    (*x: prolog *)
    let nl lexbuf map =
        let next = (Lexing.lexeme_start lexbuf) + 1 in
            Srcmap.nl map next
    (*x: prolog *)
    let return x = fun map -> x
    (*x: prolog *)
    let get         = Lexing.lexeme
    let getchar     = Lexing.lexeme_char
    (*x: prolog *)
    let keywords    = Hashtbl.create 27
    let keyword s   = try Hashtbl.find keywords s with Not_found -> T.ID(s)
    let _ = Array.iter (fun (str,tok) -> Hashtbl.add keywords str tok)
        [| "start"  , T.START
        ;  "term"   , T.TERM
        ;  "type"   , T.TYPE 
        ;  "head"   , T.HEAD
        ;  "tail"   , T.TAIL
        |]
    (*e: prolog *)

# 32 "lex.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\234\255\235\255\236\255\237\255\238\255\239\255\240\255\
    \241\255\242\255\001\000\245\255\246\255\001\000\076\000\151\000\
    \250\255\011\000\002\000\010\000\255\255\001\000\251\255\200\000\
    \247\255\243\255\157\000\251\255\158\000\003\000\009\000\255\255\
    \254\255\253\255\217\000\250\255\064\001\188\000\002\000\201\000\
    \255\255\101\000\253\255\220\000\250\255\251\255\221\000\005\000\
    \254\255\255\255\253\255\013\001\252\255\024\000\006\000\255\255\
    \025\000\254\255\253\255";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\011\000\255\255\255\255\021\000\007\000\006\000\
    \255\255\003\000\021\000\001\000\255\255\002\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\003\000\003\000\003\000\255\255\
    \255\255\255\255\255\255\255\255\004\000\003\000\005\000\001\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\003\000\005\000\
    \255\255\255\255\255\255\255\255\255\255\003\000\003\000\255\255\
    \255\255\255\255\255\255";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\000\000\000\000\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\000\000\021\000\000\000\255\255\
    \000\000\000\000\028\000\000\000\028\000\255\255\255\255\000\000\
    \000\000\000\000\035\000\000\000\255\255\255\255\041\000\255\255\
    \000\000\041\000\000\000\046\000\000\000\000\000\046\000\050\000\
    \000\000\000\000\000\000\053\000\000\000\255\255\056\000\000\000\
    \255\255\000\000\000\000";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\019\000\017\000\255\255\000\000\019\000\000\000\000\000\
    \000\000\000\000\000\000\019\000\023\000\000\000\000\000\019\000\
    \023\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \019\000\000\000\012\000\016\000\255\255\010\000\025\000\011\000\
    \006\000\005\000\019\000\023\000\002\000\018\000\022\000\021\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\007\000\024\000\009\000\033\000\008\000\058\000\
    \057\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\004\000\000\000\003\000\000\000\000\000\
    \000\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\013\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\032\000\042\000\
    \000\000\000\000\000\000\000\000\000\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\027\000\
    \255\255\000\000\000\000\014\000\000\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\023\000\039\000\000\000\000\000\023\000\000\000\030\000\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\039\000\000\000\000\000\000\000\048\000\255\255\
    \023\000\039\000\000\000\022\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\000\000\000\000\
    \000\000\039\000\000\000\038\000\000\000\000\000\045\000\255\255\
    \020\000\255\255\255\255\044\000\255\255\255\255\255\255\000\000\
    \000\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\000\000\000\000\000\000\000\000\000\000\
    \029\000\255\255\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\052\000\000\000\000\000\000\000\
    \047\000\255\255\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\255\255\000\000\000\000\
    \000\000\054\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\000\000\000\000\031\000\255\255\036\000\
    \000\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\040\000\000\000\000\000\049\000\255\255\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\055\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\021\000\255\255\000\000\255\255\255\255\
    \255\255\255\255\255\255\019\000\017\000\255\255\255\255\019\000\
    \017\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\000\000\000\000\038\000\000\000\010\000\000\000\
    \000\000\000\000\019\000\017\000\000\000\000\000\017\000\018\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\013\000\000\000\029\000\000\000\053\000\
    \056\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\000\000\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\030\000\041\000\
    \255\255\255\255\255\255\255\255\255\255\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\026\000\
    \028\000\255\255\255\255\014\000\255\255\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
    \014\000\014\000\014\000\014\000\014\000\014\000\014\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\023\000\039\000\255\255\255\255\023\000\255\255\026\000\
    \028\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\034\000\255\255\255\255\255\255\043\000\046\000\
    \023\000\039\000\255\255\023\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\255\255\255\255\
    \255\255\034\000\255\255\034\000\255\255\255\255\043\000\046\000\
    \000\000\021\000\038\000\043\000\046\000\047\000\054\000\255\255\
    \255\255\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\255\255\255\255\255\255\255\255\255\255\
    \026\000\028\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\051\000\255\255\255\255\255\255\
    \043\000\046\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\041\000\255\255\255\255\
    \255\255\051\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\255\255\255\255\026\000\028\000\036\000\
    \255\255\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\034\000\255\255\255\255\043\000\046\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\051\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255";
  Lexing.lex_base_code = 
   "";
  Lexing.lex_backtrk_code = 
   "";
  Lexing.lex_default_code = 
   "";
  Lexing.lex_trans_code = 
   "";
  Lexing.lex_check_code = 
   "";
  Lexing.lex_code = 
   "";
}

let rec token lexbuf =
    __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 39 "lex.mll"
                            ( fun map -> T.EOF(map) )
# 230 "lex.ml"

  | 1 ->
# 40 "lex.mll"
                            ( fun map -> token lexbuf map )
# 235 "lex.ml"

  | 2 ->
# 41 "lex.mll"
                            ( fun map -> token lexbuf map )
# 240 "lex.ml"

  | 3 ->
# 42 "lex.mll"
                            ( fun map -> nl lexbuf map; token lexbuf map )
# 245 "lex.ml"

  | 4 ->
# 43 "lex.mll"
                            ( fun map -> line lexbuf map 0; token lexbuf map )
# 250 "lex.ml"

  | 5 ->
# 44 "lex.mll"
                            ( fun map ->
                              if Lexing.lexeme_start lexbuf = 0 then
                                (line lexbuf map 0; token lexbuf map)
                              else
                                error "illegal character `#'"
                            )
# 260 "lex.ml"

  | 6 ->
# 50 "lex.mll"
                            ( return (T.INT(int_of_string(get lexbuf))))
# 265 "lex.ml"

  | 7 ->
# 51 "lex.mll"
                            ( return (keyword (get lexbuf)) )
# 270 "lex.ml"

  | 8 ->
# 52 "lex.mll"
                            ( fun map -> 
                              let p = Lexing.lexeme_start lexbuf + 2 in 
                              let s = action lexbuf 0 map (Buffer.create 80) in
                                T.CODE(Srcmap.location map p,s)
                            )
# 279 "lex.ml"

  | 9 ->
# 58 "lex.mll"
                            ( fun map ->
                              let s = string lexbuf map (Buffer.create 80) in 
                                T.STRING(s)
                            )
# 287 "lex.ml"

  | 10 ->
# 62 "lex.mll"
                            ( fun map -> T.CHAR(char lexbuf map) )
# 292 "lex.ml"

  | 11 ->
# 63 "lex.mll"
                            ( return T.PERCENT )
# 297 "lex.ml"

  | 12 ->
# 64 "lex.mll"
                            ( return T.PPERCENT )
# 302 "lex.ml"

  | 13 ->
# 65 "lex.mll"
                            ( return T.LT )
# 307 "lex.ml"

  | 14 ->
# 66 "lex.mll"
                            ( return T.GT )
# 312 "lex.ml"

  | 15 ->
# 67 "lex.mll"
                            ( return T.COLON )
# 317 "lex.ml"

  | 16 ->
# 68 "lex.mll"
                            ( return T.LPAREN )
# 322 "lex.ml"

  | 17 ->
# 69 "lex.mll"
                            ( return T.RPAREN )
# 327 "lex.ml"

  | 18 ->
# 70 "lex.mll"
                            ( return T.LBRACKET )
# 332 "lex.ml"

  | 19 ->
# 71 "lex.mll"
                            ( return T.RBRACKET )
# 337 "lex.ml"

  | 20 ->
# 73 "lex.mll"
                            ( return T.COMMA )
# 342 "lex.ml"

  | 21 ->
# 75 "lex.mll"
                            ( fun map ->
                              error ( "illegal character `"
                                    ^ get lexbuf
                                    ^ "' in specification"
                                    )
                            )
# 352 "lex.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and action lexbuf =
    __ocaml_lex_action_rec lexbuf 26
and __ocaml_lex_action_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 84 "lex.mll"
                            ( fun n map buf ->
                              error "unexpected EOF in semantic action"
                            )
# 365 "lex.ml"

  | 1 ->
# 87 "lex.mll"
                            ( fun n map buf ->
                              if n = 0 then (Buffer.contents buf)
                              else ( Buffer.add_string buf ":}"
                                   ; action lexbuf (n-1) map buf 
                                   )
                            )
# 375 "lex.ml"

  | 2 ->
# 94 "lex.mll"
                            ( fun n map buf ->
                              ( Buffer.add_string buf (get lexbuf)
                              ; action lexbuf (n+1) map buf
                              )
                            )
# 384 "lex.ml"

  | 3 ->
# 101 "lex.mll"
                            ( fun n map buf ->
                              let s = get lexbuf in
                              ( Buffer.add_string buf s
                              ; action lexbuf n map buf
                              )
                            )
# 394 "lex.ml"

  | 4 ->
# 108 "lex.mll"
                            ( fun n map buf -> 
                              ( Buffer.add_char buf '\n'
                              ; nl lexbuf map
                              ; action lexbuf n map buf
                              )
                            )
# 404 "lex.ml"

  | 5 ->
# 114 "lex.mll"
                            ( fun n map buf ->
                              error ("illegal character `"
                                    ^ get lexbuf
                                    ^ "'in action string"
                                    )
                            )
# 414 "lex.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_action_rec lexbuf __ocaml_lex_state

and line lexbuf =
    __ocaml_lex_line_rec lexbuf 34
and __ocaml_lex_line_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 123 "lex.mll"
                        ( fun map l ->
                          error "unterminated line directive" 
                        )
# 427 "lex.ml"

  | 1 ->
# 126 "lex.mll"
                        ( line lexbuf )
# 432 "lex.ml"

  | 2 ->
# 127 "lex.mll"
                        ( fun map l ->
                          let string = get lexbuf in
                          let len    = String.length string in
                          let file   = String.sub string 1 (len-2) in
                          let pos    = Lexing.lexeme_start lexbuf in
                          let loc    = file, l-1, 1 in
                                ( Srcmap.sync map pos loc
                                ; () (* return *)
                                )
                        )
# 446 "lex.ml"

  | 3 ->
# 137 "lex.mll"
                        ( fun map l -> 
                          (* inline'ing the l' expression caused an
                          int_of_string failure with ocamlopt *)
                          let l' = int_of_string (Lexing.lexeme lexbuf)
                          in  line lexbuf map l'
                        )
# 456 "lex.ml"

  | 4 ->
# 143 "lex.mll"
                        ( line lexbuf )
# 461 "lex.ml"

  | 5 ->
# 144 "lex.mll"
                        ( fun map l -> 
                          error "illegal character in line directive"
                        )
# 468 "lex.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_line_rec lexbuf __ocaml_lex_state

and string lexbuf =
    __ocaml_lex_string_rec lexbuf 43
and __ocaml_lex_string_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 150 "lex.mll"
                ( fun map buf -> 
                    error ("end of file in string: " ^ Buffer.contents buf) )
# 480 "lex.ml"

  | 1 ->
# 152 "lex.mll"
                ( fun map buf -> 
                    error ("end of line in string: " ^ Buffer.contents buf) )
# 486 "lex.ml"

  | 2 ->
# 154 "lex.mll"
                ( fun map buf -> 
                  let c = getchar lexbuf 1 in
                  let k = match c with
                      (* | 'n'  -> '\n' *)
                      (* | 't'  -> '\t' *)
                      (* | 'r'  -> '\r' *)
                      | '\n' -> '\n'
                      | _    -> c
                  in   
                     ( Buffer.add_char buf k
                     ; string lexbuf map buf
                     )
                )
# 503 "lex.ml"

  | 3 ->
# 168 "lex.mll"
                ( fun map buf -> 
                   let s = get lexbuf  in
                     ( Buffer.add_string buf s
                     ; string lexbuf map buf
                     )
                )
# 513 "lex.ml"

  | 4 ->
# 174 "lex.mll"
                ( fun map buf -> Buffer.contents buf )
# 518 "lex.ml"

  | 5 ->
# 176 "lex.mll"
                ( fun map buf -> 
                  error ( "illegal character in string: " 
                        ^ Buffer.contents buf
                        ) 
                )
# 527 "lex.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_string_rec lexbuf __ocaml_lex_state

and char lexbuf =
    __ocaml_lex_char_rec lexbuf 51
and __ocaml_lex_char_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 184 "lex.mll"
                ( fun map -> error "end of file in character constant" )
# 538 "lex.ml"

  | 1 ->
# 185 "lex.mll"
                ( fun map ->
                  let c = getchar lexbuf 1 in
                    match c with
                    | 'n'   -> '\n'
                    | 't'   -> '\t'
                    | 'r'   -> '\r'
                    | _     -> c
                )
# 550 "lex.ml"

  | 2 ->
# 194 "lex.mll"
                ( fun map -> getchar lexbuf 0 )
# 555 "lex.ml"

  | 3 ->
# 196 "lex.mll"
                ( fun map -> 
                  error (Printf.sprintf 
                            "illegal character constant: %c"
                            (getchar lexbuf 0))
                )
# 564 "lex.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_char_rec lexbuf __ocaml_lex_state

;;

# 202 "lex.mll"
 
    (*s: epilog *)
    let to_string = function
        | T.ID(s)               -> Printf.sprintf "id(%s)" s
        | T.CODE((f,l,c),s)     -> Printf.sprintf "action(%s)" s 
        | T.INT(d)              -> Printf.sprintf "int(%d)" d
        | T.STRING(s)           -> Printf.sprintf "\"%s\"" (String.escaped s)
        | T.CHAR(c)             -> Printf.sprintf "'%s\'"  (Char.escaped c)

        | T.COLON     -> ":"
        | T.COMMA     -> ","  
        | T.EOF _     -> "<eof>"
        | T.EOL       -> "<eol>"
        | T.GT        -> ">"
        | T.LBRACKET  -> "["
        | T.LPAREN    -> "("
        | T.LT        -> "<"
        | T.PERCENT   -> "%"
        | T.PPERCENT  -> "%%"
        | T.RBRACKET  -> "]"
        | T.RPAREN    -> ")"
        | T.SEMI      -> ";"  
        | T.START     -> "start"  
        | T.TERM      -> "term"
        | T.TYPE      -> "type"  
        | T.HEAD      -> "head" 
        | T.TAIL      -> "tail" 
    (*x: epilog *)
    let scan file =
        let fd          = try open_in file
                          with Sys_error(msg) -> error msg      in
        let finally ()  = close_in fd                           in
        let lexbuf      = Lexing.from_channel fd                in
        let map         = Srcmap.mk ()                          in
        let scanner lb  = token lb map                          in
        let location lb = Srcmap.location map (Lexing.lexeme_start lb) in
        let rec loop lb =
            match scanner lb with
                | T.EOF _   -> ()
                | tok       ->
                    let (file,line,col) = location lb           in
                    let tok             = to_string tok         in
                        ( Printf.printf "%-16s %3d %2d %s\n" file line col tok
                        ; flush stdout
                        ; loop lb
                        )
        in
            ( Srcmap.sync map 0 (file,1,1)
            ; loop lexbuf
            ; finally ()
            )
    (*x: epilog *)
    let main () =
        let argv        = Array.to_list Sys.argv in
            match List.tl argv with
            | file::_   -> scan file; exit 0
            | []        -> error "file name expected on command line"

    (* let _ = main () *)
    (*e: epilog *)

# 632 "lex.ml"

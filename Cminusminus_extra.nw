
\chapter{[[commons2]]}

\section{[[commons2/auxfuns.nw]]}
<<commons2/auxfuns.ml>>=
<<auxfuns.ml>>
@

<<commons2/auxfuns.mli>>=
<<auxfuns.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%
%%% ------------------------------------------------------------------ 
\section{Auxiliaries}
%%% ------------------------------------------------------------------ 
%%
%%This module provides functions we found too useful to hide them in a
%%specific module. They are usually small and generic and one could
%%argue that we found them missing in {\ocaml} standard library.
%%
<<auxfuns.mli>>=
val round_up_to : multiple_of:int -> int -> int
  (* round_up_to n k rounds k up to the nearest multiple of n.
     n must be positive and k must be nonnegative *)

val foldri : (int -> 'a -> 'b -> 'b) -> 'a list -> 'b -> 'b
  (* fold list elements right to left, passing index for List.nth *)

val map_partial : ('a -> 'b option) -> 'a list -> 'b list

val last : 'a list -> 'a (* raises Invalid_argument on empty list *)

val from: int -> upto:int -> int list
  (* from x ~upto:y is the list of integers x, .., y *)

val compare_list : ('a -> 'a -> int) -> 'a list -> 'a list -> int

module List : sig
    val take : int -> 'a list -> 'a list
      (* take the first n elements of a list, or if there are fewer
         than n elements, take the whole list (viva Haskell!) *)
end

module Option : sig 
    val is_some : 'a option -> bool
    val is_none : 'a option -> bool
    val get: 'a -> 'a option -> 'a
    val map : ('a -> 'b) -> ('a option -> 'b option)
end

module String : sig
  val foldr : (char -> 'a -> 'a) -> string -> 'a -> 'a
end

type void = Void of void (* used as placeholder for polymorphic variable *)
@
%%Here is a substring extraction function inspired by Python's [[slice]].
%%The parameters [[start]] and [[stop]] denote which part of [[str]]
%%should be extracted; negative numbers can be used to reference the
%%starting point from the end of the string rather than the beginning.  It
%%is best to think about the [[start]] and [[stop]] indices as pointing
%%between the characters; some examples makes this clear:
<<auxfuns.mli>>=
val substr: int -> int -> string -> string
@
%%
%%\begin{quote}
%%\begin{verbatim}
%%          h  e  l  l  o  _  w  o  r  l  d
%%        0  1  2  3  4  5  6  7  8  9  10 11
%%     -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1  0
%%
%%    substr 0 0 "hello world"            ;; - : string = "hello world"
%%    substr 0 1 "hello world"            ;; - : string = "h"
%%    substr 0 (-1) "hello world"         ;; - : string = "hello worl"
%%    substr (-3) (-1) "hello world"      ;; - : string = "rl"
%%    substr (0) (3) "hello world"        ;; - : string = "hel"
%%\end{verbatim}
%%\end{quote}
%%
%%
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
<<auxfuns.ml>>=
type void = Void of void (* used as placeholder for polymorphic variable *)

module Option = struct
    let is_some = function Some _ -> true  | None -> false 
    let is_none = function Some _ -> false | None -> true
    let get x = function
        | Some y -> y
        | None   -> x
    let map f = function Some x -> Some (f x) | None -> None
end
@ 
<<auxfuns.ml>>=
let round_up_to ~multiple_of:n k = n * ((k+(n-1)) / n)
@ 
<<auxfuns.ml>>=
let foldri f l z =
  let rec next n = function
    | [] -> z
    | x :: xs -> f n x (next (n+1) xs) in
  next 0 l

let rec from first ~upto = 
    if first > upto then [] else first :: from (first+1) ~upto

let substr start stop str = 
    let start = if start <  0 then String.length str + start else start in
    let stop  = if stop  <= 0 then String.length str + stop  else stop  in
        String.sub str start (stop - start)
@
<<auxfuns.ml>>=
module String = struct
  let foldr f s z =
    let rec down_from n z =
      if n < 0 then z else down_from (n-1) (f (String.get s n) z) in
    down_from (String.length s - 1) z
end
@
<<auxfuns.ml>>=
let rec last = function
  | [] -> raise (Invalid_argument "empty list")
  | [x] -> x
  | x :: xs -> last xs
@ 
<<auxfuns.ml>>=
let rec map_partial f = function
  | [] -> []
  | x :: xs ->
      match f x with
      | Some y -> y :: map_partial f xs
      | None -> map_partial f xs
@
<<auxfuns.ml>>=
let rec compare_list cmp x y = match x, y with
| [], [] -> 0
| [], _ :: _ -> -1
| _ :: _, [] ->  1
| x :: xs, y :: ys ->
    match cmp x y with
    | 0 -> compare_list cmp xs ys
    | diff -> diff
@ 
<<auxfuns.ml>>=
module List = struct
  let rec take n xs = match xs with
  | [] -> []
  | _ :: _ when n = 0 -> []
  | x :: xs -> x :: take (n-1) xs
end
@ 
\section{[[commons2/lc.nw]]}
<<commons2/lc.ml>>=
<<lc.ml>>
@

<<commons2/lc.mli>>=
<<lc.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
\section{Lexer Combinators}
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%This module provides lexer combinators (LCs). They can be used for
%%similar purposes as regular expressions: verifying that a string
%%obeys a specified syntax and extracting parts from it.  LCs are
%%not as powerful as regular expression (REs) but do not require
%%preprocessing like REs.
%%  
%%The implementation aims to be reasonable efficient by using
%%indices into the scanned string during the whole scan. However,
%%scanning of long strings (> 1000 chars) should be avoided.       
%%
%%% ------------------------------------------------------------------ 
\subsection{Interface}
%%% ------------------------------------------------------------------ 
%%
<<lc.mli>>=
exception Error of string
@
%%
%%[[Error]] reports the failure of a lexer with a message which is not
%%too descriptive but may help finding unexpected failures. 
%%
<<lc.mli>>=
type 'a lexer
@
%%A lexer scans a string to check that it matches a syntactic structure. 
%%It fails when the string does not match the expected syntactic
%%structure.  A scanner can store results while scanning to a result
%%list.  The type of a single result is [['a]].  Typically will a
%%scanner store substrings from the scanned string and thus [['a]] is
%%[[string]]. 
%%
<<lc.mli>>=
val succeed : 'a lexer
@
%%[[succeed]] is a lexer that always succeeds.  
%%
<<lc.mli>>=
val fail : string -> 'a
@
%%[[fail]] always fails with a descriptve error message. 
%%
<<lc.mli>>=
val any : 'a lexer
@
%%[[any]] consumes just one character when availabe and fails when the
%%end of string is reached. 
%%
<<lc.mli>>=
val eof : 'a lexer
@
%%[[eof]] succeeds when the end of input (i.e.  string) is reached.  It
%%does not consume any character. 
%%
<<lc.mli>>=
val satisfy : (char -> bool) -> 'a lexer
@
%%[[satisfy f]] consumes the next characters successfully when it
%%satisfies predicate [[f]]. 
%%
<<lc.mli>>=
val chr : char -> 'a lexer
@
%%[[chr c]] consumes the next character when it equals [[c]]; fails
%%otherwise. 
%%
<<lc.mli>>=
val str : string -> 'a lexer
@
%%[[str s]] succeeds when the input starts with string [[s]] - in this
%%case it consumes as many characters as [[s]] is long. 
%%
<<lc.mli>>=
val ( *** ) : 'a lexer -> 'a lexer -> 'a lexer
val seq     : 'a lexer -> 'a lexer -> 'a lexer
@
%%[[x *** y]] is a lexer that first uses lexer [[x]] and then scans the
%%remaining input using lexer [[y]].  It fails when any of [[x]] and
%%[[y]] fail.
%%   
%%
<<lc.mli>>=
val ( ||| ) : 'a lexer -> 'a lexer -> 'a lexer
val alt     : 'a lexer -> 'a lexer -> 'a lexer
@
%%[[x ||| y]] scans the input using lexer [[x]]; if [[x]] fails it scans
%%the input again using [[y]].  The lexer fails when [[y]] fails. 
%%
<<lc.mli>>=
val many : 'a lexer -> 'a lexer
@
%%[[many l]] scans the input using lexer [[l]] as many (including zero)
%%times as possible; always succeeds.  Beware:  [[many]] is greedy; i.e.
%%[[many any *** chr 'x']] will always fail because the [['x']] in the
%%input will be consumed by [[many any]]. 
%%
<<lc.mli>>=
val some : 'a lexer -> 'a lexer
@
%%[[some l]] scans the input using lexer one or more times.  [[some]] is
%%greedy -- see also [[many]]. 
%%
<<lc.mli>>=
val opt : 'a lexer -> 'a lexer
@
%%[[opt l]] scans the input using lexer [[l]] when possible; when [[l]]
%%fails the lexer does not consume input and succeeds. 
%%
<<lc.mli>>=
val save : (string -> int -> int -> 'a) -> 'a lexer -> 'a lexer
@
%%
%%[[save f l]] is a lexer [[l]] which uses a function [[f]] to store
%%results to a result list.  Whenever [[l]] sucessfully matches a
%%substring [[f]] is called as [[f str pos len]] where [[str]] is the
%%string actually scanned, [[pos]] is the character in that string that
%%[[l]] matched, and [[len]] is the number of characters [[l]] matched. 
%%The result of [[f]] will be stored in the result list which can be
%%obtained by the [[scan]] function. 
%%   
%%Since lexers built with [[save]] can be arbitrarily nested the
%%order of results in the result list is somewhat counter intuitive. 
%%This is best illustrated by an example:
%%
%%Given a string where the following 4 regions are saved (regions can
%%be nested):
%%        
%%\begin{quote}
%%\begin{verbatim}
%%        O b j e c t i v e C a m l
%%         ( (   )   (   ( ) )   )
%%         1 2   2   3   4 4 3   1 <--- look from here
%%
%%   region 1 = bjectivecam
%%   region 2 =  je
%%   region 3 =      ivec
%%   region 4 =        e
%%\end{verbatim}
%%\end{quote}
%%
%%The result list obtained by [[scan]] is:  region1, region3, region4,
%%region2.  This list ordered by the numbers of the closing
%%parentheses above.  When the matched regions do not nest a
%%[[List.rev]] applied to the result list will reorder the result list
%%into the more intuitive order of opening parentheses.  
%%
<<lc.mli>>=
val saveStr : string lexer -> string lexer
@
%%[[saveStr l]] uses lexer [[l]] to scan the input.  The substring [[l]]
%%matches is stored in the result list which can be obtained with
%%[[scan]].  See [[save]] for the order of the result list.  
%%
<<lc.mli>>=
val scan: string -> 'a lexer -> (int * 'a list)
@
%%[[scan str l]] scans string [[str]] using lexer [[l]]. The result is a
%%pair: the number of characters successfully consumed and the list of
%%stored results. [[scan]] raises [[Error]] when scanning fails. 
%%
<<lc.mli>>=
val scanFrom : int -> string -> 'a lexer -> (int * 'a list)
@
%%
%%[[scanFrom x str l]] scans string [[str]] using lexer [[l]] starting at
%%character [[x]] of [[str]] (first character is 0) and returns the
%%number of characters successfully scanned and the list of results. 
%%   
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<lc.ml>>=
let (=<=) (x:char)   (y:char)   = (=) x y

exception Error of string
let error msg           = raise (Error msg)

let strlen              = String.length     (* string -> int         *)
let get                 = String.get        (* string -> int -> char *)


type region             = int * int
@
%%
%%A lexer takes: the string to scan, the current position in the
%%string, and the list of saved regions. It returns: the number of
%%characters successfully consumed and a new region list. All lexers
%%except [save] pass the region list just trough 
%%
<<lc.ml>>=
type 'a lexer           = string -> int -> 'a list -> (int * 'a list)

(* naming convention: str=actual input, x=current position in str,
   r=region list (all regions saved by the [save] lexer) *)

let succeed str x r     = (0,r)
@ 
%%
<<lc.ml>>=

let fail msg            = error msg
@ 
%%
<<lc.ml>>=
let any                 = fun str x r -> 
                          if x < strlen str 
                          then (1,r)
                          else fail "unexpected eof"
@ 
%%
<<lc.ml>>=
let eof                 = fun str x r ->         
                          if x = strlen str
                          then (0,r)
                          else fail "eof expected"
@ 
%%
<<lc.ml>>=
let satisfy f           = fun str x r ->
                          if x < strlen str && f (get str x)
                          then (1,r)
                          else fail "predicate failed"
@ 
<<lc.ml>>=
let chr c               = satisfy ((=<=) c)
 
@ 
<<lc.ml>>=
let str s               = fun st x r ->    
                          let l = strlen s in
                          let rec loop i =
                              if   i = l 
                              then (l,r)
                              else if s.[i] =<= st.[x+i]
                                  then loop (i+1)
                                  else fail "str failed"
                              in 
                                  loop 0
@ 
<<lc.ml>>=
let seq  l1 l2          = fun str x r ->
                          let (i1,r1) = l1 str  x     r    in
                          let (i2,r2) = l2 str (x+i1) r1   in
                              (i1+i2,r2)
let ( *** ) = seq

@                               
<<lc.ml>>=
let alt l1 l2           = fun str x r ->
                          try l1 str x r with
                              Error _ -> try l2 str x r with
                                  Error _ -> fail "(x ||| y) failed"

                          (* the fun below seems superficial but it is
                             not: it prevents endless recursion in 
                             definitions like "let word = many any"
                             which are caused by strict evaluation
                             *)
let (|||) = alt
@ 
%%
<<lc.ml>>=
let rec many l          = fun str x r ->
                          (l *** many l ||| succeed) str x r 

@ 
<<lc.ml>>=
let some l              = l *** many l

@ 
<<lc.ml>>=
let opt l               = l ||| succeed

@ 
<<lc.ml>>=
let save f l            = fun str x r ->
                          let (i,r') = l str x r   in
                              (i,f str x i :: r')
@ 
%%
<<lc.ml>>=
let saveStr l           = save String.sub l
                              
(* auxilary functions *)

let scanFrom x str lexer    = lexer str x []    
let scan str lexer          = lexer str 0 [] 
@
\section{[[commons2/pc.nw]]}
<<commons2/pc.ml>>=
<<pc.ml>>
@

<<commons2/pc.mli>>=
<<pc.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% l2h substitution cfg CFG
%%% l2h substitution dots ...
%%% l2h substitution AST AST
%%% l2h substitution ast AST
%%% l2h substitution rtl RTL
%%% l2h substitution ir IR
%%% l2h substitution noweb NOWEB
%%% l2h substitution qcc QC--
%%% l2h substitution C C--
%%% l2h substitution PAL C--
%%% l2h substitution pal C--
%%% l2h substitution asdl ASDL
%%% l2h substitution ocaml OCaml
%%% l2h substitution forall forall
%%% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>
%%
%%% ------------------------------------------------------------------  
\section{Parser Combinators}\label{sec:pc}
%%% ------------------------------------------------------------------ 
%%
%%This module provides parser combinators for light weight parsing tasks
%%like parsing a unix command line.  Parser combinators are higher order
%%functions that implement basic parsing tasks.  By combining simple
%%parsers complex parsers can be built easily.  By the use of infix
%%operators the source code of such a parser resembles the grammar that
%%it recognizes.  
%%
%%The parser combinators implemented by this module are inspired by
%%Hutton's article \textit{Higher-Order Functions for Parsing}
%%\cite{hutton:92:jfp}.  The parser described by Hutton use backtracking
%%in case of an unsuccessfull parse and report all possible parses.  For
%%efficiency the parses in this module are greedy:  there is at most one
%%successful parse.  This requires to construct parsers a bit more
%%carefully.
%%
%%% ------------------------------------------------------------------  
\subsection{Interface}
%%% ------------------------------------------------------------------ 
%%
%%A parser takes a list of tokens [['t]] and returns a semantic value
%%[['v]] together with the list of remaining tokens in the input. A
%%successful parse typically means that a parser succeeds and
%%returns with an empty list of remaining tokens.  Since [[parser]] is a
%%keyword in \ocaml~the corresponding type was named [[par].  When a
%%parser fails it raises the [[Error]] exception. 
%%
%%We use the following convention for type variables:  [[t]] for token,
%%[[v]] for semantic value, and [[p]] for parser. 
<<pc.mli>>=
type ('t, 'v) par   = 't list -> 'v * 't list

exception Error     of string
@ 
%%% ------------------------------------------------------------------  
%%\subsubsection{Primitive Parsers}
%%% ------------------------------------------------------------------ 
%%
%%The two simplest parsers are [[fail]] and [[succeed]].  
%%The [[fail msg]] parser consumes no input and fails with message [[msg]].  The
%%[[succeed x]] parser also does not consume any input and returns the
%%semantic value [[x]].
<<pc.mli>>=
val fail:       string -> 'a
val succeed:    'v -> ('t,'v) par 
@ 
%%The [[any]] parser consumes the next token and returns it as
%%semantic value. It fails when there is no next token. 
<<pc.mli>>=
val any: ('t,'t) par
@ 
%%The [[eof]] parser succeeds when the list of tokens is empty and
%%returns unit as semantic value. 
<<pc.mli>>=
val eof: ('t,unit) par
@ 
%%The [[satisfy f]] parser uses a user supplied predicate [[f]] to
%%check the next token in the input.  It succeeds when [[f]] is
%%fulfilled and returns the token as semantic value.  The parser fails
%%when either the input is empty or [[f]] is not fulfilled.
<<pc.mli>>=
val satisfy: ('t -> bool) -> ('t,'t) par
@ 
%%The [[literal x]] parser expects [[x]] as the next token and fails in
%%case the input is empty or not [[x]]. When it succeeds it returns
%%[[x]] as semantic value. The type of [[x]] must be an equality type.
%%The [[literal]] parser can be easily implemented with [[satisfy]] and
%%is a handy shortcut.
<<pc.mli>>=
val literal: 't -> ('t,'t) par
@ 
%%% ------------------------------------------------------------------  
\subsection{Combinators}
%%% ------------------------------------------------------------------ 
%%
%%Parser combinators take parsers, combine them, and return a new
%%parser. When these combinators are defined as infix operators the
%%source code of complex parsers very much looks like a grammar. 
%%
%%The precedence and associativity of infix operators in \ocaml~is
%%determined by the first one or two symbols in an operator.  The
%%precedence and fixity of any operator thus is fixed.  This makes it a
%%bit harder to find operators that look good and have the right fixity. 
%%Table \ref{tab:pc:infix} show the precedence and associativity of the
%%operators used in this module.
%%
%%\begin{table}
%%    \centering
%%
%%    \begin{tabular}{cl}
%%        Operator                    & Associativity \\
%%        \hline
%%
%%        [[***]]  [[**>]]  [[**<]]   & right \\
%%        [[-->]]                     & left  \\
%%        [[|||]]                     & left  \\
%%    \end{tabular}
%%    
%%    \caption{Associativity and relative precedence of some operators.
%%    The precedence of the operators decreases to the bottom of the table}
%%    \label{tab:pc:infix}
%%\end{table}
%%
%%The parser [[x *** y]] parses the input first using [[x]] and then
%%using [[y]] for the remaining input. The parser succeeds when [[x]]
%%and [[y]] succeed and returns a pair of semantic values. Since [[***]]
%%is right associative [[x *** y *** z]] would return a [[(x,(y,z))]]
%%pair as a semantic value.
<<pc.mli>>=
val ( *** ): ('t,'v1) par -> ('t,'v2) par -> ('t,('v1*'v2)) par 
@ 
%%When using a parser like [[literal "-" *** literal any]] the
%%semantic value of the first parser is of little interest.  Therefor
%%two variations of [[***]] are provided that return either the left or
%%right semantic value only:  [[literal "-" **> any]] returns the right
%%semantic value.  The [[**<]] combinators creates a parser that returns
%%only the left semantic value. 
<<pc.mli>>=
val ( **< ): ('t,'v1) par -> ('t,'v2) par -> ('t,'v1) par 
val ( **> ): ('t,'v1) par -> ('t,'v2) par -> ('t,'v2) par 
@ 
%%The [[x ||| y]] parser tries to parse the input using parser
%%[[x]]. If this fails it tries [[y]]; [[x ||| y]] fails when both [[x]]
%%and [[y]] fail. On success the semantic value of the first successful
%%parser is returned.
<<pc.mli>>=
val ( ||| ): ('t,'v)  par -> ('t,'v)  par -> ('t,'v)  par 
@ 
%%To manipulate semantic values returned by a parser use the
%%[[p --> f]] combinator.  It takes a parser [[p]] on the left and a function
%%[[f]] on the right.  The semantic value returned by [[p]] is passed to
%%[[f]] and the value returned by [[f]] is the result of [[p --> f]]. 
%%The [[-->]] combinator models semantic actions in a traditional Yacc
%%parser. 
<<pc.mli>>=
val ( --> ): ('t,'v1) par -> ('v1 -> 'v2) -> ('t,'v2) par
@ 
%%When the semantic value for a parser is fixed one could use [[ p -->
%%(fun _ -> x)]]. The [[return]] function does just this: [[p -->
%%return x]]. So [[return]] is not a parser or parser combinator but a
%%function intended to be used on the rigth hand side of [[-->]].
<<pc.mli>>=
val return: 'v1 -> 'v2 -> 'v1
@ 
%%The precedences of the infix operators are chosen that typical
%%parsers can be written with few extra brackets:
<<example(pc.nw)>>=
        literal "--file" **> any --> fun f -> File(f) 
    ||| literal "--help"         --> return Help
@ 
%%The [[opt p]] parser tries to use [[p]] to parse the input and returns
%%[[Some x]] when [[p]] succeeds,  where [[x]] is the semantic value of
%%[[p]]. In case [[p]] fails [[None]] is returned by [[opt p]].
<<pc.mli>>=
val opt: ('t,'v)  par -> ('t,'v option) par
@ 
%%The [[many p]] parser tries to apply parser [[p]] as often as
%%possible to the input and returns the list of semantic values produced
%%by [[p]]. When [[p]] fails for the first token the returned list is
%%empty. Thus, this parser never fails. 
<<pc.mli>>=
val many : ('t, 'v) par -> ('t, 'v list) par
@ 
%%Note that [[many]] is greedy
%%and thus the following parser will never succeed:
<<example(pc.nw)>>=
    many p *** p
@ 
%%All tokens suitable for [[p]] are already consumed by [[many p]] and
%%thus none is left for the following [[p]].
%%
%%The [[some p]] parser works exactly like [[many p]] but expects at
%%least one token to parse and fails otherwise. It thus returns a non
%%empty list of semantic values.
<<pc.mli>>=
val some: ('t,'v)  par -> ('t,'v list) par
@ 
%%The parsers [[many]], [[some]], and [[opt]] resemble the [[*]],
%%[[+]], and [[?]] operator in regular expressions. But due to the greedy
%%nature of [[many]] and [[some]] their behaviour is not quite the same.
%%
%%% ------------------------------------------------------------------  
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%Every parser returns a pair of its result and the list of remaining
%%tokens.  We use the following convention for type and value variables: 
%%[[t]] for token, [[ts]] for token list, [[v]] for semantic value, and
%%[[p]] for parser. 
%%
<<pc.ml>>=
exception Error of string
let error s = raise (Error s)

type ('t,'v) par = 't list -> 'v * ('t list)
@
%%
%%% ------------------------------------------------------------------  
%%\subsubsection{Primitive Parsers}
%%% ------------------------------------------------------------------  
%%
<<pc.ml>>=
let succeed v ts = (v,ts)
let fail msg     = error msg

let any = function
    | []        -> fail "token expected but none found"
    | t::ts     -> succeed t ts

let eof = function
    | []        -> succeed () []
    | _         -> fail "end of input expected but token found"

let satisfy f = function 
    | []        -> fail "satisfy parser: no input" 
    | t::ts     -> if f t 
                   then succeed t ts
                   else fail "token does not satisfy predicate"

let literal x = satisfy (Pervasives.(=) x)
@
%%
%%% ------------------------------------------------------------------  
%%\subsubsection{Parser combinators}
%%% ------------------------------------------------------------------ 
%%
%%Complex parsers are built by combining simpler ones using the parser
%%combinators like this: [[let word = many any]]. We have to be careful
%%about the strict evaluation of \ocaml~when defining combinators in
%%terms of other combinators. For example [[many]] could be defined like this:
<<example(pc.nw)>>=
let rec many p =     p *** (many p) --> (fun (x,y) -> x::y  
                 ||| succeed []
@
%%Defining [[word]] as [[many any]] will then lead to endless recursion
%%when the module containing the definition of [[word]] is loaded.
<<example(pc.nw)>>=
many any = any *** many any
@
%%Because of this we introduce extra abstractions at [[***]] and [[many]].
%%
%%The precedence and associativity of infix operators on \ocaml;
%%operators with higher precedence come first. The table was extracted
%%from the \ocaml~scanner source code
<<precedence>>=
     %right INFIXOP4                         /* **           */
     %left  INFIXOP3 STAR                    /* * / %        */
     %left  INFIXOP2 SUBTRACTIVE             /* + -          */
     %right INFIXOP1                         /* @ ^          */
     %left  INFIXOP0 EQUAL LESS GREATER      /* = < > | ^ $  */
@
%$
<<pc.ml>>=
let ( ||| ) p1 p2 = fun ts ->
    try p1 ts with 
    Error _ ->  try p2 ts with
                Error _ -> fail "all alternatives failed"

let ( --> ) p f = fun ts ->
    let (v,ts') = p ts 
    in (f v, ts')

let return x = fun _ -> x

let ( *** ) p1 p2 = fun ts -> 
    let (v1,ts1) = p1 ts  in
    let (v2,ts2) = p2 ts1 in
        ((v1,v2),ts2)

let ( **> ) p1 p2 =
    p1 *** p2 --> snd

let ( **< ) p1 p2 =
    p1 *** p2 --> fst

let rec many p = fun ts ->
    (      p *** (many p) --> (fun (x,y)->x::y)
        ||| succeed []
    ) ts 

let opt p =
        p --> (fun x -> Some x)
    ||| succeed None

let some p =
    p *** many p --> (fun (x,y) -> x::y)
@
\section{[[commons2/pc2.nw]]}
<<commons2/pc2.ml>>=
<<pc2.ml>>
@

<<commons2/pc2.mli>>=
<<pc2.mli>>
@

%%
%%% ------------------------------------------------------------------ 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
\section{Alternative Parser Combinators}
%%% ------------------------------------------------------------------ 
%%
<<pc2.mli>>=
(*  ------------------------------------------------------------------ 

    $Id: pc2.nw,v 1.3 2002-06-05 19:32:14 lindig Exp $
  
    This module provides parser combinators.  Parsers are build from
    primitive parsers which can be combined to larger paresers by
    parser combinators.  Parser combinators are described in the
    following article:
  
        Graham Hutton, Higher-Order Functions for Parsing, J of
        Functional Programming 2(3):323-343, July 1992
  
    Parsers in this implementation do not return a list of results but
    only one result for efficency reasons.
    ------------------------------------------------------------------ *)
    

exception Error of string
(* [Error] reports parse errors *)

type ('t, 'v) par   = 't list -> 'v * 't list

(* A parser [par] takes a list of tokens ['t] and returns a value ['v]
   together with a remaining ['t list] of unconsumed tokens.  BTW: 
   "parser" is a keyword in OCaml and so could not be used for the
   type declaration.

   This module provides functions to create primitve parsers and
   parser combinators which combine parsers to new parsers. The
   primitive parsers are declared first.

   All parsers are greedy - so beware: although they look much like
   regular expressiones they have different semantics. 
*)


val succeed: 'v -> ('t,'v) par 
(* [succeed] consumes no token and returns result v *)

val fail: string -> 'a
(* [fail] raises [Error] with a descriptive message *)

val any: ('t,'t) par
(* [any] consumes the next token and returns it as result.  Fails if
   there is no next token *)

val eof: ('t,bool) par
(* [eof] succeeds when the end of input is reached, that is, there
   are no more tokens to consume *)

val satisfy: ('t -> bool) -> ('t,'t) par
(* [satisfy f] returns the next token as result if it satisfies
   predicate [f], fails otherwise *)

val literal: 't -> ('t,'t) par
(* [literal x] succeeds if the next token is [x], fails otherwise *)

(*
 *  Parser combinators - they combine existing parsers to new ones.
 *  Precedence of the new operators; operators that bind more tightly 
 *  (have higher precedence) come first:
 *
 *  p1 *-* p2, f % p    both left associative
 *  p1 <|> p2           left associative
 *
 *  A typical production looks like this:
 *
 *  let plus =    (fun left _ right -> left + right)
 *              % mult *-* literal "+" *-* mult
 *  
 *  First comes the semantic action with a parameter for each 
 *  parser in the following sequence (*-*) of parsers.
 *  Semantic actions (%) and sequences (*-*) interact very closely with
 *  each other. It is nearly impossible to have a sequence without a
 *  semantic action. 
 *)  
 
val (<|>) : ('t,'v) par -> ('t,'v) par -> ('t,'v)  par
(* [p1 <|> p2] succeeds when either [p1] or [p2] succeeds. [p1] is tried 
 * first and only when it fails [p2] is tried. Both parsers must
 * return a semantic value of the same type.  
 *)
 
val ( *-* ) : ('t, 'y -> 'z) par -> ('t, 'y) par -> ('t, 'z) par
(* [p1] is used to parse the input and then
 * [p2] the remaining input.  [p1 *-* p2] applies the function
 * returned by parser [p1] to the result of parser [p2]. This operator 
 * interacts with the [%] operator which helps to provide the right
 * functions for [p1].
 *)

val (%) : ('x -> 'y) -> ('t, 'x) par -> ('t, 'y) par
(* [f % p] applies [f] to the semantic value returned by parser [p].
 * See above for the interaction with the sequence operator [*-*].
 *)  

 val many: ('t,'v)  par -> ('t,'v list)   par
(* [many p] applies p as often as possible to the input and 
 * returns a list of results *)
   
val some: ('t,'v)  par -> ('t,'v list) par
(* [some p] tries to apply [p] as often as possible to the input, at
 * least one time.  Returns a list of length >= 1 on success.  *)

val opt: ('t,'v)  par -> 'v -> ('t,'v) par
(* [opt p v] tries to apply [p] to the input and returns its sementic value on success
 * and [v] if [p] fails.  *)
@
%%
<<pc2.ml>>=
(*  ------------------------------------------------------------------ 
    $Id: pc2.nw,v 1.3 2002-06-05 19:32:14 lindig Exp $

    Copyright (c) 1999 Christian Lindig <lindig@ips.cs.tu-bs.de>. All
    rights reserved. See COPYING for details.
  
    This module provides parser combinators.  Parsers are build from
    primitive parsers which can be combined to larger paresers by
    parser combinators.  Parser combinators are described in the
    following articles:
  
        Graham Hutton, Higher-Order Functions for Parsing, J of
        Functional Programming 2(3):323-343, July 1992

        Deterministic, Error-Correcting Combinator Parsers, 
        S. Doaitse Swierstra and Luc Dupomched, Dept. of Computer
        Science, Utrecht University, http://www.cs.ruu.nl 
        
    The parsers and combinators in this module are a mixture of the 
    above cited approaches.
    ------------------------------------------------------------------  *)

(* error reporting, used for parse errors *)
    
exception Error of string
let error s = raise (Error s)

(*  ------------------------------------------------------------------ 
    Every parser returns a pair: result * (remaining_token list) 
    Naming conventions: t=token, ts=token list, v=value, p=parser
    ------------------------------------------------------------------  *)

type ('t,'v) par = 't list -> 'v * ('t list)

(*  ------------------------------------------------------------------ 
    Primitive parsers - they can be combined to larger parsers using
    the parser combinators from below.
    ------------------------------------------------------------------  *)

let succeed v ts = (v,ts)
let fail msg     = error msg

let any = function
    | []        -> fail "token expected but none found"
    | t::ts     -> succeed t ts

let eof = function
    | []        -> succeed true []
    | _         -> fail "end of input expected but token found"

let satisfy f = function 
    | []        -> fail "satisfy parser: no input" 
    | t::ts     -> if f t 
                   then succeed t ts
                   else fail "token does not satisfy predicate"

let literal x = satisfy ((=) x)

(* ------------------------------------------------------------------  
    From the OCaml lexer: all infix operators. Operators with
    lower precedence come first
    
    %left  INFIXOP0 EQUAL LESS GREATER      /* = < > | ^ $  */
    %right INFIXOP1                         /* @ ^          */
    %left  INFIXOP2 SUBTRACTIVE             /* + -          */
    %left  INFIXOP3 STAR                    /* * / %        */
    %right INFIXOP4                         /* **           */
    ------------------------------------------------------------------ *) 

let (<|>) p1 p2 = fun ts ->
    try p1 ts with 
    Error _ ->  try p2 ts with
                Error _ -> fail "all alternatives failed"

let ( *-* ) p1 p2 = fun ts0 ->
    let (f,ts1)  = p1 ts0 in
    let (v,ts2)  = p2 ts1 in
     (f v, ts2)

let (%) f p = (succeed f) *-* p 

let opt p v = p <|> succeed v

let rec many p = fun ts ->
    ((fun x xs -> x::xs) 
  % p *-* (many p <|> succeed [])) ts
    
let some p = 
    (fun x xs -> x::xs) 
  % p *-* many p
@
%$
\section{[[commons2/pp.nw]]}
<<commons2/pp.ml>>=
<<pp.ml>>
@

<<commons2/pp.mli>>=
<<pp.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%\def\ocaml{\textsc{ocaml}}
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% l2h substitute ocaml OCaml
%%
%%% ------------------------------------------------------------------  
\section{Pretty Printer}
%%% ------------------------------------------------------------------ 
%%
%%
%%Pretty printing is the problem of finding a good layout for structured
%%text under some constraints.  John Huges has advanced the design of
%%pretty printers considerably by taking an algebraic approach
%%\cite{HughesJohn1995c}:  Pretty printers are a set of operators like
%%horizontal or vertical concatenation which obey algebraic rules.  This
%%has lead to a consistent pretty printing library; a variant of
%%his library is part of some Haskell \cite{HughesJohn1995c}
%%implementations.  Based on Hughes' work Philip Wadler has proposed
%%another algebraic pretty printer \cite{wadler:98:pp,wadler:99:pp}.  It
%%uses only six operators and a uniform document model that is well
%%suited for pretty printing tree structures like source code.  Like
%%Hughes' he has also suggested an implementation of his approach in the
%%functional language Haskell.  It relies heavily on the lazy evaluation
%%of Haskell and can not be easily ported to a strict language without
%%loss of efficiency.  This module implements the pretty printer as
%%proposed by Wadler but adopted for the strict evaluation of \ocaml. 
%%
%%
%%% ------------------------------------------------------------------  
\subsection{Interface}
%%% ------------------------------------------------------------------  
%%
%%The pretty printer provided by the [[Pp]] module is intended for
%%tree-like structures.  Documents are represented by an abstract type
%%[[doc]].  A document can be printed to a file or a string and during
%%this process the pretty printer decides about the final outcome of the
%%document.  The only parameter it takes into account is the total line
%%width and the number of characters a sub-document occupies.
%%
%%A document of type [[doc]] can be very small entity like a single
%%word.  Functions combine small documents to larger ones which then can
%%be pretty printed.
%%
<<pp.mli>>=
type doc

@ 
%%The empty document is pretty printed to the empty string. Typically
%%[[empty]] is used in one branch of an [[if]] statement.
%%
<<pp.mli>>=
val empty : doc

@ 
%%The infix operator [[x ^^ y]] concatenates two documents [[x]] and
%%[[y]] into a larger one.  It does not introduce any space or other
%%separation between the two original documents. 
%%
<<pp.mli>>=
val (^^) : doc -> doc -> doc

@ 
%%The [[text]] function turns a string into a document. The pretty printed
%%representation of the resulting document is exactly the string [[text]]
%%was applied to. 
%%
<<pp.mli>>=
val text : string -> doc

@ 
%%The important points in a document are so-called [[break]]s.  A
%%[[break]] can be either represented by a single space or a newline
%%followed by a number of spaces.  The pretty printer makes this
%%decision based on the available space.  So think of a [[break]] as a
%%space that might come out as a newline.  To give the pretty printer
%%enough flexibility documents must be joined with [[break]]s:  [[x ^^
%%break ^^ y]]. 
%%   
<<pp.mli>>=
val break : doc

@ 
%%The space character used by [[break]] my be not always appropriate. 
%%The function [[breakWith s]] behaves like [[break]] except that it
%%uses a user supplied string [[s]] instead of the space.
%%
<<pp.mli>>=
val breakWith : string -> doc

@ 
%%% ------------------------------------------------------------------  
%%\subsubsection{Nesting and Grouping}
%%% ------------------------------------------------------------------  
%%
%%When the pretty printer decides to represent a [[break]] as a
%%newline it also prints some spaces after it to indent the following
%%line.  The number of spaces is controlled by the [[nest]] operator
%%that takes a document as argument:  [[nest n d]].  All breaks turned
%%to newlines inside document [[d]] are followed by [[n]] spaces.  The
%%[[nest]] operator nests properly such that it takes the spaces
%%introduced by [[nest]]s on the outer level also into account.
%%
<<pp.mli>>=
val nest : int -> doc -> doc

@ 
%%The pretty printer considers the representation of [[break]]s not
%%one by one but looks at all [[break]]s of a sub-document. Documents
%%are structured into sub-documents by group-operators. Different group
%%operators exist to control the behavior of the pretty printer. 
%%
%%A group operator takes a document and let it become a group.  The
%%[[hgrp]] operator creates a \textit{horizontal} group.  Breaks inside
%%a [[hgrp]] are never turned into newlines but always come out as
%%spaces.  This group has a very limited usefulness because it easily
%%overruns any given line length. 
%%
<<pp.mli>>=
val hgrp : doc -> doc
    
@ 
%%The [[vgrp]] operator creates a \textit{vertical} group.  All
%%[[break]]s inside a [[vgrp]] are represented as newlines followed by
%%spaces.  Although all [[break]]s come out as newlines the indentation
%%of lines inside the group may differ:  nesting is independent of
%%grouping and thus different nesting levels can be active in the same
%%group.  Because of the fixed pretty printing strategy [[vgrp]]s are
%%used mostly at the top level of documents only.
%%
<<pp.mli>>=
val vgrp : doc -> doc

@ 
%%The \textit{automatic} group [[agrp]] is the most versatile.  Breaks
%%inside this group are either all turned into newlines (followed by
%%spaces), or into spaces.  Subgroups are, of course, not affected but
%%considered individually. 
%%   
%%To determine whether to turn [[break]]s into spaces or newlines the
%%pretty printer looks at the length of the document when all [[breaks]]
%%inside are printed as spaces, included those inside sub-groups.  In
%%case the documents fits into the rest of the current line the pretty
%%printer will print [[break]]s as spaces.  Otherwise [[break]]s will
%%become newlines.
%%
%%Typically [[agrp]]s are nested into each other.  Because the larger
%%groups on the outer levels typically do not fit into one line their
%%[[break]]s are turned into spaces.  This keeps lines short and makes
%%room for the smaller inner groups.  Chances are good that these
%%will fit into a line and thus their [[break]]s come out as spaces.
%%
<<pp.mli>>=
val agrp : doc -> doc

@ 
%%The break policy inside an [[agrp]] is fixed for all breaks of the
%%group.  Inside a \textit{flexible} group [[fgrp]] each [[break]] is
%%considered individually:  when the document up to the next [[break]]
%%fits into the current line the [[break]] comes out as space. 
%%Otherwise it comes out as newline followed by spaces. 
%%
<<pp.mli>>=
val fgrp : doc -> doc

@ 
%%% ------------------------------------------------------------------  
%%\subsubsection{Pretty Printing}
%%% ------------------------------------------------------------------  
%%
%%After small documents have been assembled to a larger one this finally
%%can be printed either to a string, or a file.  Printing to a string is
%%a costly operation and should be avoided for large documents.  Both
%%functions for pretty printing take a line width as argument.  The
%%pretty printer tries hard not to overrun this limit.  However, very
%%long [[text]] documents or [[hgrp]]s can cause overruns anyway. 
%%
%%It is usually a good idea to stress test your document by looking at
%%output printed for a small line width.  This helps to detect flaws in
%%the document creation.
%%
%%The documents passed to the pretty printing functions are wrapped by
%%a virtual [[agrp]]. To escape from this default behavior you can
%%easily wrap your document on the outer level with another group such
%%that the [[agrp]] will have no effect.
%%
<<pp.mli>>=
val ppToString : int -> doc -> string
val ppToFile : out_channel -> int -> doc -> unit
@
%%
%%% ------------------------------------------------------------------  
%%\subsubsection{Auxiliaries}
%%% ------------------------------------------------------------------ 
%%
%%When using the prerry printer it turned out that some functions are
%%frequently defined. Here are some they:
%%
%%
%%
%%A list of objects which are seperated by some seperator is very
%%common.  The [[list sep f]] function takes care to insert the
%%separator only bewteen objects but not at the end of the list.  It
%%creates a [[sep]] separated list.  Individual items are printed using
%%[[f]].  For the common case where commas are used for separating we
%%also provide an extra definition.
%%
<<pp.mli>>=
val list      : doc -> ('a -> doc) -> 'a list -> doc 
val commalist :        ('a -> doc) -> 'a list -> doc

@ 
%%Instead of writing [[x ^^ break ^^ y]] to insert a [[break]] it is
%%convenient to define an operator for this: [[x ^/ y]] joins [[x]] and
%%[[y]] with a [[break]].
%%
<<pp.mli>>=
val (^/)      : doc -> doc -> doc

@ 
%%A [[block]] contains objects [[xs]] formatted by [[f]] and enclosed
%%by curly braces.  Its body will be indented in case it does not fit on
%%a single line. 
%%
<<pp.mli>>=
val block     : ('a -> doc) -> 'a list -> doc
@
%%
%%% ------------------------------------------------------------------  
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%Users buld document of type [[doc]].  The different kinds of documents
%%are mapped to different constructors. 
%%
<<pp.ml>>=
<<auxiliaries(pp.nw)>>
<<gmode>>

type doc =
    | DocNil
    | DocCons           of doc * doc
    | DocText           of string
    | DocNest           of int * doc
    | DocBreak          of string
    | DocGroup          of gmode * doc

@ 
%%There are four different kinds of groups or modes at the user level;
%%they are captured by [[gmode]]. The names used for the different
%%groups do not match the names of the functions in the interface---this
%%is a historic legacy.
%%
<<gmode>>=
type gmode =
    | GFlat             (* hgrp *)
    | GBreak            (* vgrp *)
    | GFill             (* fgrp *)
    | GAuto             (* agrp *)

@ 
%%The constructor functions are mapped straight to the [[doc]] type.
%%When [[debug]] is [[true]] additional markup for the groups with
%%run time computed pretty printing is added.
%%
<<pp.ml>>=

let (^^) x y            = DocCons(x,y)
let empty               = DocNil
let text s              = DocText(s)
let nest i x            = DocNest(i,x)
let break               = DocBreak(" ")
let breakWith s         = DocBreak(s)

let hgrp d              = DocGroup(GFlat, d)
let vgrp d              = DocGroup(GBreak,d)
let agrp d              = if   debug
                          then DocGroup(GAuto, text "[" ^^ d ^^ text "]")
                          else DocGroup(GAuto, d)
let fgrp d              = if   debug
                          then DocGroup(GFill, text "{" ^^ d ^^ text "}")
                          else DocGroup(GFill, d)
                          
@ 
%%Pretty printing takes two steps:  users build documents of type
%%[[doc]].  The pretty printer transforms a [[doc]] value into a simple
%%document of type [[sdoc]].  The transformation from [[doc]] to
%%[[sdoc]] decides about the representation of each [[break]] in the
%%original document.  A [[sdoc]] value can be easily printed into a
%%string or file.  The algebraic properties of the pretty printer
%%guarantee that every [[doc]] value can be turned into a much more
%%restricted [[sdoc]] value. 
%%
%%A [[sdoc]] value is either an empty document ([[SNil]]), or a literal
%%text followed by some [[sdoc]] ([[SText]]), or a newline, followed by
%%a number of spaces and another [[sdoc]] value. 
%%
<<pp.ml>>=
type sdoc =
    | SNil
    | SText             of string * sdoc
    | SLine             of int    * sdoc    (* newline + spaces *)

@ 
%%Printing a [[sdoc]] value to a string or file is straight forward. 
%%The [[oc]] parameter for [[sdocToFile]] is an open file channel. For
%%efficiency, the [[sdocToString]] function uses the imperative [[Buffer]]
%%interface.
%%
<<pp.ml original>>=
let rec sdocToString = function
    | SNil              -> ""
    | SText(s,d)        -> s ^ sdocToString d
    | SLine(i,d)        -> let prefix = String.make i ' ' 
                            in  nl ^ prefix ^ sdocToString d
@
%%
<<pp.ml>>=
let sdocToString sdoc =
    let buf = Buffer.create 256 in
    let rec loop = function
        | SNil              -> ()
        | SText(s,d)        -> ( Buffer.add_string buf s
                               ; loop d
                               )
        | SLine(i,d)        -> let prefix = String.make i ' ' in
                               ( Buffer.add_char   buf '\n'
                               ; Buffer.add_string buf prefix
                               ; loop d
                               )
    in
        ( loop sdoc
        ; Buffer.contents buf
        )

let sdocToFile oc doc = 
    let pstr = output_string oc in
    let rec loop = function
        | SNil          -> () 
        | SText(s,d)    -> pstr s; loop d
        | SLine(i,d)    -> let prefix = String.make i ' ' 
                           in  pstr nl;
                               pstr prefix;
                               loop d
    in
        loop doc

@ 
%%During pretty printing [[break]]s in [[agrp]]s are either turned
%%into spaces or newlines.  After this decision is made only three
%%groups or modes remain:
%%
%%\begin{itemize}
%%\item [[Flat]]:  every [[break]] is printed as space.
%%\item [[Break]]: every [[break]] is printed as newline.
%%\item [[Fill]]:  a [[break]] at the end of the line is printed as
%%                 newline and as space otherwise. 
%%\end{itemize}
%%
<<pp.ml>>=
type mode =
    | Flat
    | Break
    | Fill

@ 
%%Pretty printing means do decide whether an [[agrp]]'s [[break]]s are
%%spaces or newlines.  This is done by [[format]] that takes three
%%arguments:  the (maximal) line width [[w]], the number of characters
%%used already used on the current line [[k]], and a list of documents. 
%%The list results from flattening the tree-structure introduced by the
%%[[DocCons]] constructor. 
%%
%%Each document in the list comes with two more informations:  the
%%number [[i]] of spaces that are to be printed after a newline, and the
%%[[mode]] (or group) the document is part of.  The mode [[m]] dictates
%%the appearance of [[break]]s:  inside a [[Flat]] group a
%%[[DocBreak(s)]] just becomes [[s]] (usually a space), inside a
%%[[Break]] group a [[DocBreak(s)]] becomes a newline followed by [[i]]
%%spaces.  When in [[Fill]] mode [[break]]s only become a newline in
%%case otherwise the current line length would be exceeded. 
%%
%%The mode [[m]] is derived from the original group which is straight
%%forward except for an [[agrp]].  To decide about the mode for the
%%contents of an [[agrp]] [[format]] uses [[fit]] to check, whether the
%%whole group fits into the rest of the line.  In case it does, the mode
%%will be [[Flat]] which means its [[break]]s will be spaces. 
<<pp.ml>>=
<<fits>>

(* format is cps to avoid stack overflow *)
let cons  s post z = post (SText (s, z))
let consl i post z = post (SLine (i, z))
let rec format w k l post = match l with
    | []                             -> post SNil
    | (i,m,DocNil)              :: z -> format w k z post
    | (i,m,DocCons(x,y))        :: z -> format w k ((i,m,x)::(i,m,y)::z) post
    | (i,m,DocNest(j,x))        :: z -> format w k ((i+j,m,x)::z) post
    | (i,m,DocText(s))          :: z -> format w (k + strlen s) z (cons s post)
    | (i,Flat, DocBreak(s))     :: z -> format w (k + strlen s) z (cons s post)
    | (i,Fill, DocBreak(s))     :: z -> let l = strlen s in
                                            if   fits (w - k - l) z 
                                            then format w (k+l) z (cons s post)
                                            else format w  i    z (consl i post)
    | (i,Break,DocBreak(s))     :: z -> format w i z (consl i post)
    | (i,m,DocGroup(GFlat ,x))  :: z -> format w k ((i,Flat ,x)::z) post
    | (i,m,DocGroup(GFill ,x))  :: z -> format w k ((i,Fill ,x)::z) post
    | (i,m,DocGroup(GBreak,x))  :: z -> format w k ((i,Break,x)::z) post
    | (i,m,DocGroup(GAuto, x))  :: z -> if fits (w-k) ((i,Flat,x)::z)
                                        then format w k ((i,Flat ,x)::z) post
                                        else format w k ((i,Break,x)::z) post
@
%%The [[fits]] predicate treats all groups it encounters as flat groups. 
%%This implements just the policy that a group including all its sub
%%groups must fit into the current line in order to have its [[break]]s
%%rendered as spaces.  The predicate is efficient because it can stop
%%whenever it encounters a real new line (from a [[vgrp]])i, or it
%%exceeds the current line width, or it reaches the end of the
%%group---whatever happens first. 
%%
<<fits>>=
let rec fits w = function
    | _ when w < 0                   -> false
    | []                             -> true
    | (i,m,DocNil)              :: z -> fits w z
    | (i,m,DocCons(x,y))        :: z -> fits w ((i,m,x)::(i,m,y)::z)
    | (i,m,DocNest(j,x))        :: z -> fits w ((i+j,m,x)::z)
    | (i,m,DocText(s))          :: z -> fits (w - strlen s) z
    | (i,Flat, DocBreak(s))     :: z -> fits (w - strlen s) z
    | (i,Fill, DocBreak(_))     :: z -> true 
    | (i,Break,DocBreak(_))     :: z -> true
    | (i,m,DocGroup(_,x))       :: z -> fits w ((i,Flat,x)::z)

@ 
%%
%%The pretty printing functions called by the user just enclose the
%%user document with a virtual [[agrp]] and start [[format]]'ing.
%%
<<pp.ml>>=
let ppToString  w doc = format w 0 [0,Flat,agrp(doc)] sdocToString
let ppToFile oc w doc = format w 0 [0,Flat,agrp(doc)] (sdocToFile oc) 
@ 
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Useful functions}
%%% ------------------------------------------------------------------ 
%%
<<pp.ml>>=
let rec list sep f xs =
    let rec loop acc = function
        | []    -> acc
        | [x]   -> acc ^^ f x 
        | x::xs -> loop (acc ^^ f x ^^ sep) xs
    in
        loop empty xs 

let commalist f = list (text "," ^^ break) f

let (^/) x y   = x ^^ break ^^ y 
let (~~) x     = x

let block f xs =   
    text "{"
    ^^ nest 4 begin
       ~~ break
       ^^ list break f xs
       end 
    ^/ text "}"

@ 
%%
%%% ------------------------------------------------------------------  
%%\subsubsection{Auxiliaries}
%%% ------------------------------------------------------------------  
%%
%%To make groups more visible during debugging set [[debug]] to
%%[[true]].
%%
<<auxiliaries(pp.nw)>>=
let debug   = false 
let strlen  = String.length

@ 
%%
%%Unix uses a single character to represent a newline.  Other
%%operating systems use different or more characters.  So we better
%%abstract from this.
%%
<<auxiliaries(pp.nw)>>=
let nl      = "\n"

@
\section{[[commons2/rc.nw]]}
%%
%%% ------------------------------------------------------------------ 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
\section{Generic Configuration Files}
%%% ------------------------------------------------------------------ 
%%
%%This module provides a parser for generic configuration files.  A
%%configuration file binds names to values, where values can be
%%integers, floats, booleans, strings and lists of the mentioned simple
%%types. 
%%        
%%\begin{verbatim}
%%        rcfile  : rclines EOF
%%
%%        rclines :
%%                | rclines rcline
%%
%%        rcline  : ID EQUAL value
%%                | ID EQUAL values
%%
%%        value   : ID
%%                | STR
%%                | TRUE
%%                | FALSE
%%                | INT
%%                | FLOAT
%%
%%        values  : value COMMA value
%%                | values COMMA value
%%
%%        digit       = ['0'-'9']
%%        letter      = ['a'-'z' 'A'-'Z' '_']
%%        ID          = letter (letter|digit)*
%%        INT         = digit+
%%        FLOAT       = integer '.' integer ('E' ('+'|'-')? integer)? 
%%        TRUE        = "true"
%%        FALSE       = "false" 
%%        STR         = '"' .... '"'      
%%\end{verbatim}
%%
%%Comments start with a [[#]] and reach to the line end.  The
%%representation of values is defined in the module [[Rc_ast]].  Both
%%strings and id values are represented as [[RCstr]]; this means, that
%%string values made up from digits and letters don't need to be
%%included into double quotes.
%%         
%%% ------------------------------------------------------------------ 
\subsection{Interface}
%%% ------------------------------------------------------------------         
%%
<<rc.mli>>=
type id         = Rc_ast.id
type rc         = Rc_ast.rc
type rcdict     = Rc_ast.rcdict

exception       Error of string         (* reports parse/scan errors *)
@
%%
%%[[find id dict]] returns the value bound to [[id]] or raises [[Not_found]]
%%in case there is no binding.
%%
<<rc.mli>>=
val find        : id -> rcdict -> rc 
@
%%
%%[[read file]] reads onfiguration from [[file]].
%%
<<rc.mli>>=
val read        : string -> rcdict
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<rc.ml>>=
type id         = Rc_ast.id
type rc         = Rc_ast.rc
type rcdict     = Rc_ast.rcdict

exception Error of string
let error msg   = raise (Error msg)
@
%%
%%[[find id rcdict]] looks up a value for [[id]]; raises [[Not_found]] in
%%case [[id]] is undefined.
%%
<<rc.ml>>=
let find   = Rc_ast.find
let asList = Rc_ast.asList
@
%%
%%[[read file]] reads rcfile [[file]], parses it, and returns it contents 
%%as value of type [[rcfile]].
%%
<<rc.ml>>=
let read file = 
    let file_ic         = try open_in file with 
                          Sys_error msg -> error msg            in
    let lexbuf          = Lexing.from_channel file_ic           in
    let finally ()      = close_in file_ic                      in
    let rc              = try 
                                Rc_parse.rcfile Rc_scan.scan lexbuf
                          with
                          | Parsing.Parse_error ->
                                finally ();
                                error ("parse error in `" ^ file ^ "'")
                          | Rc_scan.ScanError msg -> error msg
                          | e                   ->
                                finally ();
                                raise e                         in
        finally ();
        rc
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Abstract Syntax}
%%% ------------------------------------------------------------------ 
%%
<<rc_ast.mli>>=
type id         = string

type rc         =
                | RCstr         of string
                | RCbool        of bool
                | RCint         of int
                | RCfloat       of float
                | RClist        of rc list
@
%%
%%[[rcdict]] is a dictionary that maps [[id]]s to [[rc]] values. It captures 
%%a configuration read from a file using the [[read]] function. 
%%
<<rc_ast.mli>>=
type rcdict
@
%%
%%[[find id dict]] returns the value bound to [[id]] or raises [[Not_found]]
%%in case there is no binding *)
%%   
<<rc_ast.mli>>=
val find        : id -> rcdict -> rc 
@
%%
%%The following functions are used by the parser and are not for
%%clients of [[Rc]].
%%
%%[[empty]] - an empty [[rcdict]]
%%
<<rc_ast.mli>>=
val empty       : rcdict 
@
%%
%%[[add id rc dict]] adds binding [[id]] $\to$ [[rc]] to [[dict]].
%%
<<rc_ast.mli>>=
val add         : id -> rc -> rcdict -> rcdict 
@
%%
%%[[asList dict]] returns all bindings of [[dict]] in a list; for debugging.
%%
<<rc_ast.mli>>=
val asList      : rcdict -> (id * rc) list
@
%%
<<rc_ast.ml>>=
type id         =       string

type rc         =
                | RCstr of string
                | RCbool of bool
                | RCint of int
                | RCfloat of float
                | RClist of rc list

module IdMap    = 
    Map.Make(struct type t=id let compare=Pervasives.compare end)

(* rc files are maps (or dictinoaries) which map identifiers 
   to values (of type rc from above) *)
                
type rcdict     =       rc IdMap.t


let empty               = IdMap.empty
let find                = IdMap.find
let add                 = IdMap.add

(* [asList dictfile] returns the contents of [dictfile] as a lsit of
   id/rc pairs. This is for debugging only *)

let asList dict =
    let insert id rc list = (id,rc)::list       in
        IdMap.fold insert dict []
@
%%       
%%
%%% ------------------------------------------------------------------ 
\subsection{Parser}
%%% ------------------------------------------------------------------ 
%%
<<rc_parse.mly>>=
%{
open Rc_ast 
%}

%token <string> STR
%token <string> ID
%token <bool>   BOOL
%token <float>  FLOAT
%token <int>    INT

%token COMMA EQUAL TRUE FALSE EOF 


%start                  rcfile
%type  <Rc_ast.rcdict>  rcfile

%%

rcfile          : rclines EOF                   { $1            }

rclines         : /**/                          { empty         }
                | rclines rcline                { let (id,rc) = $2 in
                                                  add id rc $1
                                                } 

rcline          : ID EQUAL value                { ($1,$3)       }
                | ID EQUAL values               { ($1,RClist(List.rev $3))  }

value           : ID                            { RCstr($1)     }
                | STR                           { RCstr($1)     }
                | TRUE                          { RCbool(true)  }
                | FALSE                         { RCbool(false) }
                | INT                           { RCint($1)     }
                | FLOAT                         { RCfloat($1)   }

values          : value  COMMA value            { [$3  ; $1]    }
                | values COMMA value            {  $3 :: $1     }
@
%$
%%
%%% ------------------------------------------------------------------ 
\subsection{Scanner}
%%% ------------------------------------------------------------------ 
%%
%%
<<rc_scan.mll>>=
{
    
    open Rc_parse       (* tokens are defined here *)

    exception ScanError of string

    let error msg = raise (ScanError msg)

    let keywords = Hashtbl.create 127
    let keyword s = Hashtbl.find keywords s
    let _ = Array.iter (fun (x,y) -> Hashtbl.add keywords x y)
        [|
             ("true"        ,TRUE);
             ("false"       ,FALSE);
        |]

    let get = Lexing.lexeme

    (* buffer for string literals *)
    let strBuffer = Buffer.create 80

    let debug msg = print_endline msg

    let init () =
        Buffer.clear strBuffer
}
@
%%
<<rc_scan.mll>>=
let digit       = ['0'-'9']
let letter      = ['a'-'z' 'A'-'Z' '_']
let ident       = letter (letter|digit)*
let integer     = digit+
let float       = integer '.' integer ('E' ('+'|'-')? integer)? 
let ws          = [' ' '\r' '\011' '\012' ]
let nl          = '\n'
let tab         = '\t'
@
%%
<<rc_scan.mll>>=
rule scan = parse
    | eof               { EOF }
    | ws                { scan lexbuf }
    | nl                { scan lexbuf }
    | tab               { scan lexbuf }
    | '#' [^'\n']* nl   { scan lexbuf } 

    | ident             { let s = get lexbuf in
                          try  keyword s 
                          with Not_found -> debug "id"; ID(s) 
                        }
    | integer           { try 
                            INT   (int_of_string (get lexbuf)) 
                          with Failure _ -> 
                            let msg = "illegal integer `" ^ (get lexbuf) ^ "'"
                            in  error msg 
                        }
    | float             { try
                            FLOAT (float_of_string (get lexbuf)) 
                          with Failure _ -> 
                            let msg = "illegal float `" ^ (get lexbuf) ^ "'"
                            in  error msg 
                        }
    | '"'               { Buffer.clear strBuffer
                        ; string lexbuf 
                        ; STR(Buffer.contents strBuffer)
                        }
                        
    | '='               { EQUAL }
    | ','               { COMMA }
    
    |  _                { let c = get lexbuf in
                            error ("illegal character `" ^ c ^ "'")
                        }    

@
%%
<<rc_scan.mll>>=
and string = parse
    | eof               { error "unterminated string" }
    | '"'               { (* return *) }

    | '\\' _            { let c = String.get (get lexbuf) 1 in
                            Buffer.add_char strBuffer c;
                            string lexbuf
                        }
    | _                 { Buffer.add_string strBuffer (get lexbuf)
                        ; string lexbuf
                        }  
@
%%
\section{[[commons2/rx.nw]]}
<<commons2/rx.ml>>=
<<rx.ml>>
@

<<commons2/rx.mli>>=
<<rx.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% ------------------------------------------------------------------ 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
\section{Regular Expressions}
%%% ------------------------------------------------------------------ 
%%
%%This module provides regular expression matching.  Regular expressions
%%don't need to be compiled before they can be matched against some
%%input.  Instead the automaton is build while the input is consumed. 
%%The drawback of this method is that no subexpression matching is
%%possible to extract matching substrings.
%%
%%This algorithm used here is by Mark Hopkins who posted it once to
%%[[comp.compiles]].  Search the [[comp.compilers]] archive for a
%%detailed article and an implementation in C.
%%     
%%% ------------------------------------------------------------------ 
\subsection{Interface}
%%% ------------------------------------------------------------------ 
%%
%%The type of a regular expression over symbols of type [['a]]:
%% 
<<rx.mli>>=
type 'a rx 
@
%%
%%Construtor functions for regular expressions:
%%
<<rx.mli>>=
val zero : 'a rx                                (* never matches       *)
val unit : 'a rx                                (* matches empty input *)
val sym : 'a -> 'a rx                           (* 'x'                 *)
val many : 'a rx -> 'a rx                       (* e*                  *)
val some : 'a rx -> 'a rx                       (* e+                  *)
val opt : 'a rx -> 'a rx                        (* e?                  *)
val seq : 'a rx -> 'a rx -> 'a rx               (* e1 e2               *)
val alt : 'a rx -> 'a rx -> 'a rx               (* e1 | e2             *)
val ( ||| ) : 'a rx -> 'a rx -> 'a rx           (* e1 | e2             *)
val ( *** ) : 'a rx -> 'a rx -> 'a rx           (* e1 e2               *)
@
%%
%%[[matches e syms]] is true, iff the word [[syms]] is an element of $L(e)$, i.e. 
%%[[e]] matches the symbols [[syms]].
%%
<<rx.mli>>=
val matches : 'a rx -> 'a list -> bool
@
%%
%%[[[matchstr e str]] is true, iff string [[str]] is matched by 
%%regular expression [[e]]. 
%%
<<rx.mli>>=
val matchstr : char rx -> string -> bool
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<rx.ml>>=
let (=*=) = (=)

type 'a rx      = 
                | RXzero                                (* {}           *)
                | RXunit                                (* ""           *)
                | RXsym         of 'a                   (* 'x'          *)
                | RXmany        of ('a rx)              (* e*           *)
                | RXsome        of ('a rx)              (* e+           *)
                | RXopt         of ('a rx)              (* e?           *)
                | RXseq         of ('a rx) * ('a rx)    (* e1 e2        *)
                | RXalt         of ('a rx) * ('a rx)    (* e1 | e2      *)
@ 
%%
<<rx.ml>>=
let zero        = RXzero
let unit        = RXunit
let sym x       = RXsym x
let many        = function
                | RXunit        -> RXunit
                | RXzero        -> RXunit
                | x             -> RXmany x
let some        = function
                | RXunit        -> RXunit
                | RXzero        -> RXzero
                | x             -> RXsome x
let opt         = function
                | RXunit        -> RXunit
                | RXzero        -> RXunit
                | x             -> RXopt x
let seq x y     = match (x,y) with
                | RXzero, x     -> RXzero
                | RXunit, x     -> x
                | x     , RXzero-> RXzero
                | x     , RXunit-> x
                | x     , y     -> RXseq(x,y)
let alt x y     = match (x,y) with
                | RXzero, x     -> x
                | x     , RXzero-> x
                | x     , y     -> RXalt(x,y)
@ 
%%
<<rx.ml>>=
let ( ||| ) = alt
let ( *** ) = seq
@
%%
%%[[nullable e]] is true, iff the empty sequence ([[RXzero]]) is recognized 
%%by [[e]]. 
%%
<<rx.ml>>=
let rec nullable = function
    | RXzero            -> false
    | RXunit            -> true
    | RXsym x           -> false
    | RXmany e          -> true
    | RXsome e          -> nullable e
    | RXopt e           -> true
    | RXseq(e1,e2)      -> nullable e1 && nullable e2
    | RXalt(e1,e2)      -> nullable e1 || nullable e2
@
%%
%%[[residual e x]] returns a regular expression [[e']] that recognizes the
%%language $L(e') = \{ w | xw \in L(e)\}$. 
%%
<<rx.ml>>=
let rec residual e' x = match e' with
    | RXzero            -> RXzero
    | RXunit            -> RXzero
    | RXsym x'          -> if   x' =*= x 
                           then RXunit
                           else RXzero
    | RXmany e          -> seq (residual e x) (many e)
    | RXsome e          -> seq (residual e x) (many e)
    | RXopt e           -> residual e x
    | RXseq(e1,e2)      -> if   nullable e1
                           then alt (seq (residual e1 x) e2) (residual e2 x)
                           else seq (residual e1 x) e2
    | RXalt(e1,e2)      -> alt (residual e1 x) (residual e2 x)
@
%%    
%%[[matches e syms]] is true, iff the word [[syms]] is an element of $L(e)$, i.e. 
%%[[e]] matches the symbols [[syms]]
%%
<<rx.ml>>=
let matches e syms      = nullable (List.fold_left residual e syms)
@
%%
%%[[matchstr e str]] is true, iff string [[str]] is matched by 
%%regular expression [[e]].
%% 
<<rx.ml>>=
let matchstr e str =
    let len = String.length str         in
    let rec loop e i =
        if   i = len 
        then nullable e
        else loop (residual e (String.get str i)) (i+1)
    in
        loop e 0
@
%%
<<rx-examples.ml>>=
let e1 = many (sym 'a') *** some (sym 'b')
let e2 = sym 'a' *** opt (sym 'b') *** some (sym 'a')
@
%%
%%
%%
%%
%%                
%%
\section{[[commons2/strutil.nw]]}
<<commons2/strutil.ml>>=
<<strutil.ml>>
@

<<commons2/strutil.mli>>=
<<strutil.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{String Utilities}
%%% ------------------------------------------------------------------ 
%%
%%Sets and Maps over strings are commonly used in the compiler. Although
%%it is possible to create these data structures with one line of source
%%code this is not always the best way to do it, because different
%%instances are type incompatible. This module provides sets and maps over
%%strings for the admittedly few cases where these maps are passed between
%%modules. Neither the interface nor the implementation offers any
%%surprises.
%%
<<strutil.mli>>=
module Set: Set.S with type elt = string
module Map: Map.S with type key = string

val assoc2map: (string * 'a) list -> 'a Map.t
val from_list: string list -> Set.t
@
%%
%%% ------------------------------------------------------------------ 
\section{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<strutil.ml>>=
let compares (x:string) (y:string) = compare x y

module Compare = struct type t = string let compare=compares end
module Set = Set.Make(Compare)
module Map = Map.Make(Compare)

let assoc2map pairs =
    let f map (key,value) = Map.add key value map in
        List.fold_left f Map.empty pairs

let from_list xs = List.fold_left (fun set x -> Set.add x set) Set.empty xs
@
%%
\section{[[commons2/verbose.nw]]}
<<commons2/verbose.ml>>=
<<verbose.ml>>
@

<<commons2/verbose.mli>>=
<<verbose.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
\section{Diagnostic output}
%%
%%Uses environment level [[VERBOSITY]] to make noise.
<<verbose.mli>>=
val say : int -> string list -> unit
  (* if VERBOSITY >= k, then say k l writes every string in l to stderr *)
val eprintf : int -> ('a, out_channel, unit) format -> 'a
  (* if VERBOSITY >= k, then say k l writes every string in l to stderr *)
val verbosity : int  (* current verbosity *)
@ 
<<verbose.ml>>=
let verbosity = try int_of_string (Sys.getenv "VERBOSITY") with _ -> 0
let err l = List.iter prerr_string l; flush stderr
let say k = if verbosity >= k then err else ignore

let rec ign x = Obj.magic ign
let eprintf k = if verbosity >= k then Printf.eprintf else ign
@ 

\chapter{[[commons3]]}

\section{[[commons3/alignment.nw]]}
<<commons3/alignment.ml>>=
<<alignment.ml>>
@

<<commons3/alignment.mli>>=
<<alignment.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et:
%%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%%
%%
%%% ------------------------------------------------------------------ 
\section{Interface to manipulate alignment constraints}
%%% ------------------------------------------------------------------ 
%%
<<alignment.mli>>=
type t

val init  : int -> t

val add   : int -> t -> t
val align : int -> t -> t

val alignment : t -> int

val gcd : int -> int -> int
    (* will disappear when Alignment.t becomes RTL.assertion *)
@
%%
\section{Implementation of alignment manipulation}
%%
%%The first element of the alignment type [[t]] represents the number of
%%bytes beyond the alignment we have written.  The second element of the
%%alignment type is the last enforced alignment boundary.
<<alignment.ml>>=
type t = int * int
@
<<alignment.ml>>=
let init k = (0, k)
let add i (n, k) = (n + i, k)
let align k (n', k') = (0, k)
let rec gcd n m =
  if n > m then gcd m n
  else if n = 0 then m
  else gcd (m - n) n
let alignment (n, k) = gcd n k
@
\section{[[commons3/bits.nw]]}
<<commons3/bits.ml>>=
<<bits.ml>>
@

<<commons3/bits.mli>>=
<<bits.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 et sw=4:
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% TODO: parsing a floating point number from a string to a bits value.
%%
%%% ------------------------------------------------------------------ 
\section{Bits -- Low-Level Representation of Values}
%%% ------------------------------------------------------------------ 
%%
%%This module provides an abstract bit vector type [[bits]]. It is used
%%for holding {\PAL} values.
%%
%%Bit values can be converted to and from numbers and strings. Conversion
%%implies an \emph{interpretation} of a value. Most commonly, values can
%%be interpreted as signed or unsigned integers.  Therefore, constructors
%%and observers of [[bits]] values are organized along these lines. The
%%conversions try hard not to assume a certain representation for {\ocaml}
%%integers. The conversion is soley defined with respect to the range
%%[[max_int]] \dots [[min_int]]  of an {\ocaml} data type. However, we in
%%addition assume that $[[min_int]] = -2^{k-1}$ and $[[max_int]] =
%%2^{k-1}-1$ for some $k$, such that the cardinality of the integer range
%%is $2^k$.  The current {\ocaml} manual does not guarantee this property
%%explicitly, but the {\ocaml} implementation supports it.
%%
%%The maximum width of a bit vector is implementation dependent; however,
%%it is checked error to exceed it.
%%
%%% ------------------------------------------------------------------ 
\subsection{Interface}
%%% ------------------------------------------------------------------ 
%%
%%A [[bits]] value has an observable fixed [[width]] that is the number of
%%bits it can hold. The simplest [[bits]] value is [[zero]], a [[width]]
%%long bit vector of zeros. 
<<bits.mli>>=
type width = int

(* pad: this was previously an abstract type, but it's less convenient
 * with ocamldebug
 *)
type bits = Int64.t * int


type t = bits 

val width : t -> width         (* observer *)
val zero  : width -> t         (* constructor *)
val is_zero : t -> bool
@ 
%%Comparison is safe even on bit vectors of different widths.
%%However, its results are not necessarily meaningful aside from their
%%use in constructing hash tables.
<<bits.mli>>=
val compare : t -> t -> int
val eq      : t -> t -> bool
@ 
%%If a conversion fails because the target range is too small for a given
%%conversion, it raises the [[Overflow]] exception.
%%If a conversion fails because of bad string syntax, this is considered
%%a bug in the compiler, which halts with an error message.
%%The
%%syntax for numbers follows the {\PAL} syntax. For the details of
%%strings, see below.
<<bits.mli>>=
exception Overflow
module S: sig  (* signed *) 
    <<interface S>>
end
module U: sig (* unsigned *)
    <<interface U>>
end
@
%%
%%% ------------------------------------------------------------------ 
%%%subsection{Debugging} 
%%% ------------------------------------------------------------------ 
%%
%%Function [[to_string]] converts to a string for debugging.
%%Function [[to_decimal_string]] converts to a decimal string, possibly
%%with sign.
%%Function [[to_hex_or_decimal_string]] converts to decimal if the
%%argument is ``unsigned less then'' [[declimit]]; otherwise it converts
%%to form [["0x%x"]].
<<bits.mli>>=
val to_string         : bits -> string
val to_decimal_string : bits -> string
val to_hex_or_decimal_string : declimit:int -> bits -> string
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Arithmetic}
%%% ------------------------------------------------------------------ 
%%
%%We prefer to use {\PAL} names, not OCaml names, so logical
%%\textbf{and} and \textbf{or} are 
%%[[and]] and [[or]], not [[logand]] and [[logor]].
%%Except that because [[and]] and [[or]] are reserved words, it's
%%[[and']] and [[or']].
<<bits.mli>>=
module Ops : sig
  val add       : bits -> bits -> bits
  val and'      : bits -> bits -> bits
  val com       : bits -> bits 
  val divu      : bits -> bits -> bits
  val mul       : bits -> bits -> bits
  val neg       : bits -> bits
  val or'       : bits -> bits -> bits
  val sub       : bits -> bits -> bits
  val shra      : bits -> bits -> bits
  val shrl      : bits -> bits -> bits
  val shl       : bits -> bits -> bits
  val xor       : bits -> bits -> bits

  val sx        : int  -> bits -> bits
  val zx        : int  -> bits -> bits
  val lobits    : int  -> bits -> bits
  
  val eq        : bits -> bits -> bool
  val ne        : bits -> bits -> bool
  val lt        : bits -> bits -> bool
  val gt        : bits -> bits -> bool
  val ltu       : bits -> bits -> bool
  val gtu       : bits -> bits -> bool
end
@
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Signed Constructors}
%%% ------------------------------------------------------------------ 
%%
%%A constructor takes a signed value $v$ and creates a [[bits]] value $b$
%%of a given [[width]] $w$. The value $v$ is encoded as a two's complement
%%integer of width $w$. If $w$ is too small for this encoding ($v <
%%-2^{w-1}$ or $2^{w-1} \le v$), the constructor raises [[Overflow]].
%%
%%$$v = \sum_{i=0}^{w-2} 2^i \times b_i - 2^{w-1} \times b_{w-1}$$
<<interface S>>=
val of_int:     int         -> width -> t   (* raises Overflow *)
val of_native:  nativeint   -> width -> t   (* raises Overflow *)
val of_int32:   int32       -> width -> t   (* raises Overflow *)
val of_int64:   int64       -> width -> t   (* raises Overflow *)
val of_string:  string      -> width -> t   (* raises Overflow *)
@ 
%%
%%For the format of the strings accepted by [[of_string]], see the section
%%below.  I CANNOT FIND THE REFERENCE.  PLEASE TRY \ref OR \pageref!
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Signed Observers}
%%% ------------------------------------------------------------------ 
%%
%%A signed observer treats a bit vector $b$ of width $w$ as a number $v$
%%in two's complement representation. The observer converts it to a
%%(signed) {\ocaml} number. For the conversion to succeed, the number must
%%be within the range of the target type ($[[min_int]] \le v \le
%%[[max_int]]$), otherwise the conversion raises [[Overflow]]. 
%%%
%%$$v = \sum_{i=0}^{w-2} 2^i \times b_i - 2^{w-1} \times b_{w-1}$$
%%%
%%This guarantees $-2^{w-1} \le v < 2^{w-1}$.
<<interface S>>=
val to_int:     t -> int                        (* Overflow *)
val to_native:  t -> nativeint                  (* Overflow *)
val to_int64:   t -> int64                      (* Overflow *)
@
%%We can also observe whether a value fits in~[[n]] signed bits.
%%N.B. this is an observation of the value, not just the width.
<<interface S>>=
val fits : width -> t -> bool    (* fits w b == (b = sxlo w b) *)
@ 
%%
%%% ------------------------------------------------------------------ 
\subsection{Unsigned Constructors}
%%% ------------------------------------------------------------------ 
%%
%%An unsigned constructor takes a (signed) number $v$, and computes an
%%unsigned number $v'$ from it. 
%%
%%$$v' = v \bmod 2^k, \quad\mbox{where $[[min_int]]=-2^{k-1}$}$$
%%
%%The [[min_int]] and [[max_int]] values are the ones that are associated
%%with the type representing $v$.  
%%
%%The derived number $v'$ is the unsigned interpretation of the signed
%%number $v$. If $v' < 2^w$ holds, $v'$ is represented as a bit vector of
%%length $w < k$, using an unsigned interpretation. Otherwise, the
%%constructor function raises [[Overflow]]. 
%%$$v' = \sum_{i=0}^{w-1} 2^i \times b_i$$
<<interface U>>=
val of_int:     int         -> width -> t       
val of_native:  nativeint   -> width -> t       
val of_int64:   int64       -> width -> t       
val of_int32:   int32       -> width -> t       
val of_string:  string      -> width -> t   (* raises Overflow *)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Unsigned Observers}
%%% ------------------------------------------------------------------ 
%%
%%An unsigned observer takes a bit vector $b$ of length $w$ and interprets
%%it as an unsigned number $v$:
%%%
%%$$v = \sum_{i=0}^{w-1} 2^i \times b_i$$
%%%
%%The conversion returns a signed number $v'$ that is related to $v$ as
%%follows:
%%$$v' = \cases{v                   
%%                & \quad if $0 \le v \le [[max_int]]$\cr
%%              v + 2 \times [[min_int]]     
%%                & \quad if $[[max_int]] < v \le [[max_int]]
%%                                              - [[min_int]]$ \cr
%%              \mathit{overflow}
%%                & \quad otherwise}
%%$$
%%This means that $-2^{k-1} \le v' < 2^{k-1}$ and $v = v' \bmod 2^k$,
%%where $[[min_int]] = -2^{k-1}$ and $[[max_int]] = 2^{k-1}-1$.
%%Intuitively, the sign bit in the target type is treated as if it were a
%%regular bit. The consequence is, that a value larger than [[max_int]]
%%becomes negative. 
<<interface U>>=
val to_int:     t -> int                        (* Overflow *)
val to_native:  t -> nativeint                  (* Overflow *)
val to_int64:   t -> int64                      (* Overflow *)
@ 
%%We can also observe whether a value fits in~[[n]] unsigned bits.
%%N.B. this is an observation of the value, not just the width.
<<interface U>>=
val fits : width -> t -> bool    (* fits w b == (b = zxlo w b) *)
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Syntax for Strings}
%%% ------------------------------------------------------------------ 
%%
%%A [[bits]] value can be created from a string representation. The string
%%describes an integer, character, or floating-point literal.
%%\begin{enumerate}
%%\item The integer string representation can use a decimal, octal, or
%%      hexadecimal radix.  The characters to represent the respective
%%      radices in strings are shown below.  
%%        \begin{tabular}{ll}
%%        Radix        & characters \\
%%        \hline
%%        octal        & \ttfamily 0 1 2 3 4 5 6 7     \\
%%        decimal      & \ttfamily 0 1 2 3 4 5 6 7 8 9 \\
%%        hexadecimal  & \ttfamily 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F \\
%%        \end{tabular}
%%      The radix of a string is determined by its first two characters:
%%      \begin{itemize}
%%      \item A string starting with [[0x]] or [[0X]] is considered a
%%            hexadecimal number.
%%      \item A string starting with [[0]] is considered a string of octal
%%            numbers.
%%      \item All other strings are considered as strings with decimal numbers.
%%      \end{itemize}
%%      If a string contains illegal
%%      characters, it is considered an internal error in the compiler.
%%
%%\item A character is enclosed in single quotes like in [['a']]. The
%%      character representation honors the C escape sequences.
%%      Otherwise, each character stands for itself.
%%       \begin{quote}
%%        \begin{tabular}{ll}
%%            Escape Sequence & Interpretation \\ 
%%            \hline
%%            [[\a]]          & Alert (Bell) \\
%%            [[\b]]          & Backspace    \\
%%            [[\f]]          & Formfeed     \\
%%            [[\n]]          & Newline      \\
%%            [[\r]]          & Carriage Return \\
%%            [[\t]]          & Horizontal Tab \\
%%            [[\\]]          & Backslash    \\
%%            [[\']]          & Single Quote \\
%%            [[\"]]          & Double Quote \\
%%            [[\?]]          & Question Mark \\
%%            [[\x]]$\{\textit{hexdigit}\}$ 
%%                            & The value of \textit{hexdigit} sequence \\
%%            [[\]] $\{\textit{octdigit}\}$ 
%%                            & The value of \textit{octdigit} sequence \\
%%        \end{tabular}
%%        \end{quote} 
%%
%%\item The floating point representation [[float]] can be described by the
%%      following small grammar that is also used in the {\PAL} lexer:
%%
%%      \begin{quote}
%%      \begin{verbatim}
%%    let digit       = ['0'-'9']
%%    let nat         = digit+
%%    let frac        = nat '.' nat
%%    let exp         = ['e''E'] sign? nat
%%    let float       = frac exp? 
%%                    | nat exp
%%      \end{verbatim}
%%      \end{quote}
%%
%%     \emph{We have to say something about the width of floating point
%%     numbers.}
%%
%%\end{enumerate}
%%
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Residualizing Interface}
%%% ------------------------------------------------------------------ 
%%
%%The evaluating and residualizing instantiations provide the same
%%interface to [[bits]].
%%\begin{quote}\it
%%    The interface to this module has changed completely. Now I don't
%%    know what to do with the residualizing interface. -- CL
%%\end{quote}
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<bits.ml>>=
let (=*=) = (=)
let (=<=) (x:char)   (y:char)   = (=) x y

module I = Int64        (* signed   operations *)
exception Overflow
let impossf fmt = Printf.kprintf Impossible.impossible fmt
@ 
%%Here, we want our polymorphism.
<<bits.ml>>=
let (<=) = Pervasives.(<=)
let (>=) = Pervasives.(>=)
let (<)  = Pervasives.(<)
let (>)  = Pervasives.(>)
@
%%Values of type [[bits]] are represented as pairs of width and [[bits64]]
%%value. Whenever for the width $k < 64$ holds, we maintain the
%%following invariant: the $64-k$ most significant bits equal the sign
%%bit $k-1$ of $b$.
<<bits.ml>>=
type width      = int
type bits       = int64 * width
type t          = bits 

let width (_,w) = w
let check w = if w <= 0 || w > 64 then impossf "unsupported bitwidth %d" w
let zero w  = check w; (I.zero, w)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Sign and zero extension}
%%% ------------------------------------------------------------------ 
%%
%%The [[sx64]] operation takes an [[int64]] value and masks the $w$ least
%%significant bits ($w-1, \dots, 0$) such that the remaining $64 - w$ most
%%significant bit are equal to bit $w-1$, the sign bit of a vector of
%%length $w$. We use this to establish our invariant that unused bits
%%equal the sign bit.
<<bits.ml>>=
let sx64 i w =
  if w = 64 then i
  else
    let w' = 64-w in
    I.shift_right (I.shift_left i w') w'
@ 
%%
<<bits.ml>>=
let zx64 i w =
  if w = 64 then i
  else
    let w' = 64-w in
    I.shift_right_logical (I.shift_left i w') w'
@
\subsection{Strings}
%%
%%Conversion rules seem a bit idiosyncratic...
<<bits.ml>>=
let to_string (i,w) = Printf.sprintf "0x%Lx::bits%d" i w 
let to_decimal_string (i,w) = Printf.sprintf "%Ld" i
let to_hex_or_decimal_string ~declimit (i,w) =
  assert (declimit >= 0);
  if Uint64.lt i (I.of_int declimit) then
    Printf.sprintf "%Ld" i
  else
    Printf.sprintf "0x%Lx" (zx64 i w)
@ 
%%% ------------------------------------------------------------------ 
\subsection Arithmetic}
%%% ------------------------------------------------------------------ 
%%
<<bits.ml>>=
module Ops = struct
  <<bitwise operators>>
end
let eq (b, w) (b', w') = (w = w') && (sx64 b w) =*= (sx64 b' w)
let compare (b, w) (b', w') =
  match compare w w' with
  | 0 -> Pervasives.compare (sx64 b w) (sx64 b' w)
  | diff -> diff
let is_zero (b, w) = zx64 b w =*= I.zero
@ 
%%
<<bitwise operators>>=
let add (b, w) (b', w') =
  assert (w = w');
  (Int64.add (sx64 b w) (sx64 b' w), w)

let eq (b, w) (b', w') =
  assert (w = w');
  (sx64 b w) =*= (sx64 b' w)

let lt (b, w) (b', w') =
  assert (w = w');
  let n  = sx64 b  w  in
  let n' = sx64 b' w' in
  Pervasives.(<) n n'
let gt x y = lt y x

let ltu (b, w) (b', w') =
  assert (w = w');
  let n  = zx64 b  w  in
  let n' = zx64 b' w' in
  Uint64.lt n n'
let gtu x y = ltu y x

let neg (b,w) = (Int64.neg (sx64 b w), w)
  (* THIS SX SHOULD BE UNNECESSARY -- CONSULT KEVIN *)

let sub (b,w) (b', w') =
    assert (w = w');
    let n  = sx64 b  w  in
    let n' = sx64 b' w' in
        (Int64.sub n n', w)

let mul (b,w) (b', w') =
    assert (w = w');
    let n  = sx64 b  w  in
    let n' = sx64 b' w' in
        (Int64.mul n n', w)

let divu (b,w) (b', w') =
    assert (w = w');
    let n  = zx64 b  w  in
    let n' = zx64 b' w' in
        (Uint64.div n n', w)

let eq (b,w) (b',w') =
    assert (w = w');
    let n  = zx64 b w  in
    let n' = zx64 b' w' in
        n =*= n'

let ne x y = not (eq x y)

let sx k (b,w) =
    assert (k >= w);
    let n  = sx64 b w in
        (n ,k)

let zx k (b,w) =
    assert (k >= w);
    let n = zx64 b w in
        (n, k)

let lobits k (b, w) =
  if k <= w then (sx64 b k, k)
  else (Printf.eprintf "lobits error: k: %d, w: %d\n" k w;
        Impossible.impossible "lobits: k > w")

let shra (b,w) (b',w') =
  (* todo: pad: bug ? _n is unused ? *)
    let _n  = zx64 b w in
        (Int64.shift_right b (Int64.to_int b'), w)

let shrl (b,w) (b',w') =
    (Int64.shift_right_logical b (Int64.to_int b'), w)

let shl (b,w) (b',w') =
    (zx64 (Int64.shift_left b (Int64.to_int b')) w, w)

let or' (b,w) (b',w') =
    assert (w = w');
    (zx64 (Int64.logor b b') w, w)

let and' (b,w) (b',w') =
    assert (w = w');
    (zx64 (Int64.logand b b') w, w)

let xor (b,w) (b',w') =
    assert (w = w');
    (zx64 (Int64.logxor b b') w, w)



let com (b,w) = (Int64.lognot (zx64 b w), w)
@
%%
%%
<<bits.ml>>=
<<string scanning>>
module S = struct
    <<implementation S>>
end

module U = struct
    <<implementation U>>
end
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Signed Interpretation}
%%% ------------------------------------------------------------------ 
%%
%%The [[fits_signed]] predicate is [[true]], if a (signed) [[int64]] value [[i]]
%%can be represented as a two's complement in $w$ bits,  and [[false]]
%%otherwise. We check that the $64-w$ msb equal the sign bit.
<<implementation S>>=
let fits_signed i w =
    w = 64 or
    let i' = I.shift_right i (w-1) in i' =*= I.zero || i' =*= I.minus_one

let fits w' (i, w) = w <= w' || fits_signed i w'

let of_int i w =
    check w;
    let i' = I.of_int i in
    if fits_signed i' w then (i',w) else raise Overflow 

let of_int32 i w =
    check w;
    let i' = I.of_int32 i in
    if fits_signed i' w then (i',w) else raise Overflow 
    
let of_native i w =
    check w;
    let i' = I.of_nativeint i in
    if fits_signed i' w then (i',w) else raise Overflow

let of_int64 i w =
    check w;
    if fits_signed i w then (i,w) else raise Overflow

let of_string str w =
  check w;
  let i = string sint str w in
  if fits_signed i w then (i,w) else raise Overflow

let to_int (i,w) =
    if I.of_int min_int <= i && i <= I.of_int max_int then
      I.to_int i
    else
      raise Overflow

let to_native (i,w) =
    if  I.of_nativeint Nativeint.min_int <= i && 
        i <= I.of_nativeint Nativeint.max_int 
    then
        I.to_nativeint i
    else
        raise Overflow

let to_int64 (i,w) = i
@
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Unsigned Interpretation}
%%% ------------------------------------------------------------------ 
%%
%%The [[mask]] operation returns the [[w]] least significant bits of an
%%[[int64]] value.
%%
<<implementation U>>=
let mask i w =
    if w < 64 then 
        let m = I.shift_right_logical I.minus_one (64-w) in
        I.logand i m
    else
        i
@
%%The [[fits_unsigned]] predicate is true, if the (positive) number [[i]]
%%can be represented in [[w]] (unsigned) bits. We check that bits the
%%$64-w$ most significant bits are zero.
<<implementation U>>=
let fits_unsigned i w =
    assert (w = 64 || i >= I.zero);
    w = 64 or (I.shift_right_logical i w) =*= I.zero

let fits w' (i, w) = w <= w' || fits_unsigned i w'

let of_int i w =
    check w;
    assert (i >= 0);
    let i' = I.of_int i in 
    let i' = if i' < I.zero 
             then I.sub i' (I.shift_left (I.of_int min_int) 1)  
             else i' 
    in
        if fits_unsigned i' w then (sx64 i' w, w) else raise Overflow

let of_int32 i w =
    check w;
    assert (i >= Int32.zero);
    let i' = I.of_int32 i in 
    let i' = if i' < I.zero 
             then I.sub i' (I.shift_left (I.of_int32 Int32.min_int) 1)  
             else i' 
    in
        if fits_unsigned i' w then (sx64 i' w, w) else raise Overflow

let of_native i w =
    check w;
    assert (i >= Nativeint.zero);
    let i' = I.of_nativeint i in 
    let i' = if i' < I.zero 
             then I.sub i' (I.shift_left (I.of_nativeint Nativeint.min_int) 1) 
             else i' 
    in
        if fits_unsigned i' w then (sx64 i' w, w) else raise Overflow

let of_int64 i w =
    check w;
    if fits_unsigned i w then (sx64 i w, w) else raise Overflow

let of_string str w =
    check w;
    let i = string uint str w in
    if fits_unsigned i w then (i, w) else raise Overflow

let to_int (i,w) = 
    let i = mask i w in
    if i <= I.of_int max_int then
        I.to_int i
    else 
        let i' = I.add i (I.shift_left (I.of_int min_int) 1)  in
        if i' < I.of_int max_int then
            I.to_int i'
        else
            raise Overflow
 
let to_native (i,w) = 
    let i = mask i w in
    if i <= I.of_nativeint Nativeint.max_int then
        I.to_nativeint i
    else 
        let i' = I.add i (I.shift_left (I.of_nativeint Nativeint.min_int) 1) in
        if i' < I.of_nativeint Nativeint.max_int then
            I.to_nativeint i'
        else
            raise Overflow

let to_int64 (i,w) = 
    let i = mask i w in
    i 
@
%%% ------------------------------------------------------------------ 
%%\subsubsection{Strings}
%%% ------------------------------------------------------------------ 
%%
%%A number in string representation is unsigned. We parse the string and
%%return a 64-bit vector for the value.  
%%
%%First, we have to find out whether the string at hand denotes a
%%character, integer, or floating point number. A character starts with an
%%single quote, a floating-point number includes either a dot, an [[e]],
%%or an [[E]], everything else must be an integer.
<<string scanning>>=
<<parse int>>
<<parse float>>
<<parse char>>

let string int (s:string) (w:int) =
    assert (String.length s > 0);
    if s.[0] =<= '\'' then
        char s w 
    else if (  String.length s >= 2 
            && s.[0] =<= '0' 
            && (s.[1] =<= 'x' || s.[1] =<= 'X')
            ) then
        int s w        
    else if (String.contains s '.' || String.contains s 'e' ||
             String.contains s 'E')  then
        float s w
    else
        int s w
@        
%%This implementation cannot read very large decimal and octal number
%%representations. They would have to set the sign bit which they don't.
%%However, hexadecimal representations can use all 64 bits.
<<parse int>>=
let sint str w =
  check w;
  let len = String.length str in
  try  
    if len > 2 && str.[0] =<= '0' && (str.[1] =<= 'x' || str.[1] =<= 'X') then 
      I.of_string str
    else if len > 2 && str.[0] =<= '0' then
      I.of_string ("0o"^str)
    else
      I.of_string str
  with Failure s -> raise Overflow  (* either that, or we let through bad syntax *)
@ 
<<parse int>>=
let uint str w = 
  check w;
  try Uint64.of_string str
  with
  | Failure "overflow" -> raise Overflow
  | Failure s -> impossf "bad unsigned integer literal '%s'" str
@
%%For a floating-point literal, we trust the Caml compiler to produce
%%the right bit pattern.
%%Probably not our best idea ever.
<<parse float>>=
let float str w = 
  try 
    let x = float_of_string str in
    match w with
    | 32 -> Uint64.Cast.float32 x
    | 64 -> Int64.bits_of_float x
    | _  -> Unsupported.floatlit w
  with Failure s -> impossf "caml function '%s' failed on literal %s" s str
@ 
<<parse char>>=
let char str w =
  let str = String.sub str 1 (String.length str - 2) in
  let len = String.length str in
    try
        if   len = 0 
        then assert false
        else if str.[0] =<= '\\' && len > 1 
        then match str.[1] with
        | 'a'  when len = 2 -> I.of_int 7
        | 'b'  when len = 2 -> I.of_int 8
        | 'n'  when len = 2 -> I.of_int 10
        | 'r'  when len = 2 -> I.of_int 13
        | 't'  when len = 2 -> I.of_int 9
        | '\\' when len = 2 -> I.of_int 92
        | '\'' when len = 2 -> I.of_int 39
        | '"'  when len = 2 -> I.of_int 34
        | '?'  when len = 2 -> I.of_int 63
        | 'x'  when len = 2 -> I.of_string ("0"  ^ str)
        | '0' .. '7'        -> I.of_string ("0o" ^ str) 
        | _                 -> impossf "bad character literal '%s'" str
        else                   I.of_int (Char.code str.[0])
    with Failure s -> impossf "caml function '%s' failed on literal %s" s str
@    
%%    
%%% ================================================================== 
\section{Residualizing instantiation}
%%% ================================================================== 
%%
%%\emph{I don't know what to do with this. -- CL}
%%
%%This section is written just as a copy-and-pase of the code above. We
%%must implement a residualizing instantiation of all the functions
%%aboce. Look into \module{../tdpe/tdpe} to read about the notion of
%%``residualizing instantiation''.
%%
%%[[bits]] values are dynamic, therefore represented as a dynamic
%%expression.
%%
%%The residualizing instance provides an optimization which has to do with
%%conversions. In the code generated by the toolkit, several successive
%%conversions are done to and from bits values. We attempt to remove some
%%of these conversions by specialization. Our residual innstatiations of
%%the conversion functions, beside creating appropriate residual-code
%%expressions, maintain a tag which specifies the type of the original
%%value from which the [[bits]] were created. We exploit the tag
%%information to apply algebraic laws about succesive conversions, when
%%applicable.
%%
%%Note that the residualizing instance below is not meaning preserving
%%with respect to the evaluating instance above. The reason is that we
%%remove some of the overflow checks, to account for general assumptions
%%about the ``proper widths of [[bits]]-values''
%%
\subsection{Residualizing instantiation --- Interface}
%%
%%We make public both the tags on bitvectors and also the fact that
%%bitvectors are dynamic values. We do so in order to be able to express
%%algebraic laws about conversions in the ``bitops'' module.
%%
<<bits.mli ((residualizing))>>=
type tag = INT | NINT | INT64 | BV
type width      = int
type bitvector  = (tag * Tdpe.dynamic) (* abstract *)
type bits       = bitvector * width
@ 
%%We provide the same interface to [[bits]] as the evaluating
%%instantiation.
<<bits.mli ((residualizing))>>=
<<interface>>

@ 
%%% ------------------------------------------------------------------ 
\subsection{Residualizing instantiation --- Implementation}
%%% ------------------------------------------------------------------ 
%%
<<bits.ml ((residualizing))>>=
module E = Error
module I = Int64        (* signed   operations *)
module U = Uint64       (* unsigned operations *)

module Sy = Syntax
module T = Tdpe

exception Overflow
exception Size
exception BTA of string

@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Auxiliaries}
%%% ------------------------------------------------------------------ 
%%
%%Values of type [[bits]] are represented as pairs of width and value. The
%%width is static, therefore will be represented as an integer.
<<bits.ml ((residualizing))>>=

type tag = INT | NINT | INT64 | BV
type width      = int
type bitvector  = (tag * Tdpe.dynamic)
type bits       = bitvector * width (* width * int64 *)
@
%%
<<bits.ml ((residualizing))>>=
let maxwidth    = 64

@ 
%%A few basic function for constructing bits. They attach the
%%appropriate tags.
<<bits.ml ((residualizing))>>=

exception NotAvailable

let mkBitsINT width bits = ((INT,Sy.INT bits),width)
let mkBitsNINT width bits = ((NINT,Sy.NINT bits),width)
let mkBitsINT64 width bits = ((INT64,Sy.INT64 bits),width)
let mkBitsBV width bits =   raise NotAvailable

let width (_,w) = w

@
%%Since [[width]]s are static, [[fits]] function can detect some static
%%information: But there is one case which is dependent on the actual
%%value of [[bits]], and in that case, we need to residualize all of it.
%%
<<bits.ml ((residualizing))>>=

let fits (bits,width') width =
  let (tg,bits) = bits in
    if (width <= 0) || (width > 64) 
    then raise Size
    else (width = 64) ||
    (T.nbe' (T.arrowN(T.pair(T.a',T.a'),T.arrow(T.a',T.booNone)))
       (Sy.VAR "Bits.fits")
       (Sy.INT width',bits)
       (Sy.INT width))

@ 
%%[[check]] appears to be called in static contexts only: its arguments
%%are static. Therefore, we provide the evaluating interpretation. It
%%inlines the definition of the evaluating instantiation of [[fits]].
%%
<<bits.ml ((residualizing))>>=
let check width uint64 =
  if (not(
      if (width <= 0) || (width > 64) 
      then raise Size
      else (width = 64) || (U.le uint64 (U.shl width I.one))))
  then raise Overflow
  else ()
@
%%[[setSize]] is also called in static contexts only.
%%
<<bits.ml ((residualizing))>>=
let setSize (b,w as bits) width =
    if not (fits bits width)
    then
      raise Overflow
    else (b,width)

@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Creation of \texttt{bits} values}
%%% ------------------------------------------------------------------ 
%%
<<bits.ml ((residualizing))>>=
let of_stringi str width =
    let len    = String.length str in
    let uint64 = ( match str.[0] with
                 | '0' when len > 1 -> U.of_string ("0o"^str)
                 | _                -> U.of_string str
                 ) in
        try
            ( check width uint64
            ; mkBitsINT64 width uint64
            )
        with
            Failure _ -> syntax ("syntax error in constant: "^str)
@ 
%%         
<<bits.ml ((residualizing))>>=
let of_stringf str width =
    if   width <> 64 
    then raise Size
    else try mkBitsINT64 width (U.of_float (float_of_string str)) with
         | Failure _ -> syntax ("syntax error in constant: "^str)
@ 
%%
<<bits.ml ((residualizing))>>=
let of_stringc str width =
    let len = String.length str in
    let c   = 
            try
                if   len = 0 
                then assert false
                else if str.[0] =<= '\\' && len > 1 
                then match str.[1] with
                | 'a'  when len = 2 -> U.of_int 7
                | 'b'  when len = 2 -> U.of_int 8
                | 'n'  when len = 2 -> U.of_int 10
                | 'r'  when len = 2 -> U.of_int 13
                | 't'  when len = 2 -> U.of_int 9
                | '\\' when len = 2 -> U.of_int 92
                | '\'' when len = 2 -> U.of_int 39
                | '"'  when len = 2 -> U.of_int 34
                | '?'  when len = 2 -> U.of_int 63
                | 'x'  when len = 2 -> U.of_string ("0"  ^ str)
                | '0' .. '7'        -> U.of_string ("0o" ^ str) 
                | _                 -> syntax ("syntax error: "^str)
                else                   U.of_int (Char.code str.[0])
            with Failure _          -> syntax ("syntax error: "^str)
        in
            ( check width c;
              mkBitsINT64 width c
            ) 
@
%% Here I need to avoid a bug
<<bits.ml ((residualizing))>>=
let of_int i width =
    let uint64 = (*U.of_int i*) Int64.of_int i in
        ( check width uint64 ;
          mkBitsINT width i
         )
let of_std_int x width = ((BV,x),width)
@ 
%%
<<bits.ml ((residualizing))>>=
let of_int64 i width =
  ( check width i ;
    mkBitsINT64 width i
   )

@ 
%%
%%This implementation of [[Bits.of_nativeint]] is meaning preserving
%%only in the restrictive assumptions mentioned at the beginning of this
%%section. In the residualizing interpretation the native ints are
%%dynamic, so we just construct some expression.
%%
<<bits.ml ((residualizing))>>=
let of_nativeint i width =
  ((NINT,i),width)

@
%%    
%%% ------------------------------------------------------------------ 
%%\subsubsection{Conversions}
%%% ------------------------------------------------------------------ 
%%
%%The conversion functions implement the algebraic laws we expect to hold
%%when converting between various types of values. Most of them assume
%%that no exceptions are raised when converting. When no laws are
%%applicable, the full residual call is generated.
<<bits.ml ((residualizing))>>=
let to_int ((tag,bitv),w) =
  match tag with
    INT -> bitv
  | NINT ->
      (match bitv with
        Sy.INT64 i64 -> Sy.INT (Int64.to_int i64)
      | Sy.NINT ni -> Sy.INT (ENativeint.to_int ni)
      | Sy.INT _ -> bitv
      | _ -> T.nbe' T.arra' (Sy.VAR "Nativeint.to_int") bitv
      )
  | INT64 ->
      (match bitv with
        Sy.INT64 i64 -> Sy.INT (Int64.to_int i64)
      | Sy.NINT ni -> Sy.INT (ENativeint.to_int ni)
      | Sy.INT i -> bitv
      | _ ->
          let (v,w1) = T.nbe' (T.arrowN(T.a',T.arrow(T.a',T.paira')))
              (Sy.VAR "Bits.of_int64")  bitv (Sy.INT w) in 
          T.nbe' (T.arrow(T.paira',T.a'))
            (Sy.VAR "Bits.to_int") (v,Sy.INT w)
      )
  | BV -> T.nbe' (T.arrow(T.paira',T.a'))
        (Sy.VAR "Bits.to_int") (bitv,Sy.INT w)

@
%%
<<bits.ml ((residualizing))>>=
let to_nativeint ((tag,bitv),w) = 
  match tag with
    INT ->
      (match bitv with
        Sy.INT64 i64 -> Sy.NINT (Int64.to_nativeint i64)
      | Sy.NINT ni -> bitv
      | Sy.INT i -> Sy.NINT (ENativeint.of_int i)
      | _ -> T.nbe' T.arra' (Sy.VAR "Nativeint.to_int") bitv
      )
  | NINT -> bitv
  | INT64 ->
      (match bitv with
        Sy.INT64 i64 -> Sy.NINT (Int64.to_nativeint i64)
      | Sy.NINT ni -> bitv
      | Sy.INT i -> Sy.NINT (ENativeint.of_int i)
      | _ ->
          let (v,w1) = T.nbe' (T.arrowN(T.a',T.arrow(T.a',T.paira')))
              (Sy.VAR "Bits.of_int64")  bitv (Sy.INT w) in (* Bogus? *)
          T.nbe' (T.arrow(T.paira',T.a')) (Sy.VAR "Bits.to_nativeint") (v,Sy.INT w)
      )
  | BV -> T.nbe' (T.arrow(T.paira',T.a')) (Sy.VAR "Bits.to_nativeint") (bitv,Sy.INT w)

@ 
%%We need to fix this as soon as the rest gets fixed as well.
%%
<<bits.ml ((residualizing))>>=
type radix      = Oct
                | Dec
                | Hex

let to_string radix dBits = raise (BTA "Can't convert to string")
@
<<bits.ml ((residualizing))>>=
let zero w =
    let z = U.of_int 0 in
    ( check w z
    ; mkBitsINT w 0
    )
@
%%
\section{[[commons3/bitset64.nw]]}
<<commons3/bitset64.ml>>=
<<bitset64.ml>>
@

<<commons3/bitset64.mli>>=
<<bitset64.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%
%%
\section{Small sets of bits}
%%
%%We track the liveness of each individual bit in a register.
%%This module defines an efficient implementation of sets of bits,
%%provided the bits are numbered 0~through~63.
%%
%%The signature is intended to be consistent with [[Set.S]] (though less
%%complete). 
<<bitset64.mli>>=
type elt = int   (* range 0..63 *)
type t           (* set of elements *)

val empty : t
val is_empty : t -> bool
val mem: elt -> t -> bool
val add: elt -> t -> t
val add_range: lsb:elt -> width:int -> t -> t
val singleton: elt -> t
val single_range: lsb:elt -> width:int -> t
val remove: elt -> t -> t
val remove_range: lsb:elt -> width:int -> t -> t
val union: t -> t -> t
val inter: t -> t -> t
val diff: t -> t -> t
val subset: t -> t -> bool
val eq: t -> t -> bool
val overlap: t -> t -> bool (* nonempty intersection *)
@ 
\section{Implementation}
%%
%%Bit vectors!
<<bitset64.ml>>=
module B  = Bits
module BO = Bits.Ops
type elt = int
type t = Bits.bits

let w = 64

let int i = B.U.of_int i w
let one = int 1
let mask = BO.com (B.zero w)

let empty = B.zero w
let is_empty = B.is_zero
let inter = BO.and'
let union = BO.or'
let diff s s' = BO.and' s (BO.com s')

let overlap s s' = not (is_empty (inter s s'))

let singleton i = (assert (i < w); BO.shl one (int i))

let mem i s = not (B.is_zero (BO.and' (BO.shl one (int i)) s))
let add i s = union (singleton i) s

let single_range ~lsb ~width =
  assert (lsb + width < w);
  BO.shl (BO.shrl mask (int (w-width))) (int lsb)

let add_range ~lsb ~width s = union (single_range ~lsb ~width) s

let remove i s = diff s (singleton i)
let remove_range ~lsb ~width s = diff s (single_range ~lsb ~width)

let eq = B.eq
let subset s s' = B.eq (inter s s') s
@ 
\section{[[commons3/cell.nw]]}
<<commons3/cell.ml>>=
<<cell.ml>>
@

<<commons3/cell.mli>>=
<<cell.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
\section{Cells}
%%
%%We describe a cell size and provide conversions between widths in bits
%%and a cell count.
%%For common widths, these conversions may be more efficient than the
%%general multiply and divide instructions.
<<cell.mli>>=
type t
type count = C of int   (* a number of cells *)
type width = int        (* a number of bits *)

val to_width : t -> count -> width
val to_count : t -> width -> count
val divides  : t -> width -> bool   (* width is an even number of cells *)
val size     : t -> width (* number of bits in one cell *)

val of_size : int -> t
@ 
%%Note on the implementation: it appears that the Caml compiler is not
%%kind enough to do the div/mod operations using shifts, so we may have
%%to put in the shifts ourselves.
<<cell.ml>>=
type count = C of int   (* a number of cells *)
type width = int        (* a number of bits *)

type t = int * (count -> width) * (width -> count) * (width -> bool)
let to_width (_, f, _, _) = f
let to_count (_, _, f, _) = f
let size     (w, _, _, _) = w
let divides  (_, _, _, f) = f

let c1  = ( 1, (fun (C c) ->      c), (fun w -> C w), (fun w -> true))
let c8  = ( 8, (fun (C c) ->  8 * c), (fun w -> C (w / 8)),  (fun w -> w mod  8 = 0))
let c16 = (16, (fun (C c) -> 16 * c), (fun w -> C (w / 16)), (fun w -> w mod 16 = 0))
let c32 = (32, (fun (C c) -> 32 * c), (fun w -> C (w / 32)), (fun w -> w mod 32 = 0))
let c64 = (64, (fun (C c) -> 64 * c), (fun w -> C (w / 64)), (fun w -> w mod 64 = 0))

let of_size n = match n with
| 1  -> c1
| 8  -> c8
| 16 -> c16
| 32 -> c32
| 64 -> c64
|  _ -> (n, (fun (C c) -> n * c), (fun w -> C (w / n)), (fun w -> w mod n = 0))
@ 
\section{[[commons3/ctypes.nw]]}
<<commons3/ctypes.ml>>=
<<ctypes.ml>>
@

<<commons3/ctypes.mli>>=
<<ctypes.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et sts=4
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%%%Grades: 
%%
%%% inc: \usepackage{alltt}
%%
%%The [[also unwinds to]] convention supports a limited set of C types.
%%These types are lifted from Fraser and Hanson's [[lcc]] compiler.
%%To help the run-time system, we can print out an enumeration type for
%%these C types.
%%To help the author of a front end, we can print out this set of types,
%%with the corresponding \PAL\ declaration.
%%Note that the \PAL\ declarations differ depending on whether the C function
%%uses varargs.
<<ctypes.mli>>=
<<types>>
val enum_int : string -> int
(*
val ctypes_vararg_enum : string
val ctypes_vararg_str  : string
*)
@
%%From lcc, we steal the following C types:
<<types>>=
type 'a ctypes = { char               : 'a
                 ; double             : 'a
                 ; float              : 'a
                 ; int                : 'a
                 ; long_double        : 'a
                 ; long_int           : 'a
                 ; long_long_int      : 'a
                 ; short              : 'a
                 ; signed_char        : 'a
                 ; unsigned_char      : 'a
                 ; unsigned_long      : 'a
                 ; unsigned_short     : 'a
                 ; unsigned_int       : 'a
                 ; unsigned_long_long : 'a
                 ; address            : 'a
                 }
@
%%For each type, we need a string representation of the type, the width of the type,
%%and the width to which the type is promoted when passed to a varargs function.
<<types>>=
type width   = int
type metrics = { w : width; va_w : width}
@
%%
<<ctypes.ml>>=
<<types>>
module SM = Strutil.Map
let sprintf = Printf.sprintf
let fetch_ct ct str = match str with
  | "char"               -> ct.char
  | "double"             -> ct.double
  | "float"              -> ct.float
  | ""                   -> ct.int 
  | "int"                -> ct.int 
  | "long double"        -> ct.long_double
  | "long int"           -> ct.long_int
  | "long long int"      -> ct.long_long_int
  | "short"              -> ct.short
  | "signed char"        -> ct.signed_char
  | "unsigned char"      -> ct.unsigned_char
  | "unsigned long"      -> ct.unsigned_long
  | "unsigned short"     -> ct.unsigned_short
  | "unsigned int"       -> ct.unsigned_int
  | "unsigned long long" -> ct.unsigned_long_long
  | "address"            -> ct.address
  | s -> Impossible.impossible (sprintf "Unexpected C type %s\n" s)

let ct_foldi f ct z = 
 let f str = f str (fetch_ct ct str) in
 f "char" (f "double" (f "float" (f "int" (f "long double"
   (f "long int" (f "long long int" (f "short" (f "signed char"
   (f "unsigned char" (f "unsigned long" (f "unsigned short"
   (f "unsigned int" (f "unsigned long long" (f "address" z))))))))))))))
let ct_fold f = ct_foldi (fun _ x -> f x)
@
%%This description of the X86's types should probably fit somewhere in the [[Target.t]].
<<ctypes.ml>>=
let x86_ctypes =
  { char               = {w = 8 ; va_w = 32}
  ; double             = {w = 64; va_w = 64}
  ; float              = {w = 32; va_w = 64}
  ; int                = {w = 32; va_w = 32}
  ; long_double        = {w = 96; va_w = 96}
  ; long_int           = {w = 32; va_w = 32}
  ; long_long_int      = {w = 64; va_w = 64}
  ; short              = {w = 16; va_w = 32}
  ; signed_char        = {w = 8 ; va_w = 32}
  ; unsigned_char      = {w = 8 ; va_w = 32}
  ; unsigned_long      = {w = 32; va_w = 32}
  ; unsigned_short     = {w = 16; va_w = 32}
  ; unsigned_int       = {w = 32; va_w = 32}
  ; unsigned_long_long = {w = 64; va_w = 64}
  ; address            = {w = 32; va_w = 32}
  }
@
<<ctypes.ml>>=
let enum_ct =
  { char               = ("CHAR"            , 0)
  ; double             = ("DOUBLE"          , 1)
  ; float              = ("FLOAT"           , 2)
  ; int                = ("INT"             , 3)
  ; long_double        = ("LONGDOUBLE"      , 4)
  ; long_int           = ("LONGINT"         , 5)
  ; long_long_int      = ("LONGLONGINT"     , 6)
  ; short              = ("SHORT"           , 7)
  ; signed_char        = ("SIGNEDCHAR"      , 8)
  ; unsigned_char      = ("UNSIGNEDCHAR"    , 9)
  ; unsigned_long      = ("UNSIGNEDLONG"    , 10)
  ; unsigned_short     = ("UNSIGNEDSHORT"   , 11)
  ; unsigned_int       = ("UNSIGNEDINT"     , 12)
  ; unsigned_long_long = ("UNSIGNEDLONGLONG", 13)
  ; address            = ("ADDRESS",          14)
  }
let ctypes_vararg_enum ct =
  let str_lst = ct_fold (fun (s,id) rst -> (sprintf "%s = %d" s id)::rst) enum_ct [] in
  Printf.sprintf "{ %s }" (String.concat ", " str_lst)
let enum_int h = snd (fetch_ct enum_ct h)
@
\section{[[commons3/idcode.nw]]}
<<commons3/idcode.ml>>=
<<idcode.ml>>
@

<<commons3/idcode.mli>>=
<<idcode.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
\section{Code arbitrary string as an identifier}
%%
%%The idea is stolen from the old \texttt{btoa} program of fond memory.
%%We code each five-bit group as a character; this enables us to code a
%%128-bit MD5 digest in 26 characters, which is short enough for the
%%linker.
%%
<<idcode.mli>>=
val encode : string -> string
@ 
<<idcode.ml>>=
let codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_."
let () = assert (String.length codes = 64)

let encode s =
  let b = Buffer.create 32 in
  let n = String.length s in
  let rec walk i accum bits =
    if bits >= 5 then
      let idx = accum lsr (bits-5) in
      Buffer.add_char b codes.[idx land 0x1f];
      walk i accum (bits-5)
    else if i = n then
      if bits = 0 then ()
      else walk i (accum lsl 1) (bits+1)
    else
      walk (i+1) ((accum lsl 8) lor (Char.code s.[i])) (bits+8) in
  begin
    walk 0 0 0;
    Buffer.contents b
  end
@ 
\section{[[commons3/idgen.nw]]}
<<commons3/idgen.ml>>=
<<idgen.ml>>
@

<<commons3/idgen.mli>>=
<<idgen.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Please add grades for this module below. The line must start with % "%%".
%%% 
%%
%%%%Grades: B Peripheral Later
%%
%%
%%% ------------------------------------------------------------------ 
\section{Name Generator}
%%% ------------------------------------------------------------------ 
%%
%%For labels, temporary variables, and similar objects generated by the
%%compiler we need an infinite supply of unique names.  In order to
%%avoid collisions with existing names in a {\PAL} program these names
%%are constructed in way that is not availabe at the {\PAL} source
%%level.  For example, no legal {\PAL} name contains a space and thus
%%generated names may contain spaces to avoid clases with exitisting
%%names.  This module provides a generator for names:  every invocation
%%generates a new name.  To aid debugging, a string can be supplied that
%%becomes part of the generated name.
%%
%%The names generated by this module generally \emph{do not} respect the
%%syntax for symbols of an assembly language.  Names that are used for
%%assembly symbols are mangled to ensure they conform to the assembler
%%at hand.  This happens usually in a compiler phase later than the one
%%where names are introduced.  See module \module{mangle} for the
%%connection between {\PAL} and assembly names.
%%
%%% ------------------------------------------------------------------ 
\subsection{Interface}
%%% ------------------------------------------------------------------ 
%%
%%The interface provides functions to generate unique names derived from
%%an existing legal {\PAL} name.  A generator permit to supply a string
%%that becomes part of the generated name.  The supplied name \emph{must}
%%be a legal {\PAL} name or the empty string, otherwise it is an unchecked
%%runtime-error.  Supplying the same name twice will result in different
%%generated names:  every invocation yields a unique name.
%%
%%Although one naming scheme could be used for different kinds of names
%%the interface provides functions for different kinds of names: labels,
%%temporaries, stack-offsets, and so on.  The kind of a name is encoded in
%%the generated string and hopefully can aid debugging. The name of a the
%%functions indicate their purpose. 
%%
<<idgen.mli>>=
type generator = string -> string
val label:      generator       (* denotes pc value *)
val offset:     generator       (* offset in stack       *)
val exit:       generator       (* label for exit node in procedure *)
val cont:       generator       (* symbol for dynamic continuation value *)
val slot:       generator       (* slot address on stack *)
val block:      generator       (* offset in Lua-generated Block.t address *)

module ContEntry : sig
  val cut    : generator       (* label for cut-to entry point *)
  val unwind : generator       (* label for unwind entry point *)
  val return : generator       (* label for alternate-return entry point *)
end
(* add more as needed *)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation must maintain state in order to generate unique
%%names. We use a counter to create unique strings. {\PAL} names must
%%not include a colon ``[[:]]'' character; we include such a character
%%into the generated names to avoid name clashes with existing names.
%%
<<idgen.ml>>=
type generator = string -> string
let count = Reinit.ref 0
@
%%Names returned by [[id]] use the supplied name as a prefix, followed
%%by a unique number. 
%%For a label, the prefix is chosen to be \texttt{.L}, which magically
%%causes the GNU assembler, linker and debugger to ignore the symbol.
%%(Contrary to the documentation, which claims that a bare~\texttt{L} is
%%the magic prefix.)
<<idgen.ml>>=
let id kind s =
    ( incr count
    ; Printf.sprintf "%s%s:%c%d" (if kind == 'l' then ".L" else "") s kind !count
    )
@
%%The kind of a name is encoded by a single letter in the name.
<<idgen.ml>>=
let label   = id 'l' 
let offset  = id 'o'
let exit    = id 'x'
let cont    = id 'c'
let slot    = id 's'
let block   = id 'b'
module ContEntry = struct
  let cut    = id 'C'
  let unwind = id 'U'
  let return = id 'R'
end
(* add more here as needed *)
@
\section{[[commons3/reinit.nw]]}
<<commons3/reinit.ml>>=
<<reinit.ml>>
@

<<commons3/reinit.mli>>=
<<reinit.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
\section{Reinitialization}
%%
%%If multiple files are compiled in a single pass, we do not want to
%%output to depend on the sequence in which the files are processed.
%%Calling [[Reinit.reset]] will reset any mutable state that can effect the
%%output.
%%
%%A module can ask to be reinitialized when the driver is reinitialized.
%%Any function registered with [[at]] is called by [[reset]].
<<reinit.mli>>=
val at : (unit -> unit) -> unit
val reset : unit -> unit
@ 
%%
%%The common case is to create a ref cell that is automatically
%%reinitialized when [[reset]] is called.
<<reinit.mli>>=
val ref : 'a -> 'a ref
@ 
<<reinit.ml>>=
let tasks = ref ([] : (unit -> unit) list)
let at f = tasks := f :: !tasks
let reset () = List.iter (fun f -> f ()) (!tasks)
let ref x =
  let r = ref x in
  at (fun () -> r := x);
  r
@ 
\section{[[commons3/tx.nw]]}
<<commons3/tx.ml>>=
<<tx.ml>>
@

<<commons3/tx.mli>>=
<<tx.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
<<tx.mli>>=
val decrement : name:string -> from:int -> to':int -> unit
val remaining : unit -> int
val set_limit : int -> unit
val used : unit -> int
val last : unit -> string
@
<<tx.ml>>=
type t = { mutable limit : int; mutable remaining : int; mutable last : string; }
let ts = { limit = max_int; remaining = max_int; last = "<none>"; }
let _ = Reinit.at (fun () -> begin 
  ts.limit <- max_int;
  ts.remaining <- ts.limit;
  ts.last <- "<none>";
end)

let () = Debug.register "tx" "watch transaction counts"

let set_limit n = ts.limit <- n; ts.remaining <- n
let remaining () = ts.remaining
let decrement ~name ~from ~to' =
  assert (ts.remaining = from);
  if from <> to' then
    begin
      Debug.eprintf "tx" "'%s' decrementing tx's from %d to %d (diff is %d)\n"
        name from to' (from-to');
      ts.remaining <- to';
      ts.last <- name
    end

let used _ = ts.limit - ts.remaining
let last _ = ts.last

@
\section{[[commons3/uint64.nw]]}
<<commons3/uint64.ml>>=
<<uint64.ml>>
@

<<commons3/uint64.mli>>=
<<uint64.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% l2h substitution C C--
%%% l2h substitution PAL C--
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% l2h substitution asdl ASDL
%%% l2h substitution ocaml OCaml
%%% l2h substitution forall forall
%%
%%% ------------------------------------------------------------------ 
\section{UInt64 -- unsigned operations on \texttt{int64}}
%%% ------------------------------------------------------------------ 
%%
%%This module provides unsigned operations on {\ocaml} [[int64]] values
%%and some conversions. The operations just add a new interpretation to
%%values of type [[int64]] but no new type is introduced.
%%
%%% ------------------------------------------------------------------ 
\subsection{Interface}
%%% ------------------------------------------------------------------ 
%%
%%Values of [[int64]] can be converted into [[float]] values by
%%re-interpreting the bit patterns of the [[int64]] value. This is a much
%%different operation than provided by the [[Int64]] module which
%%converts between [[float]] and [[int64]] by maintaining the numerical
%%value. This conversion maintains the bit patters and thus relates two
%%very different numerical values.
%%
%%Primitive functions, called \textit{external}, are implemented in C,
%%\textit{internal} functions use them and are implemented in {\ocaml}. 
<<uint64.mli>>=
<<external functions>>
<<internal functions>>
@
%%The [[Cast]] module provides two different packagings of the identity
%%function.
%%Function [[Cast.float64]] takes a 64-bit floating-point value and
%%returns the same bits as a 64-bit integer.
%%Function [[Cast.float32]] takes a 64-bit floating-point value,
%%converts it to a 32-bit floating-point value, and returns those bits
%%in the least significant 32~bits of a 64-bit integer.
<<uint64.mli>>=
module Cast : sig
 external float64 :   float -> int64 = "uint64_float64"
 external float32 :   float -> int64 = "uint64_float32"
end
@
%%The function [[of_int]] copies an [[int]] bitwise into an [[int64]]
%%value; unlike [[Int64.of_int]] no sign-extension is performed.
<<external functions>>=
(* external of_int:     int   -> int64                  = "uint64_i2i" *)
@
%%The following arithmetical operations consider their arguments and
%%return values as unsigned integers. Otherwise they implement the
%%behavior of the corresponding functions in the [[Int64]] module.
<<external functions>>=
external cmp:        int64 -> int64 -> int           = "uint64_compare"
external add:        int64 -> int64 -> int64         = "uint64_add"
external sub:        int64 -> int64 -> int64         = "uint64_sub"
external mul:        int64 -> int64 -> int64         = "uint64_mul"
external div:        int64 -> int64 -> int64         = "uint64_div"
external modu:       int64 -> int64 -> int64         = "uint64_mod"
@
%%The [[of_string]] function parses a string into a [[int64]] value. 
%%Unlike the corresponding function from [[Int64]] it uses the highest
%%result bit as well and thus considers the result as an unsigned
%%integer. Also unlike [[Int64.of_string]], it considers a number to be
%%in octal notation, when it starts with a [[0]],
%%and for a decimal number, it accepts a trailing [[u]] or [[U]].
%%\begin{quote}
%%    \begin{tabular}{ll}
%%        Prefix         & encoding \\
%%        \hline
%%        [[0x]], [[0X]] & hexadecimal \\
%%        [[0o]], [[0O]] & octal       \\
%%        [[0b]], [[0B]] & binary      \\
%%        [[0]]          & octal       \\
%%        else           & decimal     \\
%%    \end{tabular}
%%\end{quote}
%%This function raises [[Failure]] with either [["overflow"]] or [["syntax"]].
<<external functions>>=
external of_string:  string -> int64                 = "uint64_of_string"
@
%%Unsigned comparison of [[int64]] values.
<<internal functions>>=
val eq:              int64 -> int64 -> bool     (* equal         *)
val lt:              int64 -> int64 -> bool     (* less than     *)
val gt:              int64 -> int64 -> bool     (* greather than *)
val le:              int64 -> int64 -> bool     (* less equal    *)
val ge:              int64 -> int64 -> bool     (* greater equal *)
@
%%Shift operations for unsigned [[int64]] values.
<<internal functions>>=
val shl:             int -> int64 -> int64      (* shift left  *)
val shr:             int -> int64 -> int64      (* shift right *)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation is imostly done in C like the implementation of
%%[[Int64]].  It simply provides some additional operations in the same
%%style as the [[Int64]] implementation. 
<<uint64.ml>>=
module I = Int64
<<external functions>>
module Cast = struct
 external float64 :   float -> int64 = "uint64_float64"
 external float32 :   float -> int64 = "uint64_float32"
end
@
%%Comparison functions are implemented with the help of the [[cmp]]
%%primitive. 
<<uint64.ml>>=
let eq  x y =    (cmp x y) = 0
let lt  x y =    (cmp x y) < 0
let gt  x y =    (cmp x y) > 0
let le  x y =    (lt x y) || (eq x y)
let ge  x y =    (gt x y) || (eq x y)

let le  x y =    not (gt x y)
let ge  x y =    not (lt x y)
@
%%The shift operations can be taken from the [[Int64]] module because
%%they are the same for signed and unsigned values.  This applies to
%%many other operations as well.
<<uint64.ml>>=
let shl n x =    I.shift_left x n
let shr n x =    I.shift_right_logical x n  
@
%%
%%% ------------------------------------------------------------------ 
\subsection{C implementation of the primitives}
%%% ------------------------------------------------------------------ 
<<uint64p.c>>=
#include <caml/fail.h>
#include <caml/mlvalues.h>
#include <caml/alloc.h>
#include <caml/config.h>
@
%%Unsigned comparison of [[int64]] values; this implements the
%%(mathematical) sign function of the difference of the two values. 
<<uint64p.c>>=
value uint64_compare(value v1, value v2)
{
    uint64 i1 = Int64_val(v1);
    uint64 i2 = Int64_val(v2);
    return i1 == i2 ? Val_int(0) : i1 < i2 ? Val_int(-1) : Val_int(1);
}
@
%%Bitwise conversion of a [[float]] to a [[int64]].
<<uint64p.c>>=
value uint64_float64(value f)
{
    union { double d; int64 i; } buffer;
    buffer.d = Double_val(f);
    return copy_int64(buffer.i);
}

value uint64_float32(value f)
{
    union { float f; unsigned n; } buffer;
    int64 i;
    buffer.f = (float) Double_val(f);
    i = (int64) buffer.n;
    return copy_int64(i);
}

@
%%Bitwise conversion of a [[int64]] value to to [[float]].
<<uint64p.c>>=
value uint64_i2f(value i)
{
    union { double d; int64 i; } buffer;
    buffer.i = Int64_val(i);
    return copy_double(buffer.d);
}
@
%%The following function is a quick hack and not portable to 64 bit
%%architectures.  It converts an [[int]] value bitwise into an [[int64]]
%%value. 
<<uint64p.c>>=
value uint64_i2i(value i)
{
    union { int32 i[2]; int64 j; } buffer;
    
    buffer.i[0] = Int_val(i);
    buffer.i[1] = 0;

    return copy_int64(buffer.j);
}
@
%%Implementation of unsigned arithmetic operators.
<<uint64p.c>>=
value uint64_add(value v1, value v2)  /* ML */
{ return copy_int64((uint64)Int64_val(v1) + (uint64)Int64_val(v2)); }

value uint64_sub(value v1, value v2)  /* ML */
{ return copy_int64((uint64)Int64_val(v1) - (uint64)Int64_val(v2)); }

value uint64_mul(value v1, value v2)  /* ML */
{ return copy_int64((uint64)Int64_val(v1) * (uint64)Int64_val(v2)); }
@ 
<<uint64p.c>>=
value uint64_div(value v1, value v2)  /* ML */
{
    int64 divisor = Int64_val(v2);
    if (divisor == 0) raise_zero_divide();
    return copy_int64((uint64)Int64_val(v1) / (uint64)divisor);
}

value uint64_mod(value v1, value v2)  /* ML */
{
    int64 divisor = Int64_val(v2);
    if (divisor == 0) raise_zero_divide();
    return copy_int64((uint64)Int64_val(v1) % (uint64)divisor);
}
@
%%Some more code stolen from the {\ocaml} implementation because it is
%%declared [[static]] there such that we can't access it.
%%[[parse_digit]] returns the value of a digit in its string
%%representation. 
<<uint64p.c>>=
static int parse_digit(char * p)
{
    int c = *p;
    if (c >= '0' && c <= '9')
        return c - '0';
    else if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    else if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    else
        return -1;
}
@
%%A string number contains its radix implicitly. This function sets the
%%[[base]] accordingly and returns an advanced [[p]] such that a header
%%like [[0x]] is skipped. 
<<uint64p.c>>=
static char* parse_base (char *p, int *base)
{
    *base = 10;
    if (*p == '0') {
        switch (p[1]) {
        case 'x': case 'X':
            *base = 16; return p + 2;
        case 'o': case 'O':
            *base =  8; return p + 2; 
        case 'b': case 'B':
            *base =  2; return p + 2; 
        default:
            *base =  8; return p;
        }
    } else {
        return p;
    }
}
@
%%Convert a string to an unsigned [[int64]] value.  In case of syntax
%%errors or overflow, raise [[Failure]].  
%%
<<uint64p.c>>=
value uint64_of_string(value s)          /* ML */
{
    uint64 max_uint64 = ~(uint64)0;
    char * p;
    uint64 res, threshold;
    int base, d;

    p = parse_base (String_val(s), &base);
    threshold = max_uint64 / (uint64) base;
    for (res = 0; /*nothing*/; p++) {
        d = parse_digit(p);
        if (d < 0 || d >= base) break;
        /* Detect overflow in multiplication base * res */
        if (threshold < res) caml_failwith("overflow");
        res = res * (uint64)base + (uint64)d;
        /* Detect overflow in addition (base * res) + d */
        if (res < (uint64)d) caml_failwith("overflow");
    }
    if ((base == 10 || (base == 8 && res == 0)) && (*p == 'u' || *p == 'U')) p++;
    if (p != String_val(s) + caml_string_length(s)) failwith("syntax");
    return copy_int64(res);
}
@ 

\chapter{[[error]]}

\section{[[error/debug.nw]]}
<<error/debug.ml>>=
<<debug.ml>>
@

<<error/debug.mli>>=
<<debug.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
\section{Diagnostic output}
%%
%%Uses environment variable [[QCDEBUG]] to make noise.
%%This variable contains a comma-separated list of words;
%%if a word is on the list, output happens.
<<debug.mli>>=
val on : string -> bool   (* debugging on for this word *)
val eprintf : string -> ('a, out_channel, unit) format -> 'a
  (* if debugging on, print to stderr *)
@
%%You can ask for information about what's known, which is provided by
%%[[register]].
%%It's a checked error to register the same word more than once.
<<debug.mli>>=
val explain : unit -> unit   (* print known words to stderr *)
val register : word:string -> meaning:string -> unit
@ 
<<debug.ml>>=
let debugging =
  try Str.split (Str.regexp ",") (Sys.getenv "QCDEBUG") with _ -> []
let on s = List.mem s debugging

let refs = ref ([] : (string * string) list)
let register ~word ~meaning =
  let (<) : string -> string -> bool = Pervasives.(<) in
  let rec insert word meaning = function
    | [] -> [(word, meaning)]
    | ((w, m) as p) :: ps when word < w -> (word, meaning) :: p :: ps
    | p :: ps -> p :: insert word meaning ps in
  if List.mem_assoc word (!refs) then
    Impossible.impossible ("Debug.register: multiple registrations of " ^ word)
  else
    refs := insert word meaning (!refs)

let rec ign x = Obj.magic ign
let print_and_flush s = (prerr_string s; flush stderr)
let eprintf s = if on s then Printf.kprintf print_and_flush else ign
(* for reasons known only to INRIA, eprintf and kprintf have different types,
   so the above will not typecheck *)
let eprintf s = if on s then Printf.eprintf else ign
@ 
<<debug.ml>>=
let explain () =
  Printf.eprintf "Words recognized in QCDEBUG:\n";
  List.iter (fun (w, e) -> Printf.eprintf "  %-15s  %s\n" w e) (!refs)
@ 
\section{[[error/error.nw]]}
<<error/error.ml>>=
<<error.ml>>
@

<<error/error.mli>>=
<<error.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------  
\section{Error Handling}
%%% ------------------------------------------------------------------ 
%%
%%The idea of error-handling in {\qcc} is not to stop in all cases after
%%an error but to mark results as either good or bad.  Bad values can be
%%used for further computation although the overall result will be bad. 
%%The hope is, to detect even more errors that are \textit{not} caused
%%by any previous error.  Details of this idea and the following
%%implementation can be found in \textit{Eliminating Spurious Error
%%Messages Using Exceptions, Polymorphism and Higher-Order Functions}
%%\cite{ramsey:99:compj}.
%%
%%% ------------------------------------------------------------------  
\subsection{Interface}
%%% ------------------------------------------------------------------  
%%
%%Technically, results are wrapped in an [['a error]] type; good results
%%are represented by the [[Ok]] constructor, bad results by [[Error]]. 
%%A set of combinators helps to deal with this type of values. In
%%addition, an exception can be raised to signal an error.
%%
<<error.mli>>=
type 'a error       = Error                     (* bad result  *)
                    | Ok        of 'a           (* good result *)

exception ErrorExn  of string
val error :         string -> 'a (* ErrorExn *)
val errorf : ('a, unit, string, 'b) format4 -> 'a
@
%%
%%Now that a bad result can be either signaled by returning an [[Error]]
%%value, or raising the [[ErrorExn]] exception, the following policy
%%helps to decide which method to use:
%%
%%\begin{enumerate}
%%\item Good values are returned wrapped by [[Ok]].
%%\item Computations that use bad values provided from the outside
%%      result in bad values that are returned wrapped in [[Error]].
%%\item If a computation (over good or bad values) detects a new error
%%      this is reported with an exception. It is the obligation of the
%%      client to catch this exception, report it, and possibly return a
%%      bad value to go on.
%%\end{enumerate}
%%
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Error functions}\label{sect:error-fun}
%%% ------------------------------------------------------------------ 
%%
%%In the original paper \textit{Eliminating Spurious Error Messages
%%Using Exceptions, Polymorphism and Higher-Order Functions}
%%\cite{ramsey:99:compj} higher order functions usually expect functions
%%as the first argument:  [[('a -> 'b) -> 'a error -> 'b error]] and
%%arguments to them at higher positions.  Moving the function argument
%%to the last position like in [['a error -> ('a -> 'b)]] provides more
%%syntactical freedom because the function can be easier written inline,
%%covering multiple lines of source code.  For this reason function
%%arguments will come last.
%%
%%Combinators to deal with functions that do not naturally expect 
%%values of type [[error]].
<<error.mli>>=
val combine : 'a error error -> 'a error
val ematch  : 'a error -> ('a -> 'b) -> 'b error
val ematch2 : 'a error -> 'b error -> ('a -> 'b -> 'c) -> 'c error
val ematch3 : 'a error -> 'b error -> 'c error ->
              ('a -> 'b -> 'c -> 'd) -> 'd error
val ematch4 : 'a error -> 'b error -> 'c error -> 'd error -> 
              ('a -> 'b -> 'c -> 'd -> 'e) -> 'e error
val ematch5 : 'a error -> 'b error -> 'c error -> 'd error -> 'e error ->
              ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'f error
val ematch6 : 'a error -> 'b error -> 'c error -> 'd error -> 'e error -> 'f error ->
              ('a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g) -> 'g error
val ematchPair  : 'a error * 'b error -> ('a * 'b -> 'c) -> 'c error
val ematchTriple: 'a error * 'b error * 'c error -> 
                   ('a * 'b * 'c -> 'd) -> 'd error
val ematchQuad  : 'a error * 'b error * 'c error * 'd error -> 
                   ('a * 'b * 'c * 'd -> 'e) -> 'e error
val seq         : 'a error -> ('a -> 'b error) -> 'b error
val seq2        : 'a error -> 'b error -> ('a -> 'b -> 'c error) -> 'c error
val seqPair     : 'a error * 'b error -> ('a * 'b -> 'c error) -> 'c error
val seq'        : 'b -> 'a error -> ('a -> 'b) -> 'b 
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Raising functions}
%%% ------------------------------------------------------------------ 
%%
%%
%%Raising combinators raise the constructors of an [[error]] value
%%inside a complex value to the top-level.  A complex value is bad when
%%one of its components is bad and good otherwise.  The raising
%%combinators deal with the most important data types:  options, lists,
%%and tuples.
%%
<<error.mli>>=
module Raise :
  sig
    val option : 'a error option                -> 'a option error
    val list   : 'a error list                  -> 'a list error
    val pair   : 'a error * 'b error            -> ('a * 'b) error
@
%%The [[left]] and [[right]] functions consider only one component of
%%a pair when raising the constructor.
<<error.mli>>=
    val left   : 'a error * 'b                  -> ('a * 'b) error
    val right  : 'a * 'b error                  -> ('a * 'b) error
    
    val triple : 'a error * 'b error * 'c error -> ('a * 'b * 'c) error
    val quad   : 'a error * 'b error * 'c error * 'd error 
                  -> ('a * 'b * 'c * 'd) error
  end
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Lowering functions}
%%% ------------------------------------------------------------------ 
%%
%%Lowering functions take a complex [[error]] value and push the
%%constructor from the top-level to the values inside the [[error]]
%%value. 
<<error.mli>>=
module Lower :
  sig
    val pair   : ('a * 'b)           error -> 'a error * 'b error
    val triple : ('a * 'b * 'c)      error -> 'a error * 'b error * 'c error
    val quad   : ('a * 'b * 'c * 'd) error -> 'a error 
                                            * 'b error 
                                            * 'c error 
                                            * 'd error
  end
@
%%The functions of the [[Implode]] module destroy informations by
%%reducing complex [['a error]] values to [[unit error]]. They come in
%%handy when are there are only good and bad results. Whenever an
%%any argument of a function contains an [[Error]] value the outcome is
%%[[Error]] and [[Ok()]] otherwise. 
%%
%%The [[list]] function is similar to [[Raise.list]] as is raises the
%%[[error]] type to the top level.  The [[map]] function is greedy:  it
%%does not stop when it encounters the first [[Error]] but traverses the
%%whole list.  The motivation is to give detect possible bad values in
%%the list such that the [[ErrorExn]] can be raised for them. 
<<error.mli>>=
module Implode :
  sig
    val singleton : 'a error                                  -> unit error
    val pair :      'a error * 'b error                       -> unit error
    val triple :    'a error * 'b error * 'c error            -> unit error
    val quad :      'a error * 'b error * 'c error * 'd error -> unit error
    val list :      'a error list                             -> unit error
    val map :       ('a -> 'b error) -> 'a list               -> unit error
  end
@
%%
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Catching and Printing Errors}
%%% ------------------------------------------------------------------ 
%%
%%At the point where an error occurs the first time the [[ErrorExn]]
%%is raised.  When the exception is caught is is turned into an
%%[[Error]] value and from there on the [[Error]] value is propagated. 
%%Catching the exception is done with [[catch]] in the special case, and
%%[[catch']] in the general case.  [[catch']] permits to specify the
%%value that is returned when an exception is caught whereas [[catch]]
%%always uses [[Error]] for this.
<<error.mli>>=
val catch   :       (string -> unit) 
                    -> ('a -> 'b error) -> 'a -> 'b error
val catch'  : 'b -> (string -> unit) 
                    -> ('a -> 'b      ) -> 'a -> 'b 
@
%%
%%he first argument in [[catch printer f x]] is an error reporting
%%function; [[f]] is applied to [[x]] and in case of an error [[Error]]
%%is returned. The first argument to [[catch']] is the value to return
%%in case of an error.
%%
%%The [[warningPrt]] and [[errorPrt]] functions can be passed to
%%[[catch]] and [[catch']] as error printing functions. However, in most
%%cases specialized functions for error reporting will be used to include
%%some source code locations.
%%
<<error.mli>>=
val warningPrt : string -> unit
val errorPrt   : string -> unit
@
%%
%%The following error reporting functions take a location as their first
%%argument.  Typically the location is supplied to the function like in
%%[[errorPointPrt point]] and the resulting closure is passed to
%%[[catch]].  This works because the error locations are attached where
%%exceptions are caught and not where they are raised.
%%
<<error.mli>>=
val errorPointPrt  : Srcmap.point -> string -> unit
val errorRegionPrt : Srcmap.region -> string -> unit
val errorPosPrt    : Srcmap.pos -> string -> unit
val errorRegPrt    : Srcmap.rgn -> string -> unit
@
%%
%%% ------------------------------------------------------------------  
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<error.ml>>=
type 'a error       = Error                     (* bad result  *)
                    | Ok        of 'a           (* good result *)

exception ErrorExn          of string
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Raising functions}
%%% ------------------------------------------------------------------ 
%%
%%Raising combinators raise the constructors of an [[error]] value inside
%%a complex value to the top-level. A complex value is bad when one
%%of its components is bad and good otherwise. The raising combinators
%%deal with the most important data types: options, lists, and tuples.
%%
<<error.ml>>=
module Raise = struct
    <<raise module>>
end
@
<<raise module>>=
let option = function
    | Some Error        -> Error
    | Some (Ok x)       -> Ok (Some x)
    | None              -> Ok (None)
@
%%
<<raise module>>=
let list xs =
    let rec loop acc = function
        | []            -> Ok (List.rev acc)
        | (Ok x)::xs    -> loop (x::acc) xs
        | Error::xs     -> Error 
    in      
        loop [] xs
@
%%
<<raise module>>=
let pair = function
    | (Ok x, Ok y)          -> Ok (x,y)
    | _                     -> Error
@
%%        
<<raise module>>=
let left = function
    | (Ok x, y)             -> Ok (x,y)
    | _                     -> Error
@
<<raise module>>=
let right = function
    | (x, Ok y)             -> Ok (x,y)
    | _                     -> Error
@
%%
<<raise module>>=
let triple = function
    | (Ok x, Ok y, Ok z)    -> Ok (x,y,z)
    | _                     -> Error 
@
%%
<<raise module>>=
let quad = function
    | (Ok a,Ok b,Ok c,Ok d) -> Ok (a,b,c,d)
    | _                     -> Error
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Lowering functions}
%%% ------------------------------------------------------------------ 
%%
%%Lowering functions take a complex [[error]] value and push the
%%constructor from the top-level to the values inside the [[error]]
%%value. 
%%
<<error.ml>>=
module Lower = struct
    <<lower module>>
end
@
%%
<<lower module>>=
let pair = function
    | Ok (x,y)              -> Ok x , Ok y
    | Error                 -> Error, Error 
@
<<lower module>>=
let triple = function
    | Ok (x,y,z)            -> Ok x , Ok y , Ok z
    | Error                 -> Error, Error, Error
@
<<lower module>>=
let quad = function
    | Ok (a,b,c,d)          -> Ok a , Ok b , Ok c , Ok d
    | Error                 -> Error, Error, Error, Error
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Reduction functions}
%%% ------------------------------------------------------------------ 
%%
%%Sometimes it is sufficient to distinguish between good and bad
%%values. Any complex value that has a bad value in it is itself bad.
%%The [[Implode]] module reduces everything to [[unit Error]] values
%%which means it (carefully) destroys informations.
%%
<<error.ml>>=
module Implode = struct
    <<implode module>>
end
@
%%
<<implode module>>=
let singleton = function
    | Ok _ -> Ok ()
    | _    -> Error
@
%%
<<implode module>>=
let pair = function
    | Ok _, Ok _ -> Ok ()
    | _          -> Error
@
%%
<<implode module>>=
let triple = function
    | Ok _, Ok _, Ok _ -> Ok ()
    | _                -> Error
@
%%
<<implode module>>=
let quad = function
    | Ok _, Ok _, Ok _, Ok _ -> Ok ()
    | _                      -> Error
@
%%
<<implode module>>=
let rec list = function
    | []            -> Ok ()
    | (Ok _)::xs    -> list xs
    | _             -> Error 
@
%%
<<implode module>>=
let map f l =
    let ok = Ok () in
    let rec loop res = function
        | []    -> res
        | x::xs -> ( match res, f x with
                   | Error, _     -> loop Error xs 
                   |    _ , Error -> loop Error xs
                   | _            -> loop ok    xs
                   )
    in
        loop ok l 
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Error functions}
%%% ------------------------------------------------------------------ 
%%
%%The following combinators bridge the gap between code that uses error
%%propagation using the [[error]] type and code that doesn't.
<<error.ml>>=
let combine = function  
    | Ok x      -> x
    | Error     -> Error
@
%%
<<error.ml>>=
let ematch x f = match x with Ok x -> Ok (f x) | Error -> Error
let ematch2 x y f =
  match x with Ok x -> (match y with  Ok y -> Ok (f x y) | _ -> Error) | _ -> Error
let ematch3 x y z f     = match x with Ok x -> ematch2 y z     (f x) | Error -> Error
let ematch4 x y z w f   = match x with Ok x -> ematch3 y z w   (f x) | Error -> Error
let ematch5 x y z w v f = match x with Ok x -> ematch4 y z w v (f x) | Error -> Error
let ematch6 x y z w v u f =
  match x with Ok x -> ematch5 y z w v u (f x) | Error -> Error
let ematchPair    x2 = ematch (Raise.pair x2)
let ematchTriple  x3 = ematch (Raise.triple x3)
let ematchQuad    x4 = ematch (Raise.quad x4)
@
%%
<<error.ml>>=
let seq x f = match x with Ok x -> f x | Error -> Error
let seq2 x y f =
  match x with Ok x -> (match y with  Ok y -> f x y | _ -> Error) | _ -> Error
let seq' default x f = match x with Ok x -> f x | Error -> default
let seqPair x2   = seq (Raise.pair x2)
@
%%    
%%% ------------------------------------------------------------------ 
%%\subsubsection{Error reporting}
%%% ------------------------------------------------------------------ 
%%
%%We provide functions to raise the error ([[ErrorExn]]) exception and
%%issue warnings.
%%
<<error.ml>>=
let catch' default printer f arg =
    try f arg with
    | ErrorExn(msg) -> ( printer msg 
                       ; default
                       )
@
<<error.ml>>=
let catch printer f arg = catch' Error printer f arg
let error msg           = raise (ErrorExn msg)
let errorf fmt = Printf.kprintf error fmt
@
%%
%%The following functions print error and warning messages. They differ
%%in the argument describing a source code position the error is
%%attributed to.
%%
<<error.ml>>=
let warningPrt msg = Printf.eprintf "Warning: %s\n" msg
let errorPrt   msg = Printf.eprintf "Error: %s\n"   msg
@
<<error.ml>>=
let errorPointPrt  p msg = 
    ( Printf.eprintf "%s " (Srcmap.Str.point p)
    ; errorPrt msg
    )
@
<<error.ml>>=
let errorRegionPrt r msg =
    ( Printf.eprintf "%s " (Srcmap.Str.region r)
    ; errorPrt msg
    )
@
<<error.ml>>=
let errorPosPrt    p msg =
    ( Printf.eprintf "Character %d " p
    ; errorPrt msg
    )
@
<<error.ml>>=
let errorRegPrt (l,r) msg = 
    ( Printf.eprintf "Character %d-%d " l r
    ; errorPrt msg
    )
@
%%
%%
\section{[[error/impossible.nw]]}
<<error/impossible.ml>>=
<<impossible.ml>>
@

<<error/impossible.mli>>=
<<impossible.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% l2h substitution cfg CFG
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% l2h substitution dots ...
%%% l2h substitution AST AST
%%% l2h substitution ast AST
%%% l2h substitution rtl RTL
%%% l2h substitution ir IR
%%% l2h substitution noweb NOWEB
%%% l2h substitution qcc QC--
%%% l2h substitution C C--
%%% l2h substitution PAL C--
%%% l2h substitution pal C--
%%% l2h substitution asdl ASDL
%%% l2h substitution ocaml OCaml
%%% l2h substitution forall forall
%%% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>
%%
%%\input{../config/macros.tex}
%%
%%% ------------------------------------------------------------------ 
\section{Impossible}
%%% ------------------------------------------------------------------ 
%%
%%Implementations are imperfect: they reach code that they should. This
%%module provides two function to signal these kind of internal errors:
%%
%%\begin{itemize}
%%\item Code that should be unreachable due to the internal logic of the
%%      program should call [[impossible]] with a descriptive message.
%%
%%\item Missing implementations call [[unimp]] with a descriptive message.
%%\end{itemize}
%%
%%{\ocaml} does not provide [[__LINE]__]] and [[__FILE__]] like the C
%%pre-processore.  It is therefore a good idea to include the source
%%file name in the messages passed to [[impossible]] and the like.  A
%%raised exception by itself does not include any hint where it was
%%raised.  The {\ocaml} debugger is one way of finding where an
%%excpetion was raised.
%%
<<impossible.mli>>=
val impossible: string -> 'a
val unimp:      string -> 'a
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<impossible.ml>>=
exception Impossible of string

let impossible msg =
  prerr_endline ("This can't happen: " ^ msg);
  raise (Impossible msg)
let unimp msg = 
  prerr_endline ("Not implemented in qc--: " ^ msg);
  raise (Impossible msg)
@
%%
\section{[[error/srcmap.nw]]}
<<error/srcmap.ml>>=
<<srcmap.ml>>
@

<<error/srcmap.mli>>=
<<srcmap.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% l2h substitution C C--
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% l2h substitution asdl ASDL
%%% l2h substitution ocaml OCaml
%%
%%\input{../config/macros.tex}
%%
%%% ------------------------------------------------------------------  
\section{Source Code Locations}\label{srcmap}
%%% ------------------------------------------------------------------  
%%
%%The scanner (section \ref{sec:scanner}) operates on a character
%%stream.  An offset from the beginning of the stream marks a
%%\textit{position} inside the stream; the first character in the stream
%%has position 0.  The parser (section \ref{sec:parser}) takes positions
%%reported by the scanner to mark nodes in the abstract syntax with
%%regions.  A region is a pair of two positions and defines the span a
%%node covers in the source code.
%%
%%Positions are easy to manipulate by a program but less useful for a
%%programmer who likes to think in terms of line numbers and columns in
%%a file.  A \textit{source map} translates source code
%%\textit{positions} into source code \textit{locations} that are made
%%up from
%%
%%\begin{itemize}
%%\item a file name,
%%\item a line number in that file (first line has number 1),
%%\item and a column (first column is 1). There seems to be no
%%      convention whether the first column in a line is considered 0 or
%%      1. The Emacs editor adheres to the first, the Vi editor to the
%%      latter perspective.
%%\end{itemize}
%%
%%To establish the connection between simple positions and complex
%%locations these two views must be \textit{synchronized}.  The result
%%of all synchronizations is a source map.  The views must synchronize
%%whenever advancing in the stream of characters is different from
%%moving to the next column in the position's view.  This happens
%%typically at the following points in a source file:
%%
%%\begin{itemize} 
%%\item Start of a new source file.
%%\item Beginning of a new line.
%%\item A tab character that skips some columns.
%%\item Some directive like [[#line]] from the C pre-processor
%%      indicates a non-linearity in the source code. 
%%\end{itemize}
%%
%%A synchronization establishes a connection between a source code
%%position and a (filename, line, column) location.  The point of
%%synchronization is called a synchronization point or sync point.  
%%
%%In principle, synchronization points can be placed in any order into a
%%stream of characters.  The following restriction usually does not harm
%%and helps to to build efficient source maps:  source code positions
%%increase in the order synchronization points are established.  This
%%means, that never a position to the left of an existing
%%synchronization point is synchronized.
%%
%%Building and using a source map involves the following key operations:
%%
%%\begin{itemize}
%%\item Create an initially empty source map.
%%\item Enter synchronization points into the map.
%%\item Return the location of a given position.
%%\end{itemize}
%%
%%To make any position meaningful, position 0 should be a
%%synchronization point. So whenever a source map is created a sync
%%point for position 0 should be placed into it.
%%
%%% ------------------------------------------------------------------  
\subsection{Interface}
%%% ------------------------------------------------------------------  
%%
%%Position are non negative characters counts in the input stream.  They
%%are represented by [[pos]].  A continuous region in the input
%%stream consists of the first character in the span and the first one
%%following it.
%%
<<srcmap.mli>>=
type pos            = int
type rgn            = pos * pos
@
%%The [[null]] region is sometimes used a special value when no real
%%region information is available.
%%
<<srcmap.mli>>=
val null            : rgn
@
%%
%%Programmers think in terms of locations, describing a line and
%%column in a file; they have type [[loc]].  I have chosen to use a
%%tuple to represent a location instead of a record type.  There is some
%%danger of confusing lines and columns because they share the same
%%type.  Records avoid this but have other drawbacks:  labels must be
%%unique which leads to long names and ugly pattern matching.
%%
<<srcmap.mli>>=
type location       = string    (* file   *)
                    * int       (* line   *)
                    * int       (* column *)
@
%%A source map is a mutable data structure with an undisclosed
%%representation.  A source map should never be empty but should contain
%%a synchronization point for [[pos]] 0.  The [[mk]] function returns an
%%empty source map for a file.
%%
<<srcmap.mli>>=
type map
val mk:             unit -> map (* empty map *)
@
%%
%%A synchronization is announced with [[sync]].  It synchronizes a
%%position [[pos]] with a [[location]].  A common case is the
%%synchronization for a new line trough [[nl]].  A new line stays in the
%%same file as the previous sync point and advances one line.  The
%%[[pos]] passed to [[nl]] is that of the first character on the new
%%line.  Another common case are tab characters which we currently
%%ignore.
%%
<<srcmap.mli>>=
val sync :          map -> pos -> location -> unit
val nl :            map -> pos -> unit
@
%%[[last]] returns the location of the last sync point. It is useful
%%to get the current file name and line number.
%%
<<srcmap.mli>>=
val last :          map -> location
@
%%The corresponding location for a position can be obtained with
%%[[location]].  For debugging a source map can be dumped to stdout
%%using [[dump]]. 
%%
<<srcmap.mli>>=
val location :      map -> pos -> location
val dump:           map -> unit
@
%%To make positions meaningful they can be bundled with a source map
%%that keeps track of their origins. 
%%
<<srcmap.mli>>=
type point          = map * pos
type region         = map * rgn
@
%%The [[Str]] module provides string representations for points and regions.
%%
<<srcmap.mli>>=
module Str:
sig
    val point       : point  -> string
    val region      : region -> string
end
@
%%
%%% ------------------------------------------------------------------  
\subsection{Implementation}
%%% ------------------------------------------------------------------  
%%
%%A single compilation unit can easily contain some thousand lines of
%%code and at least as many synchronization points. An implementation
%%should thus pay attention to memory requirements and run time
%%performance. 
%%
<<srcmap.ml>>=
type pos            = int
type rgn            = pos * pos
type location       = string    (* file   *)
                    * int       (* line   *)
                    * int       (* column *)
@ 
%%
<<srcmap.ml>>=
let null = (0,0)
@
%%
%%A [[syncpoint]] associates a [[pos]] with a [[location]]. To
%%lower memory requirements a bit this could be also defined as a
%%quadruple. 
%%
<<srcmap.ml>>=
type syncpoint      = pos * location
@
%%
%%We have chosen to use an array to implement a source map.  Binary
%%search can be used to implement the lookup operation and an array
%%is compact in memory.  When an array fills up it is copied
%%into a new one twice of the size of the old. 
%%
%%Using an array also requires the restriction mentioned above:  sync
%%point positions must have an increasing order.  This could be dropped
%%when the array is sorted before it is first used for the lookup
%%operation.
%%
%%Storing the file name for every sync point requires lots of memory,
%%especially when long path names are involved.  The number of different
%%files referenced by all sync point is probably small.  Storing every
%%name only once thus can help to save memory.  For this purpose a hash
%%table is established.  A file name is never stored directly in the
%%array but looked up first in the hash table.  The instance found there
%%goes into the array.  Although it looks like the one from the location
%%it is a different one that is shared among all sync points using this
%%name.
%%
<<srcmap.ml>>=
type map =          { mutable points:       syncpoint array 
                    ; mutable top:          int
                    ; files :               (string, string) Hashtbl.t
                    }
type point          = map * pos
type region         = map * rgn
@
%%
%%The [[top]] component maintains the index of the first free position
%%in the [[points]] array.  In \ocaml~every array cell must be
%%initialized upon creation.  We use [[undefined]] for this.  The
%%initial size of the array is [[size]].
%%
<<srcmap.ml>>=
let size        =  2    (* small to test alloc *)
let undefined   =  (0, ("undefined", -1, -1))    
@ 
%%
<<srcmap.ml>>=
let mk () =
    { points  = Array.create size undefined 
    ; top     = 0
    ; files   = Hashtbl.create 17
    }    
@
%%
%%To prevent that the array fills up [[alloc]] makes sure there is at
%%least space for the next sync point.  In case the array is full it
%%copies the existing array into a new one, twice of the size of the
%%old. 
%%
<<srcmap.ml>>=

let alloc srcmap =
    let length = Array.length srcmap.points in
        if   srcmap.top < length then 
            ()
        else 
            let points' = Array.create length undefined in
                srcmap.points <- Array.append srcmap.points points'
@            
%%
%%Synchronizing means simply to enter the position and the
%%corresponding location into the array.  The file name in the location
%%is replaced by an instance that comes from the hash table and is
%%shared by many sync points.  We check also for the increasing order of
%%positions.
%%
<<srcmap.ml>>=
let sync srcmap pos (file,line,col) =
    let _     = alloc srcmap in
    let file' = try  Hashtbl.find srcmap.files file
                with Not_found -> ( Hashtbl.add srcmap.files file file
                                  ; file
                                  ) 
    in
    let location' = (file', line, col) in
    let top   = srcmap.top   in
        ( assert ((pos = 0) || (fst srcmap.points.(top-1) < pos))
        ; srcmap.points.(top) <- (pos,location')
        ; srcmap.top <- srcmap.top + 1
        )
@
%%
%%[[last]] returns the location of the last sync point. It is useful
%%to get the current file name and line number.
%%
<<srcmap.ml>>=
let last map =
    ( assert (map.top > 0 && map.top <= Array.length map.points)
    ; snd map.points.(map.top-1)
    )
@
%%
%%Entering a sync point for a new line is so common that it deserves
%%its own function.  The sync point is actually at the position
%%following the newline character because we know that this will be at the
%%beginning of the next line; thus [[position]] must point to this first
%%character of the new line.  The new line is in the same file as the
%%last sync point.
%%
%%Since [[last]] already returns the shared instance of the file name, the
%%hash table lookup in [[sync]] is superficial. Because [[nl]] is the most
%%frequently called sync function it is worth implementing it as a
%%specialed version of [[sync]] instead of calling [[sync]]:
%%
<<nl specification>>=
let nl map pos = 
    let (file, line, _) = last map in
        sync map pos (file, line+1, 1)
@
%%
<<srcmap.ml>>=
let nl srcmap pos =
    let _               = alloc srcmap  in
    let (file, line, _) = last srcmap   in
    let location' = (file, line+1,1) in
    let top   = srcmap.top   in
        ( assert ((pos = 0) || (fst srcmap.points.(top-1) < pos))
        ; srcmap.points.(top) <- (pos,location')
        ; srcmap.top <- srcmap.top + 1
        )
@
%%        
%%Function [[cmp]] compares a [[pos]] with a [[(pos,location)]]
%%pair; the [[pos]] is the one we like to find in the array.
%%
<<srcmap.ml>>=
let cmp x (y,_) = compare x y
@
%%
%%We want to find the element in the array with the position we are
%%looking for, or, if it is not there, the element to the left of it.
%%We expect that the array is not empty when it is used and secure this
%%by an assertion.  Only the first [[length]] entries are searched in
%%the array.
%%
<<srcmap.ml>>=
let search x array length cmp =
    let rec loop left right =
        if left > right then
            ( assert (0 <= right && right < Array.length array)
            ; array.(right)
            )
        else
            let pivot = (left + right)/2 in
            let res   = cmp x array.(pivot) in
            let _     = assert (0 <= pivot && pivot < Array.length array) in
                
                if res = 0 then 
                    array.(pivot)
                else if res < 0 then
                    loop left (pivot-1)
                else
                    loop (pivot+1) right
    in
        ( assert (length > 0)
        ; loop 0 (length-1)
        )
@
%%
%%To calculate the location of a position we have to find the sync
%%point to its left.  We do a binary search for this point in the map
%%which gives us a location.  The actual location is possibly to the
%%right of this point:  we simply have to add the missing columns to go
%%there.
%%
<<srcmap.ml>>=
let location map pos =
    let pos',(file,line,col) = search pos map.points map.top cmp in
    (file,line,pos - pos' + col)
@
%%
%%To aid debugging we provide a function [[dump]] to write the
%%contents of a [[srcmap]] to stdout.
%%
<<srcmap.ml>>=
let dump map =
    let point (pos,(file,line,col)) = 
        Printf.printf "%5d: %-32s %4d %3d\n" pos file line col
    in
        for i=0 to map.top-1 do
            point map.points.(i)
        done
@
%%
%%For reporting locations to the user they must be available as
%%strings. The [[Str]] module provides conversions.
%%
<<srcmap.ml>>=
module Str = struct
    let point  (map,pos) =
      let (file,line,column) = location map pos in
      Printf.sprintf "File \"%s\", line %d, character %d" file line column

    
    let region (map,rgn) =
        match rgn with 
        | (0,0)        -> Printf.sprintf "<unknown location>"
        | (left,right) -> 
        let (file1,l1,col1) = location map left   in
        let (file2,l2,col2) = location map right  in
        let (=$=) : string -> string -> bool = Pervasives.(=) in
            if file1 =$= file2 && l1 = l2 then
                Printf.sprintf 
                "File \"%s\", line %d, characters %d-%d" file1 l1 col1 col2
            else if file1 =$= file2 then
                Printf.sprintf 
                "File \"%s\", line %d, character %d - line %d, character %d"
                file1 l1 col1 l2 col2
            else
                Printf.sprintf 
                "File \"%s\", line %d, character %d - file %s, line %d, character %d"
                file1 l1 col2 file2 l2 col2
end
@
%$
\section{[[error/unsupported.nw]]}
<<error/unsupported.ml>>=
<<unsupported.ml>>
@

<<error/unsupported.mli>>=
<<unsupported.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
\section{Announcing unsupported constructs}
%%
%%This is a central place at which to announce all the things that a
%%back end does not support.
%%The virtue is that each comes with a lengthy explanation of what to do
%%to fix the problem.
<<unsupported.mli>>=
exception Unsupported
val explain : int -> int list -> unit

  (* Each function below always raises Unsupported *)

val widen_float : int -> 'a
val stack_width : have:int -> want:int -> 'a
val calling_convention : string -> 'a
val automaton_widths : int -> 'a
val automaton_widen  : have:int -> want:int -> 'a
val div_and_mod : unit -> 'a
val div_overflows : unit -> 'a
val floatlit : int -> 'a
val mulx_and_mulux : unit -> 'a
val singlebit : op:string -> 'a
val popcnt : notok:int -> ok:int -> 'a
@ 
<<unsupported.ml>>=
exception Unsupported
type state = { mutable n : int; mutable explanations : (int list -> string list) list }
let state = { n = 0; explanations = [] }

let getn f =
  state.n <- state.n + 1;
  let n = state.n in
  state.explanations <- f :: state.explanations;
  n
@ 
%%
%%In the [[fail]] function we unfortunately need to hard-code the name of the
%%binary being run (qc--) because otherwise OCaml provides the {\em absolute}
%%pathname of the binary, and users' error messages will thus not match
%%up with recorded error messages in the test suite (their binaries are likely
%%in different locations).
%%At some point in the future, if deemed necessary, we could always provide
%%a hack using an environment variable.  If the variable is set, we output
%%its value as [[binname]], otherwise we actually use [[Sys.argv.(0)]].
<<unsupported.ml>>=
let fail msg code args =
(*  let binname = Sys.argv.(0) in *)
  let binname = "qc--" in
  let args = String.concat ", " (List.map string_of_int (code :: args)) in
  Printf.eprintf "%s\n" msg;
  Printf.eprintf "For a longer explanation run\n  %s -e 'Unsupported.explain(%s)'\n"
        binname args;
  raise Unsupported
@ 
%%
<<unsupported.ml>>=
let explain n ns =
  let rec ex m l = match l with
  | [] -> Printf.printf "There is no explanation numbered %d\n" n
  | x :: xs ->
      if m = n then
        List.iter (Printf.printf "%s\n") (x ns)
      else
        ex (m-1) xs
  in ex state.n state.explanations
@ 
%%
<<unsupported.ml>>=
let exs ss = (fun _ -> ss)
let ex0 f = function
  |	[] -> f()
  |	_  ->
      ["For this explanation code, Unsupported.explain expects exactly one argument"]
let ex1 f = function
  | [n] -> f n
  | _ ->
      ["For this explanation code, Unsupported.explain expects exactly two arguments"]
let ex2 f = function
  | [n; m] -> f n m
  | _ ->
    ["For this explanation code, Unsupported.explain expects exactly three arguments"]
@ 
<<unsupported.ml>>=
let s = Printf.sprintf
let nosupport s = "This back end does not support " ^ s
@ 
%%
<<unsupported.ml>>=
let widen_n = getn (ex1 (fun n ->
    [ s "On this target, floating-point operations can be at most %d bits wide." n;
      "Narrower operations can be widened using one of the stages in the Widen";
      s "module, but anything wider than %d bits is unsupported." n;
    ]))

let widen_float d =
  fail (nosupport (s "%d-bit floating-point computation" d)) widen_n [d]
@ 
%%
<<unsupported.ml>>=
let stack_width_n = getn (ex2 (fun h w ->
  [ s "Your code tried to pass a %d-bit argument to an operator that takes its" h;
    s "arguments on the machine stack, but on this target, only %d-bit values can" w;
    "go on the machine stack.";
    "(This message could be triggered if you tried to use software rounding modes";
    "instead of hardware rounding modes in a floating-point instruction on the";
    s "Pentium, or if you tried to use something other than %d-bit floats.)" w;
  ]))
let stack_width ~have ~want =
  fail (nosupport (s "%d-bit value on the machine stack" have))
       stack_width_n [have; want]
@ 
%%
<<unsupported.ml>>=
let calling_convention_n = getn (ex0 (fun _ ->
  [ "Your code tried to make a procedure call, return, or cut to using an"
  ; "unsupported calling convention.  Please verify the correct spelling of the"
  ; "calling convention or get a wizard to extend the compiler with this"
  ; "calling convention."
  ]))
let calling_convention name =
  fail (nosupport (s "the '%s' calling convention" name))
       calling_convention_n []
@ 
%%
<<unsupported.ml>>=
let automaton_widths_n = getn (ex1 (fun x ->
  [ s "Your code tried to pass a %d-bit value as a parameter or return" x
  ; "value to/from a procedure although it was not supported by the calling"
  ; "convention being used for the call/return/cut to."
  ]))
let automaton_widths w =
  fail (s "The current calling convention could not support a %d-bit value" w)
      automaton_widths_n [w]

let automaton_widen_n = getn (ex2 (fun have want ->
  [ s "Your code tried to pass a %d-bit value as a parameter or return" have
  ; "value to/from a procedure although the calling convention being"
  ; s "used expected a value %d-bits wide or potentially narrower." want
  ]))
let automaton_widen ~have ~want =
  fail (s "The current calling convention either could not widen a " ^
        s "%d-bit value to %d-bits or fit it in a %d-bit register"
          have want want)
      automaton_widen_n [ have ; want ]
@ 
<<unsupported.ml>>=
let div_and_mod_n = getn (fun _ ->
    ["On this target, signed division and modulus round toward zero.";
     "You must use the operators %quot and %rem, not %div and %mod.";
    ])

let div_and_mod () = fail (nosupport "%div and %mod") div_and_mod_n []

let div_overflows_n = getn (fun _ ->
    ["This code generator cannot test for %div_overflows and %quot_overflows"])

let div_overflows () =
  fail (nosupport "overflow detection for division") div_overflows_n []
@ 
<<unsupported.ml>>=
let mulx_and_mulux_n = getn (fun _ ->
    ["This target does not support extended integer-multiply operators."]
    )

let mulx_and_mulux () = fail (nosupport "%mulx and %mulux") mulx_and_mulux_n []
@ 
<<unsupported.ml>>=
let floatlit = getn (ex1 (fun n ->
    [ "On this target, floating-point literals can be either 32 or 64 bits wide.";
      s "You asked for a literal of %d bits.  You could try %%f2f%d(<literal>)." n n;
    ]))

let floatlit d =
  fail (nosupport (s "%d-bit floating-point literal" d)) floatlit [d]
@ 
<<unsupported.ml>>=
let singlebit_n = getn (fun _ ->
  ["This target does not support extended addition and subtraction using";
   "single-bit values with the %addc, %carry, %subb, and %borrow operators.";
  ])
let singlebit ~op =
  fail (nosupport (s "the %%%s operator" op)) singlebit_n []
@ 
<<unsupported.ml>>=
let popcnt_n = getn (ex2 (fun good bad ->
  [ s "Your code tried to use the %%popcnt operator on a %d-bit argument," bad;
    s "but on this target, %%popcnt applies only to %d-bit values." good;
  ]))
let popcnt ~notok ~ok =
  fail (nosupport (s "%%popcnt(bits%d)" notok))
       popcnt_n [ok; notok]
@ 

\chapter{[[parsing]]}

\section{[[parsing/ast.nw]]}
%%%
%%% $Id: ast.nw,v 1.13 2005-06-07 20:19:43 nr Exp $
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%%
%%
%%% ------------------------------------------------------------------  
\section{Abstract Syntax Definition}\label{sec:ast}
%%% ------------------------------------------------------------------  
%%
%%The abstract syntax for \C~is not directly encoded into \ocaml~data
%%types but specified as an \asdl~\cite{adsl97} definition.  The
%%\asdl~compiler generates suitable data types and additionally code to
%%serialize the abstract syntax.  This permits to exchange the abstract
%%syntax with applications written in languages other than \ocaml~more
%%easily. 
%%
%%The abstract syntax is specified in [[ast.asdl]]; the resulting
%%modules are [[Ast]] and [[AstUtil]]. {\asdl} does not provide all the
%%data types we require so we have to define some views. A view is a
%%one-to-one mapping between an external representation using {\asdl}
%%primitive types and and internal user-defined representation.
%%
<<ast.asdl>>=
module ast {
    <<ast declaration>>
}
@
%%
%%% ------------------------------------------------------------------ 
\subsection{The \asdl-definition}
%%% ------------------------------------------------------------------ 
%%
<<ast declaration>>=
name        = (string)
conv        = (string)  -- names for calling conventions
hint        = (string)  -- hints for register allocation
reg         = (string)  -- names for global registers
target      = (string)
alias_set   = (string)  -- names for aliasing assertions
size        = (int)     
align       = (int)     -- power of 2
aligned     = (int)     -- power of 2
in_alias    = (string)
op          = (string)
@
%%
%%Every important node is wrapped by a node that includes a source
%%code position [[region]].  This is the character span in the input
%%character stream that covers the node.  The first character in the
%%stream has index 0.  The first number in a [[region]] denotes the
%%first character covered by the node, the second number the first
%%character \textit{after} the node.
%%
<<ast declaration>>=
region      = (int,int) -- (* Srcmap.reg *)

program     = (toplevel*)

toplevel    = ToplevelAt    (toplevel, region)
            | Section       (name, section*)
            | TopDecl       (decl)
            | TopProcedure  (proc)
@
%%
<<ast declaration>>=
section     = SectionAt     (section, region)
            | Decl          (decl)
            | Procedure     (proc)
            | Datum         (datum)
            | SSpan         (expr key, expr value, section*)
@
%%            
%%Extensions to the language are syntactically covered by [[pragma]]s.
%%Unknown extensions are represented by the [[Pragma]] value.
%%
<<ast declaration>>=
decl        = DeclAt        (decl, region)
            | Import        (ty?,import*)
            | Export        (ty?,export*)
            | Const         (ty?,name,expr)
            | Typedef       (ty,name*)
            | Registers     (register*)
            | Pragma                          
            | Target        (arch*)
@
%%
<<ast declaration>>=
arch        = Memsize       (int)
            | ByteorderBig
            | ByteorderLittle
            | FloatRepr     (string) -- "ieee754"
            | Charset       (string) -- "latin1"
            | WordSize      (int)    -- 32 (bits)
            | PointerSize   (int)    -- 32 (bits)

import      = (string?,name)
export      = (name, string?)

@
%%       
<<ast declaration>>=
register    = (variance, hint?, ty, name, reg?)
proc        = (conv?, name, formal*, body*, region)

body        = BodyAt        (body, region)
            | DeclBody      (decl)
            | StmtBody      (stmt)
            | DataBody      (datum*)
            
memsize     = NoSize
            | DynSize
            | FixSize       (expr)
                       
datum       = DatumAt       (datum, region)
            | Label         (name)
            | Align         (align)
            | MemDecl       (ty, memsize, init?)

@ 
%%Escape sequence in the concrete syntax of strings and character
%%literals are removed during the translation to the abstract syntax. 
%%So [[InitStr]] and [[InitUStr]] do not contain escaped characters.
%%
<<ast declaration>>=
init        = InitAt        (init, region)
            | InitExprs     (expr*)
            | InitStr       (string)
            | InitUStr      (string)
@ 
<<ast declaration>>=
ty          = TyAt          (ty, region)
            | BitsTy        (size)
            | TypeSynonym   (name)
@
<<ast declaration>>=
variance   = Invariant
            | Invisible
            | Variant

formal      = (region, bare_formal)
bare_formal = (hint?, variance, ty, name, aligned?)
actual      = (hint?, expr, aligned?)
cformal     = (region, hint?, name, aligned?)
@ 
%%
<<ast declaration>>=
flow        = FlowAt        (flow, region)
            | CutsTo        (name*)
            | UnwindsTo     (name*)
            | ReturnsTo     (name*)
            | NeverReturns
            | Aborts    

mem         = AliasAt       (mem, region)
            | Reads         (name*)
            | Writes        (name*)

procann     = Flow (flow) 
            | Alias (mem)

name_or_mem = NameOrMemAt   (name_or_mem, region)
            | Name          (hint?,name,aligned?)
            | Mem           (ty, expr, aligned?, in_alias*)
@ 
%%
<<ast declaration>>=
altcont     = (expr, expr)

range       = Point         (expr)
            | Range         (expr,expr)

arm         = ArmAt         (arm, region)
            | Case          (range*,body*)
@
%%
%%We like to represent guarded multiple assignments. The guards are paired
%%with the expressions defining the value to be assigned. Alternatively we
%%could have made the guard of an [[mem_or_name]] but this would have
%%complicated the already complicated analysis of lvalues further.
%%             
<<ast declaration>>=
guarded     = (expr? guard, expr value) 
@
%%
%%The abstract syntax does not distinguish an empty list of statements
%%from an absent optional list of statements.  An [[if]] statement
%%without an [[else]] block looks on this level like an [[if]] with an
%%empty [[else]] block.
%%
%%Comments as represented by the [[CommentStmt]] are never generated by
%%the parser.  They are used for code generation back ends that emit
%%{\PAL} code. 
%% 
<<ast declaration>>=
stmt        = StmtAt        (stmt, region)
            | IfStmt        (expr, body*, body*)
            | SwitchStmt    (range?, expr, arm*)
            | LabelStmt     (name)
            | ContStmt      (name, cformal*)
            | SpanStmt      (expr key, expr value, body*)
            | AssignStmt    (name_or_mem*, guarded*)
            | CallStmt      (name_or_mem*, conv?, expr, actual*, target*, procann*)
            | PrimStmt      (name_or_mem*, conv?, name, actual*, flow*)
            | GotoStmt      (expr, target*)
            | JumpStmt      (conv?, expr, actual*, target*)
            | CutStmt       (expr, actual*, flow*)
            | ReturnStmt    (conv?, altcont?, actual*)
            | EmptyStmt  
            | CommentStmt   (string)
            | LimitcheckStmt(expr, expr?)
@
%%
%%Literal constants pose a problem becaus their (bit) width cannot be
%%resolved during scanning and parsing. Therefore we store strings and
%%scan them later, once we know the width.
<<ast declaration>>=
expr        = ExprAt        (expr, region)
            | Sint          (string,ty?)
            | Uint          (string,ty?)
            | Float         (string,ty?)
            | Char          (int,ty?)
            | Fetch         (name_or_mem)
            | BinOp         (expr, op, expr)
            | UnOp          (op, expr)
            | PrimOp        (name, actual*)
@
%%Infix operators are abbreviations for primitive operations. The
%%parser could perform this translation right away. But we want to
%%unparse the abstract syntax back to concrete syntax and thus we keep
%%them. 
%%
\section{[[parsing/astpp.nw]]}
<<parsing/astpp.ml>>=
<<astpp.ml>>
@

<<parsing/astpp.mli>>=
<<astpp.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%%
%%% $Id: astpp.nw,v 1.11 2005-06-07 20:19:43 nr Exp $
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%%
%%
%%% ------------------------------------------------------------------  
\section{AST Pretty Printer}\label{sec:astpp}
%%% ------------------------------------------------------------------  
%%
%%For debugging and regression testing we provide a module that pretty
%%prints the abstract syntax into the concrete syntax.  The
%%implementation uses an implementation of Philip Wadler's algebraic
%%pretty printer \cite{wadler99:_a_prettier_printer} from the [[Pp]]
%%module. 
%%
%%% ------------------------------------------------------------------  
\subsection{Interface}
%%% ------------------------------------------------------------------  
%%
%%The interface provides functions to transform a program in abstract
%%syntax to a [[Pp.doc]] format.  For error reporting it is useful to
%%obtain pretty printed fragments of a program.  The following list of
%%functions provides pretty printing for important non terminals in a
%%program.  Each function returns a [[Pp.doc]] value that can be turned
%%into a [[string]] with the help of the [[Pp]] module.
%%
%%The [[emit]] function is specialized and more efficient in certain
%%cases. It is here to help John Dias emit large programs.
%%
<<astpp.mli>>=
val decl       : bool -> Ast.decl  -> Pp.doc
val stmt       : Ast.stmt          -> Pp.doc
val program    : Ast.toplevel list -> Pp.doc

val emit       : out_channel -> width:int -> Ast.toplevel list -> unit
@
%%
%%
%%% ------------------------------------------------------------------  
\subsection{Implementation}
%%% ------------------------------------------------------------------  
%%
%%The implementation builds an abstract representation of the pretty
%%printed concrete syntax in a purely functional way. The abstract
%%representation is than written to an open file.
%%
<<astpp.ml>>=
module A = Ast
module P = Pp
module E = Error

open Nopoly

let (^^)   = P.(^^)
let (^/)   = P.(^/)
let (~~) x = x
let nonempty = function [] -> false | _ :: _ -> true
@
%%
%%The module [[Pp]] provides the pretty printing primitives.  The
%%concatenation of two abstract pretty printed objects is denoted by the
%%infix operator [[^^]].  We define two more:  [[~~]] and [[~/]]; the
%%first is a prefix operator that does nothing; its only purpose is to
%%achieve a more consistent source code layout. In the following example
%%all nested code is also nested in the source code.
%%
<<example(astpp.nw)>>=
let f (x,y,z) = 
    nest begin
    ~~ x
    ^/ y
    ^/ z
    end
@
%%
%%The second operator [[^/]] joins two objects with a [[break]].  A
%%[[break]] is either represented as a space, or as a line break
%%followed by a number of spaces for indentation.  The exact outcome is
%%determined by the pretty printer.  It is easiest to think of
%%[[break]]s as spaces that might be turned into line breaks.
%%
<<astpp.ml>>=
let nest       = P.nest 4 

@ 
%%The [[commablock]] is just a handy special case of the [[block]]
%%defined in [[Pp]]. 
%%
<<astpp.ml>>=
let commablock f xs =
    nest begin
    ~~ P.list (P.text "," ^^ P.break) f xs
    end

@ 
%%To indent a group we provide [[angrp]] and [[fngrp]]; [[fngrp]] is a
%%nested [[fgrp]]. While inside an [[agrp]] all breaks are either turned
%%into spaces or newlines, each break inside a [[fgrp]] is considered
%%separately. Only breaks at the end of a line is turned into a newline
%%to make new room -- as many as possible breaks are printed as spaces.
%%    
<<astpp.ml>>=
let angrp x =
    P.agrp begin 
    ~~ nest begin
       ~~ x
       end
    end

let fngrp x =
    P.fgrp begin 
    ~~ nest begin
       ~~ x
       end
    end
@
%%
%%Most of the names used below refer directly to the grammar or abstract
%%syntax.  Since the overall purpose of this is clear we don't comment
%%the code much.
%%
<<astpp.ml>>=
let unzip = List.split
let zip   = List.combine


let id i        = P.text i
let int n       = P.text (string_of_int n)
let semi        = P.text ";"
@
%%
%%Comments are not part of the abstract syntax and thus they are
%%only created for informational purposes in this module.  The argument
%%passed to [[comment]] must not contain only matching [[/*]] and [[*/]]
%%
<<astpp.ml>>=
let comment x   = P.vgrp (P.text "// " ^^ P.text x)
@
%%
%%Todo:  write functions that escape unprintable characters in literals.
%%
<<astpp.ml>>=
let str s       = P.text ("\"" ^ String.escaped s ^ "\"")
let char i      = P.text ("'"  ^ Char.escaped(Char.chr i) ^ "'")
@ 
%%
<<astpp.ml>>=
let rec ty = function
    | A.TyAt(x,_)       -> ty x
    | A.BitsTy(n)       -> P.text "bits"  ^^ int n
    | A.TypeSynonym(name)   -> P.text name
@
%%
%%
<<astpp.ml>>=
let aligned = function
  | Some i -> P.text " aligned" ^/ int i 
  | None   -> P.empty

let rec lvalue = function
    | A.NameOrMemAt(x,_)  -> lvalue x
    | A.Name(None,x,a) -> P.agrp (id x ^^ aligned a)
    | A.Name(Some h,x,a) -> P.agrp (str h ^/ id x ^^ aligned a)
    | A.Mem(t,e,a,aliasing) -> 
        ~~ ty t 
        ^^ P.text "["
        ^^ expr e 
        ^^ aligned a
        ^^ begin match aliasing with 
               | [] -> P.empty 
                 | n :: ns ->
                    let head = P.break ^^ P.text "in" ^/ P.text n in
                    List.fold_left (fun h n -> h ^^ P.text "," ^/ P.text n) head ns
           end	
        ^^ P.text "]"
@
%%
%%A [[glvalue]] is an optionally guarded lvalue.
%%
<<astpp.ml>>=
and glvalue = function
    | x, None   -> lvalue x
    | x, Some e -> P.agrp(lvalue x  ^/ P.text "when" ^/ expr e)
                        
and actual = function
    | ( Some hint, e, a) -> P.agrp (str hint ^/ expr e ^^ aligned a)
    | ( None     , e, a) -> P.agrp (expr e ^^ aligned a)

and actuals xs = P.agrp (P.text "(" ^^ P.commalist actual xs ^^ P.text ")")
@ 
%%
<<astpp.ml>>=
and expr e = 
    let with_ty t p = match t with None -> p | Some t -> p ^^ P.text "::" ^^ ty t in
    match e with
    | A.ExprAt(x,_)       -> expr x
    | A.Sint( i, t)       -> with_ty t (P.text i)
    | A.Uint( i, t)       ->
        with_ty t (if String.get i 0 =<= '0' then P.text i else P.text (i^"U"))
    | A.Float( f, t)      -> with_ty t (P.text f)
    | A.Char( i, t)       -> with_ty t (char i)
    | A.Fetch(v)          -> lvalue v
    | A.BinOp(l,op,r)     -> P.agrp begin
                           ~~ P.text "(" ^^ expr l
                           ^^ nest begin
                              ~~ P.text op
                              ^^ (if op =$= "%" then P.break else P.empty)
                              ^^ P.breakWith ""
                              ^^ expr r
                              end
                           ^^ P.text ")"
                           end
    | A.UnOp(op,e)        -> P.agrp (P.text op ^^ expr e)
    | A.PrimOp(n,xs)      -> P.agrp (P.text "%" ^^ id n ^^ actuals xs)
@ 
%$
%%
<<astpp.ml>>=
let memsize = function
    | A.NoSize        -> P.empty
    | A.DynSize       -> P.text "[]"
    | A.FixSize(e)    -> P.text "[" ^^ expr e ^^ P.text "]"

let rec init = function
    | A.InitAt(x,_) -> init x
    | A.InitExprs(es) -> 
            P.fgrp begin
            ~~ P.text "{"
            ^/ nest begin
               ~~ P.commalist expr es
               end
            ^/ P.text "}"
            end
    | A.InitStr(s) -> str s
    | A.InitUStr(s) -> 
            P.agrp begin
            ~~ P.text "unicode"
            ^/ P.text "("
            ^/ nest begin
               ~~ str s
               end
            ^/ P.text ")"
            end

let rec datum = function
    | A.DatumAt(x,_)        -> datum x
    | A.Label(n)            -> id n ^^ P.text ":"
    | A.Align(a)            -> P.agrp (P.text "align" ^/ int a ^^ semi)
    | A.MemDecl(t,m,Some i) -> P.agrp (ty t ^^ memsize m ^/ init i ^^ semi)
    | A.MemDecl(t,m,None)   -> P.agrp (ty t ^^ memsize m ^^ semi) 
@ 
%%
<<astpp.ml>>=
let formal (_, (h, v, t, n, a)) =
    P.agrp begin
    ~~ (match h with Some hint -> str hint ^^ P.break | None -> P.empty)
    ^^ (if v =*= A.Invariant then P.text "invariant" ^^ P.break else P.empty)
    ^^ ty t
    ^/ id n
    ^^ aligned a
    end

let formals xs = P.agrp (P.text "(" ^^ P.commalist formal xs ^^ P.text ")")
@ 
%%
<<astpp.ml>>=
let cformal (_, h, n, a) =
    P.agrp begin
    ~~ (match h with Some hint -> str hint ^^ P.break | None -> P.empty)
    ^^ id n
    ^^ aligned a
    end

let cformals xs = P.agrp (P.text "(" ^^ P.commalist cformal xs ^^ P.text ")")
@ 
%%    
%%
<<astpp.ml>>=
let register is_global (v , hint, t, n, reg) = 
    angrp begin 
    ~~ (if v =*= A.Invariant then P.text "invariant" ^^ P.break else P.empty)
    ^^ (if is_global         then P.text "register"  ^^ P.break else P.empty)
    ^^ (match hint with Some h -> P.break ^^ str h | None -> P.empty)
    ^^ ty t
    ^/ id n
    ^^ (match reg with Some r -> P.break ^^ str r | None -> P.empty)
    ^^ semi
    end 
@ 
%%
<<astpp.ml>>=
let altcont (e1,e2) =   
            P.agrp begin 
            ~~ P.text "<" 
            ^^ expr e1 
            ^^ P.text "/" 
            ^/ expr e2
            ^^ P.text ">"
            end

let targets = function
    | []    -> P.empty
    | ts    -> P.agrp (P.text "targets" ^/ nest (P.commalist id ts))
    
let rec flow f =
    let also s ns = P.agrp (P.text "also" ^/ P.text s ^/ P.text "to" 
                         ^/ nest (P.commalist id ns)) in
    match f with
    | A.FlowAt(x,_)     -> flow x
    | A.CutsTo(ns)    when nonempty ns -> also "cuts"    ns
    | A.UnwindsTo(ns) when nonempty ns -> also "unwinds" ns
    | A.ReturnsTo(ns) when nonempty ns -> also "returns" ns
    | A.Aborts                         -> P.text "also aborts"
    | _                                -> P.empty

let rec alias f =
  let ann s ns = P.agrp (P.text s ^/ nest (P.commalist id ns)) in
  match f with
  | A.AliasAt(x,_)     -> alias x
  | A.Reads  ns -> ann "reads"  ns
  | A.Writes ns -> ann "writes" ns

let pann = function
  | A.Alias a -> alias a
  | A.Flow f  -> flow f

let flows = function
    | []    -> P.empty
    | xs    -> nest (P.agrp (P.list P.break flow xs))

let panns = function
    | []    -> P.empty
    | xs    -> nest (P.agrp (P.list P.break pann xs))

let conv = function
    | Some cc       -> P.agrp (P.text "foreign" ^/ str cc)
    | None          -> P.empty 
@ 
%%
%%    
<<astpp.ml>>=
let opt_ty t = ( match t with 
               | Some t -> P.break ^^ ty t
               | None   -> P.empty
               )
let export t ns =
    let export' = function
        | (x, Some y) -> P.agrp (id x ^/ P.text "as" ^/ str y)
        | (x, None  ) -> id x
    in
        P.agrp begin
        ~~ P.agrp begin 
           ~~ P.text "export" 
           ^^ opt_ty t
           end
           ^/ commablock export' ns
           ^^ semi
        end


let architecture = function
    | A.Memsize(i)      -> P.agrp (P.text "memsize" ^/ int i)
    | A.ByteorderBig    -> P.agrp (P.text "byteorder" ^/ P.text "big")
    | A.ByteorderLittle -> P.agrp (P.text "byteorder" ^/ P.text "little")
    | A.WordSize i      -> P.agrp (P.text "wordsize" ^/ int i)
    | A.PointerSize i   -> P.agrp (P.text "pointersize" ^/ int i)
    | A.FloatRepr s     -> P.agrp (P.text "float" ^/ str s)
    | A.Charset s       -> P.agrp (P.text "charset" ^/ str s)
    


let range = function
    | A.Point(e)        -> expr e
    | A.Range(e1,e2)    -> P.agrp(expr e1 ^/ P.text ".." ^/ expr e2)
@ 
%%
<<astpp.ml>>=
let rec stmt = function
    | A.StmtAt(x,_)   -> stmt x
    
    | A.IfStmt ( e, ss1, ss2)    ->
        P.agrp begin
        ~~ P.agrp (P.text "if" ^/ expr e)
        ^/ P.block (body false) ss1
        ^^ begin match ss2 with
           | []     -> P.empty
           | ss     -> P.break ^^ P.text "else" ^/ P.block (body false) ss
           end
        end
    | A.LabelStmt(n)            -> 
        P.agrp begin
        ~~ id n ^^ P.text ":"
        end
        
    | A.ContStmt(n,cf)          ->
        P.agrp begin
        ~~ P.text "continuation"
        ^^ angrp begin
           ~~ P.break
           ^^ id n
           ^^ cformals cf
           ^^ P.text ":"
           end
        end

    | A.SpanStmt(e1,e2,ss)      -> 
        P.agrp begin
        ~~ P.agrp (P.text "span" ^/ expr e1 ^/ expr e2)
        ^/ P.block (body false) ss
        end
@
%%
%%In the abstract syntax, guards in a guarded assignment belong to the
%%expression.  In the concrete syntax, the guard belongs to the lvalue.
%%Guards are thus re-combined with the left hand side of an assignment
%%before it is printed.
%%        
<<astpp.ml>>=
    | A.AssignStmt(lhs,rhs)          -> 
        let rec combine = function (* error tolerant *)
            | []   , []    -> []
            | x    , []    -> []
            | []   , x     -> []
            | x::xx, y::yy -> (x,y)::combine (xx,yy)
                                               in
        let guards, rhs = List.split rhs       in
        let lhs         = combine (lhs,guards) in
            P.agrp begin
            ~~ fngrp begin 
               ~~ P.commalist glvalue lhs 
               ^/ P.text "="
               end
            ^^ fngrp begin
               ~~ P.break
               ^^ P.commalist expr rhs
               ^^ semi
               end
            end
@ 
%%
<<astpp.ml>>=
    | A.CallStmt(lhs, cc, e, args, ts, fs) -> 
        angrp begin
        ~~ ( if nonempty lhs
             then fngrp begin 
                  ~~ P.commalist lvalue lhs 
                  ^/ P.text "="
                  ^^ P.break
                 end
             else P.empty
           )
        ^^ ( match cc with 
           | Some c -> P.agrp (P.text "foreign" ^/ str c ^^ P.break)
           | None   -> P.empty
           ) 
        ^^ angrp begin 
           ~~ expr e
           ^^ fngrp begin 
              ~~ P.break 
              ^^ P.text "(" 
              ^^ P.commalist actual args 
              ^^ P.text ")"
              end
           end
        ^^ (if nonempty ts then P.break ^^ targets ts else P.empty)
        ^^ (if nonempty fs then P.break ^^ panns fs else P.empty)
        ^^ semi
        end
@ 
%%
<<astpp.ml>>=
    | A.PrimStmt(lhs, cc, n, args, fs)     -> 
        angrp begin
        ~~ ( if nonempty lhs then 
                  ~~ P.commalist lvalue lhs 
                  ^/ P.text "="
                  ^^ P.break
             else P.empty
           )
        ^^ ( match cc with 
           | Some c -> P.agrp (P.text "foreign" ^/ str c ^^ P.break)
           | None   -> P.empty
           ) 
        ^^ fngrp begin 
           ~~ P.text "%%" 
           ^^ id n
           ^^ P.break 
           ^^ P.text "(" 
           ^^ P.commalist actual args 
           ^^ P.text ")"
           end
        ^^ (if nonempty fs then P.break ^^ flows fs else P.empty)
        ^^ semi
        end
    
    | A.GotoStmt(e,ts)                      -> 
        angrp begin
        ~~ P.text "goto"
        ^/ expr e
        ^^ (if nonempty ts then P.break ^^ targets ts else P.empty)
        ^^ semi
        end
    | A.CutStmt(e, args, fs)                -> 
        angrp begin
        ~~ P.text "cut to"
        ^/ expr e 
        ^^ fngrp begin 
           ~~ P.break 
           ^^ P.text "(" 
           ^^ P.commalist actual args 
           ^^ P.text ")"
           end
        ^^ (if nonempty fs then P.break ^^ flows fs else P.empty)
        ^^ semi
        end
    | A.ReturnStmt(cc, alt, args)           -> 
        angrp begin
        ~~ ( match cc with 
           | Some c -> P.text "foreign" ^/ str c ^^ P.break
           | None   -> P.empty
           )
        ^^ P.text "return"
        ^^ ( match alt with
           | Some a -> P.break ^^ altcont a ^^ P.break
           | None   -> P.empty
           )
        ^^ fngrp (P.break ^^ P.text "(" ^^ P.commalist actual args ^^ P.text ")") 
        ^^ semi 
        end
    | A.JumpStmt(cc,e,args,ts)              -> 
        angrp begin
        ~~ ( match cc with 
           | Some c -> P.agrp (P.text "foreign" ^/ str c) ^^ P.break
           | None   -> P.empty
           )
        ^^ fngrp begin 
           ~~ (P.text "jump" ^/ expr e)
           ^^ ( if nonempty args then 
                    ~~ P.break 
                    ^^ P.text "(" 
                    ^^ P.commalist actual args 
                    ^^ P.text ")"
                 else 
                    P.empty
              )
           ^^ (if nonempty ts then P.break ^^ targets ts else P.empty)
           end
        ^^ semi
        end
    | A.EmptyStmt      -> semi
    | A.CommentStmt(s) -> comment s

    | A.LimitcheckStmt (cookie, cont)    ->
        P.agrp begin
        ~~ P.agrp (P.text "limitcheck" ^/ expr cookie)
        ^/ begin match cont with
           | None   -> P.empty
           | Some e -> P.text "fails to" ^/ expr e
           end
        end

    | A.SwitchStmt (r,e,arms) -> 
        P.agrp begin
        ~~ P.agrp begin 
           ~~ P.text "switch"
           ^^ ( match r with
              | Some r -> P.agrp begin 
                ~~ P.break 
                ^^ P.text "[" 
                ^^ range r 
                ^^ P.text "]"
                end
              | None   -> P.empty
              )
           ^/ expr e
           end
        ^/ P.agrp (P.block arm arms)
        end
        
and body is_global = function
    | A.BodyAt(x, _)    -> body is_global x
    | A.DeclBody(d)     -> decl is_global d
    | A.StmtBody(s)     -> stmt s
    | A.DataBody(dd)    -> 
            P.agrp begin
            ~~ P.text "stackdata"
            ^/ P.block datum dd
            end
    
and proc (cc,n,fs,ss,_) =  
    P.agrp begin 
    ~~ P.agrp begin
       ~~ begin match cc with 
          | Some c -> P.text "foreign" ^/ str c ^^ P.break
          | None   -> P.empty
          end
       ^^ id n
       ^^ formals fs
       end
    ^/ P.text "{"
    ^^ nest begin
       ~~ P.break
       ^^ P.list P.break (body false) ss
       end 
    ^/ P.text "}" 
    end
@ 
%%
<<astpp.ml>>=
and decl is_global = function
    | A.DeclAt(x,_) -> decl is_global x
    | A.Import( t, ns) -> 
        let import' = function
        | (Some x, y) -> P.agrp (str x ^/ P.text "as" ^/ P.text y)
        | (None  , y) -> id y
        in
            P.agrp begin
            ~~ P.agrp (P.text "import" ^/ opt_ty t)
            ^/ commablock import' ns
            ^^ semi
            end
    | A.Export( t, ns) -> export t ns
    | A.Const (t,n,e) ->
            P.agrp begin 
            ~~ P.text "const"
            ^^ ( match t with
               | Some t -> P.break ^^ ty t
               | None   -> P.empty
               )
            ^/ id n
            ^/ P.text "="
            ^/ expr e
            ^^ semi
            end
    | A.Registers( rs) ->
            P.vgrp begin
            ~~ P.list P.break (register is_global) rs
            end
    | A.Typedef (t,nn)  -> 
        angrp begin
        ~~ P.text "typedef"
        ^/ ty t
        ^/ P.text "="
        ^/ commablock id nn
        ^^ semi
        end 
    
    | A.Target (arch) -> 
            angrp begin
            ~~ P.text "target"
            ^/ P.list P.break architecture arch
            ^^ semi
            end
    | A.Pragma        -> comment "pragma"
@ 
%%
<<astpp.ml>>=
and arm = function
    | A.ArmAt(x,_)          -> arm x
    | A.Case(ranges, stmts) ->
        P.agrp begin
        ~~ P.text "case"
        ^/ P.agrp (P.list (P.text "," ^^ P.break) range ranges)
        ^^ P.text ":"
        ^/ P.block (body false) stmts
        end 

and section  = function (* inside a section *)
    | A.SectionAt(x,_)  -> section x
    | A.Decl(d)         -> decl true d
    | A.Datum( d)       -> datum d
    | A.Procedure(p)    -> proc p
    | A.SSpan( e1, e2, ss) ->  
        P.agrp begin
        ~~ P.agrp (P.text "span" ^/ expr e1 ^/ expr e2)
        ^/ P.block section ss
        end
@ 
%%       
%%       
<<astpp.ml>>=
let rec toplevel = function
    | A.ToplevelAt(x, _)  -> toplevel x
    | A.Section(name, ss) -> 
            P.agrp begin 
            ~~ P.agrp (P.text "section" ^/ str name)
            ^/ P.block section ss
            end
    | A.TopDecl(d)        -> decl true d
    | A.TopProcedure(p)   -> proc p

let program ds = P.vgrp begin
                  ~~ P.list (P.break ^^ P.break) toplevel ds
                  ^^ P.break
                  end
                                            
let pp = program
@
%%
%%The [[emit]] function is more imperative than [[pp]]. It pretty-print
%%every top-level element seperately and is therefore much faster. I also
%%believe, that this solves stack overflow problems when large programs
%%are emitted. The [[Astasm]] module was changes accordingly to use
%%[[emit]].
%%
<<astpp.ml>>=
let emit fd ~width tl =
    List.iter (fun t -> ( P.ppToFile fd width (toplevel t)
                        ; output_string fd "\n\n"
                        )) tl
@
\section{[[parsing/parser.nw]]}
%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% Todo: parse %foo as abbreviation for $foo(). The change is already
%%% marked in the code below. It causes a shift/reduce conflict that is
%%% properly resolved. However, it would be nice to use precedences to
%%% avoid it. --CL Fri Aug  9 15:07:22 EDT 2002
%%
%%% ------------------------------------------------------------------  
\section{Lexical Analysis}\label{sec:scanner}
%%% ------------------------------------------------------------------  
%%
%%The scanner for lexical analysis is generated from a specification for
%%\ocaml~Lex. 
%%
%%The generated scanner keeps track of its current position in its
%%input stream by counting the bytes it consumes.  In order to maintain
%%the more useful information of the current line and column in the
%%input we maintain some state in a source map which maps input stream
%%positions to a file name, line number, column number triple.  The
%%source map is passed as a parameter [[map]] into the scanner.
%%
%%The first action of the parser is to place a sync point into the
%%source map.  This guarantees that every position in the input can be
%%maped to a location.  The fist character is always in line 1 and
%%column 1 in [[file]].
%%
%%Whenever the scanner encounters a newline character it places a new
%%sync point for the following character into the source map.
%%
<<scan.mli>>=
val scan : Srcmap.map -> Lexing.lexbuf -> Parse.token
val tok2str : Parse.token -> string
@ 
%%
<<scan.mll>>=
{
    <<prolog>>
}
@ 
<<prolog>>=
module P = Parse    (* tokens are defined here *)
module E = Error

let nl lexbuf map =
    let next = (Lexing.lexeme_start lexbuf) + 1     in
        Srcmap.nl map next
    
@ 
%%The tab character is one byte long, but moves the cursor additional
%%$x$ positions to the right.  The number $x$ of virtual spaces depends
%%on the column $c$ of the tab:
%%            $$x = 7 - (c~\textrm{mod}~8)$$ 
%%Whenever the scanner encounters a tab character it calls the [[tab]]
%%function to place a sync point into the source map.  We currently
%%ignore tabs by not placing a sync point in the [[map]].  Sync points
%%are explained in section \ref{srcmap} about source code position
%%tracking.
<<prolog>>=
let tab lexbuf map = ()
@ 
%%The current location can be obtained by passing the current position
%%to [[Srcmap.loc]]:
<<prolog>>=
let location lexbuf map =
    Srcmap.location map (Lexing.lexeme_start lexbuf)
     
let error lexbuf msg = Error.error msg
@ 
%%We define some helpers; [[get]] returns the matched string and is
%%quite intuitive when called as [[get lexbuf]].
<<prolog>>=
let get         = Lexing.lexeme
let getchar     = Lexing.lexeme_char
let strlen      = String.length
let pos_start   = Lexing.lexeme_start
let pos_end     = Lexing.lexeme_end
let substr      = Auxfuns.substr
@
%%All keywords are stored in a hash table that maps them to tokens;
%%[[keyword s]] tries to lookup [[s]] in the table of keywords and
%%returns the matching token or raises [[Not_found]].  Keywords are not
%%directly encoded into the automaton of the scanner because this is
%%notorious for overflowing the tables of the automaton's
%%implementation.
%%
<<prolog>>=
let keywords    = Hashtbl.create 127
let keyword s   = Hashtbl.find keywords s

let _ = Array.iter (fun (str,tok) -> Hashtbl.add keywords str tok)
    [|("aborts"         , P.ABORTS)
    ; ("align"          , P.ALIGN)
    ; ("aligned"        , P.ALIGNED)
    ; ("also"           , P.ALSO)
    ; ("as"             , P.AS)
    ; ("big"            , P.BIG)
    ; ("byteorder"      , P.BYTEORDER)
    ; ("case"           , P.CASE)
    ; ("const"          , P.CONST)
    ; ("continuation"   , P.CONTINUATION)
    ; ("cut"            , P.CUT)
    ; ("cuts"           , P.CUTS)
    ; ("else"           , P.ELSE)
    ; ("equal"          , P.EQUAL)
    ; ("export"         , P.EXPORT)
    ; ("fails"          , P.FAILS)
    ; ("foreign"        , P.FOREIGN)
    ; ("goto"           , P.GOTO)
    ; ("if"             , P.IF)
    ; ("import"         , P.IMPORT)
    ; ("in"             , P.IN)
    ; ("invariant"      , P.INVARIANT)
    ; ("jump"           , P.JUMP)
    ; ("limitcheck"     , P.LIMITCHECK)
    ; ("little"         , P.LITTLE)
    ; ("memsize"        , P.MEMSIZE)
    ; ("never"          , P.NEVER)
    ; ("pragma"         , P.PRAGMA)
    ; ("register"       , P.REGISTER)
    ; ("reads"          , P.READS)
    ; ("return"         , P.RETURN)
    ; ("returns"        , P.RETURNS)
    ; ("section"        , P.SECTION)
    ; ("semi"           , P.SEMI)
    ; ("span"           , P.SPAN)
    ; ("stackdata"      , P.STACKDATA)
    ; ("switch"         , P.SWITCH)
    ; ("target"         , P.TARGET)
    ; ("targets"        , P.TARGETS)
    ; ("to"             , P.TO)
    ; ("typedef"        , P.TYPEDEF)
    ; ("unicode"        , P.UNICODE)
    ; ("unwinds"        , P.UNWINDS)
    ; ("writes"         , P.WRITES)

    ; ("float"          , P.FLOATREPR)
    ; ("charset"        , P.CHARSET)
    ; ("pointersize"    , P.PTRSIZE)
    ; ("wordsize"       , P.WRDSIZE)

    |]
@
%%
%%% ------------------------------------------------------------------  
\subsection{Declarations for Regular Expressions}
%%% ------------------------------------------------------------------  
<<scan.mll>>=
let digit       = ['0'-'9']
let octal       = ['0'-'7']
let hex         = ['0'-'9' 'A'-'F' 'a'-'f']

let printable   = [' '-'~']     (* add 8bit chars *)
let alpha       = ['a'-'z' 'A'-'Z']
let misc        = ['.' '_' '$' '@']

let escape      = ['\\' '\'' '"' 'a' 'b' 'f' 'n' 'r' 't' '?' ]

let sign        = ['+' '-']
let nat         = digit+
let uint        = ['1'-'9'] digit* ['u' 'U']    (* unsigned decimal *)
let zerou       = '0' ['u' 'U']                 (* unsigned decimal zero *)
let hexint      = '0' ['x' 'X'] hex+            (* hex *)
let octint      = '0' digit*                    (* octal *)
let sint        = ['1'-'9'] digit*         (* signed decimal *)
let frac        = nat '.' nat
let exp         = ['e''E'] sign? nat
let float       = frac exp? 
                | nat exp

let cxxcomment  = "//" [^ '\n']*
                
let id          = (alpha | misc) (alpha | misc | digit)*
let ws          = [' ' '\012' '\r']  (* SP FF CR *)
let nl          = '\n'          
let tab         = '\t'
@
%$
%%% ------------------------------------------------------------------  
\subsection{The Main Lexer}
%%% ------------------------------------------------------------------  
%%
%%The entry point for the lexer is the [[scan]] function. When a
%%source code map [[map]] is applied to it, it becomes a lexer
%%function suitable for a parser generated by \textsc{ocamllex}.
<<scanner entry point>>=
let scan map lexbuf =
    token lexbuf map
@
%%When the lexer is called is enters the [[token]] context where it
%%recognizes all keywords and simple tokens.  For complex tokens like
%%strings or comments it branches into special contexts.
<<scan.mll>>=
rule token = parse
    eof         { fun map -> P.EOF          }
  | ws+         { fun map -> token lexbuf map }
  | tab         { fun map -> tab lexbuf map; token lexbuf map }
  | nl          { fun map -> nl lexbuf map ; token lexbuf map }
  | nl ws* '#'  { fun map -> line lexbuf map 0; token lexbuf map }
  | ws* '#'     { fun map -> 
                  if Lexing.lexeme_start lexbuf = 0 then 
                        ( line lexbuf map 0
                        ; token lexbuf map
                        )
                  else
                        error lexbuf "illegal character" 
                }
  | ";"         { fun map -> P.SEMI         }
  | ":"         { fun map -> P.COLON        }
  | "::"        { fun map -> P.CCOLON       }
  | ","         { fun map -> P.COMMA        }
  | ".."        { fun map -> P.DOTDOT       }
  
  | "("         { fun map -> P.LPAREN       }
  | ")"         { fun map -> P.RPAREN       }
  | "{"         { fun map -> P.LBRACE       }
  | "}"         { fun map -> P.RBRACE       }
  | "["         { fun map -> P.LBRACKET     }
  | "]"         { fun map -> P.RBRACKET     }
  | "%%"        { fun map -> P.PPERCENT     }

  
  | "="         { fun map -> P.EQUAL        }
  

  (* infix/prefix operators *)
  
  | "+"         { fun map -> P.PLUS(get lexbuf)      }
  | "-"         { fun map -> P.MINUS(get lexbuf)     }
  | "*"         { fun map -> P.STAR(get lexbuf)      }
  | "/"         { fun map -> P.SLASH(get lexbuf)     }
  | "%"         { fun map -> P.PERCENT(get lexbuf)   }
  | "@>>"        { fun map -> P.GGREATER(get lexbuf)  }
  | "@<<"        { fun map -> P.LLESS(get lexbuf)     }
  | "&"         { fun map -> P.AMPERSAND(get lexbuf) }
  | "|"         { fun map -> P.BAR(get lexbuf)       }
  | "^"         { fun map -> P.CARET(get lexbuf)     }
  | "~"         { fun map -> P.TILDE(get lexbuf)     }
  | "=="        { fun map -> P.EEQ(get lexbuf)       }
  | "!="        { fun map -> P.NEQ(get lexbuf)       }
  | "<"         { fun map -> P.LT(get lexbuf)        }
  | "<="        { fun map -> P.LEQ(get lexbuf)       }
  | ">"         { fun map -> P.GT(get lexbuf)        }
  | ">="        { fun map -> P.GEQ(get lexbuf)       }

  | "`" id "`"  { fun map -> P.INFIXOP(substr 1 (-1) (get lexbuf)) }
              
  | "bits" nat  { fun map -> 
                  let s = substr 4 0 (get lexbuf) in
                  P.BITSn (int_of_string s)
                }
@
%%An identifier is an [[ID]] unless it is a reserved word.  When it is
%%the reserved word [[pragma]] the [[PRAGMA]] token is returned by
%%[[keyword]] and we switch to the special [[pragma1]] context. 
<<scan.mll>>=
  | id          { fun map ->  
                  let s  = get lexbuf in 
                  let k  = try keyword s with Not_found -> P.ID s in
                    if k = P.PRAGMA then pragma1 lexbuf map else k  
                } 
  | '%' id      { fun map ->
                  let s = substr 1 0 (get lexbuf)
                  in P.PRIMOP(s)
                }
  | float       { fun map -> P.FLT  (get lexbuf) }
  | sint        { fun map -> P.SINT (get lexbuf) }
  | uint        { fun map -> P.UINT (get lexbuf) }
  | zerou       { fun map -> P.UINT (get lexbuf) }
  | hexint      { fun map -> P.UINT (get lexbuf) }
  | octint      { fun map -> P.UINT (get lexbuf) }
  
  | "/*"        { fun map -> comment1 lexbuf map }
  | cxxcomment  { fun map -> token lexbuf map (* skip comment *) }
  
  | "\""        { fun map -> string  lexbuf map (Buffer.create 80) }
  | "'"         { fun map -> character lexbuf map } 
 
  | _           { fun map -> error lexbuf "illegal character" }
@
%%
%%% ------------------------------------------------------------------  
\subsection{Character Literals}
%%% ------------------------------------------------------------------  
%%
%%We decode charcter literals to integers here, using some helper
%%functions from the prolog. We use a continuation style: the result is
%%passed to the [[character_end]] lexer which should recognize the end of
%%the literal and return the value. This way we can write a lexer for
%%escape sequences that we can re-use for strings.
%%
%%The first two rules match each one character. Since [[printable]]
%%includes the backslash it is critical that the rule for backslash comes
%%first, because in the case of two matches of the same length the first
%%one is chosen!
<<scan.mll>>=
and character = parse
    '\\'                        { fun map ->
                                  let i = escape lexbuf in
                                  if i >= 256 then
                                    error lexbuf "character literal too large"
                                  else  
                                    character_end lexbuf map i
                                }  
  | printable                   { fun map -> 
                                  let c = getchar lexbuf 0 in
                                  character_end lexbuf map (Char.code c)   
                                }
                                  
  | _                           { fun map ->
                                  error lexbuf 
                                    ( "illegal character literal: "
                                    ^  get lexbuf
                                    )
                                }

and character_end = parse
    "'"                         { fun map i -> P.CHAR(i)           }
  | _                           { fun map i -> 
                                  error lexbuf 
                                    ( "illegal character literal (too many characters): "
                                    ^  get lexbuf
                                    ) 
                                }  
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Escape Sequences}
%%% ------------------------------------------------------------------ 
%%
%%The documentation for \texttt{ocamllex} doesn't say whether ties
%%are broken in favor of
%%the longest match, but apparently they are.
<<scan.mll>>=
and escape = parse
    |  escape                   { decode_escape (getchar lexbuf 0) }
    |  ['x' 'X'] hex            { decode_hex (getchar lexbuf 1)    }
    |  ['x' 'X'] hex hex        { decode_hex (getchar lexbuf 1) * 16 + 
                                  decode_hex (getchar lexbuf 2) }
    |  octal                    { decode_hex (getchar lexbuf 0) }
    |  octal octal              { decode_hex (getchar lexbuf 0) * 8 +
                                  decode_hex (getchar lexbuf 1) }
    |  octal octal octal        { decode_hex (getchar lexbuf 0) * 64 +
                                  decode_hex (getchar lexbuf 1) * 8  +
                                  decode_hex (getchar lexbuf 2) }
    | _                         { error lexbuf "illegal escape sequence" }
@
%%This both depends on the machine we are running on and the target, which
%%might be different. For now, this implements the Latin-1 on Unix.
<<prolog>>=
let rec decode_escape = function
    | 'a'  -> 7
    | 'b'  -> 8
    | 'n'  -> 10
    | 'r'  -> 13
    | 't'  -> 9
    | '\\' -> 92
    | '\'' -> 39
    | '"'  -> 34
    | '?'  -> 63
    |  _   -> Impossible.impossible "unknown escape sequence"

let decode_hex c = match c with 
    | 'a' .. 'f' -> Char.code c - Char.code 'a' + 10
    | 'A' .. 'F' -> Char.code c - Char.code 'A' + 10
    | '0' .. '9' -> Char.code c - Char.code '0'
    | _          -> Impossible.impossible 
                        ("not a hexadecimal character: "^Char.escaped c)
@
%%% ------------------------------------------------------------------  
\subsection{Comments}
%%% ------------------------------------------------------------------  
%%
%%Comments in C-- originally could nest but for compatibility with the C
%%preprocessor this feature was droped.  Since it is impossible to
%%include the character sequence [[*/]] in a C comment C$++$ style
%%comments are additionally accepted:  a comment starts with [//] and
%%goes up to the end of the line.  The latter comments are not
%%implemented with a separate scanner context but inlined.
<<scan.mll>>=
and comment1 = parse
    eof                         { fun map ->
                                  error lexbuf "unterminated comment" 
                                }
  | [^ '*' '\n' '\t' '/']+      { fun map ->
                                  comment1 lexbuf map
                                }
  | nl                          { fun map ->
                                  nl lexbuf map; comment1 lexbuf map 
                                }
  | nl '#'                      { fun map -> 
                                  line lexbuf map 0; comment1 lexbuf map
                                }
  
  | tab                         { fun map -> 
                                  tab lexbuf map; comment1 lexbuf map
                                }
  | "*"                         { fun map ->
                                  comment1 lexbuf map
                                }
  | "*/"                        { fun map ->
                                  token lexbuf map 
                                }
  | _                           { fun map ->
                                  comment1 lexbuf map 
                                }
@
%%
%%% ------------------------------------------------------------------  
\subsection{Strings}
%%% ------------------------------------------------------------------  
%%
%%All escape sequences are handled by the [[escape]] scanner. When the
%%escape scanner returns we simply continue to scan the string until we
%%reach the double quote. A string must only contain printable characters;
%%unfortunately, the lexer specification does not allow to use the
%%[[printable]] definition inside a character class.
<<scan.mll>>=
and string = parse
    eof                         { fun map buf -> 
                                  error lexbuf "unterminated string" 
                                }
  | "\""                        { fun map buf -> P.STR (Buffer.contents buf) 
                                  (* we are done *)
                                }

  | [^ '\000'-'\031'
       '\128'-'\255'
       '"' '\\' ]+              { fun map buf ->
                                  let s    = get lexbuf              in
                                  ( Buffer.add_string buf s
                                  ; string lexbuf map buf
                                  )
                                }
  | '\\'                        { fun map buf -> 
                                  let i = escape lexbuf in
                                  if i >= 256 then
                                    error lexbuf "character literal too large"
                                  else
                                    ( Buffer.add_char buf (Char.chr(i))
                                    ; string lexbuf map buf
                                    )
                                }    
  | _                           { fun map buf ->
                                  error lexbuf "illegal character in string"
                                }
@
%%
%%% ------------------------------------------------------------------  
\subsection{Pragmas}
%%% ------------------------------------------------------------------ 
%%
%%Pragmas are special because the work on the lexical as well as on the
%%grammatical level: 
%%\begin{itemize}
%%\item A \textit{known} pragma is handled like a keyword -- normal
%%      scanning and parsing resumes.
%%
%%\item An \textit{unknown} pragma is skipped by the scanner. 
%%\end{itemize}
%%The split personality of pragmas leads to a scanner that uses a
%%sequence of three scanner contexts to simulate some parsing in case an
%%unknown pragma must be skipped over.
%%
%%To decide whether a pragma is known we look at its
%%\textit{target}---the identifier following the [[pragma]] keyword.
%%While looking for the identifier white space is skipped and special
%%characters are noticed. It is an error when no identifier is found.
%%
%%When an identifier is found but it is not in the [[keywords]] table
%%the pragma must be skipped by the parser.  This requires to find the
%%body of the pragma that is enclosed by curly brackets.  Looking for
%%the opening bracket takes place in the [[pragma2]] scanner context.
<<scan.mll>>=
and pragma1 = parse
    eof                 { fun map -> P.EOF }
  | ws+                 { fun map -> pragma1 lexbuf map }
  | tab                 { fun map -> tab lexbuf map; pragma1 lexbuf map }
  | nl                  { fun map -> nl lexbuf map;  pragma1 lexbuf map } 
  | id                  { fun map -> 
                          let s  = get lexbuf in 
                          try ( match keyword s with 
                              | _     -> pragma2 lexbuf map s
                              )
                          with Not_found -> pragma2 lexbuf map s
                        }
  | _                   { fun map -> 
                          error lexbuf "id for pragma expected" 
                        }


and pragma2 = parse
    eof                 { fun map id -> 
                          error lexbuf "pragma body expected" 
                        }
  | ws+                 { fun map id -> pragma2 lexbuf map id }
  | tab                 { fun map id -> tab lexbuf map; pragma2 lexbuf map id}
  | nl                  { fun map id -> nl  lexbuf map; pragma2 lexbuf map id}
  | '{'                 { fun map id -> 
                          pragma3 lexbuf map 0 
                        }
  | _                   { fun map id -> 
                          error lexbuf "pragma body expected" 
                        }
@
%%It is an error when the opening bracket is not found. Once it is
%%found the body of the pragma is skipped over in context [[pragma3]]. A
%%body of a pragma must contain legal \C~tokens. We don't have to care
%%for the details but must consider only the following cases:
%%\begin{itemize}
%%\item The curly brackets may nest. So we keep a [[level]] to find the
%%      matching closing bracket.
%%
%%\item Brackets inside of strings literals, character literals, and
%%      comments are not considered. Each of these are handled in their
%%      own scanner contexts.
%%\end{itemize}
<<scan.mll>>=
and pragma3 = parse
    eof                         { fun map level ->
                                  error lexbuf "unterminated pragma" 
                                }
  | [^ '{' '}'  '\n' '\t' 
       '/' '\'' '"']+           { fun map level ->
                                  pragma3 lexbuf map level
                                }
  | nl                          { fun map level ->
                                  nl lexbuf map
                                ; pragma3 lexbuf map level 
                                }
  | tab                         { fun map level -> 
                                  tab lexbuf map; pragma3 lexbuf map level
                                }
  | '{'                         { fun map level -> 
                                  pragma3 lexbuf map (level+1)
                                }
  | '}'                         { fun map level ->
                                  if   level = 0 
                                  then token lexbuf map
                                  else pragma3 lexbuf map (level-1)
                                }
  | cxxcomment                  { fun map -> pragma3 lexbuf map (* ignore *) } 
  | "/*"                        { fun map level -> 
                                  ignore (comment1 lexbuf map) 
                                ; pragma3 lexbuf map level
                                }
  | "\""                        { fun map level -> 
                                  ignore (string lexbuf map (Buffer.create 80))
                                ; pragma3 lexbuf map level
                                }
  | "'"                         { fun map level -> 
                                  ignore (character lexbuf map)
                                ; pragma3 lexbuf map level
                                }
  
  | _                           { fun map level ->
                                  pragma3 lexbuf map level 
                                }
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{C-Style Line Pragma}
%%% ------------------------------------------------------------------ 
%%
%%Although not intended it is likely that \C~is used with the C
%%preprocessor.  It emits directives to link a line in its output to a
%%another source file.  In principle the [[line]] pragma is intended for
%%this task.  However, the C preprocessor can not emit this pragmas
%%instead and thus we provide support for the C preprocessor directive.
%%
%%The implementation is a new scanner context that requires that the
%%line directive is matched by the following regular expression (in the
%%syntax used by \ocaml-Lex and using expressions defined above):
%%\begin{center}
%%[[ws* '#' ws+ nat '"'[^ '"']*'"' ws* '\n']]
%%\end{center}
%%Note that {\small ANSI/ISO} C allows whitespace before and after the
%%[[#]] character. Leading whitespace has already been recognized at this
%%point.
%%
%%The meaning of a line directive
%%\texttt{\#}~\textit{line}~\texttt{"}file\texttt{"} is that the
%%\textit{following} line is on line \textit{line} in file
%%\textit{file}.  The implementation links the current line to
%%$\textit{line}-1$ in \textit{file} by placing a sync point.
%%
%%This implementation does not check the syntax but just recognizes
%%different tokens. It returns when it finds a string and relies on the
%%fact that the line number must come first.
<<scan.mll>>=
and line = parse 
    eof                 { fun map l ->
                          error lexbuf "unterminated line directive" 
                        }
  | ws+                 { fun map l -> line lexbuf map l }
  | tab                 { fun map l -> line lexbuf map l }
  | '"'                 { fun map l ->
                          let buf      = Buffer.create 80 in
                          let _        = string lexbuf map buf in
                          let file     = Buffer.contents buf in
                          let pos      = Lexing.lexeme_start lexbuf in
                          let location = file, l-1, 1 in
                                ( Srcmap.sync map pos location
                                ; () (* return *)
                                )
                        }
  | nat                 { fun map l -> 
                          
                          (* inline'ing the l' expression caused an
                          int_of_string failure with ocamlopt *)
                          
                          let l' = int_of_string (get lexbuf)
                          in  line lexbuf map l'
                        }
  | id                  { fun map l ->
                          line lexbuf map l
                        }
  | _                   { fun map l -> 
                          error lexbuf 
                          "illegal character in line directive"
                        }
@
%%
<<scan.mll>>=
{   (* start of epilog *)
    <<scanner entry point>>
@
%%
%%% ------------------------------------------------------------------  
\subsection{Debugging the Scanner}
%%% ------------------------------------------------------------------  
%%
%%In case of an parse error the problem may be actually caused by the
%%scanner.  For debugging we define a function [[tok2str]] that turns a
%%token (as defined in [[parse.mli]]) into a string.  This is used below
%%to define a function that reports the stream of all tokens for a file
%%together with their positions.
<<scan.mll>>=
    let tok2str = function

    | P.ABORTS            -> "ABORTS"
    | P.ALIGN             -> "ALIGN"
    | P.ALIGNED           -> "ALIGNED"
    | P.ALSO              -> "ALSO"
    | P.AS                -> "AS"
    | P.COLON             -> "COLON"
    | P.CCOLON            -> "CCOLON"
    | P.COMMA             -> "COMMA"
    | P.CONST             -> "CONST"
    | P.CONTINUATION      -> "CONTINUATION"
    | P.CUT               -> "CUT"
    | P.CUTS              -> "CUTS"
    | P.ELSE              -> "ELSE"
    | P.EOF               -> "EOF"
    | P.EQUAL             -> "EQUAL"
    | P.EXPORT            -> "EXPORT"
    | P.FAILS             -> "FAILS"
    | P.FOREIGN           -> "FOREIGN"
    | P.GOTO              -> "GOTO"
    | P.IF                -> "IF"
    | P.IMPORT            -> "IMPORT"
    | P.IN                -> "IN"
    | P.INVARIANT         -> "INVARIANT"
    | P.JUMP              -> "JUMP"
    | P.LBRACE            -> "LBRACE"
    | P.LBRACKET          -> "LBRACKET"
    | P.LPAREN            -> "LPAREN"
    | P.NEVER             -> "NEVER"
    | P.PPERCENT          -> "PPERCENT"
    | P.PRAGMA            -> "PRAGMA"
    | P.RBRACE            -> "RBRACE"
    | P.RBRACKET          -> "RBRACKET"
    | P.READS             -> "READS"
    | P.REGISTER          -> "REGISTER"
    | P.RETURN            -> "RETURN"
    | P.RETURNS           -> "RETURNS"
    | P.RPAREN            -> "RPAREN"
    | P.SECTION           -> "SECTION"
    | P.SEMI              -> "SEMI"
    | P.SPAN              -> "SPAN"
    | P.STACKDATA         -> "STACKDATA"
    | P.TARGETS           -> "TARGETS"
    | P.TO                -> "TO"
    | P.UNICODE           -> "UNICODE"
    | P.UNWINDS           -> "UNWINDS"
    | P.WRITES            -> "WRITES"

    | P.TYPEDEF           -> "TYPEDEF" 
    | P.MEMSIZE           -> "MEMSIZE"
    | P.BYTEORDER         -> "BYTEORDER"
    | P.LIMITCHECK        -> "LIMITCHECK"
    | P.LITTLE            -> "LITTLE"
    | P.BIG               -> "BIG"
    | P.CASE              -> "CASE"
    | P.DEFAULT           -> "DEFAULT"
    | P.TARGET            -> "TARGET"
    | P.DOTDOT            -> "DOTDOT"
    | P.SWITCH            -> "SWITCH"

    | P.WRDSIZE           -> "WORSIZE"
    | P.PTRSIZE           -> "POINTERSIZE"
    | P.FLOATREPR         -> "FLOAT"
    | P.CHARSET           -> "CHARSET"
    

    | P.AMPERSAND(s)      -> "AMPERSAND(" ^ s ^ ")"
    | P.BAR(s)            -> "BAR(" ^       s ^ ")"
    | P.CARET(s)          -> "CARET(" ^     s ^ ")"
    | P.EEQ(s)            -> "EEQ(" ^       s ^ ")"
    | P.GEQ(s)            -> "GEQ(" ^       s ^ ")"
    | P.GGREATER(s)       -> "GGREATER(" ^  s ^ ")"
    | P.GT(s)             -> "GT(" ^        s ^ ")"
    | P.LEQ(s)            -> "LEQ(" ^       s ^ ")"
    | P.LLESS(s)          -> "LLESS(" ^     s ^ ")"
    | P.LT(s)             -> "LT(" ^        s ^ ")"
    | P.MINUS(s)          -> "MINUS(" ^     s ^ ")"
    | P.NEQ(s)            -> "NEQ(" ^       s ^ ")"
    | P.PERCENT(s)        -> "PERCENT(" ^   s ^ ")"
    | P.PLUS(s)           -> "PLUS(" ^      s ^ ")"
    | P.SLASH(s)          -> "SLASH(" ^     s ^ ")"
    | P.STAR(s)           -> "STAR(" ^      s ^ ")"
    | P.TILDE(s)          -> "TILDE(" ^     s ^ ")"
    | P.UMINUS(s)         -> "UMINUS" ^     s ^ ")"
    
    
    | P.ID(s)             -> "ID(" ^        s ^ ")"
    | P.STR(s)            -> "STR(" ^       String.escaped s ^ ")"
    | P.INFIXOP(s)        -> "INFIXOP(" ^   s ^ ")"
    | P.PRIMOP(s)         -> "PRIMOP(" ^    s ^ ")"
    | P.SINT(s)           -> "SINT(" ^       s ^ ")"
    | P.UINT(s)           -> "UINT(" ^       s ^ ")"
    | P.FLT(s)            -> "FLT(" ^       s ^ ")"
    | P.CHAR(i)           -> "CHAR(" ^ Char.escaped (Char.chr i) ^ ")"

    | P.BITSn(i)          -> "BITSn(" ^ string_of_int i ^ ")"

} (* end of epilog *)
@
%%
%%% ------------------------------------------------------------------  
\section{Grammatical Analysis}\label{sec:parser}
%%% ------------------------------------------------------------------  
%%
%%The parser reads a token stream created by the scanner (module
%%[[Scan]]) and return the abstract syntax of the input, as defined by
%%module [[Ast]]. 
<<parse.mly>>=
%{
    module A = Ast
    module E = Error

(* pad: syncweb does not support multi-lang; can't have special comments for
 * yacc (C) and OCaml so have to inline the ocaml code here manually
 *)
let p  ()  = (Parsing.symbol_start (), Parsing.symbol_end())
let pn n   = (Parsing.rhs_start n, Parsing.rhs_end n)
let px ()  = (Parsing.symbol_start ())

let rev    = List.rev

let dep msg =
  let deprecated = Reinit.ref false in
  fun x ->
    if not (!deprecated) then
      begin
        Printf.eprintf "C-- warning: %s\n" msg;
        deprecated := true;
      end;
    x

let mkRegs v (hint,ty,regs) = List.map (fun (id,reg) -> (v, hint, ty, id, reg)) regs
let mkTypedefs ty names = List.map (fun n -> A.Typedef(n,ty)) names

let rdep = dep "Use of 'register' keyword is deprecated"
let noeqdep = dep "Hardware register name without '=' is deprecated"

let str2uint str =
  let b = Bits.U.of_string str Nativeint.size in
  try Bits.U.to_int b with Bits.Overflow ->
    Error.errorf "constant %s overflows %d-bit native integer" str (Nativeint.size-1)

let ast_mem ty exp (align, alias) = A.Mem(ty, exp, align, alias)

let uminus e =
  let rec strip = function
    | A.ExprAt(e, _) -> strip e
    | A.Sint(s, w) -> A.Sint("-" ^ s, w)
    | _ -> A.UnOp("-", e) in
  strip e

%}
@     
%%
%%[[p]] returns the region for the left hand symbol in the current
%%production.  A region (of type [[int * int]] contains the position of
%%the first character character of the symbol in input stream, and the
%%position of the first character after the symbol.  These regions are
%%attached to important nodes in the abstract syntax.  The function
%%[[pn]] returns the region for symbol [[n]] on the right hand side,
%%where the leftmost symbol has index 1.
<<helper functions>>=
let p  ()  = (Parsing.symbol_start (), Parsing.symbol_end())
let pn n   = (Parsing.rhs_start n, Parsing.rhs_end n)
let px ()  = (Parsing.symbol_start ())

let rev    = List.rev
@ 
%%
<<helper functions>>=
let dep msg =
  let deprecated = Reinit.ref false in
  fun x ->
    if not (!deprecated) then
      begin
        Printf.eprintf "C-- warning: %s\n" msg;
        deprecated := true;
      end;
    x

let rdep = dep "Use of 'register' keyword is deprecated"
let noeqdep = dep "Hardware register name without '=' is deprecated"
@ 
%%
<<helper functions>>=
let mkRegs v (hint,ty,regs) = List.map (fun (id,reg) -> (v, hint, ty, id, reg)) regs
let mkTypedefs ty names = List.map (fun n -> A.Typedef(n,ty)) names
@            
%%
%%The [[[str2uint]] function takes the string representation of an integer
%%and returns its value.
<<helper functions>>=
let str2uint str =
  let b = Bits.U.of_string str Nativeint.size in
  try Bits.U.to_int b with Bits.Overflow ->
    Error.errorf "constant %s overflows %d-bit native integer" str (Nativeint.size-1)
@         
<<parse.mly>>=
%token ABORTS ALIGN ALIGNED ALSO AS AMPERSAND BIG BYTEORDER CASE COLON CCOLON
%token COMMA CONST CONTINUATION CUT CUTS DEFAULT DOTDOT ELSE EOF EQUAL
%token EXPORT FAILS FOREIGN GOTO IF IMPORT IN INFIXOP INVARIANT JUMP LBRACE
%token LBRACKET LIMITCHECK LITTLE LPAREN MEMSIZE NEVER PPERCENT RBRACE RBRACKET 
%token READS REGISTER RETURN RETURNS RPAREN SECTION SEMI SPAN STACKDATA SWITCH 
%token TARGET TARGETS TO TYPEDEF UNICODE UNWINDS WRITES
%token WRDSIZE PTRSIZE FLOATREPR CHARSET

/* pragmas */

%token PRAGMA
@ 
%%
<<parse.mly>>=
/* infix and prefix operators */

%token <string> EEQ NEQ LT LEQ GT GEQ
%token <string> BAR                      
%token <string> CARET                    
%token <string> AMPERSAND                
%token <string> LLESS GGREATER           
%token <string> PLUS MINUS               
%token <string> PERCENT STAR SLASH       
%token <string> TILDE UMINUS                    
%token <string> INFIXOP
%token <string> PRIMOP 

%token <string>         ID
%token <string>         STR
%token <int>            BITSn

%token <string>         SINT
%token <string>         UINT
%token <string>         FLT
%token <int>            CHAR
@
%%The precedence of tokens from lowest to highest precedence.
<<parse.mly>>=
/* lvalue conflict resolution */
%right      ID
%right      LBRACKET

/* conflict resolution for %foo() and %foo. We ensure the '(' has
   higher precedence and gets shifted. Take the following two
   declarations out and you get a shift/reduce conflict which defaults
   to shifting. This is correct, but we also like to get rid of the
   warning. */
%nonassoc   PRIMOP
%nonassoc   LPAREN

%nonassoc   INFIXOP
%nonassoc   EEQ NEQ LT LEQ GT GEQ
%left       BAR                      
%left       CARET                    
%left       AMPERSAND                
%left       LLESS GGREATER           
%left       PLUS MINUS               
%left       PERCENT STAR SLASH       
%right      TILDE UMINUS

%start program
%type <Ast.program>program

%%

program     :   toplevels                      { rev $1}

toplevels   :   toplevels toplevelAt           { $2::$1 }
            |   /**/                           { []     }
@ 
%$
%%
<<parse.mly>>=
toplevelAt  :   toplevel                       { A.ToplevelAt($1,p())       }
toplevel    :   SECTION STR LBRACE sections RBRACE  { A.Section($2, rev $4) }
            |   procedure                      { A.TopProcedure($1)         }
            |   declAt                         { A.TopDecl($1)              }
@ 
%$
%%
<<parse.mly>>=
sections    :   sections sectionAt             { $2 :: $1 }
            |   /**/                           { []       }

sectionAt   :   section                        { A.SectionAt($1,p()) }
section     :   procedure                      { A.Procedure($1)     }
            |   datum                          { A.Datum($1)         }
            |   span                           { A.SSpan($1)         }
            |   declAt                         { A.Decl($1)          }

@ 
%$
%%You might hope to have a nonterminal for an optional type, but this
%%little optimization leads to shift-reduce conflicts.
<<parse.mly>>=
declAt      :   decl                           { A.DeclAt($1,p()) }   
decl        :   INVARIANT /*----*/ registers SEMI
                    { A.Registers(mkRegs A.Invariant $2) }
            |   /*-----*/ /*----*/ registers SEMI
                    { A.Registers(mkRegs A.Variant $1)   }
            |   INVARIANT REGISTER registers SEMI
                    { rdep (A.Registers(mkRegs A.Invariant $3)) }
            |   /*-----*/ REGISTER registers SEMI
                    { rdep (A.Registers(mkRegs A.Variant $2))   }
          
            |   EXPORT ty exports  SEMI        { A.Export(Some $2, $3) }
            |   EXPORT    exports  SEMI        { A.Export(None,$2)    }
            |   IMPORT ty imports  SEMI        { A.Import(Some $2,$3)           }
            |   IMPORT    imports  SEMI        { A.Import(None,$2)           }
            |   CONST     ID EQUAL exprAt SEMI { A.Const(None,$2,$4)       }
            |   CONST  ty ID EQUAL exprAt SEMI { A.Const(Some $2,$3,$5)    }
            |   TYPEDEF ty names SEMI          { A.Typedef($2,rev $3)      }
            |   TARGET properties SEMI         { A.Target(rev $2)          }
@ 
%$
%%
<<parse.mly>>=
uint        : SINT { str2uint $1 }
            | UINT { str2uint $1 }

property    :   MEMSIZE uint                   { A.Memsize $2      }
            |   BYTEORDER BIG                  { A.ByteorderBig    }
            |   BYTEORDER LITTLE               { A.ByteorderLittle }
            |   FLOATREPR STR                  { A.FloatRepr $2    }
            |   CHARSET STR                    { A.Charset $2      }
            |   PTRSIZE uint                   { A.PointerSize $2  }
            |   WRDSIZE uint                   { A.WordSize $2     }
@ 
%$
<<parse.mly>>=
properties  :   properties property            { $2 :: $1 }
            |   /**/                           { []       }
@ 
%%
<<parse.mly>>=
span        :   SPAN sexprAt exprAt
                LBRACE sections RBRACE         { $2, $3, rev $5 }

@ 
%$
<<parse.mly>>=
datumAt     :   datum                          { A.DatumAt($1,p()) }
datum       :   ID COLON                       { A.Label $1 }
            |   ALIGN uint SEMI                { A.Align $2 }
            |   tyAt size opt_initAt SEMI      { A.MemDecl($1,$2,$3)}

opt_initAt : initAt { Some $1 } | { None }
@ 
%$
%%
<<parse.mly>>=
initAt      :   init                           { A.InitAt($1,p()) }
init        :   LBRACE   exprs RBRACE          { A.InitExprs($2)  }
            |   LBRACE         RBRACE          { A.InitExprs([])  }
            |   STR                            { A.InitStr($1)    }
            |   string16                       { A.InitUStr($1)   }
@ 
%%
<<parse.mly>>=
registers   :   STR    tyAt regs opt_comma     { Some $1, $2, rev $3 }
            |          tyAt regs opt_comma     { None   , $1, rev $2 }

regs        :   regs COMMA ID optEq STR        { ($3, Some $5)::$1 }
            |   regs COMMA ID                  { ($3, None   )::$1 }
            |   ID optEq STR                   { [($1,Some $3)]    }
            |   ID                             { [($1,None   )]    }

optEq       :   { noeqdep () }
            |   EQUAL  { () }
@ 
%$
%%
<<parse.mly>>=
size        :   LBRACKET exprAt RBRACKET       { A.FixSize($2) }
            |   LBRACKET       RBRACKET        { A.DynSize     }
            |                                  { A.NoSize      }

procedure   :   conv ID frmls body             {  $1, $2, $3, $4, p() }
            |        ID frmls body             {None, $1, $2, $3, p() }

body        :   LBRACE body0 RBRACE            { rev $2 }

body0       :   body0 bodyAt                   { $2 :: $1 }
            |   /**/                           { []       }

bodyAt      :   body1                          { A.BodyAt($1,p()) }
body1       :   declAt                         { A.DeclBody $1    }
            |   stackdecl                      { A.DataBody $1    }
            |   stmtAt                         { A.StmtBody $1    }

frmls       :   LPAREN  formals RPAREN         { $2 }
            |   LPAREN          RPAREN         { [] }
actls       :   LPAREN  actuals RPAREN         { $2 }
            |   LPAREN          RPAREN         { [] }

formals     :   formals_ opt_comma             { rev $1   }
formals_    :   formals_ COMMA formal          { $3 :: $1 }
            |   formal                         { [$1]     }

actuals     :   actuals_ opt_comma             { rev $1   }
actuals_    :   actuals_ COMMA actual          { $3 :: $1 }
            |   actual                         { [$1]     }

formal      :   bare_formal                    { p(), $1 }
bare_formal :   opt_kind opt_invariant opt_register tyAt ID opt_aligned
                { $1, $2, $4, $5, $6 }

opt_kind : STR { Some $1 } | { None }
opt_invariant : INVARIANT { A.Invariant } | { A.Variant }
opt_register  : REGISTER { () } | { () }

cformal     :   opt_kind ID opt_aligned        { p(), $1, $2, $3 }

cformals    :   cformals_ opt_comma            { rev $1   }
            |   /**/      opt_comma            { []       }
cformals_   :   cformals_ COMMA cformal        { $3 :: $1 }
            |   cformal                        { [$1]     }

actual      :   opt_kind exprAt opt_aligned    { $1, $2, $3 }
@ 
%%
<<parse.mly>>=
stackdecl   :   STACKDATA LBRACE data RBRACE   { rev $3 }

data        :   data  datumAt                  { $2 :: $1 }
            |   /**/                           { []       }

conv        :   FOREIGN STR                    { Some $2 }

aligned     :   ALIGNED uint                   { $2 }

flowAt      :   flow                           { A.FlowAt($1,p()) }
flow        :   ALSO CUTS     TO names         { A.CutsTo($4)     }
            |   ALSO UNWINDS  TO names         { A.UnwindsTo($4)  }
            |   ALSO RETURNS  TO names         { A.ReturnsTo($4)  }
            |   ALSO ABORTS                    { A.Aborts         }
            |   NEVER RETURNS                  { A.NeverReturns   }

flows       :   flows flowAt                   { $2 :: $1 }
            |   /**/                           { []       }

targets     :   TARGETS names                  { $2 }
            |   /**/                           { [] }

aliasAt     :   alias                          { A.AliasAt($1,p()) }
alias       :   READS  opt_names               { A.Reads ($2)       }
            |   WRITES opt_names               { A.Writes($2)       }

procanns    :   procanns flowAt                { A.Flow  $2 :: $1 }
            |   procanns aliasAt               { A.Alias $2 :: $1 }
            |   /**/                           { []       }
@
%$
%%
%%The grammar uses [[nameOrMem]] not only at the left hand side of
%%assignments but also as part of expressions where they denote the values
%%of registers and memory.  The introduction of hints for registers
%%(implemented as [[opstr ID]] or similar) has lead to serious
%%reduce/reduce conflicts caused by the use of [[nameOrMemAt]] in
%%[[sexpr]].  One way of getting rid of them was to split the original
%%[[nameOrMemAt]] into [nameOrMemAt0]] and [[nameOrMemAt]]:
%%[[nameOrMemAt0]] does not include [[STR ID]] which is not needed for
%%[[sexpr]].
%%
%%
<<parse.mly>>=
nameOrMemAt :   nameOrMem                      { A.NameOrMemAt($1,p()) } 
nameOrMem   :   nameOrMem0                     { $1 } 
            |   ID aligned                     { A.Name(None, $1, Some $2) }
            |   STR ID opt_aligned             { A.Name(Some $1,$2,$3) } 
@ 
%$
%%            
<<helper functions>>=
let ast_mem ty exp (align, alias) = A.Mem(ty, exp, align, alias)
@ 
%%
<<parse.mly>>=
nameOrMemAt0:   nameOrMem0                    { A.NameOrMemAt($1,p()) }
nameOrMem0  :   ID                            { A.Name(None, $1, None)}
            |   mem_type LBRACKET exprAt mem_properties RBRACKET { ast_mem $1 $3 $4 }

mem_type : sty { $1 }
         | ID  { A.TypeSynonym($1) }

mem_properties : aligned opt_in_ids { (Some $1, $2) }
               | IN ids opt_aligned { ($3, $2) }
               |                    { (None, []) }

opt_aligned : { None } | aligned { Some $1 }
opt_in_ids  : { [] } | IN ids { $2 }
ids         : ID { [$1] }
            | ID COMMA ids { $1 :: $3 }


nameOrMems  :   nameOrMems_ opt_comma          { rev $1   }
nameOrMems_ :   nameOrMems_ COMMA nameOrMemAt  { $3 :: $1 }
            |   nameOrMemAt                    { [$1]     }

tyAt        :   ty                             { A.TyAt($1,p()) }
ty          :   sty                            { $1             }
            |   ID                             { A.TypeSynonym($1)  }

sty         :   BITSn                          { A.BitsTy($1)     }

returnto    :   LT sexprAt SLASH sexprAt GT    { Some($2,$4) }
            |   /**/                           { None        }
@ 
%%
<<parse.mly>>=
stmtAt      :   stmt                           { A.StmtAt($1,p())     }
stmt        :   SEMI                           { A.EmptyStmt          }
            |   ID COLON                       { A.LabelStmt $1       }
            |   SPAN sexprAt sexprAt body      { A.SpanStmt($2,$3,$4) }
            |   nameOrMems EQUAL exprs SEMI       
                { A.AssignStmt($1,List.map (fun e -> None,e) $3)  }

            |   nameOrMems EQUAL conv PPERCENT ID actls flows SEMI
                { A.PrimStmt($1, $3, $5, $6, rev $7) }      
            
            |                 conv PPERCENT ID actls flows SEMI
                { A.PrimStmt([], $1, $3, $4, rev $5) }      
            
            |   nameOrMems EQUAL conv expr actls targets procanns SEMI
                { A.CallStmt($1, $3, $4, $5, $6, rev $7)  }
            
            |                 conv expr actls targets procanns SEMI
                { A.CallStmt([], $1, $2, $3, $4, rev $5)  }
                                          
            |   nameOrMems EQUAL      PPERCENT ID actls flows SEMI
                { A.PrimStmt($1, None, $4, $5, rev $6)    }
            
            |                      PPERCENT ID actls flows SEMI
                { A.PrimStmt( [], None, $2, $3, rev $4)}
            
            |   nameOrMems EQUAL      expr actls targets procanns SEMI
                { A.CallStmt($1, None, $3, $4, $5, rev $6)}

            |                      expr actls targets procanns SEMI
                { A.CallStmt([], None, $1, $2, $3, rev $4)}
 
            |   IF exprAt body                      {A.IfStmt($2,$3,[])}
            |   IF exprAt body  ELSE body           {A.IfStmt($2,$3,$5)}
            |   GOTO exprAt targets SEMI            {A.GotoStmt($2,$3)}
            |   CONTINUATION ID LPAREN cformals RPAREN COLON
                                                    {A.ContStmt($2,$4)}
            |   CUT TO expr actls flows SEMI        {A.CutStmt($3,$4, rev $5)  }
            |   LIMITCHECK exprAt limitfailure SEMI {A.LimitcheckStmt($2,$3)  }
            |   conv JUMP exprAt       targets SEMI {A.JumpStmt($1  ,$3,[],$4) }
            |        JUMP exprAt       targets SEMI {A.JumpStmt(None,$2,[],$3) }
            |   conv JUMP exprAt actls targets SEMI {A.JumpStmt($1  ,$3,$4,$5) }
            |        JUMP exprAt actls targets SEMI {A.JumpStmt(None,$2,$3,$4) }
            |   conv RETURN returnto       SEMI     {A.ReturnStmt($1  ,$3,[])  }
            |        RETURN returnto       SEMI     {A.ReturnStmt(None,$2,[])  }
            |   conv RETURN returnto actls SEMI     {A.ReturnStmt($1  ,$3,$4)  }
            |        RETURN returnto actls SEMI     {A.ReturnStmt(None,$2,$3)  }
            |   SWITCH srange expr LBRACE arms RBRACE  
                        {A.SwitchStmt($2,$3, rev $5)}
@ 
%%
<<parse.mly>>=
limitfailure : FAILS TO exprAt {Some $3}
            |  /**/            {None}
@ 
%$
%%
<<parse.mly>>=
srange      :   LBRACKET range RBRACKET        {Some $2}
            |   /**/                           {None}

range       :   expr                           {A.Point $1     }
            |   expr DOTDOT expr               {A.Range ($1,$3)}

ranges      :   ranges_                        { rev $1 }
            |   ranges_ COMMA                  { rev $1 }
            |   /**/                           { [] } 

ranges_     :   ranges_ COMMA range            { $3 :: $1 } 
            |   range                          { [$1]     } 

arms        :   arms armAt                     { $2 :: $1  }
            |   /**/                           { []        }

armAt       :   arm                            { A.ArmAt($1,p()) }
arm         :   CASE ranges COLON body         { A.Case($2,$4)   } 
@ 
%%
<<parse.mly>>=
sexprAt     :   sexpr                          { A.ExprAt($1, p()) }
sexpr       :   SINT opt_colon_ty              { A.Sint ($1, $2)   }
            |   UINT opt_colon_ty              { A.Uint ($1, $2)   }
            |   FLT  opt_colon_ty              { A.Float($1, $2)   }
            |   CHAR opt_colon_ty              { A.Char ($1, $2)   }
            |   nameOrMemAt0                   { A.Fetch $1        }
           /*   allow to write nullary OPs like constants */
            |   PRIMOP                         { A.PrimOp($1,[])   }
            |   LPAREN exprAt RPAREN           { $2                }
opt_colon_ty : CCOLON tyAt { Some $2 } | { None }
@ 
%$
%%
<<parse.mly>>=
exprAt      :   expr                           { A.ExprAt($1, p())    }
expr:       |   sexpr                          { $1                   }
            |   PRIMOP actls                   { A.PrimOp($1,$2)      }

            |   exprAt PLUS       exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt MINUS      exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt PERCENT    exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt STAR       exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt SLASH      exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt LLESS      exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt GGREATER   exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt CARET      exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt BAR        exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt AMPERSAND  exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt EEQ        exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt NEQ        exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt LT         exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt LEQ        exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt GEQ        exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt GT         exprAt       { A.BinOp($1,$2,$3) }
            |   exprAt INFIXOP    exprAt       { A.PrimOp($2,[None,$1,None;
                                                              None,$3,None]) }
            |   TILDE exprAt %prec TILDE       { A.UnOp($1,$2)     }
            |   MINUS exprAt %prec UMINUS      { uminus $2         }

exprs       :   exprs_ opt_comma               { rev $1   }
exprs_      :   exprs_ COMMA exprAt            { $3 :: $1 }
            |   exprAt                         { [$1]     }
@ 
%%
<<helper functions>>=
let uminus e =
  let rec strip = function
    | A.ExprAt(e, _) -> strip e
    | A.Sint(s, w) -> A.Sint("-" ^ s, w)
    | _ -> A.UnOp("-", e) in
  strip e
@ 
%%
<<parse.mly>>=
imports     :   imports_ opt_comma             { rev $1           }
imports_    :   imports_ COMMA STR AS ID       { (Some $3,$5)::$1 }
            |   imports_ COMMA        ID       { (None   ,$3)::$1 } 
            |   STR AS ID                      { [Some $1,$3]     }
            |   ID                             { [None   ,$1]     }

exports     :   exports_ opt_comma             { rev $1           }
exports_    :   exports_ COMMA ID AS STR       { ($3,Some $5)::$1 }
            |   exports_ COMMA ID              { ($3,None)::$1    }
            |   ID AS STR                      { [$1,Some $3]     }
            |   ID                             { [$1,None]        }

names       :   names_ opt_comma               { rev $1 }
names_      :   names_ COMMA ID                { $3:: $1}
            |   ID                             { [$1] }

opt_names   :   names { $1 }
            |   /**/  { [] }

opt_comma   :   COMMA                          {}
            |   /**/                           {}

string16    :   UNICODE LPAREN STR RPAREN      { $3 }
@

\chapter{[[front_rtl]]}

\section{[[front_rtl/register.nw]]}
<<front_rtl/register.ml>>=
<<register.ml>>
@

<<front_rtl/register.mli>>=
<<register.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{Register}
%%% ------------------------------------------------------------------ 
%%
%%A [[Register.t]] describes a register-like location.
%%Such a location includes hardware-registers or temporaries, but not
%%spill locations.  The distinguishing feature of a register is a fixed
%%address within its space: the address is an integer rather than a
%%general expression.
%%
%%A~[[space]] is identified by a single [[char]], but its representation
%%includes its aggregation semantics and the width of a single cell in
%%the space.
%%The cell width is described by a value of type [[Cell.t]], chosen
%%because it the [[Cell.t]] handles common arithmetic operations using
%%shifts instead of multiplies and divides.
%%Within any single back end, the value of the [[char]] completely
%%identifies the space and therefore determines the corresponding
%%aggregation and [[Cell.t]].
%%This means that a postexpander and recognizer may safely scrutinize
%%only the [[char]] in order to identify and use the space.
%%But different back ends may use different aggregations or cell sizes,
%%so any machine-independent code, such as alias analysis, must look
%%explicitly to determine cell size and aggregation.
%%
%%A [[t]] value is an aggregate of cells, so it can represent a register
%%pair or quad as well as a single register.
%%The representation includes the target-specific [[space]], 
%%the address (index) 
%%within the space of the lowest cell in the aggregate,
%%and the [[count]] of the number of cells aggregated.
%%To compute the width of register requires looking at the space to find
%%the width of a single cell (cf [[Cell.to_width]]);
%%the function [[Register.width]] is provided for this purpose.
%%
%%We also define a type [[Register.x]], which is a sum type that may be
%%either a register or a slice of a register.
%%This type is useful for performing accurate liveness analysis at the
%%slice level.
%%
%%We cannot refer to types in module \module{rtl} because this would
%%create a cyclic dependency,
<<exported types(register.nw)>>=
open Nopoly

type aggregation = 
    | BigEndian
    | LittleEndian
    | Identity
type space = char * aggregation * Cell.t   (* name, byte order, cell size *)
type count = Cell.count = C of int
type width = int
type reg = space * int * count (* Rtl.space, index, number of cells *)
type t = reg
type x = Reg   of t
       | Slice of width * int * t
@
%%We provide an extended set type.
<<exported types(register.nw)>>=
module type SETX = sig
  include Set.S
  val of_list   : elt list -> t
  val to_string : t -> string    (* elements sep. by commas (no braces) *)
end
@
%%We can ask the width of a register.
%%We also provide safe comparisons.
<<register.mli>>=
<<exported types(register.nw)>>
val width   : t -> int
val eq      : t -> t -> bool
val compare : t -> t -> int
@ 
%%We can also query extended registers.
<<register.mli>>=
val widthx : x -> int
val eqx    : x -> x -> bool
@ 
%%We have two kinds of sets.
<<register.mli>>=
module SetX: SETX  with type elt = x
module MapX: Map.S with type key = x
module Set:  SETX  with type elt = t
module Map:  Map.S with type key = t
@
%%Sometimes it is useful to consider only registers; we can promote a type [[x]] to a
%%type [[t]] by returning the register or the register from which we are taking a slice,
%%as appropriate.
%%We can also convert between different types of sets.
<<register.mli>>=
val promote_x     : x -> t
val rset_to_rxset : Set.t  -> SetX.t
val promote_rxset : SetX.t -> Set.t
@
%%We sometimes need to map a list of registers into a compact set of integers.
%%[[reg_int_map]] maps a list of $n$ integers into the numbers $[0..n-1]$, in
%%alphanumeric order (by space, then index).
%%Additionally, we return the number of registers in the first element of the pair.
<<register.mli>>=
val reg_int_map : t list -> int * int Map.t
@ 
%%We need to check whether one register contains another.
<<register.mli>>=
val contains : outer:x -> inner:x -> bool
@
%%Registers are exported to Lua as a new \emph{userdata} type.
%%
%%%pad: no LUA for now
<<register.mli LUA>>=
module RT (C : Lua.Lib.CORE) : sig
	val map : t C.V.map
end
@
%%
%%
%%% ------------------------------------------------------------------ 
\section{Implementation of registers}
%%% ------------------------------------------------------------------ 
%%
%%We can't use the built-in [[compare]] because it is not safe to
%%[[compare]] values of type [[Cell.t]].
%%In any case,
%%profiling showed that registers are compared frequently; 
%%in an earlier version of code that could safely use the polymorphic
%%[[compare]], 
%%a monomorphic version improved compile time by over~10\%.
<<register.ml>>=
<<exported types(register.nw)>>
module Compare = struct
    type t = reg 
    let compare (((xs,_,_),xi,C xc):t) (((ys,_,_),yi,C yc):t) =
        let x = comparec xs ys in
        if x <> 0 then x
        else let i = comparei xi yi in if i <> 0 then i 
        else comparei xc yc
    let compare' x y = compare y x

    let compare = try ignore (Sys.getenv "QCREVERSE"); compare' with _ -> compare

(*
    let compare (((xs,_,_),xi,C xc) as x:t) (((ys,_,_),yi,C yc) as y:t) =
      let answer = compare x y in
      let prime = compare y x in
      if prime <> -answer then
        Printf.kprintf Impossible.impossible "$%c[%d:%d] ? $%c[%d:%d] == %d (neg %d)\n" xs xi xc ys yi yc answer prime;
      answer
*)
end
let compare = Compare.compare
let eq r r' = Compare.compare r r' = 0
module CompareX = struct
    type t = x
    let compare x y = match x, y with
    | Slice (w, lsb, r), Slice (w', lsb', r') ->
        let x = comparei w w' in
        if x <> 0 then x
        else
          let x = comparei lsb lsb' in
          if x <> 0 then x
          else Compare.compare r r'
    | Slice _, Reg _  ->  1
    | Reg _, Slice _  -> -1
    | Reg r, Reg r'   -> Compare.compare r r'
end
@ 
%%
<<register.ml>>=
module SetX = struct
  module S = Set.Make(CompareX)
  include S
  let of_list l = List.fold_right add l empty
  let to_string s =
    let elt = function
      | Reg ((s,_,_), i, C 1) -> Printf.sprintf "%c%d" s i
      | Reg ((s,_,_), i, C n) -> Printf.sprintf "%c%d:%d" s i n
      | Slice (w, i, ((s,_,_), i', _)) ->
          Printf.sprintf "%c%d@[%d..%d]" s i' i (i + w - 1) in
    String.concat ", " (List.map elt (elements s))
end
module Set = struct
  module S = Set.Make(Compare)
  include S
  let of_list l = List.fold_right add l empty
  let to_string s =
    let elt ((s,_,_), i, C n) =
      if n = 1 then
        Printf.sprintf "%c%d" s i
      else
        Printf.sprintf "%c%d:%d" s i n in
    String.concat ", " (List.map elt (elements s))
end
@ 
%%
<<register.ml>>=
module MapX = Map.Make(CompareX)
module Map  = Map.Make(Compare)
@
<<register.ml>>=
let promote_x = function Reg r | Slice (_, _, r) -> r
let rset_to_rxset set = Set.fold (fun r rst -> SetX.add (Reg r) rst) set SetX.empty
let promote_rxset set =
  SetX.fold (fun r rst -> match r with Reg r | Slice (_,_,r) -> Set.add r rst)
            set Set.empty
@
%%Creating the integer map is rather simple.
<<register.ml>>=
let reg_int_map regs =
  let cmp ((s1,_,_),i1,_) ((s2,_,_),i2,_) =
    match comparec s1 s2 with 0 -> comparei i1 i2 | n -> n in
  let order = List.sort cmp regs in
  (List.fold_left (fun (i,map) r -> (i+1, Map.add r i map)) (0, Map.empty) order)
@
%%The [[RT]] module creates an embedding/projection pair for registers.
%%%pad: no LUA
<<register.ml LUA>>=
module RT (C : Lua.Lib.CORE) = struct
    module V = C.V

   let agg =
     V.default Identity
       (V.enum "aggregation"
          ["big", BigEndian; "little", LittleEndian; "identity", Identity]) 

    let embedRegister ((s,a,cell),i,C c) =
      (V.record V.value).V.embed
      [ "space", V.string.V.embed (Char.escaped s)
      ; "agg",   agg.V.embed a
      ; "cellsize", V.int.V.embed (Cell.size cell)
      ; "index", V.int.V.embed i
      ; "width", V.int.V.embed (Cell.to_width cell (C c))
      ; "count", V.int.V.embed c
      ] 

    let projectRegister reg = match reg with
      | V.Table reg ->
          (try
            let field f = V.Table.find reg (V.String f) in
            let s    = String.get (V.string.V.project (field "space")) 0 in
            let cell = Cell.of_size (V.int.V.project (field "cellsize")) in
            let i    = V.int.V.project (field "index") in
            let a    = agg.V.project (field "agg") in
            let c    = match field "count" with
            | V.Nil -> let w = V.int.V.project (field "width") in
                       Cell.to_count cell w
            | cf    -> C (V.int.V.project cf) in
            ((s,a,cell),i,c)
          with V.Projection _ -> raise (V.Projection (V.Table reg, "register")))
      | _ -> raise (V.Projection (reg, "register"))

    let map = {
      V.embed = embedRegister ; V.project = projectRegister;
      V.is = (fun r -> try ignore (projectRegister r); true
                       with V.Projection (_, _) -> false); }
end
@ 
<<Lua code for registers>>=
Register = { }

function Register.create(t)
  if not t.width and not t.count then t.count = 1 end     
  assert(t.space and t.cellsize and t.index)
  assert(t.count > 0)
  t["I am a register"] = 1
  return t
end

function Register.is(r)
  return r["I am a register"]
end

function Register.range(r1, r2)
  assert(Register.is(r1) and Register.is(r2))
  assert(r1.space == r1.space and r1.agg == r2.agg and r1.cellsize == r2.cellsize
        and r1.count == r2.count)
  assert(r1.index <= r2.index)
  local l = { }
  local next = 1
  local i = r1.index
  local space, cellsize, agg, count = r1.space, r1.cellsize, r1.agg, r1.count
  while i <= r2.index do
    l[next] =
      Register.create { space = space, cellsize = cellsize, agg = agg, count = count,
                        index = i }
    i = i + count
    next = next + 1
  end
  return l
end
@ 
%%
<<register.ml>>=
let width ((_, _, ms), _, c) = Cell.to_width ms c
let widthx = function
  | Reg r -> width r
  | Slice (w, _, _) -> w

let rec eqx x x' = match x, x' with
| Reg r, Reg r' -> eq r r'
| Slice (w, lsb, r), Slice (w', lsb', r') -> w = w && lsb = lsb && eq r r'
| Reg _, Slice _ -> false
| Slice _, Reg _ -> false
@ 
%%If somebody tries to take a slice of a register pair,
%%we will go to their house and spit in their food.
%%If nobody does such a bad thing, a slice contains a register if and
%%only if the slice is the whole register.
<<register.ml>>=
let contains ~outer ~inner = match outer, inner with
| Reg ((s, _, _), i, C c), Reg ((s', _, _), i', C c') ->
    s =<= s' && i' >= i && i' + c' <= i + c
| Reg ((s, _, _), i, C c), Slice (w', lsb', ((s', _, _), i', C c')) ->
    s =<= s' && i' >= i && i' + c' <= i + c
| Slice (w, lsb, ((s, _, _), i, C c)), Reg ((s', _, cell), i', C c') ->
    if c <> 1 then
      Impossible.impossible "slice of register aggregate";
    lsb = 0 && w = Cell.to_width cell (C c') && s =<= s' && i = i' && c = c'
| Slice (w, lsb, ((s, _, _), i, C c)), Slice (w', lsb', ((s', _, _), i', C c')) ->
    if c <> 1 || c' <> 1 then
      Impossible.impossible "slice of register aggregate";
    s =<= s' && i = i' && lsb <= lsb' && lsb+w >= lsb'+w'
@ 
\section{[[front_rtl/reloc.nw]]}
<<front_rtl/reloc.ml>>=
<<reloc.ml>>
@

<<front_rtl/reloc.mli>>=
<<reloc.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% ------------------------------------------------------------------ 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
\section{Relocatable Addresses}
%%% ------------------------------------------------------------------ 
%%
%%A relocatable address formed by sums and differences of symbolic and
%%literal constants.
%%A [['a relocatable]] value represents a bit vector of type [[['a]] whose
%%value might not be known until link time. Since the representation is 
%%polymorphic over the type of the constant, [[add_const]] receives as
%%first argument a function that adds constants.
%%
%%It might be necessary to turn a relocatable address back into an
%%expression, which might conceivably undergo a PIC transformation.
%%For that reason, to make a relocatable address from a symbol, it is
%%necessary to supply a suitable function.
<<reloc.mli>>=
type symbol = Symbol.t * (Symbol.t -> Rtl.width -> Rtl.exp)

type exp = Pos of symbol * Rtl.width | Neg of symbol * Rtl.width
type t  = exp list * Bits.bits
(* pad: was previously an abstract type
 *   'type t'
 * but it forbids to see the data from the debugger
 *)


(* constructors *)
val of_const : Bits.bits -> t
val of_sym   : symbol -> Rtl.width -> t
val add :  t -> t -> t
val sub :  t -> t -> t

(* observers *)
val fold : const:(Bits.bits -> 'a) -> sym:(symbol -> 'a) ->
           add:('a -> 'a -> 'a) -> sub:('a -> 'a -> 'a) -> t -> 'a

val width : t -> Rtl.width
val if_bare : t -> Bits.bits option (* if not a bare value, returns None *)
val as_simple : t -> Symbol.t option * Bits.bits
   (* checked RTE if not simple *)
@
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%No known need for efficiency here.
<<reloc.ml>>=
open Nopoly

type symbol = Symbol.t * (Symbol.t -> Rtl.width -> Rtl.exp)
let eqsym (s,_) (s',_) = s#mangled_text =$= s'#mangled_text

type exp = Pos of symbol * Rtl.width | Neg of symbol * Rtl.width
let neg = function Pos (s, w) -> Neg (s, w) | Neg (s, w) -> Pos (s, w)

type t  = exp list * Bits.bits
let of_const c    = ([], c)
let of_sym s w    = ([Pos (s, w)], Bits.zero w)
let add (xs, xc) (ys, yc) = (xs @ ys, Bits.Ops.add xc yc)
let sub (xs, xc) (ys, yc) = (xs @ List.map neg ys, Bits.Ops.sub xc yc)
let fold ~const ~sym ~add ~sub (ss, c) =
  let extend e = function Pos (s, w) -> add e (sym s)
                        | Neg (s, w) -> sub e (sym s) in
  match ss with
  | Pos (s, w) :: ss when Bits.is_zero c -> List.fold_left extend (sym s)   ss
  | _                                    -> List.fold_left extend (const c) ss
@
%$
<<reloc.ml>>=
let width (_, b) = Bits.width b
let if_bare = function ([], b) -> Some b | (_::_, _) -> None
let as_simple a =
  let w = Bits.width (snd a) in
  let const bits = (None, bits) in
  let sym (s, _) = (Some s, Bits.zero w) in
  let add (s, b) (s', b') = match s, s' with
  | Some s, None   -> (Some s, Bits.Ops.add b b')
  | None, Some s   -> (Some s, Bits.Ops.add b b')
  | None, None     -> (None, Bits.Ops.add b b')
  | Some _, Some _ -> Impossible.impossible "added symbols in simple reloc" in
  let sub (s, b) (s', b') = match s' with
  | None -> (s, Bits.Ops.sub b b')
  | Some _ -> Impossible.impossible "subtracted symbols in simple reloc" in
  fold ~const ~sym ~add ~sub a
@ 
\section{[[front_rtl/rtl.nw]]}
<<front_rtl/rtl.ml>>=
<<rtl.ml>>
@

<<front_rtl/rtl.mli>>=
<<rtl.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 et sw=4: 
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{Register-transfer Lists (\rtl)}
%%% ------------------------------------------------------------------ 
%%
%%Register-transfer lists capture the meaning of instructions.  They are
%%used as part of the abstract representation of {\PAL}.  The meaning of a
%%register-transfer list is well defined and especially independent from
%%any properties of a target architecture because no hidden assumptions
%%exist.
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Interface}
%%% ------------------------------------------------------------------ 
%%
%%The interface is divided into three parts:  \emph{public},
%%\emph{private}, and \emph{common}.  The public part provides constructor
%%functions to build {\rtl}s but hides their actual implementation.  The
%%private part reveals these and is intended only for parts of the back
%%end that does re-writing of {\rtl}s.  Both private and public parts
%%share \emph{common} types.  The public part includes function that
%%converts public values into private values and thus makes their details
%%accessible. 
<<rtl.mli>>=
<<definitions of exported, exposed types>>

module Private: sig
    <<representation exposed in the private interface>>
end

<<types and functions exported at top level>>
@
%%A value can be converted from public to private view and vice versa.
%%Module [[Dn]] provides conversion from public to private view, [[Up]]
%%from private to public.
<<rtl.mli>>=
module Dn: sig 
    <<DN>>
end

module Up: sig 
    <<UP>>
end
@
%%% ------------------------------------------------------------------ 
%%\subsubsection{Common Types}
%%% ------------------------------------------------------------------ 
%%
%%All common types are types aliases that are mainly used to make the
%%signatures more readable.  A [[space]] describes some kind of memory,
%%like a set of registers or main memory.  The number of [[spaces]] is a
%%property of a target architecture and thus can not be fixed here with
%%a sum type.  The [[char]] type provides a big enough cardinality and
%%is nice to print and remember.  A [[width]] is a number of bits which
%%corresponds to the {\PAL} [[bits]]$k$ types. 
<<definitions of exported, exposed types>>=
type aggregation = Register.aggregation = 
    | BigEndian
    | LittleEndian
    | Identity

type space = char * aggregation * Cell.t   (* name, byte order, cell size *)
type width = int
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Public View}
%%% ------------------------------------------------------------------ 
%%
%%The public view provides constructor functions for {\rtl}s.  Using them
%%should be the \emph{only} way to create {\rtl}s when translating from
%%the abstract syntax tree.
%%
%%A constant expression can be a boolean value, a number of bits, or a
%%link-time value, which has a name.
%%To support position-independent code, the compiler must distinguish
%%three kinds of link-time value: a locally defined code label, a
%%locally defined data label, and an imported symbol.
%%A [[fetch]] creates an expression
%%that represents the value stored in a [[loc]]. Operators [[op]] can be
%%applied to values and return a value.
<<types and functions exported at top level>>=

(* pad: was originally abstrac types but it forbids to use
 * the debugger to inspect values.
 *
 * 
 * type exp          (* denotes a compile-time or run-time value *)
 * type loc          (* mutable container of a bit vector *)
 * type rtl          (* effect of a computation *)
 * type opr          (* a pure function on values *)
 * type assertion    (* a claim about the run-time value of an address *)
 *)

type exp       = Private.exp     
type loc       = Private.loc   
type rtl       = Private.rtl        
type opr       = Private.opr        
type assertion = Private.assertion  

val bool      : bool -> exp                    
val bits      : Bits.bits -> width -> exp      
val codesym   : Symbol.t -> width -> exp    (* locally defined code label (incl proc) *)
val datasym   : Symbol.t -> width -> exp    (* locally defined data label *)
val impsym    : Symbol.t -> width -> exp    (* imported symbol *)
val late      : string -> width -> exp         (* late compile time constant *)
val fetch     : loc -> width -> exp
val app       : opr -> exp list -> exp

val opr       : string -> width list -> opr
@
%%A [[loc]] may be:
%%\begin{itemize}
%%\item
%%      A register \emph{reg}. Registers include hardware registers and
%%      temporaries. The main feature of a register is, that its address
%%      in an integer, rather than an expression.
%%\item
%%      A memory cell \emph{mem}. A memory cell is addressed by an
%%      expression and can be an aggregation of hardware cells.
%%\item
%%       A named {\PAL} variable [[var]].
%%\item
%%      A \emph{slice} from a location at a known width and least-significant
%%      bit.
%%\end{itemize}
%%An [[assertion]] is a claim about alignment or placement of an address~$a$.
%%We can [[shift]] an assertion by an integer~$k$ in order to get a
%%claim about the address $a+k$. 
%%We can also [[shift_multiple]], which shifts an assertion by an
%%unknown multiple of~$k$.
%%Finally, we can ask what alignment is implied by an assertion.
<<definitions of exported, exposed types>>=
type count = Register.count = C of int
@ 
%%
<<types and functions exported at top level>>=
val none     : assertion
val aligned  : int -> assertion
val shift    : int -> assertion -> assertion
val shift_multiple : int -> assertion -> assertion
val alignment: assertion -> int
val mem      : assertion -> space -> count -> exp -> loc
val reg      : Register.t -> loc
val regx     : Register.x -> loc
val var      : string -> index:int -> width -> loc
val global   : string -> index:int -> width -> loc
val slice    : width -> lsb:int -> loc -> loc
@
%%An effect alters one or more [[loc]]s.  A [[store]] puts the value of
%%[[exp]] into a location; a [[kill]] invalidates a location's content.
%%Effects are represented as {\rtl}s.
<<types and functions exported at top level>>=
val store     : loc -> exp -> width -> rtl
val kill      : loc -> rtl
@
%%A register-transfer list {\rtl} may be guarded; to execute a guarded
%%\rtl, if the guard is false, do nothing, otherwise perform the \rtl.
%%A guard must be a boolean expression.  The function [[guard]] takes a
%%boolean expression [[exp]] and an [[rtl]] and produces a guarded \rtl.
%%
%%The function [[par]] composes \rtl s in parallel.
%%A parallel composition simultaneously performs the effects of all
%%RTLs; that is, it evaluates all guards and right-hand sides before
%%making any assignment.
%%It is an \emph{unchecked run-time error} to compose in parallel two or
%%more RTLs that assign to the same location; such a parallel
%%composition is not meaningful.
<<types and functions exported at top level>>=
val guard     : exp -> rtl -> rtl
val par       : rtl list -> rtl
@
%%For uniformity, the [[null]] {\rtl} is sometimes useful. 
%%It is equivalent to [[par []]], which does nothing.
<<types and functions exported at top level>>=
val null      : rtl
@
%%We provide special versions of [[fetch]] and [[store]] that convert a
%%slice to something without a slice.
%%They use [[lobits]], [[bitExtract]], or [[bitInsert]].
%%It's not clear if they're useful.
<<types and functions exported at top level>>=
val fetch_cvt : loc -> width -> exp
val store_cvt : loc -> exp -> width -> rtl
@ 
%%We also, because we have it here already, export a function to compute
%%the width of a location.
<<types and functions exported at top level>>=
val locwidth : loc -> width
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Conversion between Private and Public Views}
%%% ------------------------------------------------------------------ 
%%
%%The purpose of the private interface is to exploit the implementation
%%details by pattern matching, for example. Values created by the public
%%interface per se are not compatible with the private types. Conversion
%%functions provide access to these values. Each function is named after
%%the type it converts.
%%
%%It is not possible to make the conversion functions part of
%%[[Private]] without putting the public interface at the same time into
%%a sub-module like [[Public]]:  there is no way to refer to a type
%%outside of [[Private]] from inside [[Private]] that is also declared
%%inside [[Private]]. 
<<DN>>=
val exp:        exp         -> Private.exp
val loc:        loc         -> Private.loc       
val rtl:        rtl         -> Private.rtl
val opr:        opr         -> Private.opr
val assertion:  assertion   -> Private.assertion
@ 
<<UP>>=
val exp:        Private.exp       -> exp
val loc:        Private.loc       -> loc
val rtl:        Private.rtl       -> rtl
val opr:        Private.opr       -> opr
val assertion:  Private.assertion -> assertion
val effect :    Private.effect    -> rtl
val const  :    Private.const     -> exp
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{The Private View}
%%% ------------------------------------------------------------------ 
%%
%%The private view defines {\rtl}s in terms of data structures. Values
%%defined using the public functions can be converted to their private
%%representation to facilitate pattern matching over them.
%%
%%We want to represent assertions for specific properties but have not
%%yet found a representation. Todo: replace all $-1$ values in the code
%%with [[Rtl.none]]. 
<<representation exposed in the private interface>>=
type aligned   = int     (* alignment guaranteed *)
type assertion = aligned (* may one day include alias info *)
@
%%An operator for values at run-time is represented by its name and a
%%list of [[width]]s.  Each [[width]] corresponds to a $\forall$-bound
%%variable in the type scheme of the operator's type.  From the type
%%scheme and the [[width list]] a monomorphic type of the operator can
%%be deduced.
<<representation exposed in the private interface>>=
type opr         = string * width list
@
%%Expressions provide values to be stored in [[loc]]s as well as
%%addresses local to a [[space]].  An expression can access constant
%%values and values fetched from memory.  A fetch from memory makes the
%%[[width]] number of fetched bits explicit.  A label denotes a {\PAL}
%%data- or goto-label and its type. 
%%
%%The width of a [[Bits]] value is stored inside the value of type
%%[[Bits.bits]].
%%We hope this offers the advantage that mostly the width is static (see
%%the careful implementation of [[RTL.bits]]) and yet it can be easily
%%grabbed by an automatically generated recognizer.
<<representation exposed in the private interface>>=
type const      = Bool      of bool
                | Bits      of Bits.bits            (* literal constant *)
                | Link      of Symbol.t * symkind * width  (* link-time constant *)
                | Diff      of const  * const   (* difference of two constants *)
                | Late      of string * width   (* late compile time constant *)
and symkind = Code | Data | Imported (* three kinds of symbol, needed for PIC *)

type exp        = Const     of const               
                | Fetch     of loc * width 
                | App       of opr * exp  list
@
%%A location describes a memory location or register on the target
%%architecture or a {\PAL} register. The code generation will remove all
%%{\PAL} registers and provide memory locations for them. A memory
%%cell [[Mem]] lives in an address [[space]] at the address denoted by
%%[[exp]]. In order to fetch [[width]] bits at once several memory
%%units from the chosen [[space]] must be aggregated. For example, a 32
%%bit fetch must aggregate 4 8-bit values when the memory space is made
%%by 8-bit bytes. The aggregation is described by a value of the type
%%[[aggregation]]. 
<<representation exposed in the private interface>>=
and  count     = Register.count = C of int
and  loc       = Mem        of space 
                            *  count
                            *  exp 
                            *  assertion
                | Reg       of Register.t (* space * int * count *)         
          
                | Var       of string    (* name from C-- source   *)
                            *  int       (* index for run-time API *)
                            *  width
                | Global    of string * int * width (* global C-- variable *)
                | Slice     of width     (* number of bits in loc *)
                            *  int       (* index of least-significant bit of slice *)
                            *  loc  (* location from which slice is drawn *)
@
%%Bits are numbered with the least-significant bit as bit~0.
%%
%%An [[effect]] is describes an assignment of a [[width]] bits value obtained
%%from an expression [[exp]], or a [[Kill]]. A killed location contains an
%%undefined value.
<<representation exposed in the private interface>>=
type effect     = Store     of loc * exp  * width
                | Kill      of loc
@
%%A guarded effect is pair of an expression and an effect. The effect takes
%%place, if and only if the expression evaluates to [[true]].      
<<representation exposed in the private interface>>=
type guarded    = exp  * effect
@
%%And finally, a \emph{register-transfer list} is a list of guarded
%%effects. When a {\rtl} is evaluated, first all guarding expressions
%%are evaluated and then all effects of the guards that evaluated to
%%true become effective simultaneously.
<<representation exposed in the private interface>>=
type rtl        = Rtl of guarded list
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The interface of [[Private]] defines only data types; we re-use the
%%definitions to obtain the implementation.  The same is true for common
%%data types. 
%%
<<rtl.ml>>=
<<definitions of exported, exposed types>>

module Private = struct
    <<Private>>
end

<<definitions of types and functions exported at top level>>

module Dn = struct    
    <<Dn>>
end

module Up = struct    
    <<Up>>
end

module Convert = Dn (* deprecated, for backward compatibility *)
module Revert  = Up (* deprecated, for backward compatibility *) 
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{The Private View}
%%% ------------------------------------------------------------------ 
%%
%%The implementation of the private view must repeat the type
%%definitions from the interface. 
%%
<<Private>>=
<<representation exposed in the private interface>>
@
%%        
%%% ------------------------------------------------------------------ 
%%\subsubsection{The Public View}
%%% ------------------------------------------------------------------ 
%%
%%The implementation of the public view basically uses the [[Private]]
%%definitions such that they become compatible.  However, this fact is
%%hidden by the interface.
%%
<<definitions of types and functions exported at top level>>=
open Private    (* never do that *)
type exp       = Private.exp     
type loc       = Private.loc   
type rtl       = Private.rtl        
type opr       = Private.opr        
type assertion = Private.assertion  
@
%%If we switch to [[Alignment.t]], [[shift]] and [[shift_multiple]] will
%%no longer be the same.
<<definitions of types and functions exported at top level>>=
let aligned k = k
let alignment k = k
let shift k' k = 
  let rec gcd (m:int) (n:int) =
    let rec g m n = if n = 0 then m else g n (m mod n) in
    if  n < 0 then gcd m (- n)
    else if m < n then gcd n m
    else g m n in
  gcd k k'
let shift_multiple = shift  (* OK for this rep, which is lossy *)
let none = aligned 1
@
%%
%%Below are simple, nonetheless frequently used functions values on
%%{\rtl}s.
%%
<<definitions of types and functions exported at top level>>=
let par rtls   = Rtl (List.concat (List.map (fun (Rtl x) -> x) rtls))
let slice width ~lsb loc = Slice (width, lsb, loc) 
@
%%
%%The [[guard]] function combines every guard in the {\rtl} with the
%%given expression using Boolean conjunction.  We use a fairly
%%unsophisticated notion of conjunction; it doesn't even reassociate.
%%%
<<definitions of types and functions exported at top level>>=
let conjunction = ("conjoin", [])   (* logical and *)
let conjoin g g' = match g with
| Const(Bool true)  -> g'
| Const(Bool false) -> g
| _ -> match g' with      
       | Const(Bool true)  -> g
       | Const(Bool false) -> g'
       | _ -> App(conjunction, [g; g'])
@
<<definitions of types and functions exported at top level>>=
let guard expr (Rtl geffects) =
    let conjunct (guard,effect) = (conjoin expr guard, effect) in
    Rtl (List.map conjunct geffects)  
@
%%
%%
<<definitions of types and functions exported at top level>>=
let true'  = Const (Bool true)
let false' = Const (Bool false)
let bool p = if p then true' else false'
@ 
%%
%%Note that the width used in a bit vector is the [[width]] argument,
%%\emph{not} the width buried inside the bit vector itself.  We do things
%%this way to support type-directed partial evaluation; the [[width]]
%%argument is normally static. 
%%
%%\begin{quote}\it
%%    Literals are currently stored in 64 bit wide bit vectors
%%    ([[Bits.bits]]). There types, however, as noted in [[Rtl.rtl]]s
%%    might be smaller.  The reason is, that the types of literals are
%%    unknown during scanning and parsing. So every literal is first
%%    stored in maximal bit vector and gets its type assigned later. --CL
%%\end{quote}
%%
%%
<<definitions of types and functions exported at top level>>=
let bits b width            = ( assert (Bits.width b = width)
                              ; Const (Bits b)
                              )
let codesym name width      = Const (Link(name,Code,width))
let datasym name width      = Const (Link(name,Data,width))
let impsym  name width      = Const (Link(name,Imported,width))
let diff const1 const2      = Const (Diff(const1,const2))
let late name width         = Const (Late(name,width))
let fetch loc w             = Fetch(loc, w)
let app op exprs            = App(op,exprs)
let opr name widths         = (name,widths)

(* location *)
let mem assertion sp count expr = Mem(sp,count,expr,assertion)
let var    name ~index width    = Var (name,index,width)
let global name ~index width    = Global (name,index,width)
let reg r                       = Reg r
let regx = function
  | Register.Reg r -> Reg r
  | Register.Slice (w, lsb, r) -> Slice(w, lsb, Reg r)

(* effect *)
let rtl effect              = Rtl [(bool true, effect)]
let store loc expr width    = rtl (Store(loc, expr, width))
let kill  loc               = rtl (Kill(loc))
let null                    = Rtl []
@ 
%%
%%Fetch and store could convert slices, but I'm not sure if this code is
%%really useful.
<<definitions of types and functions exported at top level>>=
let locwidth = function
  | Mem((_,_,ms),c,_,_) -> Cell.to_width ms c
  | Reg((_,_,ms),_,c)   -> Cell.to_width ms c
  | Var(_,_,w)            -> w
  | Global(_,_,w)         -> w
  | Slice(w, _, _)        -> w 

let rec fetch_cvt loc n = 
  match loc with
  | Slice(n', lsb, loc) ->
      assert (n'=n);
      let w = locwidth loc in
      if lsb = 0 then 
        App(("lobits", [w; n]), [fetch loc n])
      else
        App(("bitExtract", [w; n]), [Const (Bits (Bits.U.of_int lsb w)); fetch loc n])
  | _ -> Fetch(loc,n)
@ 
<<definitions of types and functions exported at top level>>=
let store_cvt loc expr n = 
  match loc with
  | Slice(n', lsb, loc) ->
      assert (n'=n);
      let w = locwidth loc in
      let wide = Fetch(loc, w) in
      let lsb = Const (Bits (Bits.U.of_int lsb w)) in
      let wide' = App(("bitInsert", [w; n]), [lsb; wide; expr]) in
      rtl (Store(loc, wide', w))
  | _ -> rtl (Store(loc,expr,n))
@
%%
%%All conversion functions are the identity [[id]] because public and
%%private values have the same representation.
%%% surprised you don't prefer  `let expr e = e' etc...  ---NR
%%
<<Dn>>=
let id          = fun x -> x
let exp         = id
let loc         = id
let rtl         = id
let opr         = id
let assertion   = id
@ 
%%
<<Up>>=
let effect      = rtl (* from above *)
let id          = fun x -> x
let exp         = id
let loc         = id
let rtl         = id
let opr         = id
let assertion   = id
let const c     = Const c
@
\section{[[front_rtl/rtldebug.nw]]}
<<front_rtl/rtldebug.ml>>=
<<rtldebug.ml>>
@

<<front_rtl/rtldebug.mli>>=
<<rtldebug.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et: Vi gets the first post!
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{Functions for Debugging RTLs}
%%% ------------------------------------------------------------------ 
%%
<<rtldebug.mli>>=
exception TypeCheck of Rtl.rtl
val typecheck:     Rtl.rtl -> unit      (* raises TypeCheck *)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<rtldebug.ml>>=
open Nopoly

module RP = Rtl.Private
exception TypeCheck of Rtl.rtl
let fail rtl = raise (TypeCheck rtl)

let typecheck (r:Rtl.rtl) =
    let width n ty = match ty with
        | Types.Bits k when n = k  -> ty
        | _                        -> fail r in
    let bits = function
        | Types.Bits n             -> n
        | _                        -> fail r in
    let bool = function
        | Types.Bool               -> ()
        | _                        -> fail r in 
        
    let rec exp = function
        | RP.Fetch (l, w)          -> width w (loc l)
        | RP.Const c               -> const c  
        | RP.App(opr, args)        -> 
            let argtys       = List.map exp args in
            let opty, result = Rtlop.mono (Rtl.Up.opr opr) in
                if opty =*= argtys then  (* comparing lists of types! *)
                    result
                else
                    fail r
    
    and const = function
        | RP.Bool _                -> Types.Bool 
        | RP.Bits b                -> Types.Bits (Bits.width b)
        | RP.Link (_,_,w)          -> Types.Bits w
 | RP.Diff (c,c')	   -> let t = const c and t' = const c' in
                                      if t =*= t' then t else fail r
        | RP.Late (_,w)            -> Types.Bits w
    
    and loc = function
        | RP.Mem ((_, _, ms),c,e,ass) ->
     let _ = bits (exp e) in Types.Bits (Cell.to_width ms c)
        | RP.Reg ((_, _, ms),i,c)     -> Types.Bits (Cell.to_width ms c)
        | RP.Slice (w,i,l)         -> let _ = bits (loc l) in Types.Bits w
        | RP.Var    (_,_,w)        -> Types.Bits w
        | RP.Global (_,_,w)        -> Types.Bits w
        
    and effect = function
        | RP.Store (l,e,w)         -> let _  = width w (loc l) in
                                      let _  = width w (exp e) in
                                      ()  
        | RP.Kill  (l)             -> let _ = bits (loc l) in ()  
    
    and guarded (e,eff)            =  ( bool (exp e)
                                      ; effect eff
                                      )
    and rtl (RP.Rtl rtl)           = List.iter guarded rtl in 
    rtl (Rtl.Dn.rtl r)
@
\section{[[front_rtl/rtlop.nw]]}
<<front_rtl/rtlop.ml>>=
<<rtlop.ml>>
@

<<front_rtl/rtlop.mli>>=
<<rtlop.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% ------------------------------------------------------------------ 
\section{Support for RTL operators}
%%% ------------------------------------------------------------------ 
%%
%%This module provides miscellaneous support for RTL operators.
%%The primary goals are
%%\begin{itemize}
%%\item
%%To keep a central repository of type information about operators,
%%including machine-dependent operators that are used only in back ends.
%%\item
%%To help the front end translate each {\PAL} operator into an RTL
%%operator.
%%Typically this means filling in the type parameters, which is done
%%based on the knowledge of the operator's type scheme and of the types
%%of its arguments.
%%\end{itemize}
%%
%%\paragraph{Registering operators}
%%
%%The official {\PAL} operators are built into this module, but every
%%back end may add new operators.
%%New operators should be added at program startup time, regardless of
%%whether the back end is actually run.
%%To name machine-dependent operators, each back end should pick a
%%unique prefix, e.g., [[x86_]].
%%It is a checked run-time error to register an operator twice.
<<rtlop.mli>>=
val add_operator : name:string -> result_is_float:bool -> Types.tyscheme -> unit
@
%%\paragraph{Extracting type information}
%%
%%Here are some miscellaneous functions
%%that have to do with operators' types.
%%Given an instantiated operator, one can get its type with [[mono]].
%%One can query whether an operator's result is a floating-point value,
%%which is unfortunately necessary to support an evil hack in the
%%widener.
%%(It would be very good if Kevin could get floating-point widening on a
%%principled basis so that this could go \emph{away}.)
%%The [[fold]] function enables one to visit all the operators, and
%%[[print_shapes]] was useful once as a guide to hand-writing a generic
%%code expander (see module [[Opshape]] for more information on shapes).
<<rtlop.mli>>=
val mono : Rtl.opr -> Types.monotype      (* Not_found *)
val has_floating_result : Rtl.opr -> bool
val fold : (string -> Types.tyscheme -> 'a -> 'a) -> 'a -> 'a
val print_shapes : unit -> unit
@ 
%%We also provide, outside of the [[Types]] submodule, the ability to
%%enumerate the names of all the operators.
<<rtlop.mli>>=
val opnames : unit -> string list  (* names of all source-language operators *)
@ 
%%\paragraph{Translation from surface {\PAL} into RTL operators}
%%
%%Three different translations are provided: for the prefix named form
%%[[%name(...)]], for the infix binary form, and for the symbolic unary
%%form.
%%Different translations are needed because the [[-]] symbol translates
%%into [[%sub]] when binary but [[%neg]] when unary.
%%Each translation returns the type of the operator's result and
%%an {\rtl} operator that implements the {\PAL} operator.
<<rtlop.mli>>=
module Translate : sig
  val prefix : string -> Types.ty list -> Types.ty * Rtl.opr (*ErrorExn*)
  val binary : string -> Types.ty list -> Types.ty * Rtl.opr (*ErrorExn*)
  val unary  : string -> Types.ty list -> Types.ty * Rtl.opr (*ErrorExn*)
end
@ 
%%\paragraph {Program generation}
%%
%%Calling [[Emit.creators]] emits an implementation of the functions in
%%[[Rewrite.Ops]].   Handy.
<<rtlop.mli>>=
module Emit : sig
  val creators : unit -> unit
end
@ 
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<rtlop.ml>>=
module T = Types        (* save external Types module here *)
let (-->) = T.proc 
let impossf fmt = Printf.kprintf Impossible.impossible fmt
@
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{RTL-Op Types}
%%% ------------------------------------------------------------------ 
%%
%%The [[ops]] table associates {\rtl} operators with their types. A
%%function type is constructed by [[T.proc]] that takes the list of
%%arguments and the result type. Most functions are polymorphic; a
%%[[T.bitsv]]~$n$ introduces a (bound) polymorphic [[bits]] type variable
%%$n$. For example, the type for [[add]] demands that all arguments and
%%the result have the same width. If the type variable of the result is
%%not identical to one of the arguments, the operator is polymorphic in
%%its return size. 
<<rtlop.ml>>=
let predefined = 
  (* the four values below characterize the proper interpretation of a
     result, but the only information we actually use is a Boolean
     telling us if the result is a floating-point value *)
  let float = true in
  let int   = false in
  let code2 = false in
  let bool  = false in
  [  "NaN"          , int,   [T.var 1] --> T.var 2
  ;  "add"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "addc"         , int,   [T.var 1; T.var 1; T.fixbits 1] --> T.var 1
  ;  "add_overflows", bool,  [T.var 1; T.var 1] --> T.bool
  ;  "and"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "bit"          , int,   [T.bool] --> T.fixbits 1
  ;  "bool"         , bool,  [T.fixbits 1] --> T.bool
  ;  "borrow"       , int,   [T.var 1; T.var 1; T.fixbits 1] --> T.fixbits 1
  ;  "carry"        , int,   [T.var 1; T.var 1; T.fixbits 1] --> T.fixbits 1
  ;  "com"          , int,   [T.var 1] --> T.var 1
  ;  "conjoin"      , bool,  [T.bool; T.bool] --> T.bool
  ;  "disjoin"      , bool,  [T.bool; T.bool] --> T.bool
  ;  "div"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "div_overflows", bool,  [T.var 1; T.var 1] --> T.bool
  ;  "divu"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "eq"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "f2f"          , float, [T.var 1; T.fixbits 2] --> T.var 2
  ;  "f2f_implicit_round", float, [T.var 1] --> T.var 2
  ;  "f2i"          , int,   [T.var 1; T.fixbits 2] --> T.var 2
  ;  "fabs"         , float, [T.var 1] --> T.var 1
  ;  "fadd"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "false"        , bool,  [] --> T.bool
  ;  "fcmp"         , code2, [T.var 1; T.var 1] --> T.fixbits 2
  ;  "fdiv"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "feq"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fge"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fgt"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fle"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "float_eq"     , code2, [] --> T.fixbits 2
  ;  "float_gt"     , code2, [] --> T.fixbits 2
  ;  "float_lt"     , code2, [] --> T.fixbits 2
  ;  "flt"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fmul"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "fmulx"        , float, [T.var 1; T.var 1] --> T.double 1
  ;  "fne"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fneg"         , float, [T.var 1] --> T.var 1
  ;  "fordered"     , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "fsqrt"        , float, [T.var 1; T.fixbits 2] --> T.var 1
  ;  "fsub"         , float, [T.var 1; T.var 1; T.fixbits 2] --> T.var 1
  ;  "funordered"   , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "ge"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "geu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "gt"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "gtu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "i2f"          , float, [T.var 1; T.fixbits 2] --> T.var 2
  ;  "le"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "leu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "lobits"       , int,   [T.var 1] --> T.var 2
  ;  "lt"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "ltu"          , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "minf"         , float, [] --> T.var 1
  ;  "mod"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "modu"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "mul"          , int,   [T.var 1; T.var 1] --> T.var 1 
  ;  "mulux"        , int,   [T.var 1; T.var 1] --> T.double 1 
  ;  "mulx"         , int,   [T.var 1; T.var 1] --> T.double 1 
  ;  "mul_overflows", bool,  [T.var 1; T.var 1] --> T.bool
  ;  "mulu_overflows", bool, [T.var 1; T.var 1] --> T.bool
  ;  "mzero"        , float, [] --> T.var 1
  ;  "ne"           , bool,  [T.var 1; T.var 1] --> T.bool
  ;  "neg"          , int,   [T.var 1] --> T.var 1
  ;  "not"          , bool,  [T.bool] --> T.bool
  ;  "or"           , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "pinf"         , float, [] --> T.var 1
  ;  "popcnt"       , int,   [T.var 1] --> T.var 1
  ;  "pzero"        , float, [] --> T.var 1
  ;  "quot"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "quot_overflows", bool,  [T.var 1; T.var 1] --> T.bool
  ;  "rem"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "rotl"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "rotr"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "round_down"   , code2, [] --> T.fixbits 2
  ;  "round_nearest", code2, [] --> T.fixbits 2
  ;  "round_up"     , code2, [] --> T.fixbits 2
  ;  "round_zero"   , code2, [] --> T.fixbits 2
  ;  "shl"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "shra"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "shrl"         , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "sub"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "subb"         , int,   [T.var 1; T.var 1; T.fixbits 1] --> T.var 1
  ;  "sub_overflows", bool,  [T.var 1; T.var 1] --> T.bool
  ;  "sx"           , int,   [T.var 1] --> T.var 2
  ;  "true"         , bool,  [] --> T.bool
  ;  "unordered"    , code2, [] --> T.fixbits 2
  ;  "xor"          , int,   [T.var 1; T.var 1] --> T.var 1
  ;  "zx"           , int,   [T.var 1] --> T.var 2
     (* not C-- operators, but might show up in RTLs *)    
  ;  "bitExtract"   , int,   [T.var 1; T.var 1] --> T.var 2
  ;  "bitInsert"    , int,   [T.var 1; T.var 1; T.var 2] --> T.var 1
  ;  "bitTransfer"  , int,   [T.var 1; T.var 1; T.var 1; T.var 1; T.var 1] --> T.var 1 
                    
  ] 
@ 
%%
<<rtlop.ml>>=
let optypes  = ref (Strutil.assoc2map (List.map (fun (o, _, t) -> (o, t)) predefined))
let opfloats = ref (Strutil.assoc2map (List.map (fun (o, f, _) -> (o, f)) predefined))
@ 
<<rtlop.ml>>=
let add_operator ~name:o ~result_is_float:f t =
  if Strutil.Map.mem o (!optypes) then
    impossf "registered a duplicate RTL operator %%%s" o;
  optypes  := Strutil.Map.add o t (!optypes);
  opfloats := Strutil.Map.add o f (!opfloats)
@ 
%%We once printed operators' signatures.
<<rtlop.ml>>=
let print_shapes () = 
  Strutil.Map.iter (fun o t ->
    Printf.printf "%16s : %s\n" o (Types.scheme_string t)) (!optypes)
@ 
%%Some operators are not visible.
%%An operator is invisible if it is for internal use only or if it has
%%been expunged from the {\PAL} specification.
<<rtlop.ml>>=
let visible = function
  | "bitExtract" | "bitInsert" | "bitTransfer" | "f2f_implicit_round" -> false
  | "fcmp" | "float_lt" | "float_eq" | "float_gt" | "unordered" -> false (*expunged*)
  | _ -> true 

let fold f z =
  Strutil.Map.fold (fun o t z -> if visible o then f o t z else z) (!optypes) z

let opnames () = fold (fun o _ os -> o :: os) []
@ 
<<rtlop.ml>>=
let findopname name t =
  try Strutil.Map.find name t
  with Not_found ->
    ( Printf.eprintf "unknown RTL operator '%%%s'" name
    ; raise Not_found
    )
let findop op = findopname (fst (Rtl.Dn.opr op))
let mono op = let _, ws = Rtl.Dn.opr op in Types.instantiate (findop op (!optypes)) ws
let has_floating_result op = findop op (!opfloats)
@
%%% ------------------------------------------------------------------ 
\subsection{Translation from {\PAL} operators to {\rtl} operators}
%%% ------------------------------------------------------------------ 
%%
%%{\PAL} primitive operators and {\rtl} primitive operators are closely
%%connected. To typecheck the application of a {\PAL} operator, we use the
%%type of the corresponding {\RTL} operator.  For example, the {\PAL}
%%operator [[add]] is translated to the {\rtl} operator [[add]], that has
%%the exact same signature. 
%%
%%The exceptions are {\PAL} operators like [[zx32]] that encodes the size
%%of their return value in the name. {\rtl} operators are more polymorphic
%%than {\PAL} operators and thus there are no separate operators [[zx1]],
%%\dots, [[zx32]], \dots, but a single polymorphic operator [[zx]]:
%%%
%%$$[[zx]]: \forall~\alpha,\beta.[[bits]]\alpha \to [[bits]]\beta$$
%%%
%%An application [[zx32 (1::bits10)]] is translated into the {\rtl}
%%operator [[(zx,[10,32])]], where [[10]] is bound by $\alpha$, and [[32]]
%%by $\beta$ in the above type scheme. Hence, the size of the result,
%%which is inferred from the name, is always the \emph{last}
%%value in the \emph{width list} of an {\rtl} operator.
%%
%%If an operator name has a numerical component, it denotes the size of
%%the result. Such a size always becomes the last element in the width
%%list of an operator. 
<<rtlop.ml>>=
module Translate = struct
  let prefix opname argtys =
    try 
      let op, retsize = T.split opname in
      let opty        = findopname op (!optypes) in
      let argwidths   = T.widthlist opname opty argtys in
      ( match retsize with
      | None   -> T.appl opname opty argtys, Rtl.opr op argwidths
      | Some n -> T.bits n,                  Rtl.opr op (argwidths@[n])
      )            
    with
    | Not_found  -> Error.errorf "unknown operator %%%s" opname
@ 
%%Infix and prefix symbols are stored in tables.
%%Nothing should go wrong  in lookup because the only symbols that make
%%it this far should have been blessed by the parser.
<<rtlop.ml>>=
  let binops = Strutil.assoc2map 
      [  "+"      , "add"
      ;  "-"      , "sub"
      ;  "*"      , "mul"
      ;  "/"      , "divu"
      ;  "%"      , "modu"
      ;  "<<"     , "shl"
      ;  ">>"     , "shrl"
      ;  "=="     , "eq"
      ;  "<="     , "leu"
      ;  ">="     , "geu"
      ;  ">"      , "gtu"
      ;  "<"      , "ltu"
      ;  "!="     , "ne"
      ;  "&"      , "and"
      ;  "^"      , "xor"
      ;  "|"      , "or"
      ;  "!="     , "ne"
      ] 

  let unops = Strutil.assoc2map 
      [  "-"      , "neg"
      ;  "~"      , "com"
      ]

  let binary op =
    try prefix (Strutil.Map.find op binops) 
    with Not_found -> Impossible.impossible ("unknown binary infix operator "^op)

  let unary op =
    try prefix (Strutil.Map.find op unops) 
    with Not_found -> Impossible.impossible ("unknown unary symbolic operator "^op)
end
@        
<<rtlop.ml>>=
let ws = ["w"; "w'"; "w3"; "w4"; "w5"]
let args = ["x"; "y"; "z"; "u"; "v"]

let width n = try List.nth ws   n with _ -> Impossible.impossible "too many widths"
let arg   n = try List.nth args n with _ -> Impossible.impossible "too many args"


module Emit = struct
  let pf = Printf.printf
  let mangle = function
    | "and" -> "_and"
    | "NaN" -> "_Nan"
    | "mod" -> "_mod"
    | "or" -> "_or"
    | n -> n
          
  let emitop name (parms, _ as tyscheme) =
    let nargs   = List.length parms in
    let nwidths = T.largest_key tyscheme in
    begin
      pf "let %s" (mangle name);
      for i = 0 to nwidths - 1 do pf " %s"  (width i) done;
      for i = 0 to nargs   - 1 do pf " %s"  (arg   i) done;
      pf " = Rtl.app (Rtl.opr \"%s\" [" name;
      for i = 0 to nwidths - 1 do pf "%s;"  (width i) done;
      pf "]) [";
      for i = 0 to nargs   - 1 do pf "%s; " (arg   i) done;
      pf "]\n";
    end
  let creators () =
    pf "(* This code generated automatically by Rtlop.Emit.creators *)\n";
    Strutil.Map.iter emitop (!optypes)
end    
@
\section{[[front_rtl/rtlutil.nw]]}
<<front_rtl/rtlutil.ml>>=
<<rtlutil.ml>>
@

<<front_rtl/rtlutil.mli>>=
<<rtlutil.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% vim: ts=8 sw=4 et:
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{RTL Utilities}
%%% ------------------------------------------------------------------ 
%%
%%This module provides functions to observe and transform {\rtl}s. 
%%
\subsection{Important types}
%%To avoid circularity, this type is defined here, but it really goes in
%%module [[Automaton]].
<<rtlutil.mli>>=
type aloc = 
    { fetch  : Rtl.width -> Rtl.exp
    ; store  : Rtl.exp -> Rtl.width -> Rtl.rtl
    }
@ 
%%
\subsection{Common operations on RTLs}
%%These functions reassociate constants.
%%It can be mildly useful to partially apply them to a width.
%%N.B. [[addk x 0 === x]] always.
<<rtlutil.mli>>=
val add  : Rtl.width -> Rtl.exp -> Rtl.exp -> Rtl.exp
val addk : Rtl.width -> Rtl.exp -> int     -> Rtl.exp
@ 
%%These functions use the width of the location.
%%Although we gain some convenience,
%%we lose some redundancy; use these functions only where the width is
%%not readily available.
<<rtlutil.mli>>=
val fetch : Rtl.loc -> Rtl.exp
val store : Rtl.loc -> Rtl.exp -> Rtl.rtl
@ 
%%For convenience, conversion of a relocatable address back to an expression. 
<<rtlutil.mli>>=
val reloc : Reloc.t -> Rtl.width -> Rtl.exp
@ 
%%It's useful to check and see if a location is a hardware register.
%%It is a checked run-time error to call [[to_hardware l]] unless
%%[[is_hardware l]].
<<rtlutil.mli>>=
val is_hardware : Rtl.Private.loc -> bool
val to_hardware : Rtl.Private.loc -> Register.x
@ 
%%% ------------------------------------------------------------------ 
\subsection{Equality and comparison}
%%% ------------------------------------------------------------------ 
%%Calling these functions avoids polymorphic
%%equality and comparison, which could fault at run time by comparing a function.
<<rtlutil.mli>>=
module Eq : sig
  val space : Rtl.space         -> Rtl.space         -> bool
  val const : Rtl.Private.const -> Rtl.Private.const -> bool
  val loc   : Rtl.Private.loc   -> Rtl.Private.loc   -> bool
  val exp   : Rtl.Private.exp   -> Rtl.Private.exp   -> bool
  val rtl   : Rtl.Private.rtl   -> Rtl.Private.rtl   -> bool
end
module Compare : sig
  val space : Rtl.space         -> Rtl.space         -> int
  val const : Rtl.Private.const -> Rtl.Private.const -> int
  val loc   : Rtl.Private.loc   -> Rtl.Private.loc   -> int
  val exp   : Rtl.Private.exp   -> Rtl.Private.exp   -> int
  val rtl   : Rtl.Private.rtl   -> Rtl.Private.rtl   -> int
end
@ 
%%% ------------------------------------------------------------------ 
\subsection{Width}
%%% ------------------------------------------------------------------ 
%%
%%Locations and non-boolean expressions have a \emph{width} that can be
%%observed.  It is a checked run-time error to pass a boolean expression
%%to [[exp]].
<<rtlutil.mli>>=
module Width: sig
    val loc:    Rtl.loc -> int
    val exp:    Rtl.exp -> int
    val exp':   Rtl.Private.exp -> int
end 
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Evaluation Time Classification}
%%% ------------------------------------------------------------------ 
%%
%%The form of an {\rtl} expression tells whether it is a compile-time
%%constant, link-time constant, or run-time expression.
<<rtlutil.mli>>=
module Time: sig
    val compile:    Rtl.exp -> bool (* true, iff compile-time const *)
    val link:       Rtl.exp -> bool (* true, off compile-time or link-time *)
end
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Read-Write Sets}
%%% ------------------------------------------------------------------ 
%%
%%A \emph{register} is an {\rtl} location that is addressed by a known
%%(integer) value (c.f.~module \module{register}). Registers are of
%%special interest for liveness analysis where it is important to know,
%%the registers that read or written by an {\rtl}.
%%Because slices of registers may also be used in an {\rtl}, we maintain
%%locations of type [[Register.x]].
%%We provide two methods
%%to observe an {\rtl}'s locations: [[fold]] scans an [[Rtl.rtl]] value
%%and reports any register or slice in a read or write position to a function. This
%%does not require heap allocation and is therefore efficient.  The
%%slightly less efficient function [[sets]] reports registers and slices in read and
%%write positions as sets.
%%\begin{quote}\it
%%    The [[fold]] function is related to registers and slices, and therefore its name
%%    should imply this. We need another fold over memory locations that
%%    reports aliasing informations.
%%\end{quote}
<<rtlutil.mli>>=
module ReadWrite: sig
    type 'a observert = Register.t -> 'a -> 'a
    type 'a observerx = Register.x -> 'a -> 'a
    val fold: read: 'a observerx -> write: 'a observerx -> Rtl.rtl -> 'a -> 'a
    val fold_promote: read: 'a observert -> write: 'a observert -> Rtl.rtl -> 'a -> 'a
    val sets: Rtl.rtl -> (Register.SetX.t * Register.SetX.t)
    val sets_promote: Rtl.rtl -> (Register.Set.t * Register.Set.t)
end
@ 
<<rtlutil.mli>>=
module ReadWriteKill: sig
    type 'a observert = Register.t -> 'a -> 'a
    type 'a observerx = Register.x -> 'a -> 'a
    val fold: read: 'a observerx -> write: 'a observerx -> kill: 'a observerx ->
                    Rtl.rtl -> 'a -> 'a
    val fold_promote: read: 'a observert -> write: 'a observert -> kill: 'a observert ->
                      Rtl.rtl -> 'a -> 'a
    val sets: Rtl.rtl -> Register.SetX.t * Register.SetX.t * Register.SetX.t
    val sets_promote: Rtl.rtl -> Register.Set.t * Register.Set.t * Register.Set.t
end
@ 
%%Sometimes we need to know about all locations, not just registers.
<<rtlutil.mli>>=
module FullReadWriteKill: sig
    type 'a observer = Rtl.Private.loc -> 'a -> 'a
    val fold: read: 'a observer -> write: 'a observer -> kill: 'a observer ->
                    Rtl.rtl -> 'a -> 'a
end
@ 
%%% ------------------------------------------------------------------ 
\subsection{Search}
%%% ------------------------------------------------------------------ 
%%
%%We can search for operators, locations, or constants satisfying a
%%given predicate.
<<rtlutil.mli>>=
module Exists : sig
  module Opr : sig
    val rtl : (Rtl.opr -> bool) -> Rtl.rtl -> bool
  end
  module Loc : sig
    val exp : (Rtl.Private.loc -> bool) -> Rtl.Private.exp -> bool
    val rtl : (Rtl.Private.loc -> bool) -> Rtl.Private.rtl -> bool
  end
  module Const : sig
    val rtl : (Rtl.Private.const -> bool) -> Rtl.rtl -> bool
  end
end 
@ 
%%If a location satisfying a predicate exists, we can find it.
<<rtlutil.mli>>=
module Find : sig
  module Loc : sig
    val exp : (Rtl.Private.loc -> bool) -> Rtl.Private.exp -> Rtl.Private.loc option
  end
end 
@    
%%We fold over locations of type [[Register.x]] or
%%locations that appear under [[Fetch]].
<<rtlutil.mli>>=
module Fold : sig
  module RegX : sig
    val loc : (Register.x -> 'a -> 'a) -> Rtl.loc -> 'a -> 'a
  end
  module LocFetched : sig
    val rtl : (Rtl.Private.loc -> 'a -> 'a) -> Rtl.Private.rtl -> 'a -> 'a
  end
end
@ 
%%% ------------------------------------------------------------------ 
\subsection{Aliasing}
%%% ------------------------------------------------------------------ 
%%
%%If a store to one item could affect the value of another, those two
%%items \emph{may alias}.
%%
%%The implementation correctly accounts for cell sizes and now gives
%%correct answers on registers, but it does not currently account for
%%slices and may therefore claim two slices alias even if they are
%%distinct slices of the same register.
%%We have a special case, [[store_uses']] to check whether a location
%%may alias with the locations used in a store (either the rhs or the
%%addressing expression).
<<rtlutil.mli>>=
module MayAlias : sig
  val regs   : Register.t -> Register.t -> bool   
  val locs   : Rtl.loc -> Rtl.loc -> bool  (* useful to partially apply *)
  val locs'  : Rtl.Private.loc -> Rtl.Private.loc -> bool (* partially apply *)
  val exp    : Rtl.loc -> Rtl.exp -> bool  (* useful to partially apply *)
  val exp'   : Rtl.Private.loc -> Rtl.Private.exp -> bool (* partially apply *)
  val store_uses' :
        Rtl.Private.loc -> (Rtl.Private.loc * Rtl.Private.exp * int) -> bool
end
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Substitution}
%%% ------------------------------------------------------------------ 
%%
%%Register allocation requires to re-write an {\rtl} by substituting
%%registers inside. The translation of a procedure creates expressions
%%that contain [[Rtl.link]] values that later must be substituted for
%%compile-time constants. Substitutions for locations, registers. and
%%expressions are provided by the [[Subst]] sub-module:
<<rtlutil.mli>>=
module Subst: sig
    val loc:        guard:(Rtl.Private.loc -> bool)               
                    -> map:(Rtl.Private.loc -> Rtl.Private.loc) 
                    -> Rtl.rtl -> Rtl.rtl
    
    val aloc:       guard:(Rtl.Private.loc -> bool)               
                    -> map:(Rtl.Private.loc -> aloc) 
                    -> Rtl.rtl -> Rtl.rtl
    
    val exp:        guard:(Rtl.Private.exp -> bool)
                    -> map:(Rtl.Private.exp -> Rtl.Private.exp) 
                    -> Rtl.rtl -> Rtl.rtl
    
    val exp_of_exp: guard:(Rtl.Private.exp -> bool)
                    -> map:(Rtl.Private.exp -> Rtl.Private.exp) 
                    -> Rtl.exp -> Rtl.exp
    val exp_of_loc: guard:(Rtl.Private.exp -> bool)
                    -> map:(Rtl.Private.exp -> Rtl.Private.exp) 
                    -> Rtl.loc -> Rtl.loc
    val loc_of_loc: guard:(Rtl.Private.loc -> bool)
                    -> map:(Rtl.Private.loc -> Rtl.Private.loc) 
                    -> Rtl.loc -> Rtl.loc
    
    val reg:        map:(Register.t -> Register.t) -> Rtl.rtl -> Rtl.rtl
    
    val reg_def:    map:(Register.t -> Register.t) -> Rtl.rtl -> Rtl.rtl
    
    val reg_use:    map:(Register.t -> Register.t) -> Rtl.rtl -> Rtl.rtl

    val reg_to_mem: map:(Register.t -> Rtl.Private.loc) -> Rtl.rtl -> Rtl.rtl

    module Fetch : sig   (* substitute for Fetch(l, w) *)
      val rtl:      guard:(Rtl.Private.loc -> bool) ->
                    fetch:(Rtl.Private.loc -> Rtl.width -> Rtl.Private.exp) ->
                    Rtl.rtl -> Rtl.rtl
      val exp':     guard:(Rtl.Private.loc -> bool) ->
                    fetch:(Rtl.Private.loc -> Rtl.width -> Rtl.Private.exp) ->
                    Rtl.Private.exp -> Rtl.Private.exp
    end
end
@
%%Function [[loc]] substitutes locations in an {\rtl}. We pass each
%%location that passes the [[guard]] predicate to [[map]] to obtain the
%%new location. The location returned by [[map]] is taken literally and
%%not further traversed by [[loc]]. If a location fails to pass the
%%[[guard]] it is recursively traversed to substitute locations within.
%%
%%Function [[exp]] works like [[loc]], except that it substitutes
%%expressions.
%%
%%Function [[reg]] substitutes registers in an {\rtl}. It takes a
%%[[lookup]] function for [[Rtl.spaces]] and a [[map]] function that
%%describes the substitution. 
%%
%%% ------------------------------------------------------------------ 
\subsection{Classification}
%%% ------------------------------------------------------------------ 
%%
%%Register allocation may benefit from knowing whether an {\rtl}
%%represents a move instruction. [[singleAssignment]] returns a destination
%%and source register pair if the input {\rtl} consists of a single,
%%unconditional assignment with any number of unconditional kills. If the
%%{\rtl} has a different form, [[singleAssignment]] returns [[None]].
<<rtlutil.mli>>=
module RTLType: sig
    val singleAssignment:    Rtl.rtl -> (Register.t * Register.t) option
end
@
%%
%%% ------------------------------------------------------------------ 
\subsection{RTL AST Representation}
%%% ------------------------------------------------------------------ 
%%
%%For debugging we like to make the intermediate code visible by
%%translating it back to {\PAL} syntax.  Technically this means, that
%%{\rtl}s are translated to the {\PAL} abstract syntax ({\AST}); for the
%%{\AST} a pretty printer (in module \module{ast}) translates it back to
%%{\small ASCII} codes. This module provides a translation from an {\rtl}
%%to a {\PAL} statement.
<<rtlutil.mli>>=
module ToAST: sig
    type verbosity =    Low | High             (* default is High   *)
    val verbosity:      verbosity -> verbosity (* returns old value *)

    val expr:           Rtl.exp  -> Ast.expr 
    val rtl:            Rtl.rtl  -> Ast.stmt 
end
@
%%
%%% ------------------------------------------------------------------ 
\subsection{RTL String Representation}
%%% ------------------------------------------------------------------ 
%%
%%For debugging, we want to represent {\rtl}s as strings. The string
%%representation is meant to be human-, but not necessarily
%%machine-readable. 
<<rtlutil.mli>>=
module ToUnreadableString: sig
    val regx: Register.x -> string
    val reg:  Register.t -> string
    val rtl:  Rtl.rtl -> string
    val exp:  Rtl.exp -> string
    val loc:  Rtl.loc -> string
    val agg:  Rtl.aggregation -> string
end
module ToString: sig
    val reg: Register.t -> string
    val rtl: Rtl.rtl -> string
    val exp: Rtl.exp -> string
    val loc: Rtl.loc -> string
    val const: Rtl.Private.const -> string
end
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<rtlutil.ml>>=
open Nopoly

module R   = Rtl
module RP  = Rtl.Private
module Up  = Rtl.Up
module Dn  = Rtl.Dn
module Rg  = Register
module RS  = Register.Set
module RSX = Register.SetX

let id     x = x
let falsef x = false

let unimpf fmt = Printf.kprintf Impossible.unimp fmt
let sprintf = Printf.sprintf

type aloc = 
    { fetch  : Rtl.width -> Rtl.exp
    ; store  : Rtl.exp -> Rtl.width -> Rtl.rtl
    }

module Width = struct
    <<Width>>
end

let fetch l   = R.fetch l   (Width.loc l)
let store l e = R.store l e (Width.loc l)
@ 
%%
<<rtlutil.ml>>=
<<define common ReadWriteKill Higher Order Fns>>

module ReadWrite = struct
    <<ReadWrite>>
end

module ReadWriteKill = struct
    <<ReadWriteKill>>
end

module FullReadWriteKill = struct
    <<FullReadWriteKill>>
end

module Subst = struct
    <<Subst>>
end

module ToString = struct
    <<ToString>>
end

module ToAST = struct
    <<ToAST>>
end

module ToUnreadableString = struct
    <<ToUnreadableString>>
end

module Time = struct
    <<Time>>
end    
@ 
<<rtlutil.ml>>=
let rec is_hardware = function
  | RP.Reg r -> true
  | RP.Slice (w, lsb, r) -> is_hardware r
  | _ -> false

let rec to_hardware = function
  | RP.Reg r -> Rg.Reg r
  | RP.Slice (w, lsb, r) ->
      (match to_hardware r with
      | Rg.Reg r -> Rg.Slice (w, lsb, r)
      | Rg.Slice (w', lsb', r) -> Rg.Slice(w', lsb+lsb', r))
  | l -> Printf.kprintf Impossible.impossible
           "to_hardware given non-harware location %s" (ToString.location' l)
@
%%Register allocation may benefit from knowing whether an {\rtl} represents a
%%move instruction. [[singleAssignment]] returns a destination and source
%%register pair if the input {\rtl} consists of a single, unconditional
%%assignment with any number of unconditional kills. If the {\rtl} has a
%%different form, [[singleAssignment]] returns [[None]].
<<rtlutil.ml>>=
module RTLType = struct
    <<RTLType>>
end
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Width of Locations and Expressions}
%%% ------------------------------------------------------------------ 
%%
<<Width>>=
let loc = Rtl.locwidth
@
%%
%%A named {\rtl} operator has a type and semantics that is independent of
%%its implementation. We have to look it up for expressions that have an
%%application on the outermost level.
%%
<<Width>>=
let rec const = function
    | RP.Bool _       -> Impossible.impossible "asked width of Boolean"
    | RP.Bits b       -> Bits.width b
    | RP.Link (_,_,w) -> w
    | RP.Diff (c,_)   -> const c
    | RP.Late (_,w)   -> w

let exp' = function
    | RP.Const(c)   -> const c
    | RP.Fetch(_,w) -> w
    | RP.App (op,_) -> 
        ( match snd (Rtlop.mono (Rtl.Up.opr op)) with
        | Types.Bits n -> n
        | Types.Bool   -> Impossible.impossible "asked width of Boolean operator"
        ) 
let exp e = exp' (Rtl.Dn.exp e)
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Registers read and written by an RTL}
%%% ------------------------------------------------------------------ 
%%
<<define common ReadWriteKill Higher Order Fns>>=
let fold handle_reg handle_slice handle_mem ~read ~write ~kill r z = 
  let rec rtl (z:'a) (RP.Rtl gs)  = List.fold_left guarded z gs
      and guarded z (g, eff) = exp (effect z eff) g
      and effect z eff = match eff with
        | RP.Store (lhs, rhs, _)         -> loc write (exp z rhs) lhs
        | RP.Kill lhs                    -> loc kill z lhs
      and loc which z l = match l with
        | RP.Mem (space, w, addr, _) as m -> exp (handle_mem which z m) addr
        | RP.Reg r                        -> handle_reg       which z r
        | RP.Slice (w, i, l)              -> handle_slice loc which z (w, i, l)
        | RP.Var _                        -> z
        | RP.Global _                     -> z
      and exp z e = match e with
        | RP.Const _                      -> z
        | RP.Fetch (l, w)                 -> loc read z l
        | RP.App (_, es)                  -> List.fold_left exp z es
  in
     rtl z (Rtl.Dn.rtl r)

let fold_regx ~read ~write ~kill r z =
  fold (fun which z r -> which (Rg.Reg r) z)
       (fun loc which z (w, i, l) -> match l with
                        | RP.Reg r -> which (Rg.Slice (w, i, r)) z
                        | _        -> loc which z l)
       (fun _ z _ -> z)
    ~read ~write ~kill r z

let fold_regt ~read ~write ~kill r z =
  fold (fun which z r -> which r z)
       (fun loc which z (w, i, l) -> loc which z l)
       (fun _ z _ -> z)
       ~read ~write ~kill r z
@
%%
<<ReadWrite>>=
type 'a observert = Register.t -> 'a -> 'a
type 'a observerx = Register.x -> 'a -> 'a

let fold         ~read ~write r z = fold_regx ~read ~write ~kill:write r z
let fold_promote ~read ~write r z = fold_regt ~read ~write ~kill:write r z

let mk_sets fold add empty rtl =
    let add_left  r (left,right) = (add r left, right) in
    let add_right r (left,right) = (left, add r right) in
    let empty = (empty, empty) in
    fold ~read:add_left ~write:add_right rtl empty
let sets         rtl = mk_sets fold         RSX.add RSX.empty rtl
let sets_promote rtl = mk_sets fold_promote RS.add  RS.empty  rtl
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Registers read, written, and killed by an RTL}
%%% ------------------------------------------------------------------ 
%%
<<ReadWriteKill>>=
type 'a observert = Register.t -> 'a -> 'a
type 'a observerx = Register.x -> 'a -> 'a
let fold         = fold_regx
let fold_promote = fold_regt

let mk_sets fold add empty rtl =
  let read  reg (r, w, k) = (add reg r, w, k) in
  let write reg (r, w, k) = (r, add reg w, k) in
  let kill  reg (r, w, k) = (r, w, add reg k) in
  fold ~read ~write ~kill rtl (empty, empty, empty)

let sets         rtl = mk_sets fold         RSX.add RSX.empty rtl
let sets_promote rtl = mk_sets fold_promote RS.add  RS.empty  rtl
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{All locations read, written, and killed by an RTL}
%%% ------------------------------------------------------------------ 
%%
%%I'M NOT SURE WHAT'S GOING ON WITH SLICES HERE...
%%
<<FullReadWriteKill>>=
type 'a observer = RP.loc -> 'a -> 'a
let fold ~read ~write ~kill r z =
  fold (fun which z r -> which (RP.Reg r) z)
       (fun loc which z (w, i, l) ->  (* ??? *)
         match l with
         | RP.Reg r -> which (RP.Slice (w, i, l)) z
         | _        -> loc which z l)
       (fun which z m -> which m z)
    ~read ~write ~kill r z
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Substitutions inside RTLs (Second Try)}
%%% ------------------------------------------------------------------ 
%%
%%The [[DownUp]] module allows to apply functions that work on the private
%%representation of {\rtl}s to their abstract public representation.
<<Subst>>=
module DownUp = struct
    let rtl f r = Rtl.Up.rtl (f (Rtl.Dn.rtl r))
    let loc f l = Rtl.Up.loc (f (Rtl.Dn.loc l))
    let exp f e = Rtl.Up.exp (f (Rtl.Dn.exp e))
end
@
%%It is sometimes useful to apply a function only to the locations defined or
%%used in an {\rtl}.
%%We define a general function [[loc\_gen']] that takes two extra boolean
%%arguments: [[def]] and [[use]]. These arguments indicate whether the function
%%should be applied to definitions and/or uses. The [[loc]] sub-function is
%%resposible for checking the [[act]] boolean variable before applying the
%%function. The caller of [[loc]] pass this variable according to whether the
%%location is used as a def or a use.
<<Subst>>=
let loc_gen' guard map rtl ~def ~use = 
    let rec exp = function
        | RP.Fetch (l, width)  -> RP.Fetch(loc use l, width)
        | RP.App(opr, exprs)   -> RP.App(opr, List.map exp exprs)
        | x                    -> x
    and loc act l = if act && guard l then map l else match l with
        | RP.Mem (sp,w,e,ass)  -> RP.Mem(sp, w, exp e, ass)
        | RP.Slice (w,i,l)     -> RP.Slice(w,i,loc act l)
        | x                    -> x
    and effect = function      
        | RP.Store (l,e,width) -> RP.Store(loc def l, exp e, width)
        | RP.Kill  (l)         -> RP.Kill (loc def l)
    and guarded (e,eff)        = (exp e, effect eff)
    and subst (RP.Rtl rtl)     = RP.Rtl (List.map guarded rtl)
    in    
        subst rtl
let loc'     guard map rtl = loc_gen' guard map rtl ~def:true  ~use:true
let loc_def' guard map rtl = loc_gen' guard map rtl ~def:true  ~use:false
let loc_use' guard map rtl = loc_gen' guard map rtl ~def:false ~use:true

let aloc guard map rtl = 
  let rec exp = function
    | RP.Fetch (l, width)  -> fetch l width
    | RP.App(opr, exprs)   -> RP.App(opr, List.map exp exprs)
    | RP.Const c as e      -> e
  and fetch l   w = if guard l then Dn.exp((map l).fetch w) else RP.Fetch (loc l, w)
  and store l e w =
    if guard l then
      match Dn.rtl ((map l).store (Up.exp e) w) with
      | RP.Rtl [RP.Const (RP.Bool true), eff] -> eff
      | _ -> unimpf "aloc substitution on fancy location"
    else
      RP.Store (loc l, e, w)
  and loc = function
    | RP.Mem (sp,w,e,ass)  -> RP.Mem(sp, w, exp e, ass)
    | RP.Slice (w,i,l)     -> if guard l then unimpf "aloc slice"
                              else RP.Slice(w,i,loc l)
    | (RP.Global _ | RP.Var _ | RP.Reg _) as l -> l
  and effect = function      
    | RP.Store (l,e,width) -> store l (exp e) width
    | RP.Kill  (l)         -> if guard l then unimpf "aloc kill " else RP.Kill (loc l)
  and guarded (e,eff)        = (exp e, effect eff)
  and subst (RP.Rtl rtl)     = RP.Rtl (List.map guarded rtl) in    
  subst rtl


let subst_exp_loc ~eguard ~emap ~lguard ~lmap =
    let rec subst_exp e = if eguard e then emap e else match e with
        | RP.Fetch (l, width)  -> RP.Fetch(subst_loc l, width)
        | RP.App(opr, exprs)   -> RP.App(opr, List.map subst_exp exprs)
        | x                    -> x
    and subst_loc l = if lguard l then lmap l else match l with
        | RP.Mem (sp,w,e,ass)  -> RP.Mem(sp, w, subst_exp e, ass)
        | RP.Slice (w,i,l)     -> RP.Slice(w,i,subst_loc l)
        | x                    -> x                                    in
    (subst_exp, subst_loc)
let exp' eguard emap rtl =
    let (exp, loc) = subst_exp_loc ~eguard ~emap ~lguard:falsef ~lmap:id in
    let effect = function
        | RP.Store (l,e,width)     -> RP.Store(loc l, exp e, width)
        | RP.Kill  (l)             -> RP.Kill (loc l)               in
    let guarded (e,eff)            = (exp e, effect eff)            in
    let subst (RP.Rtl rtl)         = RP.Rtl (List.map guarded rtl)  in
    subst rtl
@
%%For subtitutiong registers we use the substitution function for
%%locations and provide it with the appropirate guard and map.
<<Subst>>=
let reg_gen' map rtl loc' =
  let map = function RP.Reg r -> RP.Reg(map r) | _ -> assert false in
  let is_register = function RP.Reg _ -> true | _ -> false in
  loc' is_register map rtl

let reg_to_mem_gen' map rtl loc' =
  let map = function RP.Reg r -> map r | _ -> assert false in
  let is_register = function RP.Reg _ -> true | _ -> false in
  loc' is_register map rtl

let reg' map rtl     = reg_gen' map rtl loc'
let reg_def' map rtl = reg_gen' map rtl loc_def'
let reg_use' map rtl = reg_gen' map rtl loc_use'
let reg_to_mem' map rtl     = reg_to_mem_gen' map rtl loc'

let exp        ~guard  ~map rtl = DownUp.rtl (exp' guard  map) rtl
let exp_of_exp ~guard  ~map exp =
  let (subst_exp,_) = subst_exp_loc ~eguard:guard ~emap:map ~lguard:falsef ~lmap:id in
  DownUp.exp subst_exp exp

let exp_of_loc ~guard  ~map loc =
  let (_,subst_loc) = subst_exp_loc ~eguard:guard ~emap:map ~lguard:falsef ~lmap:id in
  DownUp.loc subst_loc loc

let loc_of_loc ~guard  ~map loc =
  let (_,subst_loc) = subst_exp_loc ~eguard:falsef ~emap:id ~lguard:guard ~lmap:map in
  DownUp.loc subst_loc loc
  
let loc        ~guard  ~map rtl = DownUp.rtl (loc' guard  map) rtl 
let aloc       ~guard  ~map rtl = DownUp.rtl (aloc guard  map) rtl 
let reg                ~map rtl = DownUp.rtl (reg'        map) rtl 
let reg_def            ~map rtl = DownUp.rtl (reg_def'    map) rtl 
let reg_use            ~map rtl = DownUp.rtl (reg_use'    map) rtl 
let reg_to_mem         ~map rtl = DownUp.rtl (reg_to_mem' map) rtl
@
%%
<<Subst>>=
module Fetch = struct
  let rec exp ~guard ~fetch = function
    | RP.Fetch (l, width) when guard l -> fetch l width
    | RP.Fetch (l, width) -> RP.Fetch (loc ~guard ~fetch l, width)
    | RP.App(opr, exprs)  -> RP.App(opr, List.map (exp ~guard ~fetch) exprs)
    | RP.Const _ as e     -> e
  and loc ~guard ~fetch l = match l with
  | RP.Mem (sp, w, e, ass) -> RP.Mem(sp, w, exp ~guard ~fetch e, ass)
  | RP.Slice (w,i,l)       -> RP.Slice(w,i,loc ~guard ~fetch l)
  | RP.Reg _ | RP.Var _ | RP.Global _ -> l 
  let rtl ~guard ~fetch rtl =
    let RP.Rtl effs = Dn.rtl rtl in
    let loc = loc ~guard ~fetch in
    let exp = exp ~guard ~fetch in
    let effect = function
      | RP.Store (l,e,width)     -> RP.Store(loc l, exp e, width)
      | RP.Kill  (l)             -> RP.Kill (loc l) in
    let guarded (e,eff)  = (exp e, effect eff) in
    Up.rtl (RP.Rtl (List.map guarded effs))
  let exp' = exp
end
@
%%
%%% ------------------------------------------------------------------ 
\subsection{RTL Classification}
%%% ------------------------------------------------------------------ 
%%
<<old RTLType>>=
let singleAssignment rtl =
    let rec firstAssignment rtls = match rtls with
    | [] -> (None, [])
    | (RP.Const(RP.Bool true), RP.Store(loc1, RP.Fetch(loc2, _), _))::rst ->
        (try (Some (Register.of_loc (Rtl.Up.loc loc1),
                    Register.of_loc (Rtl.Up.loc loc2)),
              rst)
        with Invalid_argument _ -> (None, []))
    | _::rst -> firstAssignment rst in
    let getFirstAssignment (RP.Rtl guardeds) = firstAssignment guardeds in

    let isKill rtl = match rtl with
    | (RP.Const(RP.Bool true), RP.Kill _) -> true
    | _ -> false in
    let rec allKills rtls = List.for_all isKill rtls in

    let (assign, rst) = getFirstAssignment (Rtl.Dn.rtl rtl) in
        match assign with
        | Some _ when allKills rst -> assign
        | _ -> None
@
%%
<<RTLType>>=
let singleAssignment rtl = 
    let is_truth = function RP.Const(RP.Bool true) -> true | _ -> false in
    let is_move = function (* effect is an uncond. move *)
        | (g,RP.Store(RP.Reg(dst), RP.Fetch(RP.Reg(src),_),_)) 
            when is_truth g -> Some(dst,src)
        | _                 -> None in
    let is_kill = function (* effect is an uncond. kill *) 
        | (g, RP.Kill _) -> is_truth g
        | _              -> false in 
    match Rtl.Dn.rtl rtl with
    | RP.Rtl([])       -> None
    | RP.Rtl(fst::rst) -> if List.for_all is_kill rst then is_move fst else None
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Conversion to AST}
%%% ------------------------------------------------------------------ 
%%
<<ToAST>>=
module R = Rtl.Private
module A = Ast
module T = Types
@
%%
<<ToAST>>=
type verbosity = Low | High  (* default is High --- more accurate *)
let the_verbosity = ref High
let verbosity v =
  let v' = !the_verbosity in
  the_verbosity := v;
  v'
@ 
<<ToAST>>=
let bits n             = A.BitsTy n
let rec const = function
    | R.Bool(true)   ->  A.PrimOp ("true", [])
    | R.Bool(false)  ->  A.PrimOp ("false", [])
    | R.Bits b       ->
        let w = match !the_verbosity with
        | High -> Some (bits (Bits.width b))
        | Low  -> None in
        (try A.Sint (string_of_int (Bits.S.to_int b), w)
        with Bits.Overflow -> A.Uint (Bits.to_string b, w))
    | R.Link(sym,_,w) -> A.Fetch(A.Name(None, sym#mangled_text,None))
    | R.Diff(c1,c2)   -> A.PrimOp("-", [(None,const c1,None); (None,const c2,None)])
    | R.Late(name,w)  -> A.Fetch(A.Name(None, name, None)) (*XXX ok? *)
@
<<ToAST>>=
let opr op w =
    sprintf "%s[%s]" op (String.concat "," (List.map string_of_int w))

let rec expr' = function
    | R.Const c         -> const c
    | R.Fetch(loc,_)    -> rvalue loc
    | R.App((op,ww),ee) -> let actual e = (None, expr' e, None) in
                           match ee with
                           | [l; r] when op =$= "add" || op =$= "sub" ->
                                  let op = if op =$= "add" then "+" else "-" in
                                  A.BinOp(expr' l, op, expr' r)
                           | _ -> A.PrimOp(opr op ww, List.map actual ee)
@
%$
%%
%%N.B. This code might possibly look up the location in a machine-dependent map
%%in case it needs to the name of a hardware register variable.
%%
%%A translation of {\rtl} locations to {\PAL} is not semantic preserving
%%because {\PAL} has no notion of spaces. The translation here turns a
%%space into a (named) type, which is neither wrong nor right.
%%
<<ToAST>>=
and rvalue = function
  | R.Slice (w, i, loc) ->
      let e = rvalue loc in
      let e = if i = 0 then e
              else A.PrimOp("shrl", [None, e, None;
                                     None, A.Sint (string_of_int i, None), None]) in
      let e = A.PrimOp("lobits" ^ string_of_int w, [None, e, None]) in
      e
  | loc -> A.Fetch(location' loc) 

and location' =
  let name n = A.Name (None, n, None) in
  function
    | R.Mem ((sp,agg,ms),c,e,ass) ->
        let width = Cell.to_width ms c in
        (match !the_verbosity with
        | High ->
            let a       =  match agg with
                           | Rtl.Identity     -> 'I'
                           | Rtl.BigEndian    -> 'B'
                           | Rtl.LittleEndian -> 'L' in
            let space   =  sprintf "$%c(%d%c)" sp width a in
            let aligned = if ass = 1 then None else Some ass in 
            A.Mem(A.TypeSynonym space,expr' e,aligned,
                  if sp =<= 'm' then [] else ["'" ^ Char.escaped sp ^ "'"])
        | Low ->
            A.Mem(A.BitsTy width,expr' e, (if ass = 1 then None else Some ass),
                  if sp =<= 'm' then [] else ["'" ^ Char.escaped sp ^ "'"]))
    | R.Reg((sp,_,ms),i,c) -> 
        (match !the_verbosity with
        | High ->
            let space   =  sprintf "$%c(%d)" sp (Cell.to_width ms c) in   
            let s       = string_of_int i in
            A.Mem(A.TypeSynonym space,A.Sint(s,None), None, [])
        | Low -> name (sprintf "$%c%d" sp i))
    | R.Var    (n,_,width)   -> name n
    | R.Global (n,_,width)   -> name n
    | R.Slice (w,i,loc)      ->
        name (sprintf "Slice(%d, %d, %s)" w i (ToString.location' loc))

let (<<) f g  = fun x -> f (g x)
let expr       = expr'     << Rtl.Dn.exp
let location   = location' << Rtl.Dn.loc

@
%$
%%
%%A [[kill]] is translated into an assignment of [[%undef()]].
%%
<<ToAST>>=
let rec effect guard = function
    | R.Kill   loc       -> 
        let width = Width.loc  (Rtl.Up.loc loc)       in
        let undef = R.App(("undef",[width]),[]) in
            effect guard (R.Store(loc, undef, width))
    | R.Store  (loc,e,w) ->
            (location' loc,(guard, expr' e))

let guard = function
  | R.Const (R.Bool true) -> None
  | g -> Some (expr' g)  

let guarded (g, eff) = effect (guard g) eff

let rtl' (R.Rtl gg) = 
  match gg with
  | [] -> A.EmptyStmt
  | _ :: _ ->
    let pairs    = List.map (guarded ) gg in
    let lhs, rhs = List.split pairs             in
        A.AssignStmt(lhs,rhs)
let rtl = rtl' << Rtl.Dn.rtl
@
%%% ------------------------------------------------------------------ 
\subsection{Conversion to Readable String}
%%% ------------------------------------------------------------------ 
%%
<<ToString>>=
module R = Rtl.Private
module A = Ast
module T = Types
@
%%
<<ToString>>=
let rec const = function
    | R.Bool true     ->  "true"
    | R.Bool false    ->  "false"
    | R.Bits b        ->  Int64.to_string (Bits.S.to_int64 b)
    | R.Link(sym,_,w) -> sym#mangled_text
    | R.Diff(c1,c2)   -> (const c1) ^ "-" ^ (const c2)
    | R.Late(name,w)  -> "<" ^ name ^ ">"
@
%%
<<ToString>>=
let opr op w = match op, w with
| ("sx"  | "zx"  | "lobits" |
   "i2f" | "f2i" |"f2f" ), [w1;w2]  -> "%" ^ op ^ string_of_int w2
| _, _                              -> "%" ^ op

let join = String.concat

let rec expr' = function
    | R.Const c         -> const c
    | R.Fetch(loc,_)    -> location' loc
    | R.App((op,ww),ee) -> match ee with
                           | [l; r] when op =$= "add" || op =$= "sub" ->
                                  let op = if op =$= "add" then " + " else " - " in
                                  brexpr' l ^ op ^ brexpr' r
                           | _ -> opr op ww ^ "(" ^ join ", " (List.map expr' ee) ^ ")"
and brexpr' e = match e with (* bracketed expression *)
    | R.App ((op,ww), _) when op =$= "add" || op =$= "sub" -> "(" ^ expr' e ^ ")"
    | _ -> expr' e
@
%$
%%
<<ToString>>=
and agg = function
  | Rtl.BigEndian    -> "B"
  | Rtl.LittleEndian -> "L"
  | Rtl.Identity     -> "I"
and location' = function 
    | R.Mem ((sp,a,ms),c,e,ass) ->
        let space = if sp =<= 'm' then "bits" ^ string_of_int (Cell.to_width ms c)
                    else "$" ^ Char.escaped sp in
        sprintf "%s%s[%s]" space (agg a) (expr' e)
    | R.Reg r -> reg r
    | R.Var    (name,_,width)       -> name
    | R.Global (name,_,width)       -> name
    | R.Slice (w,i,loc)          ->

        location' loc ^ "@[" ^ string_of_int i ^ ".." ^ string_of_int (i+w-1) ^ "]"

and reg ((sp,a,_),i,R.C n) =
  if n = 1 then
    sprintf "$%s[%d]" (Char.escaped sp) i
  else
    sprintf "$%s[%d:%d%s]" (Char.escaped sp) i n (agg a)

    
let (<<) f g  = fun x -> f (g x)
let expr       = expr'     << Rtl.Dn.exp
let loc = location' << Rtl.Dn.loc
@
%$
%%
%%A [[kill]] is translated into an assignment of [[%undef()]].
<<ToString>>=
let rec effect = function
    | R.Kill   loc       -> "kill " ^ location' loc
    | R.Store  (loc,e,w) -> location' loc ^ " := " ^ expr' e

let guard = function
  | R.Const (R.Bool true) -> ""
  | g -> expr' g ^ " --> " 

let guarded (g, eff) = guard g ^ effect eff

let rtl' (R.Rtl gg) = 
  match gg with
  | [] -> "skip"
  | _ :: _ -> join " | " (List.map guarded gg)
let rtl = rtl' << Rtl.Dn.rtl
let exp = expr
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Evaluation Time Classification}
%%% ------------------------------------------------------------------ 
%%
<<Time>>=
let compile e = match Dn.exp e with
    | RP.Const(RP.Bits _) -> true
    | RP.Const(RP.Bool _) -> true
    | RP.Const(RP.Late _) -> true
    | _                   -> false

let link e = match Dn.exp e with     
    | RP.Const(RP.Bits _) -> true
    | RP.Const(RP.Bool _) -> true
    | RP.Const(RP.Late _) -> true
    | RP.Const(RP.Link _) -> true       
    | RP.Const(RP.Diff _) -> true
    | RP.App(("add",_), [RP.Const(RP.Link _); RP.Const(RP.Bits _)])
        -> true
    | RP.App(("add",_), [RP.Const(RP.Diff _); RP.Const(RP.Bits _)])
        -> true
    | _                   -> false
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Conversion to String}
%%% ------------------------------------------------------------------ 
%%
%%We convert a given {\rtl} into {\PAL} abstract syntax and then
%%pretty-print it into a string. To avoid newlines in the string we pass
%%[[max_int]] as the line-width to the pretty-printer. 
<<ToUnreadableString>>=
module P  = Pp
module R  = Rtl
module RP = Rtl.Private 

let (^^)   = P.(^^)
let (^/)   = P.(^/)

let indent x = P.nest 4 (P.break ^^ x)
let int i    = P.text (string_of_int i)
let str s    = P.text s
let char c   = P.text (sprintf "'%c'" c)

let tuple docs = 
    P.agrp (P.text "(" ^^ P.list (P.text "," ^^ P.break) id docs ^^ P.text ")")
    
let apply c args = P.agrp(str c ^^ indent(tuple args))

let aggregation' = function
    | R.BigEndian       -> P.text "BE"
    | R.LittleEndian    -> P.text "LE"
    | R.Identity        -> P.text "ID"

let agg = function
    | R.BigEndian       -> "big"
    | R.LittleEndian    -> "little"
    | R.Identity        -> "none"

let opr (name, ws) =
    tuple [str name; tuple (List.map int ws)]

let rec const = function
    | RP.Bool(b)        -> apply "Bool"  [str (if b then "true" else "false")]
    | RP.Bits(b)        -> apply "Bits"  [ str (Int64.to_string (Bits.U.to_int64 b))
                                         ; int (Bits.width b)
                                         ]
    | RP.Link(r,k,w)    -> apply "Link"  [str r#mangled_text; P.text (kind k); int w]
    | RP.Diff(c1,c2)    -> apply "Diff"  [const c1; const c2]
    | RP.Late(s,w)      -> apply "Late"  [str s; int w]
and kind = function RP.Code -> "Code" | RP.Data -> "Data" | RP.Imported -> "Imported"

let rec exp = function
    | RP.Const(k)       -> apply "Const" [const k]
    | RP.Fetch(l,w)     -> apply "Fetch" [loc l; int w]
    | RP.App(o,es)      -> apply "App"   [opr o; tuple (List.map exp es)] 
    
and loc = function
    | RP.Mem((sp, agg, ms), c, e, ass) -> 
        apply "Mem" [char sp; aggregation' agg; int (Cell.to_width ms c); exp e]
    | RP.Reg((sp,agg,ms),i,R.C c) ->
        apply "Reg" [char sp; int i; str (sprintf "C %d" c)]
    | RP.Var(name, index, w) ->
        apply "Var" [str name; int index; int w]
    | RP.Global(name, index, w) ->
        apply "Global" [str name; int index; int w]
    | RP.Slice(w, i, l) ->
        apply "Slice" [int w; int i; loc l]
        

let effect = function
    | RP.Store(l,e,w) -> apply "Store" [loc l; exp e; int w]
    | RP.Kill(l)      -> apply "Kill"  [loc l]  

let guarded (g, e) =
    tuple [exp g; effect e]

let rtl' (RP.Rtl x) =
    apply "Rtl" (List.map guarded x)
    
let rtl r =
    let pp = rtl' (R.Dn.rtl r) in
        Pp.ppToString 66 (* line width *) pp

let exp e =
    let pp = exp (R.Dn.exp e) in
        Pp.ppToString 66 (* line width *) pp

let reg' ((sp,agg,ms),i,R.C c) =
  tuple [char sp; int i; str (sprintf "C %d" c)]
let reg r =
  Pp.ppToString 66 (P.agrp (reg' r))


let regx r = match r with
  | Rg.Reg r -> Pp.ppToString 66 (P.agrp (reg' r))
  | Rg.Slice (w, lsb, r) -> 
      Pp.ppToString 66 (P.agrp (  reg' r ^^ str "@" ^^ int lsb ^^ str ":" ^^ int w))

let loc l = Pp.ppToString 66 (loc (Dn.loc l))
@
%%
\subsection{Aliasing}
%%Recall that registers may overlap due to aggregation, even if they do not have
%%the same index.
%%Hence, the following code is wrong (and should never be reintroduced to the compiler):
%%\begin{code}
%%let regs' ((s,_,_), i, w) ((s',_,_), i', w') = s =<= s' && i = i'  (* WRONG!!! *)
%%\end{code}
%%
%%The following code is a little more careful:
<<rtlutil.ml>>=
module Down = Rtl.Dn
module MayAlias = struct
  let regs ((s,_,_), i, R.C c) ((s',_,_), i', R.C c') =
    s =<= s' && not (i + c <= i' || i' + c' <= i)

  let () = Debug.register "may-alias" "check register may-alias function"

  let regs =
    if Debug.on "may-alias" then
      let regs ((s,_,_), i, R.C c as r) ((s',_,_), i', R.C c' as r') =
        let good = regs r r' in
        let what p = if p then "may" else "may not" in
        ( Printf.eprintf "Comparing $%c[%d:%d] and $%c[%d:%d]: %s alias\n"
                        s i c s' i' c' (what good)
        ; good
        ) in
      regs
    else
      regs

  let with_reg r = function
    | RP.Reg r' -> regs r r'
    | _ -> false

  let with_vari vi = function
    | RP.Var (_, vi', _) -> vi = vi'
    | _ -> false

  let with_globali vi = function
    | RP.Global (_, vi', _) -> vi = vi'
    | _ -> false

  type slot = string * int  (* symbol and offset *)

  let stack_slot = function
    | RP.Fetch(RP.Reg(('V',_,_), 0, _), _) -> Some ("", 0)
    | RP.App (("add", [_]), [RP.Fetch(RP.Reg(('V',_,_), 0, _), _); offset]) ->
        (match offset with
        | RP.Const (RP.Bits k') -> Some ("", Bits.S.to_int k')
        | RP.Const (RP.Late (s, _)) -> Some (s, 0)
        | RP.App (("add", [_]), [RP.Const l; RP.Const r]) ->
            (match l, r with
            | RP.Late (s, _), RP.Bits k -> Some (s, Bits.S.to_int k)
            | RP.Bits k, RP.Late (s, _) -> Some (s, Bits.S.to_int k)
            | _ -> None)
        | _ -> None)
    | _ -> None

  let rec is_initialized_data = function
    | RP.Const (RP.Link(_, _, _)) -> true
    | RP.Const (RP.Diff(_, _)) -> true
    | RP.App ((("add"|"sub"), [_]), [RP.Const _ as l; RP.Const _ as r]) ->
        is_initialized_data l || is_initialized_data r
    | _ -> false

  let with_mem (s,_,_) (R.C c) e = function  (* different stack slots don't alias *)
    | RP.Mem ((s',_,_), R.C c', e', _) ->
        s =<= s' &&
        (match stack_slot e, stack_slot e' with
        | None,   Some _ -> not (is_initialized_data e)
        | Some _, None   -> not (is_initialized_data e')
        | None,   None   -> true
        | Some (sym, n), Some(sym', n') ->
(*
Printf.eprintf "--> comparing stack slots %s+%d and %s+%d\n" sym n sym' n';
*)
                sym =$= sym' && not (n + c <= n' || n' + c' <= n))
    | _ -> false

  let unslice f l =
    let rec un = function
      | RP.Slice (_, _, l) -> un l
      | l -> l
    in f (un l)

  let rec locs' l = match l with
    | RP.Reg r            -> unslice (with_reg  r)
    | RP.Var    (_, i, _) -> unslice (with_vari i)
    | RP.Global (_, i, _) -> unslice (with_globali i)
    | RP.Mem (s, w, e, _) -> unslice (with_mem s w e)
    | RP.Slice (_, _, l)  -> locs' l
  and locs l =
    let alias = locs' (Down.loc l) in
    fun l' -> alias (Down.loc l')
          
  let has_loc f e =
    let rec has es ess = match es with
      | [] -> (match ess with [] -> false | es :: ess -> has es ess)
      | RP.Const _ :: es -> has es ess
      | RP.Fetch (l, w) :: es ->
          f l || (match l with
                 | RP.Mem (_, _, e, _) -> has (e :: es) ess
                 | _ -> has es ess)
      | RP.App (_, es') :: es -> has es (es' :: ess) in
    has [e] []

  let exp' l =
    let may_alias = has_loc (locs' l) in
    fun e ->
      let answer = may_alias e in
      let module S = ToString in
      let _debug () = 
        Printf.eprintf "*** Expression %s %s alias with location %s\n"
          (S.exp (Rtl.Up.exp e)) (if answer then " may " else " may not ")
          (S.loc (Rtl.Up.loc l)) in
      answer

  let exp l =
    let alias = exp' (Down.loc l) in
    fun e -> alias (Down.exp e)


  let store_uses' l (l', r', _) =
    exp' l r' || match l' with RP.Mem (_, _, e, _) -> exp' l e | _ -> false
end
@ 
%$
%%
<<rtlutil.ml>>=
@ 
\section{Reassociating arithemtic}
<<rtlutil.ml>>=
let add' w =
  let addop = R.opr "add" [w] in
  fun x y -> R.app addop [x; y]

let rec is_sum_of_constants = function
  | RP.Const (RP.Bits _ | RP.Late (_, _)) -> true
  | RP.App   ((("add"), [w]), es)   -> List.for_all is_sum_of_constants es
  | _ -> false

let addc w =
  let add' = add' w in
  let addconst x y = match x, y with
    | RP.Bits b, RP.Bits b' -> R.bits (Bits.Ops.add b b') w
    | c, c' -> add' (Up.const c) (Up.const c') in
  fun x y ->
    match Down.exp x with
    | RP.App (("add", [w']), [x1; RP.Const c]) -> add' (Up.exp x1) (addconst c y)
    | RP.App (("add", [w']), [x1; x2]) when is_sum_of_constants x2 ->
        add' (Up.exp x1) (add' (Up.exp x2) (Up.const y))
    | _ -> add' x (Up.const y) 

let addk w =
  let add = addc w in
  fun x k -> if k = 0 then x else add x (RP.Bits (Bits.S.of_int k w))

let add w =
  let add = add' w in
  fun x y -> match (Down.exp y) with
  | RP.Const c -> addc w x c
  | _ -> add x y
@ 
\subsection{Operator search}
<<rtlutil.ml>>=
module Exists = struct
  module Loc = struct
    let exp = MayAlias.has_loc
    let rtl p =
      let exp = exp p in
      let effect = function
        | RP.Store (l, r, w) -> exp r || exp (RP.Fetch (l, w))
        | RP.Kill l          -> exp (RP.Fetch (l, 0)) in (* width cheat is OK *)
      let ge (guard, eff) = exp guard || effect eff in
      fun (RP.Rtl ges) -> List.exists ge ges
  end
  module Opr = struct
    let rtl p =
      let rec rtl (RP.Rtl gs) = List.exists guarded gs
      and guarded (g, eff) = exp g || effect eff
      and effect = function
        | RP.Store (lhs, rhs, _) -> loc lhs || exp rhs
        | RP.Kill lhs            -> loc lhs
      and loc = function
        | RP.Mem (_, _, addr, _) -> exp addr
        | RP.Reg r               -> false
        | RP.Slice (_, _, l)     -> loc l
        | RP.Var _               -> false
        | RP.Global _            -> false
      and exp = function         
        | RP.Const _             -> false
        | RP.Fetch (l, w)        -> loc l
        | RP.App (opr, es)       -> p (Rtl.Up.opr opr) || List.exists exp es in
      fun r -> rtl (Rtl.Dn.rtl r)
  end
  module Const = struct
    let rtl const_ftn =
      let rec rtl (RP.Rtl gs) = List.exists guarded gs
      and guarded (e, eff) = exp e || effect eff
      and effect eff = match eff with
        | RP.Store(l, e, _) -> loc l || exp e
        | RP.Kill l -> loc l
      and loc l = match l with
        | RP.Mem(_,_,e,_)   -> exp e
        | RP.Slice(_,_,l')  -> loc l'
        | RP.Reg _ | RP.Var _ | RP.Global _ -> false
      and exp e = match e with
        | RP.Const c     -> const c
        | RP.Fetch(l, _) -> loc l
        | RP.App(_, es)  -> List.exists exp es
      and const c = const_ftn c in
      fun r -> rtl (R.Dn.rtl r)
  end
end 
@ 
%%
<<rtlutil.ml>>=
module Find = struct
  module Loc = struct
    let exp f e =
      let rec has es ess = match es with
        | [] -> (match ess with [] -> None | es :: ess -> has es ess)
        | RP.Const _ :: es -> has es ess
        | RP.Fetch (l, w) :: es ->
            if f l then Some l
            else ( match l with
                 | RP.Mem (_, _, e, _) -> has (e :: es) ess
                 | _ -> has es ess)
        | RP.App (_, es') :: es -> has es (es' :: ess) in
      has [e] []
  end
end 
@ 
<<rtlutil.ml>>=
module Fold = struct
  module RegX = struct
    let loc f l z =
      let rec exp z = function
        | RP.Const _ -> z
        | RP.Fetch (l, _) -> loc z l
        | RP.App (_, es') -> List.fold_left exp z es'
      and loc z = function
        | RP.Reg   r                -> f (Rg.Reg r) z
        | RP.Slice (w, i, RP.Reg r) -> f (Rg.Slice (w, i, r)) z
        | RP.Slice (_, _, l)        -> loc z l
        | _ -> z in
      loc z (Rtl.Dn.loc l)
  end
  module LocFetched = struct
    let rtl f rtl z = 
      let rec exp z e =
        let rec fold z es ess = match es with
        | [] -> (match ess with [] -> z | es :: ess -> fold z es ess)
        | RP.Const _ :: es -> fold z es ess
        | RP.Fetch (l, w) :: es -> let z = f l z in fold (loc z l) es ess
        | RP.App (_, es') :: es -> fold z es (es' :: ess) in
        fold z [e] [] 
      and loc z = function
        | RP.Mem (_, _, e, _) -> exp z e
        | _ -> z in
      let effect z = function
        | RP.Kill l -> loc z l
        | RP.Store (l, r, w) -> exp (loc z l) r in
      let guarded z (g, e) = effect (exp z g) e in
      let RP.Rtl effs = rtl in
      List.fold_left guarded z effs
  end
end 
@ 
<<rtlutil.ml>>=
<<comparisons>>
module Eq = struct
  let space  ((s:char), _, _)  ((s':char), _, _) = s =<= s'
  let const c c' = Compare.const c c' = 0
  let loc   l l' = Compare.loc   l l' = 0
  let exp   e e' = Compare.exp   e e' = 0
  let rtl   r r' = Compare.rtl   r r' = 0
end
@ 
<<comparisons>>=
module Compare = struct
  let less    = -1
  let equal   = 0
  let greater = 1

  let space (s, _, _) (s', _, _) = comparec s s'

  let rec const c c' = match c, c' with
  | (RP.Bool l, RP.Bool r) -> compareb l r
  | (RP.Bits l, RP.Bits r) -> Bits.compare l r
  | (RP.Link (l1, l2, l3), RP.Link (r1, r2, r3)) ->  
    (match Pervasives.compare l1 r1 with
    | 0 ->
        (match Pervasives.compare l2 r2 with
        | 0 -> compare l3 r3
        | diff -> diff)
    | diff -> diff)
  | (RP.Diff (l1, l2), RP.Diff (r1, r2)) ->  
      (match const l1 r1 with
      | 0 -> const l2 r2
      | diff    -> diff)
  | (RP.Late (l1, l2), RP.Late (r1, r2)) ->  
      (match compares l1 r1 with
      | 0   -> comparei l2 r2
      | diff    -> diff)
  | (RP.Bool _, RP.Bits _) -> less
  | (RP.Bool _, RP.Link _) -> less
  | (RP.Bool _, RP.Diff _) -> less
  | (RP.Bool _, RP.Late _) -> less
  | (RP.Bits _, RP.Bool _) -> greater
  | (RP.Bits _, RP.Link _) -> less
  | (RP.Bits _, RP.Diff _) -> less
  | (RP.Bits _, RP.Late _) -> less
  | (RP.Link _, RP.Bool _) -> greater
  | (RP.Link _, RP.Bits _) -> greater
  | (RP.Link _, RP.Diff _) -> less
  | (RP.Link _, RP.Late _) -> less
  | (RP.Diff _, RP.Bool _) -> greater
  | (RP.Diff _, RP.Bits _) -> greater
  | (RP.Diff _, RP.Link _) -> greater
  | (RP.Diff _, RP.Late _) -> less
  | (RP.Late _, RP.Bool _) -> greater
  | (RP.Late _, RP.Bits _) -> greater
  | (RP.Late _, RP.Link _) -> greater
  | (RP.Late _, RP.Diff _) -> greater
  and symkind k k' = match k, k' with
  | (RP.Code, RP.Code) -> equal
  | (RP.Data, RP.Data) -> equal
  | (RP.Imported, RP.Imported) -> equal
  | (RP.Code, RP.Data) -> less
  | (RP.Code, RP.Imported) -> less
  | (RP.Data, RP.Code) -> greater
  | (RP.Data, RP.Imported) -> less
  | (RP.Imported, RP.Code) -> greater
  | (RP.Imported, RP.Data) -> greater

  let rec exp e e' = match e, e' with
  | (RP.Const l, RP.Const r) -> const l r
    | (RP.Fetch (l1, l2), RP.Fetch (r1, r2)) ->  
        (match loc l1 r1 with
          | 0   -> compare l2 r2
          | diff    -> diff)
    | (RP.App (l1, l2), RP.App (r1, r2)) ->  
        (match Pervasives.compare l1 r1 with
        | 0   -> Auxfuns.compare_list exp l2 r2
        | diff    -> diff)
    | (RP.Const _, RP.Fetch _) -> less
    | (RP.Const _, RP.App _) -> less
    | (RP.Fetch _, RP.Const _) -> greater
    | (RP.Fetch _, RP.App _) -> less
    | (RP.App _, RP.Const _) -> greater
    | (RP.App _, RP.Fetch _) -> greater
  and count (RP.C l) (RP.C r) = compare l r
  and loc l l' = match l, l' with
  | (RP.Mem (l1, l2, l3, l4), RP.Mem (r1, r2, r3, r4)) ->
        (match space l1 r1 with
        | 0   ->  
            (match count l2 r2 with
            | 0   ->  
                (match exp l3 r3 with
                | 0   -> Pervasives.compare l4 r4
                | diff    -> diff)
            | diff    -> diff)
        | diff    -> diff)
    | (RP.Reg l, RP.Reg r) -> Register.compare l r
    | (RP.Var (l1, l2, l3), RP.Var (r1, r2, r3)) -> comparei l2 r2
    | (RP.Global (l1, l2, l3), RP.Global (r1, r2, r3)) ->  comparei l2 r2
    | (RP.Slice (l1, l2, l3), RP.Slice (r1, r2, r3)) ->  
        (match comparei l2 r2 with
        | 0   ->  
            (match comparei l1 r1 with
            | 0   -> loc l3 r3
            | diff    -> diff)
           | diff    -> diff)
    | (RP.Mem _, RP.Reg _) -> less
    | (RP.Mem _, RP.Var _) -> less
    | (RP.Mem _, RP.Global _) -> less
    | (RP.Mem _, RP.Slice _) -> less
    | (RP.Reg _, RP.Mem _) -> greater
    | (RP.Reg _, RP.Var _) -> less
    | (RP.Reg _, RP.Global _) -> less
    | (RP.Reg _, RP.Slice _) -> less
    | (RP.Var _, RP.Mem _) -> greater
    | (RP.Var _, RP.Reg _) -> greater
    | (RP.Var _, RP.Global _) -> less
    | (RP.Var _, RP.Slice _) -> less
    | (RP.Global _, RP.Mem _) -> greater
    | (RP.Global _, RP.Reg _) -> greater
    | (RP.Global _, RP.Var _) -> greater
    | (RP.Global _, RP.Slice _) -> less
    | (RP.Slice _, RP.Mem _) -> greater
    | (RP.Slice _, RP.Reg _) -> greater
    | (RP.Slice _, RP.Var _) -> greater
    | (RP.Slice _, RP.Global _) -> greater

  let effect e e' = match e, e' with
  | (RP.Store (l1, l2, l3), RP.Store (r1, r2, r3)) ->  
      (match loc l1 r1 with
      | 0   ->  
          (match exp l2 r2 with
          | 0   -> compare l3 r3
          | diff    -> diff)
      | diff    -> diff)
  | (RP.Kill l, RP.Kill r) -> loc l r
  | (RP.Store _, RP.Kill _) -> -1
  | (RP.Kill _, RP.Store _) -> 1
  let guarded (l1, l2) (r1, r2) =
      (match exp l1 r1 with
      | 0   -> effect l2 r2
      | diff    -> diff)
  let rtl (RP.Rtl l) (RP.Rtl r) = Auxfuns.compare_list guarded l r
end
@ 
<<rtlutil.ml>>=
let reloc addr w =
  let const b = R.bits b w in
  let sym (s, mk) = mk s w in
  let infix op a b = R.app (R.opr op [w]) [a; b] in
  let add, sub = infix "add", infix "sub" in
  Reloc.fold ~const ~sym ~add ~sub addr
@ 
\section{[[front_rtl/symbol.nw]]}
<<front_rtl/symbol.ml>>=
<<symbol.ml>>
@

<<front_rtl/symbol.mli>>=
<<symbol.mli>>
@

%%
%%% ------------------------------------------------------------------ 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
\section{Symbol}
%%% ------------------------------------------------------------------ 
%%
%%A symbol is a linker-specific representation of a value that is not
%%known before link time. To allow assemblers to define their
%%representation locally, we just define a class type.
%%
%%All that we ask for at the moment, is that a symbol can be observed as a
%%string.
%%
<<class type t>>=
class type t = object
    method mangled_text:    string
    method original_text:   string
end 
@
%%
%%Since we only define types, interface and implementation are the same.
%%
<<symbol.mli>>=
<<class type t>>
val unmangled    : string -> t
val with_mangler : (string -> string) -> string -> t
@
<<symbol.ml>>=
<<class type t>>
class unmangled (n:string) : t = 
object(this)
    method original_text = n
    method mangled_text  = n
end
class mangled (mangle:string->string) (n:string) : t = object
    method mangled_text    = mangle n
    method original_text   = n
end
let unmangled n = new unmangled n
let with_mangler m n = new mangled m n
@
%%
\section{[[front_rtl/types.nw]]}
<<front_rtl/types.ml>>=
<<types.ml>>
@

<<front_rtl/types.mli>>=
<<types.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% l2h substitution C C--
%%% l2h substitution asdl ASDL
%%% l2h substitution ocaml OCaml
%%% l2h substitution forall forall
%%% l2h substitution to ->
%%% l2h substitution rtl RTL
%%
%%%%Grades: B Central Immediate
%%
%%% ------------------------------------------------------------------  
\section{Types}\label{sec:types}
%%% ------------------------------------------------------------------  
%%
%%Expressions in {\PAL} are type checked. This module provides types and
%%type checking functions for {\rtl} operators. 
%%
%%Conditions in {\PAL} have type [[bool]], values types [[bits]]$n$. These
%%two are the basic types. {\PAL} and their closely related {\rtl}
%%operators have polymorphic function types. The typical case is an
%%operator like [[add]]:
%%
%%$$[[add]]: \forall~n.[[bits]]n \times [[bits]]n \to [[bits]]n$$
%%
%%The result size of [[add]] is the size of its arguments. A concrete
%%instance like $n=32$ is called a (function) type. The general scheme is
%%called a (polymorphic) \emph{type scheme}.
%%
%%{\PAL} has a number of operators whose types are a bit more complicated
%%than that of [[add]]. The first complication is illustrated by the
%%[[zx]] operator. The [[zx]] operator widens a value by filling high
%%bits with zeros. In {\PAL} the width of the result is encoded into the
%%name: [[zx32]] widens a value to 32 bits; its type scheme can be thought
%%of like this:
%%
%%$$[[sz32]]: \forall~n.[[bits]]n \to [[bits32]]$$
%%
%%However, this is not the way [[zx]] is implemented in the compiler. All
%%{\PAL} operators are translated to {\rtl} operators that are allowed to
%%be polymorphic in the result size. The general [[sz]] operators has the
%%following type:
%%$$[[sz]]: \forall~n,m.[[bits]]n \to [[bits]]m$$
%%The translation (in \module{rtlop}) of [[sz32]] into [[sz]] takes care
%%that $m$ is bound to $32$.
%%
%%The second complication is introduced by multiplication operators like
%%[[mulx]]:
%%$$[[mulx]]: \forall~n,m.[[bits]]$n$ \times [[bits]]$n$ \to [[bits]]m, m = 2n$$
%%The result of a multiplication is twice as wide as the operands. This
%%constraint cannot be easily expressed in the above formalism using bound
%%variables. We therefore have to employ a little hack to express it.
%%
%%The same goes the other way round, the result of a [[div]] operator is
%%half the width of its operands.
%%
%%% ------------------------------------------------------------------ 
\subsection{Interface (Types)}
%%% ------------------------------------------------------------------ 
%%
%%The parameterized type [['a t]] describes either a type [[ty]] when 
%%[['a]] equals [[int]], or a type scheme, when [['a]] is a [[size]]. In a
%%type scheme the width of a value is one of the following:
%%\begin{itemize}
%%\item A constant, like 32.
%%\item A bound variable. To maximize confusion, variables are identified
%%      by integers. Maybe we should switch to characters. Bound variables
%%      allow to express that two values in a function type have the same
%%      width.
%%\item The size of a another bound variable, times two. This is a hack to
%%      express the result width of a multiplication operator, as explained
%%      above.
%%\end{itemize}
<<exported type definitions(types.nw)>>=
<<definition of type [[size]]>>
type 'a t = Bool
          | Bits of 'a 
type ty   = int t
@
%%The type of a function is a pair of a list of operand types and a result
%%type. A [[tyscheme]] describes a type scheme, a [[monotype]] the
%%instance of a type scheme.
<<exported type definitions(types.nw)>>=
type tyscheme = (size t) list * (size t)
type monotype = (int  t) list * (int  t)
@
%%Unlike in the formalism that uses $\forall$ to bind type variables
%%explicitly, type variables in the implementation are bound implicitly:
%%The [[tyscheme]] for the [[add]] and [[mulx]] primitves are encoded as
%%follows:
%%\begin{quote}
%%    \begin{verbatim}
%%add:  ([Bits(Var 1); Bits(Var 1)], Bits(Var 1))
%%mulx: ([Bits(Var 1); Bits(Var 1)], Bits(Double 1))
%%    \end{verbatim}
%%\end{quote}
%%The [[Var 1]] values identify the variable in the type scheme that is
%%replaced by an integer when the type scheme is instantiated. In case of
%%[[mulx]], the size of the result is twice the number of bits [[Var 1]]
%%gets bound to.
%%
%%% ------------------------------------------------------------------ 
\subsection{Interface (Functions)}
%%% ------------------------------------------------------------------ 
%%
%%The [[appl]] function implements the type checking of arguments that are
%%supplied to a primitive function: given the [[tyscheme]] to describe the
%%primitive, and the list of argument [[ty]]s, [[appl]] returns the type
%%of the primitive's result. In case the primitive's [[tyscheme]] can not
%%be instantiated such that the supplied argument type match, the error
%%exception is raised.
%%
%%Each function takes a first argument that is the name of the operator
%%being applied.
<<appl>>=
val appl      : string -> tyscheme -> ty list -> ty       (* raises Error.ErrorExn *)
val widthlist : string -> tyscheme -> ty list -> int list (* raises Error.ErrorExn *)
@
%%Instantiation of a type scheme fails  when a type scheme contains a
%%variable in the result position that does not also show up in an
%%argument position. This indicates a checked run-time error in the type
%%specification of a primitive and should never happen.  
%%
%%The [[widthlist]] function takes the type of a primitive (a
%%[[tyscheme]]) and a list of argument types and returns the sizes bound
%%by the variables in the type scheme.
<<appl>>=
val split : string -> string * int option     (* RTL op name, return width *)
@
%%Some operators encode the size of their return values in their name:
%%[[zx32]] is the zero-extension function that returns a 32 bit value.
%%The [[split]] function returns the operator name (without the numbers)
%%and the size of the return value, if it exists:
<<appl>>=
val instantiate: tyscheme -> widths:int list -> monotype
@
%%An operator inside an {\rtl} is monomorphic. It carries a \emph{width
%%list} that allows to reconstruct the monomorphic type from its
%%polymorphic type scheme. This process is called instantiation. It is a
%%checked run-time error if the width list is too short to instantiate all
%%variables in the type scheme.
%%
%%% ------------------------------------------------------------------ 
\subsection{Useful abbreviations}
%%% ------------------------------------------------------------------ 
%%
%%When dealing with type the same types are used over and over again. 
%%Here are some useful definitions for them.  There are at least three
%%target dependent types:  the native word type [[word]], the native
%%code pointer type [[code]], and the native data pointer type.  We
%%define types for them here, but only for the moment. 
<<abbrevs>>=
val fixbits : int -> size t              (* fixed/constant size       *)
val var     : key -> size t              (* variable size             *)
val double  : key -> size t              (* doubled width - see above *)
val half    : key -> size t              (* halfed width  - see above *)
val bool    : 'a t                       (* bool                      *)
val bits    : 'a -> 'a t
val proc    : size t list -> size t -> tyscheme   (* build proc type  *)
  (* keys used in sizes must be dense, or an unchecked RTE [SHOULD BE CHECKED] *)
val largest_key : tyscheme -> key
  (* return the largest key in the type scheme, or 0 if no keys *)
@
%%Finally, here we put together the interface file.
<<types.mli>>=
<<exported type definitions(types.nw)>>
<<appl>>
<<abbrevs>>
val to_string     : ty -> string
val scheme_string : tyscheme -> string
@
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%A substitution associates a width variable (identified by an [[int]])
%%with an integer bit width. We use a map to implement a substitution.  In
%%addition to the functions provided by [[Map]] we define some helper
%%functions. 
<<definition of type [[size]]>>=
type key  = int
type size = Const  of int
          | Var    of key
          | Double of key      
          | Half   of key
@ 
%%
<<types.ml>>=
<<exported type definitions(types.nw)>>
 (* types from the interface definition *)
@
%%\emph{Rather than having a fixed operator [[Double]] we could implement a
%%map: [[Fun of key * (int -> int)]]. The key indentifies a width
%%variable, and ultimately a width. We take it, and apply the function to
%%obtain a new width. In our case the function is simply multiplication by
%%two. I haven't thought about this, but would in the general case expect
%%problems with circular dependencies among types. What is the right
%%formalism here? -- CL}
%% 
<<types.ml>>=
module E = Error
module S = Map.Make(struct type t=key let compare=compare end)

let impossf fmt = Printf.kprintf Impossible.impossible fmt

let to_string = function
  | Bool -> "bool"
  | Bits n -> "bits" ^ string_of_int n

let lookup key env = S.find key env 
let dump env       = let f key data res = (key,data)::res in S.fold f env []
@
%%To check that the application of an operator is well typed, we
%%\emph{match} the type scheme of the operator against the operand types.
%%A match takes a type scheme and a type, and produces a substitution. The
%%substitution records bindings for width variables, resulting from a
%%match between a constant width and a variable width. These are the
%%important cases:
%%\begin{itemize}
%%\item A type variable width matches with a fixed width; this leads to an
%%      instantiation of the variable that is recorded in the
%%      substitution.
%%\item A width variable might have been instantiated; thus the
%%      instantiation must be looked up in the substitutions and checked
%%      against the fixed width.
%%\end{itemize}
%%The [[match]] function matches a [[tyscheme]] with a [[ty]] and
%%returns a substitution.  In case of a mismatch, [[matchExn]] is
%%raised. 
%%
%%We never expect to see a [[Double]] constructor during matching. It should
%%only show up in the result position of a function type. Since only the
%%argument positions are matched, we should never see it here. However,
%%a succeeding match can bind a width variable that \emph{is} mentioned in
%%a [[Double]] result position.
%%
%%\emph{Is it possible to define a general match function where [[Double]]
%%can show up in all positions? -- CL}
<<types.ml>>=
let match' opname sigma expected actual =
  let to_string' = function
    | Bool -> to_string Bool
    | Bits (Const x) -> to_string (Bits x)
    | Bits (Var x) when S.mem x sigma -> to_string (Bits (lookup x sigma))
    | Bits _ -> "bitsxxx (not easily identified)" in
  let badarg () =
    E.errorf
      "operator %%%s expected argument of type %s, got %s (in unspecified position)"
      opname (to_string' expected) (to_string actual) in
  match expected, actual with
    | Bool          , Bool                      -> sigma
    | Bits(Const x) , Bits y when x = y         -> sigma

    | Bits(Var x)   , Bits y when S.mem x sigma -> if lookup x sigma = y then sigma
                                                   else badarg()
    | Bits(Var x)   , Bits y                    -> S.add x y sigma
    
    | Bits(Double x), Bits y when S.mem x sigma ->
        if (lookup x sigma) * 2 = y then sigma else badarg()
    | Bits(Double x), Bits y                    -> S.add x (y/2) sigma
    
    | Bits(Half x)  , Bits y when S.mem x sigma ->
        if (lookup x sigma) / 2 = y then sigma else badarg()
    | Bits(Half x)  , Bits y                     -> S.add x (y*2) sigma
    
    | _             , _                          -> badarg()
@
%%The [[subst]] function applies a substitution [[sigma]] to a [[size t]]
%%and returns a [[ty]].  In the context of C-- this must always succeed,
%%because primitive operators are predefined and only their type schemes
%%are used for matching and substitution.
<<types.ml>>=
let subst opname sigma = function
    | Bool             -> Bool
    | Bits(Const x)    -> Bits x
    | Bits(Var x)      -> (try Bits(lookup x sigma) with Not_found -> 
        E.errorf "operator %%%s is polymorphic;\n    to indicate the size, \
                  use a suffix such as %%%s32" opname opname)
    | Bits(Double x)   -> (try Bits(2*(lookup x sigma)) with Not_found ->
                                impossf "internal error (2) in application")
    | Bits(Half x)     -> (try Bits((lookup x sigma)/2) with Not_found ->
                                impossf "internal error (3) in application")
@
%%The [[appl]] function matches the argument types with the [[size t]]
%%values at the argument positions of a [[tyscheme]].  The resulting
%%substitution is applied to the result [[size t]] to get the result
%%[[ty]].
<<types.ml>>=
let wrongargs opname args' args =
  E.errorf "operator %s expected %d arguments, got %d"
    opname (List.length args') (List.length args)

let appl opname (args',r) args =
  let sigma = try List.fold_left2 (match' opname) S.empty args' args with
              | Invalid_argument _ -> wrongargs opname args' args in
  subst opname sigma r
@
%%The [[widthlist]] function takes the type of a primitive (a
%%[[tyscheme]]) and a list of argument types and returns the sizes bound
%%by the variables in the type scheme.
<<types.ml>>=
let widthlist opname (args',r) args =
  let sigma = try List.fold_left2 (match' opname) S.empty args' args with
              | Invalid_argument _ -> wrongargs opname args' args in
  let sorted = List.sort (fun (key1,_) (key2,_) -> compare key1 key2) (dump sigma) in
  List.map snd sorted
@
%%The implementation of [[spilt]] uses regular expressions to split off
%%a trailing number.
<<types.ml>>=
let rtlop = Str.regexp "^\\([A-Za-z0-9_]*[A-Za-z_]\\)\\([0-9]+\\)?$"

let split op =
    let matched n l = Str.matched_group n l in  
    if Str.string_match rtlop op 0 then
        let basename = matched 1 op in
        let size     = try Some (int_of_string (matched 2 op))
                       with Not_found -> None in
            (basename, size)
    else
        impossf "illegal operator %%%s?" op
@            
%$
%%[[Instantiate]] computes a monomorphic function type from a width list
%%and a polymorphic [[tyscheme]] by instantiating it. The $n$-th element
%%in the (zero based) width list instantiates [[Var]] $n+1$ in the
%%[[tyscheme]]. It is a checked run-time error if [[tyscheme]] contains a
%%variable [[Var]] $x$ where $x > |[[width]]|$. 
<<types.ml>>=
<<key size>>
let instantiate ((args,ret):tyscheme) ~widths  =
  if List.length widths <> largest_key (args, ret) then
    impossf "instantiated %d-key type scheme with %d widths"
      (largest_key (args, ret)) (List.length widths);
  let inst = function
    | Bits (Var i)   -> ( try Bits (List.nth widths (i-1)) with 
                        | Failure _ -> assert false
                        ) 
    | Bits (Double i)-> ( try Bits (2 * (List.nth widths (i-1))) with 
                        | Failure _ -> assert false
                        )
    | Bits (Half i)  -> ( try Bits ((List.nth widths (i-1))/2) with 
                        | Failure _ -> assert false
                        )
    | Bits (Const k) -> Bits k
    | Bool           -> Bool in
  (List.map inst args, inst ret)
@        
%%The implementation of the abbreviations is trivial:
<<types.ml>>=
let fixbits x        = assert (x > 0); Bits(Const x)
let var    x         = assert (x > 0); Bits(Var x)
let double x         = assert (x > 0); Bits(Double x)
let half   x         = assert (x > 0); Bits(Half x)
let bool             = Bool
let bits x           = Bits x
let proc args res    = (args,res)
@
<<key size>>=
let largest_key (args, res) =
  let rec count k = function
    | [] -> k
    | (Bool | Bits (Const _)) :: ws -> count k ws
    | (Bits (Var n) | Bits (Double n) | Bits (Half n)) :: ws -> count (max k n) ws in
  count 0 (res :: args)
@ 
<<types.ml>>=
let keyname = function
| 1 -> "n"
| 2 -> "m"
| n -> Printf.sprintf "t%d" (n-2)

let scheme_string (args, result) =
  let spr = Printf.sprintf in
  let ty = function 
    | Bits (Var i)    -> spr "#%s bits"   (keyname i)
    | Bits (Double i) -> spr "2*#%s bits" (keyname i)
    | Bits (Half i)   -> spr "#%s/2 bits" (keyname i)
    | Bits (Const k)  -> spr "#%d bits"   k
    | Bool            -> "bool" in
  let scheme = match args with
  | _ :: _ -> String.concat " * " (List.map ty args) ^ " -> " ^ ty result 
  | [] -> ty result in
  match largest_key (args, result) with
  | 0 -> scheme
  | n -> spr "\\/ %s . %s" (String.concat ", " (List.map keyname (Auxfuns.from 1 ~upto:n)))
                           scheme
@ 

\chapter{[[front_asm]]}

\section{[[front_asm/asm.nw]]}
<<front_asm/asm.ml>>=
<<asm.ml>>
@

<<front_asm/asm.mli>>=
<<asm.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% ------------------------------------------------------------------ 
\section{Abstract Assembler Interface}
%%% ------------------------------------------------------------------ 
%%
%%The code generators use this interface to access text-based and binary
%%assemblers. Assembler aspects like symbols and relocatable addresses
%%(from module \module{symbol}) escape the assembler and become part of
%%symbol tables and expressions.  To avoid that all aspects of the
%%compiler must be functorized over the different assemblers we have
%%chosen to use a very polymorphic interface that uses Objective Caml's
%%object system.
<<asm.mli>>=
<<exported type definitions(asm.nw)>>

val map : ('a -> 'b) -> 'b assembler -> 'a assembler
val reloc_string : (Bits.bits -> string) -> Reloc.t -> string
     (* make string form of relocatable address using mangled text of symbols *)
@ 
%%
<<exported type definitions(asm.nw)>>=
class type ['proc] assembler = object
    <<assembler methods>>
end
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Assembler Methods}
%%% ------------------------------------------------------------------ 
%%
%%The assembler interface has an imperative flavor: a client emits a
%%program by invoking a sequence of methods that mutate an [[assembler]]
%%object. Most methods result in some side effects, like emitting code to
%%a file, that cannot be observed directly.
%%
%%We want an assembler to be our single access point to the back end.
%%Therefore the assembler contains some methods that are not strictly
%%related to an assembler per se. We group these functions under [[etc]]
%%below.
<<assembler methods>>=
(* declarations *)
method import : string -> Symbol.t        (* any name is legal *)
method export : string -> Symbol.t        (* any name is legal *)
method local  : string -> Symbol.t        (* any name is legal *)

(* definitions *)
method label  : Symbol.t -> unit  (*bind symbol to current location counter*)
method const  : Symbol.t -> Bits.bits -> unit (*bind symbol to constant*)

(* section, location counter *)
method section : string -> unit
method current : string                 (* req: section called *)

method org     : int -> unit            (* set location counter       *)
method align   : int -> unit            (* align location counter     *)
method addloc  : int -> unit            (* increment location counter *)

(* size (bytes) of long jump instruction *)
method longjmp_size : unit -> int

(* emit instructions - add more methods for different instr types *)
method cfg_instr   : 'proc -> unit

(* emit data *)
method value  : Bits.bits -> unit
method addr   : Reloc.t -> unit  
method zeroes : int -> unit             (* n bytes of zeroes *)

(* announce number of global variables -- used only in interpreter *)
method globals : int -> unit            (* allocate space for n globals (not bytes) *)

(* comment *)
method comment: string -> unit 

(* emit *)
method emit: unit                       (* finalize *)
    (* should probably be called progend *)
@
%%
%%The most important abstraction is the symbol: a symbol \emph{must be
%%declared before it can be used}. Later a value is bound to the value.
%%The assembler must accept any name to declare a symbol for and hide the
%%idiosyncrasies of a possibly underlying real assembler.
%%
%%Symbols are most commonly used for labels.  The scope of a symbol
%%depends on its definition:
%%
%%\begin{enumerate}
%%\item [[local]]:  the value of the symbol is defined exactly once
%%      inside the compilation unit (program) at hand and not visible
%%      outside of it.
%%
%%\item [[import]]: the value of the symbol is defined once in another
%%      compilation unit but made visible in the compilation unit at hand
%%      by an import declaration. No symbol exported from the module at
%%      hand can be imported.
%%
%%\item [[export]]: a [[local]] symbol is additionally exported such that
%%      other compilation units can import it. No imported symbol can be
%%      exported.
%%\end{enumerate}      
%%
%%An assembler maintains named \emph{sections} and for each section a
%%\emph{location counter}.  The [[section]] method announces the start
%%of a new section, the [[current]] method returns the currently active
%%section. It is an unchecked run-time error to call [[current]] before
%%[[section]].  
%%
%%The [[label]] method binds the current value of the location counter to
%%a symbol. In a textual assembler this typically done by emitting a
%%label. The [[const]] method binds a symbol to an explicitly given value.
%%
%%The location counter of the current section can be manipulated: [[align
%%n]] aligns to the next multiple of [[n]], [[addloc n]] increments it,
%%and [[org n]] sets it to [[n]]. In all cases [[n]] must be positive.
%%
%%The main task of an assembler is to emit data and instructions. 
%%To emit data into the current section, use [[value]] to emit an
%%arbitrary value, [[addr]] to 
%%emit a relocatable address, or [[zeroes]] to emit a string of zeroes.
%%While [[value]] could be subsumed by [[addr]] and is therefore not
%%strictly necessary, it is a convenient special case.
%%Clients should use it when possible and should expect to realize a
%%small gain in efficiency.
%%
%%The method [[cfg_instr]] emits all the instructions and labels for a
%%procedure; the bytes go into the current section.
%%
%%
%%Comments are emitted using [[comment]]. It is an unchecked run-time
%%error if the string argument contains a newline. 
%%
%%After all instructions and data has been passed to an [[assembler]]
%%object the [[emit]] method must be called. It finishes any remaining
%%business. It is an unchecked run-time error to invoke any [[assembler]]
%%method subsequently.
%%
%%
<<asm.ml>>=
<<exported type definitions(asm.nw)>>

class ['proc] mapped_asm f (asm : 'a assembler) : ['proc] assembler =
object
    (* declarations *)
    method import s = asm#import s
    method export s = asm#export s
    method local  s = asm#local s

    (* sections *)
    method section s = asm#section s
    method current   = asm#current 

    (* definitions *)
    method label s   = asm#label s
    method const s b = asm#const s b

    (* locations *)

    method org n    = asm#org n
    method align n  = asm#align n
    method addloc n = asm#addloc n

    (* instructions *)
    method longjmp_size () = asm#longjmp_size ()
    method cfg_instr proc = asm#cfg_instr (f proc)

    method globals n = asm#globals n
    method zeroes n = asm#zeroes n
    method value v = asm#value v
    method addr  a = asm#addr a
    method comment s = asm#comment s
    method emit = asm#emit
end
let map f asm = new mapped_asm f asm
@ 
<<asm.ml>>=
let reloc_string const =
  let sym (s, _) = s#mangled_text in
  let infix op a b = String.concat "" [a; " "; op; " "; b] in
  Reloc.fold ~const ~sym ~add:(infix "+") ~sub:(infix "-")
@

\chapter{[[front_fenv]]}

\section{[[front_fenv/block.nw]]}
<<front_fenv/block.ml>>=
<<block.ml>>
@

<<front_fenv/block.mli>>=
<<block.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Please add grades for this module below. The line must start with % "%%".
%%% 
%%
%%%%Grades: B Subsystem Later
%%
%%
%%% ------------------------------------------------------------------ 
\section{Memory Blocks}
%%% ------------------------------------------------------------------ 
%%
%%This module provides composable memory blocks: complex blocks composed
%%from simpler blocks using two operations. Their main application is the
%%construction of a stack frame. The design of the abstraction and its
%%application to stack frame composition is also discussed in the paper
%%\emph{Declarative Composition of Stack Frames} by Lindig and Ramsey [To
%%appear in Proc. of the 14th International Conference on Compiler
%%Construction, 2004, Springer].
%%
%%A block represents a contiguous piece of memory at run time,
%%characterized by four properties at compile time: a base address
%%expression $b$, a fixed size $s$, and a alignment requirement $a$. At
%%run time, a block occoupies the address interval $b, \dots, b+s$ and $b$
%%is $a$-aligned: $b \bmod a =0$ holds. The fourth property is a set of
%%additional constraints for the base address that result from block
%%operations. All four properties can be observed.
%%
<<block.mli>>=
type t

val base:           t -> Rtl.exp
val size:           t -> int
val alignment:      t -> int
val constraints:    t -> Rtleqn.t list
@
%%
%%\paragraph{Block Creation} A block is constructed by providing a base
%%address, size, and alignment.  Such a block is otherwise unconstrained.
%%Usually, constraints result from block operations and there is no need
%%to mention them explicitly.  Having said that, [[with_constraint]] adds
%%a constraint to an existing block.
%%
<<block.mli>>=
val at:                 base:Rtl.exp -> size:int -> alignment:int -> t
val with_constraint:    t -> Rtleqn.t -> t
@
%%
%%We often wish to create a block at an unknown offset from a known place.
%%Function [[relative]] is a higher-order function that we use to solve
%%this problem.  Calling [[relative e s f]] builds an address at unknown
%%offset from [[e]], where the name [[s]] is used somehow in constructing
%%the address (for debugging).  It then calls function [[f]] on this
%%address.  Example use is [[relative vfp "slot" at ~size:0
%%~alignment:1]].  This function might more properly live in module
%%[[Idgen]].
%%
%%Function [[srelative]] is just like [[relative]], except that its
%%argument uses a different label.  To hell with labels!
<<block.mli>>=
val relative  : Rtl.exp -> string -> (base:Rtl.exp  -> 'a) -> 'a
  (* construct address at unknown offset and call function *)
val srelative : Rtl.exp -> string -> (start:Rtl.exp -> 'a) -> 'a
  (* construct address at unknown offset and call function *)

(* pad: ugly *)
val _empty_vfp_hook: (Rtl.width -> t) ref
@
%%
%%\paragraph{Block Operations} Block composition is guided by
%%interference: Two blocks whose data are live at the same time can be
%%concatenated into one bigger block that holds both. Two blocks whose
%%life times are disjoint can be overlapped into one block where they
%%share memory.
%%
<<block.mli>>=
exception OverlapHigh
type placement      = High | Low
val cathl:          t -> t -> t
val overlap:        placement -> t -> t -> t   (* OverlapHigh *)
@
%%
%%The operation [[cathl hi lo]] concatentes two block such that [[hi]]
%%sits atop of [[lo]] in memory. Caution: the argument order is counter
%%intuitive! The placement guarantees the alignment reuqirements of the
%%constituents. For this reason, the two blocks may be not directly
%%adjacent in the result, but separated by a small gap.
%%
%%The operation [[overlap p x y]] places [[x]] and [[y]] according to the
%%placement strategy [[p]]: [[overlap Low]] aligns the two blocks at their
%%lower ends, [[overlap High]] at their upper ends in the resulting block. 
%%Overlapping at the high end may fail, in which case [[OverlapHigh]] is
%%raised. To succeed, the size difference of [[x]] and [[y]] must be a
%%multiple of the smaller blocks's alignment. For this reason is
%%overlapping at the high end rarely used.
%%
%%\paragraph{Convenience Functions} The following functions are
%%implementable in terms of the primitive functions above. The list
%%functions take the width of an address expression as argument;
%%if the list is empty, then an empty block is returned.
%%
<<block.mli>>=
val adjust:         t -> t                  (* size is multiple of alignment *)
val cathl_list:     Rtl.width -> t list -> t
val overlap_list:   Rtl.width -> placement -> t list -> t
@
%%
\subsection{Lua Interface}
%%
%%Blocks are exported as abstract user data to Lua. The [[Block.relative]]
%%function does not take an address directly, but another block whose
%%address $a$ is used to form a new address $a+k$, where $k$ is a late
%%compile-time constant derived from the string argument. The other two
%%arguments provide size and alignment.
%%
<<block.mli>>=
module Lua: sig
    val relative:   t -> string -> int (*size*) -> int (* align *) -> t
    (* observer *)
    val base:       t -> string         (* show base address *)
    val constraints:t -> string list    (* for debugging *)
    val size:       t -> int
    val alignment:  t -> int
    (* operations *)
    val adjust:     t -> t
    val cat:        Rtl.width -> t list -> t
    val overlap:    Rtl.width -> placement (* "high"|"low"*) -> t list -> t   

    val eq : t -> t -> bool
end
@
%%
\subsection{Implementation}
%%
<<block.ml>>=
module C  = Rtleqn
module RU = Rtlutil

type t =
    { base:         Rtl.exp
    ; size:         int
    ; alignment:    int
    ; constraints:  C.t list
    }

let base t          = t.base
let size t          = t.size
let alignment t     = t.alignment
let constraints t   = t.constraints

let at ~base ~size ~alignment =
    { base          = base
    ; size          = size
    ; alignment     = alignment
    ; constraints   = []
    }
let with_constraint t c = {t with constraints = c :: t.constraints}

let relative anchor dbg f = 
  let w = RU.Width.exp anchor in
  f ~base:(RU.add w anchor (Rtl.late (Idgen.offset dbg) w))
let srelative anchor dbg f = relative anchor dbg (fun ~base -> f ~start:base)
@
%%
%%\paragraph{Utilities} Function [[align x n]] returns the smallest
%%multiple of $n$ that is not smaller than $x$. Think of $x$ becoming
%%$n$-aligned. Function [[add]] adds an integer to an {\rtl} expression
%%and returns an {\rtl} expression.
%%
<<block.ml>>=
let align x n = Auxfuns.round_up_to ~multiple_of:n x
let add exp i = RU.addk (RU.Width.exp exp) exp i
@
%%
%%Function [[offset]] creates an address relative to a [[base]] address
%%using [[name]] to generate a late compile-time constant. Function
%%[[empty]] provides an empty block addressed from the virtual frame
%%pointer. 
%%
<<block.ml>>=
let offset base name ptrwidth =
    RU.add ptrwidth base (Rtl.late (Idgen.offset name) ptrwidth)

let _empty_vfp_hook = ref (fun ptrwidth -> failwith "_empty_vfp_hook not set")
let empty ptrwidth = 
  !_empty_vfp_hook ptrwidth
(* pad: was 
    relative (Vfp.mk ptrwidth) "empty block" at ~size:0 ~alignment:1
  but it was bringing too many dependencies
*)
@
%%
%%\paragraph{Block Operations} When concatenating, we have to leave a gap
%%between the first and the second block to make sure we respect the
%%alignment of the second block.  We do so by virtually increasing the
%%size of the first block to [[size']] which is a multiple of the second
%%block's alignment. The alignment of the resulting block is the maximum
%%of the two incoming alignments.
%%
<<block.ml>>=
let cathl hi lo =
    let size' = align (size lo) (alignment hi) in
        { base          = base lo
        ; size          = size' + size hi
        ; alignment     = max (alignment lo) (alignment hi)
        ; constraints   = C.equate (add (base lo) size') (base hi)  
                          :: (constraints lo) @ (constraints hi) 
        }
@
%%
%%Overlapping at the high is impossible if a precondition isn't met. We
%%check it and raise [[OverlapHigh]] when it is violated.
%%
<<block.ml>>=
type placement = High | Low
exception OverlapHigh

let overlap place x y = match place with
    | Low ->      
        { base          = base x
        ; size          = max (size x) (size y)
        ; alignment     = max (alignment x) (alignment y)
        ; constraints   = C.equate (base x) (base y)
                          :: (constraints x) @ (constraints y)
        }    
    | High -> let x,y = if size x < size y then x,y else y,x in
        if (size y - size x) mod (alignment x) <> 0 then raise OverlapHigh else
        { base          = base y    (* y is the larger block *)
        ; size          = size y
        ; alignment     = max (alignment x) (alignment y)
        ; constraints   = C.equate (add (base x) (size x))
                                   (add (base y) (size y))
                          :: (constraints x) @ (constraints y)
        }           
@ 
%%
%%\paragraph{Convenience Functions}
%%
<<block.ml>>=
let adjust t = { t with size = align (size t) (alignment t) }
let cathl_list w = function
  | [] -> empty w
  | b :: bs -> List.fold_left cathl b bs
let overlap_list w p = function
  | [] -> empty w
  | b :: bs -> List.fold_left (overlap p) b bs
@
%%
%%\paragraph{Export to Lua} We export the block abstraction to Lua. The
%%actual export is handled in module \module{lualink}. Here we just
%%provide the {\ocaml} functions that implement the new Lua primitives and
%%the representation [[T]] for blocks in Lua..  
%%
%%The Lua version of [[relative]] differs from the Caml version in that
%%the anchor address is the base address of an existing block.
%%
<<block.ml>>=
module Lua = struct 
    let size      = size 
    let alignment = alignment 
    let adjust    = adjust
    let cat     = cathl_list
    let overlap = overlap_list
        
    let constraints block = List.map Rtleqn.to_string (constraints block)

    let relative block name size alignment =
      relative (base block) name at ~size ~alignment
    let base block        = Rtlutil.ToString.exp (base block)

    let eq b1 b2 =
      b1.size = b2.size && b1.alignment = b1.alignment &&
      Rtlutil.Eq.exp (Rtl.Dn.exp b1.base) (Rtl.Dn.exp b2.base) (* ignore constraints! *)

end
@
%%Norman suggested to have overlap and concatenation functions in Lua that
%%take any number of parameters which can be either blocks or lists
%%(tables) of blocks. This amounts to functions that take a list of Lua
%%values.
%%
\section{[[front_fenv/eqn.nw]]}
<<front_fenv/eqn.ml>>=
<<eqn.ml>>
@

<<front_fenv/eqn.mli>>=
<<eqn.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim:ts=8 sw=4 et:
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{Linear Equations over Integers}
%%% ------------------------------------------------------------------ 
%%
%%\begin{quote}\it
%%    I like to propose an interface change: forget [[empty]] and
%%    [[make_zero]]. Only provide [[solve]] and let it take a list of
%%    sums, each known to be zero. --CL (Fri May 10 15:26:10 EDT 2002)
%%\end{quote}
%%
%%This module provides a solver for linear equations: the solver takes a
%%set of linear equations as input and finds the values of the embedded
%%variables. A linear equation has the form $\sum_{i} c_i t_i = 0$ where
%%each coefficient $c_i$ is an integer and each term $t_i$ is either a
%%variable ($v$) or a non-zero constant ($k$): $t ::= v | k$. From a set
%%of linear equations the solver determines the values for each variable
%%$v = \sum_{j} c_j t_j$ where each $c_j$ is an integer.  This means, in
%%the solution each variable is expressed as a linear combination of
%%terms. To determine $n$ variables, $n$ independent equations are
%%necessary. If this condition is met, each $t_j$ in a variable's
%%denotation is a constant. Otherwise $t_j$ may still be a variable. In
%%that case the solution can be considered a constraint system. 
%%
%%The algorithm for equation solving is basically the one suggested by
%%\cite{Derman:1984:SES} and \cite{Ramsey:1996:SSL}, which are in turn
%%inspired by Knuth's incremental algorithm that is implemented in his
%%Metafont software (\cite{Knuth:1979:TMN} Chapter 4, \cite{Knuth:1986:MP}
%%\S~585).  However, Knuth's algorithm assumes that coefficients $c_i$ and
%%terms denote floating point values and thus it cannot be used unaltered
%%in the integer domain. The solver used here works in the integer domain,
%%but is incomplete, i.e.~it sometimes fails to find an existing solution.
%%We believe that this does not pose a problem for the intended
%%application.
%%
%%The solver keeps two data structures: a \emph{set} of equations, and a
%%\emph{map} from variables to terms. The map records solutions found for
%%variables and is initially empty. The set consists of terms that are
%%known to be zero. In the example below terms are variables $v$ or
%%unit constants:
%%
%%\begin{eqnarray*}
%%    3 v_1 + 5 v_2 &=& 0 \\
%%    2 v_2 + 3 v_3 &=& 0 \\
%%    2 v_1 - 5 v_3 &=& 0 \\
%%      v_2 + 3     &=& 0
%%\end{eqnarray*}
%%
%%The equations in the set are kept in \emph{normal form}: each equation
%%is divided by the greatest common divisor of its coefficients. In the
%%example above, equations are in normal form. If the first equation were
%%$9 v_1 + 15 v_2 = 0$ it would have been divided by
%%$\mathrm{gcd}(9,15)=3$ before it were entered into the set. To make
%%progress, the solver scans all equations in the set for a variable with
%%unit ($\pm 1$) coefficient: if it cannot find a unit variable it
%%considers the equations unsolvable. In the example above it finds $v_2 +
%%3 = 0$ and rewrites it to $v_2 = -3$. This solution is recorded in the
%%map, applied to the (empty map), and the set, which is subsequently
%%normalized. Redundant equations ($0=0$) are removed.
%%
%%\begin{eqnarray*}
%%      v_2           &\mapsto& -3 \\ 
%%      v_1 - 5       &=& 0  \\ % 3 v1 + 5 v2 = 3 v1 - 15 = v1-5
%%      -2 + v_3      &=& 0  \\ % 2 v2 + 3 v3 = -6 + 3 v3 = -2+v3
%%      2 v_1 - 5 v_3 &=& 0 
%%\end{eqnarray*}
%%
%%In the next round the solver finds $v_1 -5 = 0$ and rewrites it to
%%$v_1 = 5$:
%%
%%\begin{eqnarray*}
%%      v_2         &\mapsto& -3 \\
%%      v_1         &\mapsto& 5  \\
%%      -2 + v_3    &=& 0 \\ 
%%      2 - v_3     &=& 0  
%%\end{eqnarray*}
%%
%%And finally: $v_3 = 2$, which yields the solution: $v_2 = -3$, $v_1 =
%%5$, and $v_3 = 2$.
%%
%%In the general case the intermediate solutions in the map are also sums
%%containing variables: variables on the left hand side of the map are
%%\emph{dependent} on the \emph{independent} variables on the right hand
%%side. Initially all variables are independent; during the solving
%%process more and more variables become dependent, and later \emph{known}
%%when their right hand side contains no longer variables.
%%Whenever a new term for a variable is found it must be used to rewrite the set
%%\emph{and} the map. However, only the set is normalized after such a step.
%%
%%In practice, we delay the rewriting of each equation in the set until it is
%%next examined (i.e. we perform lazy updates).
%%Why? Because when we have a large number of variables and equations,
%%we don't want to rewrite the equations a quadratic number of times.
%%We take another measure to ensure the efficiency of rewriting the environment:
%%we keep track of which environment bindings depend on variables, so when a variable
%%changes, we update only the environment bindings that depend on the variable.
%%
%%Here is a set of equations that the solver cannot find the solution $v_1
%%= 3$, $v_2 = -5$ for:
%%
%%\begin{eqnarray*}
%%    8 v_1 - 9 v_2 - 69 &=& 0 \\
%%    5 v_1 + 3 v_2      &=& 0
%%\end{eqnarray*}
%%
%%The equations are in normal form but there is no unit coefficient the
%%solver could use to rewrite one equation. To overcome this, one could
%%take the normalization one step further and subtract equations from each
%%other in a directed way to create unit coefficients.
%%
%%% ------------------------------------------------------------------ 
\subsection{Interface}
%%% ------------------------------------------------------------------ 
%%
%%The equation solver is parameterized over the representation of terms.
%%Observation functions are used by the solver to inspect a term.
%%If and only if a term [[t]] is a variable the function [[variable]]
%%returns a [[string]] representing the variable, and [[None]] otherwise.
%%For efficiency, a total order [[compare]] must be defined on terms.
%%
<<EXP>>=
module type EXP = sig
    type t                                      (* a term *)
    val variable: t -> string option            
    val compare: t -> t -> int                  (* -1/0/1 *)
    val print: t -> string                      (* for debugging *)
end
@
%%
%%The solver maintains a set [[t]] of equations. A [[sum]] is a linear
%%combination of [[terms]] with integers as coefficients.  An equation is
%%added to [[t]] by [[make_zero]]: it takes a set [[t]], a [[sum]]  $s$,
%%and adds the equation $s=0$ to the set [[t]]. The solver reports its
%%results as two lists that associate each variable with its term: the
%%known and the dependent variables. If too few equations are given to
%%eliminate all variables terms found for dependent variables still
%%contain variables, in contrast to the terms of known variables. If the
%%solver fails to find a solution, [[Can'tSolve]] is raised. This
%%indicates an internal compiler error. Since [[t]] is abstract the value
%%returned by the [[Can'tSolve]] exception is not useful for a client.
%%
<<S(eqn.nw)>>=
module type S = sig
    type t                                      (* set of equations *)
    type term
    type sum      = (int * term) list

    exception Can'tSolve of t

    type solution = 
        { known:     (string * sum) list
        ; dependent: (string * sum) list
        }

    val empty:          t                       (* empty set of equations *)
    val make_zero:      sum -> t -> t           (* add equation *)
    val solve:          t -> solution           (* Can'tSolve *)
end
@ 
%%
<<eqn.mli>>=
<<EXP>>
<<S(eqn.nw)>>
module Make (E: EXP): S with type term = E.t
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation works almost as explained at the beginning of this
%%section. An equation $\sum_i c_i t_i = 0$ is represented as the [[sum]]
%%$\sum c_i t_i$ where the components are ordered with respect to the
%%total term order: if $\prec$ represents the order of terms, the
%%following holds: $t_i \prec t_j \Rightarrow i < j$. In addition, no term
%%$t$ appears twice in a sum.
%%
<<eqn.ml>>=
open Nopoly

<<EXP>>
<<S(eqn.nw)>>
module Make (E: EXP) = struct
    type term     = E.t

    <<Make(eqn.nw)>>
end    

module Test = struct
    <<Test>>
end
@
%%Type [[t]] represents a set of equations, the solutions for variables
%%found so far, and a mapping from a variable to the solutions that depend
%%on the variable (for efficiency, as explained above).
%%An initially [[empty]] set has no equations and no solutions.
<<Make(eqn.nw)>>=
type sum   = (int * E.t) list                 (* invariant: ordered *)
type assoc = string * sum

type solution = 
    { known     : (string * sum) list
    ; dependent : (string * sum) list
    }

module SM = Map.Make (struct type t = string let compare = compares end)
type t   = 
    { set  : sum list          (* invariant: normalized *)
    ; env  : sum SM.t
    ; deps : string list SM.t
    }

let empty = 
    { set  = []
    ; env  = SM.empty
    ; deps = SM.empty
    }

exception Can'tSolve of t
let error msg = raise (Can'tSolve msg)
@
%%The [[dump]] function prints a [[t]] value to [[stdout]] for debugging.
%%Because terms are abstract they cannot be printed, except when they
%%denote variables. It helped to track down some bugs, though.
<<Make(eqn.nw)>>=
let dump t =
  let spr = Printf.sprintf in
  let product (i,term) =
    if i = 1 then
      E.print term
    else
      spr "%d * %s" i (E.print term) in
  let sum = function
    | [] -> "0"
    | s  -> String.concat " + " (List.map product s) in
  let eqn s =
    let pos = List.filter (fun (i, t) -> i >= 0)  s in
    let neg = List.filter (fun (i, t) -> i <  0)  s in
    let neg = List.map    (fun (i, t) -> (-i, t)) neg in
    spr "  %s = %s" (sum pos) (sum neg) in
  let assoc v s rst = spr "  %s :-> %s" v (sum s) :: rst in
  let multiple f s = String.concat "\n" (List.map f s) in
  let set f s = String.concat "\n" (SM.fold assoc s []) in
  Printf.printf
    "Eqn.t: unsolved equations\n%s\n------ solved variables:\n%s\n------ Eqn.t ends\n"
    (multiple eqn t.set) (set assoc t.env);
  flush stdout
@
%%Normalizing an equation means dividing it by the greatest common
%%divisor (gcd) of its coefficients. The gcd of two numbers is found by
%%the following algorithm \cite{Knuth:ACP68-1}:
<<Make(eqn.nw)>>=
let rec gcd (m:int) (n:int) =
    let rec g m n = if n = 0 then m else g n (m mod n) in
        if  n < 0 then
            gcd m (- n)
        else if m < n then gcd n m
        else g m n

let normalize = function
    | [] -> []
    | ((c,_)::rest) as sum ->
        let g = List.fold_left (fun k (c,_) -> gcd k c) c rest in
            if g > 1 then
                List.map (fun (c,t) -> (c / g, t)) sum
            else
                sum
@            
%%The central operation on sums $s_1$, $s_2$ is the computation of their
%%linear combination $c s_1 + s_2$.  The function [[combine]] does this by
%%taking advantage of the ordering of terms. Any component with a
%%coefficient of zero does not appear in the result.
<<Make(eqn.nw)>>=
let combine (k1:int) (sum1:sum) (sum2:sum) =
    let rec loop = function 
 | []                 , [] -> []
 | ((c1,x1)::s1 as _x) , ((c2,x2)::s2 as y) when E.compare x1 x2 < 0 ->
            let k = k1 * c1 in
            if k = 0 then loop (s1, y) else
            (k, x1) :: loop (s1, y) 
 | ((c1,x1)::s1) , ((c2,x2)::s2) when E.compare x1 x2 = 0 -> 
            let k = k1 * c1 + c2 in 
            if k = 0 then loop (s1, s2) else
     (k, x1) :: loop (s1, s2)
 | ((c1,x1)::s1 as x) , ((c2,x2)::s2 as _y)  (*   x1 > x2 *) ->
            let k = c2 in
            if k = 0 then loop (x, s2) else
            (k, x2) :: loop (x, s2)
 | ((c1,x1)::s1) , [] ->
            let k = k1 * c1 in
            if k = 0 then loop (s1, []) else
            (k, x1) :: loop (s1, [])
 | []                 ,  ((c2,x2)::s2) ->
            let k = c2 in
            if k = 0 then loop ([], s2) else
            (k, x2) :: loop ([], s2)
    in
 loop (sum1,sum2)
@
%%For the substitution of a variable, the variable must be found in a sum.
%%The [[split]] function takes a variable $v$ and a sum $s$ and returns
%%the coefficient $c$ of $v$ in $s = + \dots c v + \dots$ and $s - cv$. If
%%$v$ does not appear in $s$, then $c = 0$ is assumed.
<<Make(eqn.nw)>>=
let split (v:string) (sum:sum) =
    let rec loop a = function
        | []             -> (0, sum)
        | (c,t as ct)::s -> 
            ( match E.variable t with
            | Some v' when v =$= v' -> (c, List.rev a @ s)
            | _                     -> loop (ct::a) s
            )
    in 
        loop [] sum
@    
%$
%%Elimination of a variable $v$ in a sum $s = \dots + c t + \dots$ means
%%replacing $c t$ with the value of $c v$. The [[elim]] function takes a
%%variable [[v]], its value [[vsum]] and replace it in [[sum]].
<<Make(eqn.nw)>>=
let elim (v:string) (vsum:sum) (sum:sum) =  
    match split v sum with
    | (0,_)    -> sum
    | (c,sum') -> combine c vsum sum'
@
%%To update equations (or, more accurately, the solution environment),
%%we need to know the variables in an equation.
<<Make(eqn.nw)>>=
let vars (sum:sum) =
  let rec loop vs = function
    | (_, t)::s ->
       ( match E.variable t with
       | Some v -> loop (v::vs) s
       | _      -> loop vs s
       )
    | [] -> vs in 
  loop [] sum
@
%%Given an environment, the [[elim_all]] function replaces each variable in the
%%[[sum]] with its soultion in [[env]].
<<Make(eqn.nw)>>=
let elim_all env (sum:sum) =
  let vs = vars sum in
  List.fold_left (fun sum v -> try elim v (SM.find v env) sum
                               with Not_found -> sum) sum vs
@
%%A [[sum]] is zero, only if it is empty or all coefficients are zero.
<<Make(eqn.nw)>>=
let rec zero = function
   | []                        -> true
   | (0,_)::rest               -> zero rest
   | _                         -> false
@
%%To make progress, the solver scans the set of equation and tries to find
%%a variable $v$ with a unit ($\pm 1$) coefficient. If this succeeds, the
%%equation $s=0$ that the variable is part of is rewritten to
%%$v=\mathit{vsum}$, and the pair $(v, \mathit{vsum})$ is returned. 
%%Before considering each equation, the equation must be updated with the solutions we
%%have found, and normalized (this is the lazy equation update).
%%As a consequence of lazy update, we must be prepared to find that all the
%%equations are zero sums.
%%Hence, the function takes two continuations as arguments:
%%[[found]] is called when a candidate variable is found;
%%[[finished]] is called if there are no non-zero sums.
<<Make(eqn.nw)>>=
let candidate t found finished =
    let negate          = List.map (fun (c,trm) -> (-c,trm))                       in
    let unitvar (c,trm) = Auxfuns.Option.is_some (E.variable trm) && (c = 1 || c = -1) in
    let rec loop accum_set = function
       | []        -> (* all eqns scanned *)
           (match accum_set with
           | [] -> finished { t with set = accum_set }
           | _  -> error    { t with set = accum_set }
           )
       | sum::sums -> 
           let sum = normalize (elim_all t.env sum) in
           if zero sum then
             loop accum_set sums
           else 
             try let v      = match E.variable (snd (List.find unitvar sum)) with
                              | Some v -> v
                              | None   -> assert false in   
                 let c,vsum = split v sum in 
                     match c with
                     | -1 -> found (v, vsum,        { t with set = accum_set @ sums })
                     |  1 -> found (v, negate vsum, { t with set = accum_set @ sums })
                     | _  -> assert false    (* c is a unit, i.e. +/-1 *)
             with Not_found -> loop (sum::accum_set) sums (* check next equation *)
    in
        loop [] t.set
@
%%An elimination step on the level replaces a variable by
%%its value in all found solutions that depend on the variable
%%(as witnessed by the [[deps]] map).
%%Then, the [[deps]] map must be updated:
%%the solutions that depended on the new variable must be updated to depend
%%on the variables in the new solution,
%%and the new variable must be added.
%%Finally, the new solution $v \mapsto \mathit{vsum}$ is recorded.
<<Make(eqn.nw)>>=
let update (v:string) (vsum:sum) t =
  let find x map = try SM.find x map with Not_found -> [] in
  let depends_on_v = find v t.deps in
  let env = List.fold_left (fun env v' -> SM.add v' (elim v vsum (SM.find v' env)) env)
                           t.env depends_on_v in
  let vs = vars vsum in
  let new_deps = v :: depends_on_v in
  let add deps v' = SM.add v' (new_deps @ find v' deps) deps in
  { set  = t.set
  ; env  = SM.add v vsum env
  ; deps = List.fold_left add t.deps vs
  }
@
%%The [[solver]] iterates over [[t]] as long as it can find a candidate
%%variable for elimination. 
<<Make(eqn.nw)>>=
let solver t =
  let rec loop t =
    candidate t (fun (v, vsum, t') -> loop (update v vsum t')) (fun t' -> t') in
  loop t
@
%%After all equations have been eliminated, the solution can be found in
%%the [[t.env]] value. To eliminate $n$ variables, $n$ independent
%%equations are necessary. If this condition is violated, the problem is
%%under-specified and the terms of variables still contain independent
%%variables.  The solution [[env.t]] is partitioned into two association
%%lists: the first includes all variables that are completely known, the
%%second all other, i.e. those that still depend on variables.
%%
<<Make(eqn.nw)>>=
let solve t =
  (* let ()     = dump t in *)
  let t         = try solver t with Can'tSolve x -> (dump x; error x)in
  (* let ()     = dump t in *)
  let known sum = List.for_all (fun (_,e) -> Auxfuns.Option.is_none (E.variable e)) sum in
  let k,d       =
    SM.fold (fun s sum (k,d) -> if known sum then ((s,sum)::k,d) else (k, (s,sum)::d))
            t.env ([], []) in
      { known     = k
      ; dependent = d
      }
@        
%%   
%%The [[make_zero]] function establishes the invariants for equations:
%%coefficients are normalized and ordered by variables. Identical terms
%%are merged by adding their coefficients.
%%
<<Make(eqn.nw)>>=
let rec merge sum =  match sum with
    | []       -> []
    | [_] as x -> x
    | (c1,t1 as ct1)::((c2,t2)::rest1 as rest2)  ->
        if E.compare t1 t2 = 0 then
            if c1+c2 <> 0 then
                merge ((c1+c2,t1)::rest1)
            else
                merge rest1     (* drop zero coefficient *)
        else
            ct1 :: merge rest2


let make_zero (sum:sum) (t:t) =
  let cmp (_,tx) (_,ty) = E.compare tx ty in 
  let eqn = normalize (merge (List.sort cmp sum)) in
  let r   = { t with set = eqn::t.set } in
  (* dump t; *)
  match eqn with [] -> t | _ :: _ -> r
        
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Test}
%%% ------------------------------------------------------------------ 
%%
<<Test>>=
module E = struct
    type t = Var of string
           | Unit
           | Const of string

    let variable = function
        | Var s  -> Some s 
        | _      -> None
        
    let compare : t -> t -> int = Pervasives.compare

    let print = function
        | Var(s) -> s
        | Unit     -> "1"
        | Const(s) -> s
end

module S = Make(E)

let test eqns =
    let t = List.fold_left (fun t eqn -> S.make_zero eqn t) S.empty eqns
    in
        S.solve t

let eqns1 =
    [ [3,E.Var "x";5   ,E.Var "y"]
    ; [2,E.Var "y";3   ,E.Var "z"]
    ; [3,E.Var "x";(-3),E.Var "x"]
    ; [2,E.Var "x";(-5),E.Var "z"]
    ; [3,E.Unit   ;1   ,E.Var "y"]
    ]
let eqns2 =
    [ [-3,E.Unit;1, E.Var "x"; 1, E.Var "y"; 1, E.Var "z"]
    ; [-1,E.Unit;1, E.Var "x";-1, E.Var "y";-1, E.Var "z"]
    ; [4, E.Unit;1, E.Var "z"]
    ]


let eqns3 =
    [ [3,E.Var "x";5   ,E.Var "y"; 3,E.Const "k1"]
    ; [2,E.Var "y";3   ,E.Var "z"]
    ; [3,E.Var "x";(-3),E.Var "x"]
    ; [2,E.Var "x";(-5),E.Var "z"; 2,E.Const "k1"]
    ; [3,E.Unit   ;1   ,E.Var "y"; 3,E.Const "k3"]
    ]
    
(*
let _ = assert 
        (test eqns1 = 
            { S.known = ["x", [5, E.Unit]; "z", [2, E.Unit]; "y", [-3, E.Unit]]
            ; S.dependent = []
            })
                
let _ = assert 
        (test eqns2 = 
            { S.known = ["y", [5, E.Unit]; "x", [2, E.Unit]; "z", [-4, E.Unit]]
            ; S.dependent = []
            })
*)        

@ 
\section{[[front_fenv/fenv.nw]]}
<<front_fenv/fenv.ml>>=
<<fenv.ml>>
@

<<front_fenv/fenv.mli>>=
<<fenv.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 et sts=4 sw=4
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%\iffalse
%%Clients:
%%
%%Driver: check produces env, compile consumes it
%%  
%%  check: Dirty.empty, Dirty.push, Dirty.emptyscope, Dirty.errorFlag Fenv.clean
%%  also: consistency check with target
%%
%%  lualink: Driver.check, Driver.compile need env type (no ops)
%%
%%\fi
%%
%%% ------------------------------------------------------------------ 
\section{The Fat Environment}
%%% ------------------------------------------------------------------ 
%%
%%The meaning, or denotation, of names in a {\PAL} program are recorded
%%in an environment.  Because only one environment is used for all
%%different kinds of names, it is called fat.  The fat environment not
%%only serves the classic symbol table purpose, but also represents some
%%global state of the compiler.  It is used to pass around informations
%%between the different phases of the compiler.  In particular the fat
%%environment holds informations about:
%%\begin{itemize}
%%\item Values, like constants, labels for goto and data, procedures.
%%\item Types, as they are declared by the [[typedef]] directive.
%%\item A flag that indicates a serious error.
%%\end{itemize}
%%
%%The fat environment comes in two variants:  a \textit{dirty} and a
%%\textit{clean} one.  A dirty environment is built during the first
%%phases of compilation:  names bound in a dirty environment can be
%%either good or bad.  The error propagation combinators from the
%%\module{error} module are used to deal with good and bad values. 
%%After the semantics of a {\PAL} program are checked and when no errors
%%were found a dirty environment is known to bind only good values.  At
%%this point a clean environment can be generated from the dirty one. 
%%The clean environment is easier to deal with since it guarantees
%%statically that all its bound values are good.
%%
%%% ------------------------------------------------------------------ 
\subsection{Interface: Clean vs.~Dirty}
%%% ------------------------------------------------------------------ 
%%
%%A dirty and a clean environment are structurally too different for one
%%polymorphic implementation of an environment to provide both.  As a
%%consequence, two modules are provided:  [[Dirty]] and [[Clean]]. 
%%However, the interfaces of both modules still can be derived from a
%%single interface [[Env]]:
%%
<<exported signature [[Env]]>>=
module type Env = sig
    type 'a info
    type 'a partial
    val  bad: unit -> 'a info

    <<bindings appearing in signature [[Env]]>>
end
@
%%
%%By defining [[info]] and [[partial]] appropriately, the interface for
%%the [[Dirty]] and the [[Clean]] modules can be derived.  The types
%%[[info]] and [[partial]] describe possibly ``bad'' or unknown values
%%in the the signature.
%%
%%\begin{itemize}
%%\item An [['a info]] is a possibly erroneous value [['a]] in a dirty
%%      environment, but always an [['a]] in a clean environment.
%%
%%\item An [['a partial]] is a possibly unavailable value [['a]] in a
%%      dirty environment, but always an [['a]] value in a clean
%%      environment.
%%
%%\item The [[bad]] function creates a erroneous value of the 
%%      [['a info]] type.  Using this function in a clean environment causes
%%      is a checked compile-time error.
%%\end{itemize}      
%%
%%The two sub-modules [[Dirty]] and [[Clean]] just differ in the meaning
%%of [[info]] and [[partial]].  A clean environment ensures that all
%%values are present and that they are good.
%%
<<fenv.mli>>=
<<exposed types shared by clean and dirty environments>>
(* pad: now put also those private types in mli *)
<<private types shared by clean and dirty environments>>
<<exported signature [[Env]]>>

module Dirty : Env
    with type 'a info    = 'a Error.error
    with type 'a partial = 'a option

module Clean : Env
    with type 'a info    = 'a 
    with type 'a partial = 'a 

val clean : 'proc Dirty.env' -> 'proc Clean.env'
@
%%The only way to obtain a clean environment is by cleaning a dirty
%%environment.  However, the dirty environment must not be really dirty: 
%%All information must be provided and must be ``good''.  Trying
%%to clean a dirty environment with bad values will result in a checked
%%run-time error.
%%
%%% ------------------------------------------------------------------ 
\subsection{Getting Started: creating an Environment}
%%% ------------------------------------------------------------------ 
%%
%%The [[empty]] function creates an (almost) empty environment and it the
%%only way to create an environment. For every program the compiler
%%translates it creates one environment. Upon creation the environment is
%%passed two important data structures: a [[Srcmap.map]] value and an
%%assembler [[Asm.assembler]]. A [[Srcmap.map]] value associates a
%%byte-offset in the input with a more readable triple of file name, line,
%%and column. An assembler requires symbols to be registered before they
%%can be used.  Both the source map and the assembler can be observed from
%%an environment.
%%
%%IT IS NOT CLEAR TO ME WHY THE TYPE OF THE ASSEMBLER SYMBOL IS ALLOWED
%%TO LEAK INTO THE FAT ENVIRONMENT. ---NR
%%
%%BECAUSE THE FAT ENVIRONMENT HOLDS THE ASSOCIATION BETWEEN A NAME AND ITS
%%SYMBOL. WE ALREADY HAVE PLANS TO TO IMPLEMENT A LOOKUP FUNCTION IN THE
%%ASSEMBLER AND TO EXPELL THE SYMBOL FROM HERE. --CL
<<bindings appearing in signature [[Env]]>>=
(* pad: was previously an abstract type *)
type 'proc env' = { scopes          :    scope list (* top = hd scopes *)
                   ; srcmap          :    Srcmap.map
                   (* pad: the assembler is embeded in the fat env !! *)
                   ; asm             :    'proc Asm.assembler

                   ; error           :    bool
                   ; metrics         :    Metrics.t
                   ; extern          :    extern
                   ; globals         :    string  list(* global registers *)
                   ; stackdata       :    stackdata
                   }
(* type env = Proc.t env' *)
and scope           = { mutable venv:   ventry Strutil.Map.t
                   ; tenv:   tentry Strutil.Map.t
                   ; rindex: int   (* getIndex, nextIndex *)
                   }

<<types exposed in signature [[Env]]>>
val map : ('b -> 'a) -> 'a env' -> 'b env'

val empty   : Srcmap.map -> Metrics.t -> 'proc Asm.assembler -> 'proc env'
                       (* empty scope stack *)
val srcmap  : 'proc env' -> Srcmap.map
(* pad: allow to access the assembler embeded in the fat env *)
val asm     : 'proc env' -> 'proc Asm.assembler
val metrics : 'proc env' -> Metrics.t
@
%%% ------------------------------------------------------------------ 
\subsection{Scopes and the Fat Environment}
%%% ------------------------------------------------------------------ 
%%
%%The main purpose of the fat environment is to bind values to names. 
%%In {\PAL} same names have the same meaning everywhere in a program,
%%and others may differ inside and outside of a procedure.  Example of
%%the former are [[target]] declarations, and bindings for types and
%%values for the latter; these bindings are called \emph{scoped}.  This
%%interface provides a fat environment [[env]], that holds all bindings,
%%regardless whether they are scoped or un-scoped. 
%%
%%Bindings for types and values have two scopes: the global scope of the
%%entire compilation unit, and the scope inside a procedure. So in
%%principle, the scope changes, when a procedure is entered. However,
%%{\PAL} has some anomalies with respect to these well known static
%%scoping rules: 
%%
%%\begin{itemize}
%%\item Labels defined inside procedures have global scope: they are
%%      visible in the entire compilation unit.
%%\item Values imported inside a procedure have global scope, too.
%%\end{itemize}
%%
%%After a procedure is left, only the global bindings are in effect. 
%%Since a procedure is entered many times in a multi-pass compiler it
%%pays off to save the bindings for a procedure instead of re-computing
%%them every time the procedure is entered.  To facilitate this an
%%[[env]] value is internally divided into two parts:  the first is a
%%stack of [[scope]]s for values and types, and the second holds all
%%other \emph{global} information.  The bottom scope in the scope stack
%%contains all global name and type bindings.  When a procedure is
%%active all its name and type bindings are in the top-scope.  A
%%procedure's bindings can be saved by saving the [[top]] scope and
%%re-used, by [[pop]]'ing it later.
<<bindings appearing in signature [[Env]]>>=
val emptyscope: scope   
val top:        'p env' -> scope            (* top empty = assert false *)
val pop:        'p env' -> 'p env'              (* pop empty = assert false *)
val push:       'p env' -> scope -> 'p env'
@
%%This sounds more complicated than it is.  Since everything is part of
%%an [[env]] value, it is the only value that is passed around.  Only
%%before entering or leaving a procedure the scope stack must be
%%manipulated.
%%\begin{itemize}
%%\item  The scope stack of an [[empty]] [[env]] is also empty. Thus, an
%%       [[emptyscope]] should be [[push]]'ed first.  An [[env]]
%%       includes a [[Srcmpa.map]] value, which is required to give
%%       source code positions (type [[Scrpmap.rgn]] stored in the
%%       environment a meaning.
%%\item  Applying [[top]] or [[pop]] to an empty stack scope will result
%%       in an assertion violation.
%%\end{itemize}
%%
%%To inspect the value bindings in a (local) [[scope]], [[foldv]] is
%%provided:  [[foldv f s z]] applies f to all [[ventry]] values found in
%%scope [[s]] together with a result value of type [['a]] passed along;
%%[[z]] is the initial value for the result.
<<bindings appearing in signature [[Env]]>>=
val foldv:      (string -> ventry -> 'a -> 'a) -> scope -> 'a -> 'a
@  
%%
%%% ------------------------------------------------------------------ 
\subsection{Bindings for Values and Types}
%%% ------------------------------------------------------------------
%%
%%Register, label, and procedure declarations are examples for
%%declarations that bind values to names.  A {\PAL} [[typedef]]
%%declaration binds types to names.  These declarations are scoped:  a
%%declaration inside a procedure can shadow a declaration of the same
%%name at the level of the compilation unit.  The following types
%%capture the structure of values in {\PAL}.
%%
%%\begin{itemize}
%%\item A constant denotes its value directly.
%%\item A register can be either bound to a hardware register, or it can
%%      be annotated with a kind. Kinds are used to determine calling
%%      conventions (see module \module{callconv}). Each register has an
%%      index that identifies it for the run-time API.
%%\item Labels come in different flavors:  labels in [[goto]] or inside
%%      data declarations are plain vanilla.  Procedures are labels in a
%%      clean environment that include their saved local [[scope]]. 
%%\end{itemize}
%%
%%Be careful when dealing with [[goto]] labels and imported values because
%%of {\PAL}'s idiosyncrasies.  Both have global scope, even when they are
%%defined inside a procedure.  Consequently, they are added to the
%%environment (at the outermost/bottom scope) during the first pass, that
%%enters all globally bound values.  A later pass that enters only locally
%%visible values must ignore them. 
%%
%%\emph{The stort below about continuations is wrong. JD would be the best
%%to straighten it out because he implements continuations. -- CL}
%%
%%The denotation of a continuation $x$ includes a label $x'$. It is used
%%during translation the translation of an expressions that refer to $x$:
%%the reference is first represented as a \emph{symbolic constant}
%%(c.f.~\module{const}) $x'$ which is later re-written to a pointer into
%%the run-time stack. This re-write steps needs to distinguish between $x$
%%and $x'$. 
%%
%%A continuation is at run-time represented by a pointer to a pair of a
%%stack-pointer value and a code-pointer. The entry point of the
%%continuation is represented by a symbol derived from its name. The
%%pointer to the pair is a symbolic compile-time constant and is
%%represented by an [[Rtl.late]] value that uses the string part of the
%%[[denotation]]. A continuation therefore has two values associated with
%%it: a symbol for its entry point, the other for the pointer to its
%%run-time representation as a pointer to a pair.  
%%
%%Some values finally become assembler symbols. When such a value enters
%%the fat environment we reserve an assembler symbol for it. The symbol
%%becomes part of the value's denotation.
<<exposed types shared by clean and dirty environments>>=
type regkind       = RReg  of string   (* hardware reg *)
                   | RKind of string   (* calling convention kind *)
                   | RNone             (* none of above *)
@
%%{\PAL} A register has an [[index]] that identifies it \emph{within its
%%scope}.  Consequently, global registers are numbered consecutively, and
%%local registers are numbered consecutively. To avoid confusion with
%%hardware registers in the compiler backend, we name {\PAL} registers
%%variables.
<<exposed types shared by clean and dirty environments>>=
type variable =    { index:        int
                   ; rkind:        regkind
                   ; loc:          Rtl.loc
                   ; variance:     Ast.variance
                   }
@
%%The [[int]] value in the procedure denotation is the number of local
%%variables, plus the number of parameters. We need this value for the
%%interpreter.
<<exposed types shared by clean and dirty environments>>=
type symclass      = Proc          of Symbol.t
                   | Code          of Symbol.t    
                   | Data          of Symbol.t
                   | Stack         of Rtl.exp  (* address of slot *)

type denotation    = Constant      of Bits.bits
                   | Label         of symclass
                   | Import        of string * Symbol.t
                                             (* external name, assembly symbol *)
                   | Variable      of variable
                   | Continuation  of continuation
and continuation = { base       : Block.t;   (* always empty; used only for address *)
                     convention : string;
                     formals    : (string * variable * aligned) list;
                                                  (* kinded, aligned formals *)
                     mutable escapes     : bool;  (* used as rvalue *)
                     mutable cut_to      : bool;  (* mentioned in annotation *)
                     mutable unwound_to  : bool;  (* mentioned in annotation *)
                     mutable returned_to : convention list;
                        (* list every convention cc such that there exists
                           a call site with convention cc and that call site
                           `also returns to' the continuation *)
                   } (* might need a convention here *)
and convention   = string
and aligned      = int
@
%%The complete entry [[ventry]] for a value includes not only its
%%denotation, but also its type [[Types.ty]], and its source code
%%position as a [[Srcmap.rgn]] value.
<<types exposed in signature [[Env]]>>=
and  ventry        = Srcmap.rgn * (denotation * Types.ty) info
@ 
%%For error messages, we provide a way of saying what kind of thing a
%%symbol denotes.
<<fenv.mli>>=
val denotation's_category : denotation -> string
@
%%Bindings for types, which are also scoped, are much simpler. A
%%[[tentry]] for a type includes just its source code position and the
%%type it denotes:
<<types exposed in signature [[Env]]>>=
and  tentry         = Srcmap.rgn * Types.ty info
@
%%% ------------------------------------------------------------------ 
\subsection{Binding and Finding Names and Values}
%%% ------------------------------------------------------------------ 
%%
%%The following functions bind and find names and types in the top of
%%the scope stack inside an environment.  The scopes inside the
%%environment are searched from top to bottom and the first binding
%%found is returned.  The exception [[Error.ErrorExn]] is raised, if no
%%binding can be found (applies also when the scope stack is empty). 
%% 
%%Since it is illegal to re-bind names and values in the same scope, any
%%attempt to do so is reported as an error to stdout.  Additionally the
%%existing binding is re-bound to be bad in case the environment was a
%%Dirty one, and the error flag (see below) is set.
%%
%%The denotation of some values include optional informations that are
%%added by later passes, after an initial binding was entered into the
%%environment.  Since [[bind]] reports any re-binding as an error, a
%%special function [[rebindv]] is introduced for this purpose. 
%%[[rebindv]] introduces the new binding in the topmost scope that has a
%%binding for the name at hand.  So if you want to update a global
%%binding make sure, that this scope is at the top because otherwise it
%%may be shadowed by a binding in a local scope and this one would be
%%replaced.  It is a checked run-time error if no binding to update is
%%found.
%%
%%We had trouble with losing environments with rebound entries in module
%%[[Ast2ir]]. As an experiment, I have made [[rebindv']] an imperative
%%version of [[rebindv]] that updates an environment by mutation. 
<<bindings appearing in signature [[Env]]>>=
val bindv           : string -> ventry  -> 'p env' -> 'p env'
val rebindv         : string -> ventry  -> 'p env' -> 'p env'
val rebindv'        : string -> ventry  -> 'p env' -> unit  (* mutates *)
val bindt           : string -> tentry  -> 'p env' -> 'p env'
val findv           : string -> 'p env' -> ventry   (* Error.ErrorExn *)
val findt           : string -> 'p env' -> tentry   (* Error.ErrorExn *)
@ 
%%\emph{Think of algebraic rules that describe the interaction of bind
%%and find}.
%%
%%Sometimes is is necessary to know whether a value is bound in a local
%%scope.  The following predicate is true, if and only if a given name
%%is bound in the top scope, \emph{and} the top scope is not the bottom
%%scope at the same time.  It is an assertion failure to supply an
%%unknown value.
<<bindings appearing in signature [[Env]]>>=
val is_localv       : string -> 'p env' -> bool     (* *)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Error Flag}
%%% ------------------------------------------------------------------ 
%%
%%The fat environment holds an error flag.  Is is set at the first error
%%found in the static semantics of a program.  The function
%%[[flagError]] sets the flag in the returned environment, [[errorFlag]]
%%returns the flag's value in [[env]].  The [[flagError]] function obeys
%%to the following law:
%%\begin{tabular}{l}
%%    [[flagError (flagError env) = flagError env]]\\
%%    [[errorFlag (flagError empty) = true]]       \\
%%    [[errorFlag empty = false]]
%%\end{tabular}
<<bindings appearing in signature [[Env]]>>=
val flagError       : 'p env' -> 'p env'
val errorFlag       : 'p env' -> bool
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Imports, Exports, and Assembler Symbols}
%%% ------------------------------------------------------------------ 
%%
%%The translation process assigns certain {\PAL} \emph{names} to
%%assembly-level \emph{symbols}.  The relation between a name and its
%%assembly symbol is not straight forward, as explained in
%%section \ref{sect:fenv:mangle}.  In order to build a map from {\PAL} names to
%%symbols all imports and exports of a {\PAL} program must be registered.
%%This is done with [[import]] and [[export]].  To provide meaningful
%%error messages, both function receive the region of the statement at
%%hand in the source code. 
<<bindings appearing in signature [[Env]]>>=
val import: Srcmap.rgn -> string -> string -> 'p env' -> 'p env' (* import g as f *)
val export: Srcmap.rgn -> string -> string -> 'p env' -> 'p env' (* export f as g *)
@
%%The [[symbol env n]] function returns the assembly level symbol for a
%%{\PAL} name [[n]]. If [[n]] is not associated with an imported or
%%exported symbol, we register a new local symbol in the assembler and
%%return it. Since every {\PAL} name should have exactly one associated
%%symbol it is an unchecked error to call [[symbol]] twice with the same
%%name.
%%WHY IN THE WORLD IS THIS ERROR UNCHECKED?
<<bindings appearing in signature [[Env]]>>=
val symbol:   'p env' -> string -> Symbol.t
@
%%
%%% ------------------------------------------------------------------ 
\subsection{The Details of {\PAL} names and Assembler Symbols}
%%\label{sect:fenv:mangle} 
%%% ------------------------------------------------------------------ 
%%
%%A translation of {\PAL} to assembly code must create assembly level
%%\emph{symbols} for {\PAL} \emph{names} that represent addresses:
%%\begin{itemize}
%%\item Procedures
%%\item Goto-Labels
%%\item Data-Labels
%%\item Continuations
%%\end{itemize} 
%%
%%Since names for all objects above have global scope, they are unique
%%for every compilation unit and thus can, in principle, be used for
%%their assembly-level symbols, which also have a compilation-unit
%%scope.  A name from outside a compilation unit can be used after it
%%was imported; likewise can a compilation unit export a name to make it
%%accessible for others.  Import and export declarations in {\PAL} allow
%%to re-name an imported or exported object:
%%\begin{quote}
%%    [[import]] $a$ as $c$\\
%%    [[export]] $c$ as $a$
%%\end{quote}
%%The {\PAL} name $c$ corresponds to the assembly level symbol $a$.  In
%%the presence of renaming, a {\PAL} name $x$ need not 
%%correspond to the same symbol $x$ on the assembly level.  Even worse,
%%imports and exports using the [[as]] feature have non-local effects:
%%\begin{quote}
%%\begin{verbatim}
%%import print as p;
%%print () { ... }
%%\end{verbatim}
%%\end{quote}
%%
%%The assembly symbol [[print]] is already used, although [[p]] is used
%%on the {\PAL} side to refer to it.  Consequently, a {\PAL} procedure
%%[[print]] can still be defined, but the name [[print]] can no longer
%%be used as its assembly symbol.  The {\qcc} compiler must manage names
%%in order to avoid name clashes caused by re-naming.  The main idea is
%%to find and record a corresponding assembly symbol for every {\PAL}
%%name.  To make debugging easier, corresponding names on the {\PAL} and
%%the assembly side should resemble each other as much as possible.
%%
%%\subsubsection{The Rules}
%%
%%Before we go into the details how name conflicts are found and
%%resolved we like to state the rules that {\PAL} names and assembly
%%symbols must adhere to.  The following rules apply both for {\PAL}
%%names and assembler symbols inside a compilation units.
%%\begin{itemize}
%%\item A name (symbol) is either imported, or defined, but not both. 
%%      Every name (symbol) is exactly defined once.  An exported name
%%      (symbol) must be defined.
%%\item It is illegal to export a name (symbol) that is imported or to
%%      import a name that is also exported.
%%\end{itemize}
%%
%%According to the rules it is legal to import the same symbol under
%%different names in {\PAL}:
%%\begin{quote}
%%\begin{verbatim}
%%import f as g;
%%import f as h;
%%\end{verbatim}
%%\end{quote}
%%
%%A naive translation of the following code could lead to assembly code
%%that violates the second rule. 
%%\begin{quote}
%%\begin{verbatim}
%%import f as g;
%%export print as f;
%%print () { ... }
%%\end{verbatim}
%%\end{quote}
%%On the assembly level [[f]] is both imported and exported, because the
%%corresponding symbol for [[print]] is [[f]]. The {\qcc} compiler must
%%detect this problem only by looking at the {\PAL} code and reject this
%%program. 
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Design}
%%% ------------------------------------------------------------------ 
%%
%%This section sketches how assembly symbols are computed for {\PAL}
%%names and how an implementation fits into the current compiler
%%architecture.  For the rest of this section we assume that [[import]]
%%$a$ is a shortcut for [[import]] $a$ [[as]] $a$, and [[export]] $c$ a
%%shortcut for [[export]] $c$ [[as]] $c$.
%%
%%An early pass over the abstract syntax is added to the code that
%%checks the static semantics.  This pass records all [[import]] and
%%[[export]] declarations of a compilation unit.  More precisely, two
%%sets and one map are built:
%%\begin{itemize}
%%\item
%%      Set $I$ of assembly symbols imported by a {\PAL}
%%      compilation unit:  [[import g]] adds [[g]] to $I$, 
%%      The symbol [[g]] must not be element of set $E$ (see
%%      below). 
%%\item
%%      Set $E$ of assembly symbols exported by a {\PAL}
%%      compilation unit: [[export f as g]] adds [[g]] to $E$,
%%      where [[g]] must be not in $I$.
%%\item
%%      A map $m$ from {\PAL} names to their corresponding assembly
%%      level symbols:
%%      \begin{center}
%%      \begin{tabular}{ll}
%%      {\PAL} & added to map $m$ \\ \hline
%%      [[import f]]      & [[f]] $\mapsto$ [[f]] \\
%%      [[import g as f]] & [[f]] $\mapsto$ [[g]] \\
%%      [[export f]]      & [[f]] $\mapsto$ [[f]] \\
%%      [[export f as g]] & [[f]] $\mapsto$ [[g]] 
%%      \end{tabular}
%%      \end{center}
%%\item
%%      The following equations relates $I$, $E$, and $m$:
%%      $\mathit{range}(m) = I \cup E$. 
%%\end{itemize}      
%%
%%The sets $I$ and $E$ together contain the symbols which are determined
%%by the outside of a module and thus can not be used (in general) for
%%assembly symbols stemming from {\PAL} names.  Recording them in two
%%sets is necessary to detect symbols on the assembly side that are
%%imported and exported at the same time.  The map must be used during
%%translation of names.
%%
%%To translate a {\PAL} program to assembly language, not only the
%%symbols for imported or exported objects must be known but for all
%%{\PAL} objects that have a corresponding symbol.  The following
%%algorithm extends the map $m$ such that it maps all relevant {\PAL}
%%names to their symbols.
%%
%%The algorithm uses a set $M$ that contains all assembly symbols used
%%by a program.  Initially it contains the union of $I$ and $E$:  $M
%%\gets I \cup M$.  Next, the algorithm visits all \emph{definitions} of
%%objects that have a corresponding symbol and matches them against the
%%left hand side of the following table. After visiting all definitions,
%%$m$ contains a mapping from {\PAL} names to assembly symbols.
%%
%%\begin{center}
%%\def\dom{\mathit{dom}}
%%\begin{tabularx}{\hsize}{lX}
%%    Definition of $c$               & Action \\
%%    \hline
%%    [[import]] $c$                  & none \\
%%    [[import]] $x$ [[as]] $c$       & none \\
%%    label $c$, $c \in\dom(m)$       & none ($c$ is exported) \\
%%    label $c$, $c \in M$            & invent a new name $a \not\in M$, 
%%                                      $M \gets M \cup \{a\}$, 
%%                                      $m \gets m + (c \mapsto a)$\\
%%    label $c$                       & $m \gets m + (c \mapsto c)$\\
%%\end{tabularx}
%%\end{center}
%%
%%Imports can be skipped because they are already considered in the
%%initial map $m$.  The same is true for labels that are exported.  In
%%most cases the name defined by a label can also be used as a symbol. 
%%Only when the name symbol is already in use a new symbol must be
%%invented and marked as used in $M$.
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation: Large Scale Structure}
%%% ------------------------------------------------------------------ 
%%
%%The implementation tries to exploit the commonalities between the
%%[[Clean]] and [[Dirty]] module by using a functor [[Env]].  The
%%differences factored out of [[Clean]] and [[Dirty]] are supplied as an
%%argument [[Arg]] of type [[Arg]].  The main part of the implementation
%%is thus the generic functor [[Env]] which is described in the
%%following section.
%%
<<fenv.ml>>=
module E            = Error     (* handy abbreviations *)
module T            = Types
module Asm          = Asm    
@
%%
%%The [[Arg]] modules captures the diverse aspects of [[Clean]] and
%%[[Dirty]].  Different [[Arg]] implementations are passed to functor
%%[[Env]] to create [[Clean]] and [[Dirty]].
%%
<<fenv.ml>>=
module type Arg = sig
    type 'a partial
    type 'a info
    
    val good    : 'a   -> 'a info
    val asgood  : 'a info -> 'a option
    val bad     : unit -> 'a info
end
@
%%\begin{itemize}
%%    \item First of all, informations are more vaguely represented in
%%    [[Dirty]] than in [[Clean]]: a [[partial]] information might be
%%    absent in [[Dirty]], but not in [[Clean]]. And an information
%%    [[info]] can be marked as [[bad]] in [[Dirty]], but not in
%%    [[Clean]]. Functions help to create [[good]] and [[bad]] values. 
%%
%%    \item The [[update x y f]] function compares a [[partial info]]
%%    value [[x]] with a plain one [[y]].  In case they differ, [[f]] is
%%    called.  This is used to implement the update of values in the
%%    target environment.  The [[Dirty]] module checks the new [[y]]
%%    value to be consistent with the old value [[x]]. 
%%    
%%    \item The default value is used to create an initial target record
%%    as part of a [[Dirty.empty]] and [[Clean.empty]]. In [[Dirty]]
%%    nothing is known about a target yet and thus all fields are
%%    considered as good, but unknown.
%%
%%    \item The [[asgood]] function provides a way to access [[info]]
%%    information.  If the information is absent, [[None]] is returned. 
%%    In a [[Clean.env]] environment [[asgood]] always returns a
%%    [[Some]] value.
%%\end{itemize} 
%%
%%Here are the two modules for the [[Clean]] and [[Dirty]] environment
%%which are instances of [[Env]], which basically is \emph{the}
%%implementation of this module.  The arguments to [[Env]] are
%%implementations of [[Arg]].
%%
<<fenv.ml>>=
<<exposed types shared by clean and dirty environments>>
<<private types shared by clean and dirty environments>>
<<exported signature [[Env]]>>
module Env (Arg: Arg) = struct 
 <<body of functor [[Env]]>>
end
@ 
%%
<<fenv.ml>>=
module Dirty = Env (struct
    type 'a partial = 'a option
    type 'a info    = 'a Error.error
    
    let good    x   = Error.Ok(x)
    let bad     x   = Error.Error
    let asgood = function
        | Error.Ok(x) -> Some x
        | Error.Error -> None
end)
@ 
%%
<<fenv.ml>>=
module Clean = Env (struct
    type 'a partial             = 'a 
    type 'a info                = 'a

    let good x                  = x
    let asgood x                = Some x
    let bad  x                  = assert false
end)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{The Heart of the Implementation: [[Env]]}
%%% ------------------------------------------------------------------ 
%%
%%The fat and the clean version of an environment share the same basic
%%implementation [[Env]] which is functorized over [[Arg]]. [[Arg]]
%%provides us what we need to know about good and bad values:
%%
<<body of functor [[Env]]>>=
type 'a partial     = 'a Arg.partial
type 'a info        = 'a Arg.info
let  bad            = Arg.bad

(* pad: *)
type  ventry        = Srcmap.rgn * (denotation * Types.ty) info
type  tentry         = Srcmap.rgn * Types.ty info

@
%%
%%Our interfaces includes definitions for types that capture the
%%denotation of values and types. Of course, these types must be defined
%%in the implementation as well.
%%
<<body of functor [[Env]]>>=
type 'proc env'    =  { scopes          :    scope list (* top = hd scopes *)
                      ; srcmap          :    Srcmap.map
                      ; asm             :    'proc Asm.assembler
                      ; error           :    bool
                      ; metrics         :    Metrics.t
                      ; extern          :    extern
                      ; globals         :    string  list(* global registers *)
                      ; stackdata       :    stackdata
                      }
@ 
%%
%%<<types exposed in signature [[Env]]>>
<<private types shared by clean and dirty environments>>=
type stackdata =      { soffset    :    int    (* current offset *)
                      ; smaxalign  :    int    (* max stackdata align constr*)
                      ; sname      :    string (* label for offset *)
                      }
@
%%Imports and exports are recorded (see module \module{mangle}) to build
%%a map from {\PAL} names to assembly symbols.  The [[extern]] type holds
%%two sets of assembly symbols:  [[imported]] and [[exported]], and a
%%map from {\PAL} names to symbols.
<<private types shared by clean and dirty environments>>=
type extern         = { imported:     Strutil.Set.t
                      ; exported:     Strutil.Set.t
                      ; nam2sym:      Symbol.t Strutil.Map.t
                      }
@
%%
%%A [[scope]] is record of two maps for values and types respectively:
%%
<<body of functor [[Env]]>>=
and scope           = { mutable venv:   ventry Strutil.Map.t
                      ; tenv:   tentry Strutil.Map.t
                      ; rindex: int   (* getIndex, nextIndex *)
                      }
@
%%
%%An entire environment [[env]] contains the stack of scopes and members
%%for all non-scoped information, like the target, imports and exports,
%%error flag, and so on.
%%
%%% ------------------------------------------------------------------ 
\subsection{Auxiliaries}
%%% ------------------------------------------------------------------ 
%%
%%A handy error printing function: [[r]] is a [[Srcmap.reg]] source code
%%position that is used to describe the place where an error is located. 
%%
<<body of functor [[Env]]>>=
let error r map msg = E.errorRegionPrt (map,r) msg 
@
%%
<<fenv.ml>>=
let denotation's_category = function
  | Label (Proc  _) -> "procedure"
  | Label (Code  _) -> "code label"
  | Label (Data  _) -> "data label"
  | Label (Stack _) -> "stackdata label"
  | Constant _      -> "constant"
  | Continuation _  -> "continuation"
  | Import (_, _)   -> "imported symbol"
  | Variable _      -> "register variable"
@ 
%%% ------------------------------------------------------------------ 
\subsection{Mapping}
%%% ------------------------------------------------------------------ 
%%
<<body of functor [[Env]]>>=
let map f { scopes      = scopes     
          ; srcmap      = srcmap     
          ; asm         = asm        
          ; error       = error      
          ; metrics     = metrics     
          ; extern      = extern     
          ; globals     = globals    
          ; stackdata   = stackdata  
          } =
          { scopes      = scopes     
          ; srcmap      = srcmap     
          ; asm         = Asm.map f asm        
          ; error       = error      
          ; metrics     = metrics     
          ; extern      = extern     
          ; globals     = globals    
          ; stackdata   = stackdata  
          }
@ 
%%
%%% ------------------------------------------------------------------ 
\subsection{Creating \texttt{env} and \texttt{scope} values}
%%% ------------------------------------------------------------------ 
%%
%%Given the stack semantics for scopes, the implementation is obvious. 
<<body of functor [[Env]]>>=
let empty map metrics asm =  
    { scopes    = []
    ; srcmap    = map
    ; asm       = asm
    ; error     = false
    ; globals   = []
    ; stackdata = { smaxalign  = 1
                  ; soffset    = 0
                  ; sname      = "can't happen"
                  }
    ; metrics   = metrics
    ; extern    = { imported   = Strutil.Set.empty
                  ; exported   = Strutil.Set.empty
                  ; nam2sym    = Strutil.Map.empty
                  }
    } 
@
%%The implementation of the [[scope]] stack provides no surprises.
<<body of functor [[Env]]>>=
let emptyscope          = { venv   = Strutil.Map.empty
                          ; tenv   = Strutil.Map.empty 
                          ; rindex = 0
                          }

let srcmap  {srcmap=m}  = m
let asm     {asm=a}     = a 
let metrics {metrics=m} = m 

let top env = match env.scopes with
    | []    -> assert false
    | s::ss -> s

let pop env = match env.scopes with
    | []     -> assert false
    | s::ss  -> { env with scopes = ss }

let push env scope = { env with scopes = scope :: env.scopes } 
@
%%
<<body of functor [[Env]]>>=
let foldv f {venv=v} z = Strutil.Map.fold f v z
@
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Binding and Finding Names and Values}
%%% ------------------------------------------------------------------ 
%%
<<body of functor [[Env]]>>=
type typedefn = (Ast.ty * string list) * Ast.region
let addTypedefn t env = assert false
let typedefns env = assert false
let setTypedefns ts env = assert false
@ 
%%
<<body of functor [[Env]]>>=
type constdefn = (Ast.ty option * string * Ast.expr) * Ast.region
let addConstdefn t env = assert false
let constdefns env = assert false
let setConstdefns ts env = assert false
@ 
%%New Bindings are recorded in the top scope; it is a checked run-time
%%error if the scope stack is empty.  It is illegal in {\PAL} to re-bind
%%names:  if the name to be bound is found in the top scope, an error is
%%issued, the error flag is set, and the existing binding is re-bound to
%%a bad value.  
%%
%%Register values that use a hardware register are
%%additionally recorded in the [[regdecls]] component.
<<body of functor [[Env]]>>=
let bindv name (rgn,x as ventry) env = 
    let scope = ( match env.scopes with
                | []    -> assert false
                | s::ss -> s
                ) in
    try let (rgn',x) = Strutil.Map.find name scope.venv in
        ( error rgn  env.srcmap ("re-declaration of value "^name)
        ; error rgn' env.srcmap ("previously declared here")
        ; let scope = 
            { scope with venv = Strutil.Map.add name (rgn',Arg.bad()) scope.venv} 
          in
            { env with 
              scopes = scope :: List.tl env.scopes  
            ; error  = true  
            }
        )              
    with Not_found -> 
        let scope = { scope with venv = Strutil.Map.add name ventry scope.venv} in
        let env   = { env with scopes = scope :: List.tl env.scopes } in
            ( match Arg.asgood x with
            | Some(Variable _,_) when List.length env.scopes = 1 ->
                  (* this is a global register declaration *)
                  { env with globals = name :: env.globals }
            | _ -> env
            ) 
@ 
%%
<<body of functor [[Env]]>>=
let bindt name (rgn,x as tentry) env = 
    let scope = ( match env.scopes with
                | []    -> assert false
                | s::ss -> s
                ) in
    try let (rgn',x) = Strutil.Map.find name scope.tenv in
        ( error rgn  env.srcmap ("re-declaration of type "^name)
        ; error rgn' env.srcmap ("previously declared here")
        ; let scope = 
            { scope with tenv = Strutil.Map.add name (rgn',Arg.bad()) scope.tenv} 
          in
            { env with 
              scopes = scope :: List.tl env.scopes  
            ; error  = true
            }
        )              
    with Not_found -> 
        let scope = { scope with tenv = Strutil.Map.add name tentry scope.tenv} in
        let env   = { env with scopes = scope :: List.tl env.scopes } in
            env
@
%%The [[find]] functions start searching in the top of the stack and
%%move to the bottom. The first binding found is returned, and
%%[[Error.ErrorExn]] raised otherwise.
<<body of functor [[Env]]>>=
let findv name env =
  let rec loop = function
    | []    -> E.error ("unknown value: "^name)
    | s::ss -> (try Strutil.Map.find name s.venv with Not_found -> loop ss) in
  loop env.scopes
@ 
%%
<<body of functor [[Env]]>>=
let findt name env =
  let rec loop = function
    | []    -> E.error ("unknown type: "^name)
    | s::ss -> ( try Strutil.Map.find name s.tenv with Not_found -> loop ss ) in
  loop env.scopes
@
%%The [[rebindv]] function replaces the most local binding for a name. 
<<body of functor [[Env]]>>=
let rebindv name x env =
    let rec loop = function
        | []    -> Impossible.impossible ("can't rebind "^name)
        | s::ss -> if Strutil.Map.mem name s.venv 
                   then { s with venv = Strutil.Map.add name x s.venv } :: ss
                   else s :: loop ss in
    { env with scopes = loop env.scopes }

let rebindv' name x env =
    let rec loop = function
        | []    -> Impossible.impossible ("can't rebind "^name)
        | s::ss -> if Strutil.Map.mem name s.venv 
                   then s.venv <- Strutil.Map.add name x s.venv 
                   else loop ss in
    loop env.scopes 
@
%%An assertion fails if the scope stack is empty.
<<body of functor [[Env]]>>=
let is_localv name env = 
    ( match env.scopes with
    | []    -> assert false
    | [s]   -> false
    | s::ss -> Strutil.Map.mem name s.venv
    )
@
%%% ------------------------------------------------------------------ 
\subsection{The Error Flag}
%%% ------------------------------------------------------------------ 
%%
%%The fat environment also holds an error flag.  Is is set at the first
%%error found in the static semantics of a program.  The function
%%[[flagError env]] sets the flag in the returned environment,
%%[[errorFlag]] returns the flag's value in [[env]].
<<body of functor [[Env]]>>=
let flagError env = if env.error then env else { env with error = true }
let errorFlag env = env.error
@
%%% ------------------------------------------------------------------ 
\subsection{Imports, Exports, Symbols}
%%% ------------------------------------------------------------------ 
%%
%%The fat environment maintains the set of imported and exported assembly
%%\emph{symbols} and a map, that associates {\PAL} names with its symbol.
%%No assembly symbol may be imported and exported at the same time. If
%%such a case is detected, an error message is issued. Details about the
%%connection between {\PAL} names and assembly symbols can be found in
%%\module{mangle}.
<<body of functor [[Env]]>>=
let import r sym name env =
    if Strutil.Set.mem sym env.extern.exported 
    then 
        ( error r env.srcmap ("import of an exported name: "^name)
        ; flagError env
        )
    else 
        let sym'   = env.asm#import sym in
        let extern = { exported = env.extern.exported
                     ; imported = Strutil.Set.add sym  env.extern.imported
                     ; nam2sym  = Strutil.Map.add name sym' env.extern.nam2sym
                     }
         in
            { env with extern = extern }

let export r name sym env =
    if Strutil.Set.mem sym env.extern.imported 
    then 
        ( error r env.srcmap ("export of an imported name: "^name)
        ; flagError env
        )
    else 
        let sym'   = env.asm#export sym in
        let extern = { imported = env.extern.imported
                      ; exported = Strutil.Set.add sym env.extern.exported
                      ; nam2sym  = Strutil.Map.add name sym' env.extern.nam2sym
                      }
         in
            { env with extern = extern }
@
%%If a name [[n]] is imported or exported, we find its corresponding
%%assembler symbol in the [[nam2sym]] map. If we can't find it there we
%%would like to register a new symbol for [[n]]. However, [[n]] might be
%%have been used already for an exported or imported symbol: 
%%[[export c as n]] registers a symbol for [[n]] such that any
%%other entity [[n]] 
%%cannot register [[n]] for a symbol. We detect this by checking the sets
%%of names that were registered for imported and exported symbols. In the case
%%of such a collision we derive a new name from [[n]] that we use to
%%generate a symbol for [[n]].
<<body of functor [[Env]]>>=
let symbol env n =
    try Strutil.Map.find n env.extern.nam2sym
    with Not_found ->
        let rec avoid_collision n =
            if Strutil.Set.mem n env.extern.exported ||
               Strutil.Set.mem n env.extern.imported
            then
                avoid_collision (n ^ "@")
            else
                n
        in
            env.asm#local (avoid_collision n)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Register Index}
%%% ------------------------------------------------------------------ 
%%
%%No surprises here. The index is local to the current scope!
%%
<<body of functor [[Env]]>>=
let nextIndex  env   = match env.scopes with
                       | top::t -> { env with scopes = 
                                        {top with rindex = top.rindex + 1}::t
                                   } 
                       | _      -> assert false (* no scope *)

let getIndex   env   = match env.scopes with
                       | top::_ -> top.rindex
                       | _      -> assert false (* no scope *)
                       
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Hardware Registers}
%%% ------------------------------------------------------------------ 
%%
%%The list of global register declarations is built in reverse order by
%%[[bindv]].  So we have to reverse it when we return it.
%%
<<body of functor [[Env]]>>=
let globals env = List.rev env.globals
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Cleaning a fat environment}
%%% ------------------------------------------------------------------ 
%%
%%A [[Clean.env]] is created from a [[Dirty.env]] by copying values from
%%one to another.  The string typing discipline of {\ocaml} precludes
%%the use of patterns in most cases such that values must be copied
%%explicitly.
%%
<<fenv.ml>>=
let clean_env map =
    let copy key data map = match data with
    | pos, E.Ok den -> Strutil.Map.add key (pos, den) map
    | _,   E.Error  -> assert false in
    Strutil.Map.fold copy map Strutil.Map.empty      
@ 
<<fenv.ml>>=
let clean_scope s =
    { Clean.tenv   = clean_env s.Dirty.tenv
    ; Clean.venv   = clean_env s.Dirty.venv
    ; Clean.rindex = s.Dirty.rindex
    }
@ 
<<fenv.ml>>=
let clean env =
    { Clean.scopes    = List.map clean_scope env.Dirty.scopes
    ; Clean.srcmap    = env.Dirty.srcmap 
    ; Clean.asm       = env.Dirty.asm
    ; Clean.error     = env.Dirty.error
    ; Clean.metrics   = env.Dirty.metrics
    ; Clean.stackdata = env.Dirty.stackdata
    ; Clean.globals   = env.Dirty.globals
    ; Clean.extern    = env.Dirty.extern
    }
@
\section{[[front_fenv/metrics.nw]]}
<<front_fenv/metrics.ml>>=
<<metrics.ml>>
@

<<front_fenv/metrics.mli>>=
<<metrics.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%
%%% ------------------------------------------------------------------ 
\section{Target Platform Metrics}
%%% ------------------------------------------------------------------ 
%%
%%This interface describes only low-level metrics such as might be used
%%when elaborating a {\PAL} program or when bootstrapping a [[Target.t]].
%%It also provides a consistency check that sprays error messages when
%%things are not consistent. 
<<metrics.mli>>=
<<exposed types(metrics.nw)>>
val default : t
val of_ast  : 
  swap:bool -> Srcmap.map -> (Ast.region * Ast.arch) list -> 
  t Error.error
@ 
%%
%%Field [[alignment]] is the alignment required to load or store a word
%%of size [[pointersize]].
<<exposed types(metrics.nw)>>=
type t = {
  byteorder   : Rtl.aggregation ; (* big/little endian, id *)
  wordsize    : int             ; (* bits *)
  pointersize : int             ; (* bits *)
  memsize     : int             ; (* smallest addressable unit, typically 8 *)
  float       : string          ; (* name of float representation (def "ieee754") *)
  charset     : string          ; (* "latin1"  character encoding      *)
}
@
\section{Implementation}
<<metrics.ml>>=
(*open Nopoly*)
let (=*=) = (=)

module A = Ast
<<exposed types(metrics.nw)>>
let default = {
  byteorder   = Rtl.Identity;
  wordsize    = 32;
  pointersize = 32;
  memsize     = 8;
  float       = "ieee754";
  charset     = "latin1";
}

let of_ast ~swap map =
  let errorf rgn =
    Printf.kprintf (fun s -> (Error.errorRegionPrt (map, rgn) s; Error.Error)) in
  let def default = function
    | Error.Ok (Some (r, v)) -> v
    | Error.Ok None          -> default
    | Error.Error            -> assert false in
  let merge r prt what v = function (* used at int, string, and Rtl.aggregration *)
    | Error.Ok (Some (r', v')) as m when v =*= v' -> m
    | Error.Ok (Some (r', v')) ->
        errorf r "%s %s inconsistent with previous declaration of %s at %s"
          what (prt v) (prt v') (Srcmap.Str.region (map, r'))
    | Error.Ok None -> Error.Ok (Some (r, v))
    | Error.Error -> Error.Error in
  let mergei r what i v =
    if i > 0 then merge r string_of_int what i v
    else errorf r "%s must be a positive integer" what in
  let bos = function Rtl.LittleEndian -> "little" | _ -> "big" in
  let mergebo r v = merge r bos "byte order" v in
  let merges r = merge r (fun s -> s) in
  let is_ok = function  Error.Ok _ -> true | Error.Error -> false in

  let rec metrics bo w p m f c aa =
    let big_endian    r aa = metrics (mergebo r Rtl.BigEndian    bo) w p m f c aa in
    let little_endian r aa = metrics (mergebo r Rtl.LittleEndian bo) w p m f c aa in
    match aa with
    | [] -> if is_ok bo && is_ok w && is_ok p && is_ok m && is_ok f && is_ok c then
              match bo with
              | Error.Ok (Some (_, bo)) -> 
                  Error.Ok { byteorder   = bo;
                             wordsize    = def default.wordsize    w;
                             pointersize = def default.pointersize p;
                             memsize     = def default.memsize     m;
                             float       = def default.float       f;
                             charset     = def default.charset     c;
                           }
              | Error.Ok None ->
                  (Error.errorPrt "target byte order not specified"; Error.Error)
              | Error.Error   ->
                  assert false
            else
              Error.Error
    | (r,A.Memsize i)      :: aa -> metrics bo w p (mergei r "memsize" i m) f c aa
    | (r,A.ByteorderBig)   :: aa -> (if swap then little_endian else big_endian) r aa
    | (r,A.ByteorderLittle):: aa -> (if swap then big_endian else little_endian) r aa
    | (r,A.FloatRepr s)    :: aa -> metrics bo w p m (merges r "float" s f) c aa
    | (r,A.WordSize i)     :: aa -> metrics bo (mergei r "wordsize" i w) p m f c aa
    | (r,A.PointerSize i)  :: aa -> metrics bo w (mergei r "pointersize" i p) m f c aa
    | (r,A.Charset s)      :: aa -> metrics bo w p m f (merges r "charset" s c) aa in
  let n = Error.Ok None in
  metrics n n n n n n
@ 
<<metrics.ml>>=
@
\section{[[front_fenv/rtleqn.nw]]}
<<front_fenv/rtleqn.ml>>=
<<rtleqn.ml>>
@

<<front_fenv/rtleqn.mli>>=
<<rtleqn.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et:
%%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%%
%%
%%% The module name const is odd. I'm sticking to it because of the
%%% original module, but would like to find something better. rtleqn? 
%%
%%% ------------------------------------------------------------------ 
\section{Equations over RTL-Expressions}
%%% ------------------------------------------------------------------ 
%%
%%This module enables a client to build and solve a system of equations.
%%A term in an equation is an {\rtl} expression.  
%%The module is used to solve for the values of late compile-time
%%constants.
%%The equations themselves typically arise from constraints in the
%%[[Block]] module.
<<rtleqn.mli>>=
exception Can'tSolve

type t              (* equation *)
type solution =
    { known:        (string * Rtl.exp) list  (* fully solved *)
    ; dependent:    (string * Rtl.exp) list  (* depend on other variables *)
    }

val equate : Rtl.exp -> Rtl.exp -> t   (* e1 == e2 *)

val solve  : width:int -> t list -> solution   (* Can'tSolve *)
val to_string : t -> string (* for debugging *)
@  
%%The function [[equate]] creates an equation.
%%The solver treats
%%a list of equations as system of equations to be solved simultaneously.
%%Solving treats late compile-time constants as
%%variables and tries to map each one to an {\rtl} expression that is
%%variable-free. 
%%A~variable that can be expressed this way is \emph{known}.
%%A~variable whose value can be expressed only in terms of
%%other variables is \emph{dependent}. 
%%A~solution contains dependent variables only if the system of
%%equations does not provide enough information for a solution (e.g., if
%%there were fewer equations than variables).
%%
%%N.B. For details of terminology see NR's solver paper in SP\&E.
%%
%%Limitations: Despite the interface and the expressiveness of {\rtl}
%%expressions, this is not a general equation solver. How can I make
%%precise what the equation solver does without going into the details of
%%operation?
%%
%%% ------------------------------------------------------------------ 
\section{Implementation of equations}
%%% ------------------------------------------------------------------ 
%%
%%The implementation relies on the linear equation solver module
%%\module{eqn}. The main tasked solved here is to parse an {\rtl}
%%expression into linear form such that it can be passed to the linear
%%equation solver. The general idea is that complicated (and possibly
%%non-linear) terms are treated as constant with respect to equation
%%solving.
<<rtleqn.ml>>=
open Nopoly

module Dn = Rtl.Dn
module Up = Rtl.Up
module RP = Rtl.Private

exception Can'tSolve
type solution =
    { known:        (string * Rtl.exp) list
    ; dependent:    (string * Rtl.exp) list
    }
@
%%We represent an expression as a linear
%%sum of terms.  
%%A term is a constant, a variable, or one ([[Unit]]). An equation is
%%a sum whose value is known to be zero.
<<rtleqn.ml>>=
type term =
    | Const of Rtl.exp
    | Var   of string
    | Unit  

type sum = (int * term) list
type t   = sum                  (* equation, sum == 0 *)
@
%%To aid debugging, we have a printable representation of terms. 
<<rtleqn.ml>>=
module ToString = struct
    let term = function
        | Const(exp) -> "(" ^ Rtlutil.ToString.exp exp ^ ")"
        | Var(s)     -> s
        | Unit       -> "1"
    let summand (i,t) = match i with
        | 1 -> term t
        | n ->
            match t with
            | Unit -> Printf.sprintf "%d" i
            | _    -> Printf.sprintf "%d * %s" i (term t) 
    let t sum = (* no thought for efficiency *)
      let pos = List.filter (fun (i, n) -> i >= 0)  sum in
      let neg = List.filter (fun (i, n) -> i <  0)  sum in
      let neg = List.map    (fun (i, n) -> (-i, n)) neg in
      let side = function
        | [] -> "0"
        | sum -> String.concat " + " (List.map summand sum) in
      side pos ^ " = " ^ side neg
end
let to_string = ToString.t
@
%%Here are constructor functions for simple sums. We use them when we
%%parse an {\rtl} expression into a sum.
<<rtleqn.ml>>=
let sym x   = [(1, Var x)]
let int i   = if i = 0 then [] else [(i, Unit)]
let const k = [(1, Const (Up.exp k))]
let add x y = x @ y
let sub x y = x @ List.map (fun (i,y) -> (-i,y)) y
@
%%The real work is to parse an {\rtl} expression into a sum. This requires
%%in particular to recognize certain {\rtl} operators. We traverse an
%%{\rtl} expression and create a sum representation for it. 
%%Any expression we
%%don't know how to handle becomes a constant.
<<rtleqn.ml>>=
let exp e = 
    let rec exp = function
    | RP.Const(RP.Bits(b))      -> int (Bits.S.to_int b)
    | RP.Const(RP.Late(x,_))    -> sym x
    | RP.Const(_) as x          -> const x
    | RP.App(("add",_),[e1;e2]) -> add (exp e1) (exp e2)
    | RP.App(("sub",_),[e1;e2]) -> sub (exp e1) (exp e2)
    | x                         -> const x
    in
        exp (Dn.exp e)
@
%%An equation is a sum whose value is zero. The [[equate]] function
%%simply subtract both sides from each other to obtain a sum of value
%%zero.
<<rtleqn.ml>>=
let equate e1 e2 = 
    let t  = sub (exp e1) (exp e2) in
    let () = if Debug.on "rtleqn" then
               Printf.eprintf "Rtleqn.equate: %s === %s\n"
                 (ToString.t (exp e1)) (ToString.t (exp e2)) in
    t
let () = Debug.register "rtleqn" "RTL equation solver"
@
%%The linear equation solver needs to know about terms. We provide the
%%structure [[T]] for it and create an instance of the equation solver for
%%us. The equation solver provides (should be changed):
%%\begin{itemize}
%%\item [[T.t]]: the type for a set of equations.
%%\item [[T.empty]]: the empty set.
%%\item [[T.make_zero]]: adds a sum that is known to be zero to an
%%       equation set.
%%\end{itemize}
<<rtleqn.ml>>=
module T = struct
    type t = term
    let variable = function         (* identify variable *)
        | Var s -> Some s
        | _     -> None
    let compare t t' = match t, t' with
    | (Const l, Const r) -> Rtlutil.Compare.exp (Dn.exp l) (Dn.exp r)
    | (Var l, Var r) -> compares l r
    | (Unit, Unit) -> 0
    | (Const _, Var _) -> -1
    | (Const _, Unit) -> -1
    | (Var _, Const _) -> 1
    | (Var _, Unit) -> -1
    | (Unit, Const _) -> 1
    | (Unit, Var _) -> 1

    let print   = ToString.term
end
module Solver = Eqn.Make(T)         (* equation solver over terms *)
@
%%The result as it is returned by the equation solver associates a variable
%%with a sum. Since we need to return {\rtl} expressions, we have to
%%unparse a sum into an expression. 
<<rtleqn.ml>>=
let rtl ~(width:int) (e:sum) = 
    let add    = Rtlutil.add width in
    let mult   = Rtl.opr "mul" [width] in 
    let bits i = Rtl.bits (Bits.S.of_int i width) width    in 
    let late x = Rtl.late x width in
    let summand = function
        | (1,Var x)   -> late x 
        | (i,Var x)   -> Rtl.app mult [bits i; late x] 
        | (i,Unit)    -> bits i 
        | (1,Const k) -> k
        | (i,Const k) -> Rtl.app mult [bits i;k] in
    let rec loop e = function
        | []    -> e
        | [s]   -> add e (summand s)
        | s::ss -> loop (add e (summand s)) ss
    in
        match e with
        | []    -> Rtl.bits (Bits.zero width) width
        | s::ss -> loop (summand s) ss 
@
%%Here we solve the equation system. We have a list of sums that we feed
%%into the linear equation solver. Once we obtain the result, we translate
%%it back to {\rtl}s. 
<<rtleqn.ml>>=
let solve ~width sums =
    try
        let eqns   = List.fold_right Solver.make_zero sums Solver.empty in
        let result = Solver.solve eqns in
        let to_rtl = function (v,sum) -> (v,rtl width sum) in
                { known     = List.map to_rtl result.Solver.known
                ; dependent = List.map to_rtl result.Solver.dependent
                }
    with
        Solver.Can'tSolve _ -> raise Can'tSolve
@

\chapter{[[front_cfg]]}

\section{[[front_cfg/cfg.nw]]}
<<front_cfg/cfg.ml>>=
<<cfg.ml>>
@

<<front_cfg/cfg.mli>>=
<<cfg.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=2 sw=2 et: 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% 
%%% $Id: cfg.nw,v 1.80 2006-04-10 21:28:53 nr Exp $
%%
%%% ------------------------------------------------------------------ 
\section{Control-Flow Graph Revisions}
%%% ------------------------------------------------------------------ 
%%
%%Here are some possible revisions to the flow graph.
%%\begin{itemize}
%%\item
%%Make predecessor and successor fields mutable.
%%This change gives a client substantially greater freedom to choose the
%%order in which nodes are constructed.
%%\item
%%Introduce the idea of \emph{layout}.
%%A graph \emph{has layout} if the physical order of instructions and
%%labels is known.
%%A graph must have layout before it is passed to an assembler.
%%
%%Except for branch nodes as specified below, if a node has a unique
%%successor, then the node precedes its successor in the physical layout.
%%\item
%%Restrict types of nodes in the hopes of simplifying algorithms.
%%The grossest classification is by numbers of predecessors and
%%successors. 
%%\begin{itemize}
%%\item
%%A \emph{join point} has arbitrarily many precedessors and exactly one
%%successor. 
%%It is associated with a list of \emph{labels} but no code.
%%A join point is the only node with multiple predecessors.
%%\remark{Question for Glenn: how to represent the successor list?  How
%%much space do you allocate for successors whan you don't yet know how
%%many there will be?}
%%\item
%%A \emph{straight-line code} node has exactly one predecessor and one
%%successor. 
%%It models computation without interesting control flow.
%%\item
%%A \emph{branch node} performs a goto but is intended to implement no
%%other useful computation.
%%It has a unique predecessor and a unique successor.
%%Its successor must be a join point.
%%If the graph has layout, the branch node also has a layout successor,
%%which may be different from its control-flow successor.
%%The RTL of a branch node is an unconditional assignment to the program
%%counter. 
%%\item
%%A \emph{jump} node is a lot like a branch except its successor is the
%%exit node
%%\item
%%An \emph{conditional branch} has a unique predecessor and two
%%successors, which are labeled true and false.
%%Each successor must be a join point.
%%It contains an RTL that normally satisfies the following properties:
%%\begin{itemize}
%%\item
%%It contains a single effect, which is a guarded assignment to the
%%program counter.
%%\item
%%The value assigned to the program counter is the label (link-time
%%constant) of the true successor.
%%\end{itemize}
%%If the second property is not satisfied, we say the node is
%%\emph{dirty}.
%%The node must be clean before it can be passed to an assembler.
%%
%%If the graph has layout, the layout successor of a branch node must
%%be its false successor.
%%
%%It is legitimate at any time to perform the following changes as one
%%atomic operation:
%%\begin{itemize}
%%\item
%%Swap the true and false successors
%%\item
%%Negate the condition on the guard
%%\item
%%Replace the label in the assignment with the new true successor.
%%\end{itemize}
%%The [[bnegate]] operation in the postexpander interface is useful here.
%%\item
%%A node with multiple successors is a \emph{multiway branch}.
%%It has a unique predecessor.
%%There are several kinds of multiway branch.
%%\begin{itemize}
%%\item
%%Call
%%\item
%%Computed goto
%%\item
%%\emph{Cut to}.
%%Normally has a single successor (the exit) but may have multiple
%%successors. 
%%\end{itemize}
%%\item
%%THERE ARE NO DATAFLOW NODES.  INSTEAD, A NODE MAY CONTRIBUTE DEFS,
%%AND KILLS TO EACH OUTEDGE, AND A NON-JOIN NODE MAY CONTRIBUTE
%%USES TO ITS UNIQUE INEDGE.
%%\item
%%The entry node has a successor but no predecessor
%%\item
%%The exit node has a predecessor but no successor (or perhaps it should
%%be a join point)?
%%\item
%%An \emph{illegal} node has no predecessors and no successors.
%%It is used to initialize mutable successor and predecessor fields.
%%\end{itemize}
%%\item
%%An infinite loop must contain an artificial edge so it can reach the
%%exit.
%%
%%\end{itemize}
%% 
%%
\section{Goals}
%%
%%This section lists our goals for the control-flow graph.  
%%It is cribbed from a similar section in the documentation for Machine
%%SUIF. 
%%\begin{itemize}
%%\item
%%\emph {Analysis.}
%%Many compiler analyses assume a flow graph as a basic data
%%structure. 
%%Such analyses include
%%liveness analysis, reaching definitions,
%%and dead-code identification.
%%We provide the ability to traverse and observe the nodes and edges in
%%the flow graph.
%%\item
%%\emph{Transformation.}
%%We also want to support control-flow transformation, e.g., by merging
%%instructions, moving code out of loops, various forms of redundancy
%%elimination, and so on.
%%Davidson-style code expansion may also involve rewriting Boolean
%%operations into control flow.
%%\item
%%\emph {Simple ordering.}
%%To be able to emit a program, 
%%we provide minimal support for mapping the flow graph onto an ordered
%%list of code, data, and labels.
%%While we wouldn't mind supporting automated code layout and
%%code-layout optimizations, it is not a high priority.
%%Furthermore, and following Machine SUIF, we make it possible to
%%manipulate a flow graph that has no layout in memory---we require only
%%that a layout be established before code is emitted.
%%\item
%%\emph{Minimize burden on clients.}
%%We minimize the number of checked and unchecked run-time errors a
%%client can commit.
%%This policy may make the flow graph more complex and more expensive,
%%but we believe it is better that this abstraction do as much of the
%%hard work as possible.
%%\end{itemize}
%%
%%
\section{The Control-Flow Graph}
%%
%%Quick~{\PAL} uses a control-flow graph to represent a procedure.
%%The flow-graph abstraction is inspired by \citet{knoop:basic-block},
%%who described the basic-block control-flow graph as a ``living
%%dinosaur.''
%%Accordingly, our flow graph does not use basic blocks; each node
%%represents at most one instruction.
%%
%%This abstraction actually represents \emph{two} graphs: a control-flow
%%graph and a physical-layout graph.
%%A~\emph{control-flow edge} indicates the possibility that control may flow
%%from one node to another during the dynamic execution of a program.
%%A~\emph{layout edge} indicates that the code for one node
%%appears before the code for another node in the image (assembly or binary)
%%that is written to the output.\footnote
%%{N.B.~The code for a third node may intervene.}
%%When we refer to an unqualified edge, predecessor, or successor, we
%%always refer to the control-flow graph, not to the layout graph.
%%
%%We classify a node according to the number of predecessors and
%%successors it may have, and also according to the \emph{payload} it
%%may carry.
%%\begin{itemize}
%%\item
%%A \emph{join point} has arbitrarily many precedessors and exactly one
%%successor. 
%%Its payload is one or more \emph{labels} but no code.
%%A join point is the only node with multiple predecessors.
%%The layout successor a join point is its control-flow successor.
%%
%%\item
%%An \emph{ordinary instruction} has one predecessor and one successor.
%%Its payload is one instruction.
%%Its layout successor is its control-flow successor.
%%\item
%%An \emph{assertion} is just like an ordinary instruction, except that it generates
%%no code.
%%Instead, it simply asserts that the effect of the instruction has
%%taken place.
%%Its purpose is to sit on an interprocedural control-flow edge, so we
%%have a way of recording what a callee did to a stack pointer, for
%%example. 
%%\item
%%A \emph{control-flow} instruction has one predecessor and one or more
%%successors. 
%%Every successor must be a join point.
%%There are a variety of control-flow instructions with different
%%numbers of successors and different constraints on layout.
%%\begin{itemize}
%%\item
%%A \emph{branch node} performs a goto but is intended to implement no
%%other useful computation.
%%It has a unique predecessor and a unique successor.
%%Its layout successor may be different from its control-flow successor.
%%The standard RTL of a branch node is an unconditional assignment to the program
%%counter. 
%%\item
%%A \emph{jump} node is a lot like a branch except its successor is the
%%exit node, which is considered a join point \emph{ex officio}. 
%%\item
%%A \emph{conditional branch} has two
%%successors, which are labeled true and false.
%%It contains an RTL that normally satisfies the following properties:
%%\begin{itemize}
%%\item
%%It contains a single effect, which is a guarded assignment to the
%%program counter.
%%\item
%%The value assigned to the program counter is a label (link-time
%%constant) associated with the join point that is the true successor.
%%\end{itemize}
%%If the second property is not satisfied, we say the node is
%%\emph{dirty}.\footnote{We can and should prevent the node from ever
%%becoming dirty.}
%%The node must be clean before it can be passed to an assembler.
%%
%%If the graph has layout, the layout successor of a branch node must
%%be its false successor.
%%
%%It is legitimate at any time to perform the following changes as one
%%atomic operation:
%%\begin{itemize}
%%\item
%%Swap the true and false successors
%%\item
%%Negate the condition on the guard
%%\item
%%Replace the label in the assignment with the new true successor.
%%\end{itemize}
%%The [[bnegate]] operation in the postexpander interface is useful here.
%%\item
%%A computed goto with multiple successors is a \emph{multiway branch}.
%%Its layout successor is unconstrained.
%%\item 
%%A \emph{call} node has many successors, which are listed in this
%%order:
%%alternate return continuations, normal return, unwind continuations,
%%cut-to continuations. 
%%Its layout successor must implement the alternate return
%%continuations, if any, and the successor after that must be the normal
%%return continuations.
%%(If there are no alternate return continuations, the direct successor
%%implements the normal return continution.)
%%
%%If a graph has layout, the layout successor of a call node is a
%%(possibly empty) table of alternate return continuations.
%%This table may be a list of RTLs or a data block containing addresses.
%%The layout successor of the table is the normal return continuation.
%%
%%HOWEVER, IGNORING THE JUMP TABLE FOR ALTERNATE RETURNS, WE LAY OUT THE
%%NORMAL RETURN FIRST, THEN THE ALTERNATE RETURNS. FOR NOW, WE RELY ON THE
%%ASSEMBLER TO EMIT THE JUMP TABLE IMMEDIATELY AFTER THE CALL NODE.
%%
%%\item
%%A \emph{cut to} node
%%normally has a single successor (the exit) but may have multiple
%%successors. 
%%Its layout successor is unconstrained. 
%%\end{itemize}
%%\item
%%The entry node has a successor but no predecessor
%%\item
%%The exit node has one or more predecessors but no successor.
%%It is therefore considered a kind of join point.
%%\item
%%An \emph{illegal} node has no predecessors and no successors.
%%It is used to initialize mutable successor and predecessor fields.
%%\item
%%An \emph{impossible} node has two successors.
%%Its ordinary successor is its layout successor.
%%Its impossible successor is always the exit node.
%%(It exists to facilitate solution of backward dataflow problems, such
%%as liveness.)
%%An infinite loop must contain an impossible node so it can reach the
%%exit.
%%\end{itemize}
%%
\section{Invariants}
%%
%%The control-flow graph maintains several invariants:
%%\begin{itemize}
%%\item
%% The Golden Invariant: Each successor of a fork is a join point.
%%\end{itemize}
%%
\section{Interface}
%%
<<cfg.mli>>=
<<exported signatures>>
@ 
%%
<<exported signatures>>=
module type X = sig
  type jx  (* extension at join point *)
  type fx  (* extension at fork point *)
  type nx  (* extension at non-fork/join nodes *)
  val jx : unit -> jx
  val fx : unit -> fx
  val nx : unit -> nx
end

module type S = sig
  module X : X

  type label = string
  type 'i cfg
  type 'i t = 'i cfg
  type 'i node
  type regs  = Register.Set.t  (* sets of regs for dataflow *)
  type xregs = Register.SetX.t (* sets of regs for dataflow *)
  type 'i contedge = { kills:regs; defs:regs; node:'i node }
  type kind = (* all the kinds of nodes *)
    | Join | Instruction | StackAdjust | Branch | Cbranch | Mbranch
    | Jump  | Call | Return | CutTo
    | Entry | Exit | Assertion | Illegal | Impossible
  <<graph and node observers>>
  <<graph and node constructors>>
  <<graph and node mutators>>
end
@ 
<<cfg.mli>>=
module Make (X:X) : S with module X = X
@
\subsection{Interface summary}
%%Details are given below, but here are the observers:
<<graph and node observers>>=
@  
%%Here are the mutators:
<<graph and node mutators>>=
@  
%%Here are the constructors:
<<graph and node constructors>>=
@
\subsection{Observers}
%%
%%\paragraph{Observing nodes}
%%We can ask what graph the node belongs to.
<<graph and node observers>>=
val of_node       : 'i node -> 'i cfg
@ 
%%We can ask about the kind of a node, the unique number of a node, and we can compare
%%nodes for equality.
<<graph and node observers>>=
val kind          : 'i node -> kind
val num           : 'i node -> int
val eq            : 'i node -> 'i node -> bool
@ 
%%We can also ask particular predicates that relate to the kind.
%%A join node includes the exit node.
%%A \emph{head} node is the head of an extended basic block; it is
%%either the entry node or a join node that is not the exit node.
%%A non-local join node is one that can be reached only by [[cut to]] or stack
%%unwinding; if the [[is_non_local_join]] predicate is true, then the [[is_join]]
%%predicate must also be true.
<<graph and node observers>>=
val is_join           : 'i node -> bool
val is_non_local_join : 'i node -> bool
val is_fork           : 'i node -> bool
val is_head           : 'i node -> bool
@ 
%%We can ask for a label, or for all the labels, on a join node.
<<graph and node observers>>=
val label         : 'i node -> label      (* defined on any join node except exit *)
val labels        : 'i node -> label list (* defined on any join node except exit *)
@ 
%%We can ask for the instruction, if any.
%%An assertion is treated as an ordinary instruction.
%%If we ask for something \emph{executable}, we get only non-assertions.
<<graph and node observers>>=
val to_instr      : 'i node -> 'i option
val to_executable : 'i node -> 'i option
@ 
%%We can ask about the unique predecessor of a non-join node.
%%It is a checked run-time error to call this function on a join,
%%exit, entry, or illegal node.
%%Similarly, we can ask about the unique successor of a non-fork node.
<<graph and node observers>>=
val pred       : 'i node -> 'i node  (* defined on non-join, non-exit *)
val succ       : 'i node -> 'i node  (* defined on non-fork *)
@
%%We can ask about the true and false successor of a conditional branch.
%%It is a checked run-time error to call these functions on anything
%%other than a conditional branch.
<<graph and node observers>>=
val tsucc      : 'i node -> 'i node  (* defined on conditional branch *)
val fsucc      : 'i node -> 'i node  (* defined on conditional branch *)
@
%%We can ask for any successor by number, for any kind of node.
%%Successors are numbered from zero, the true successor precedes the
%%false successor (0~and~1), and the numbering for calls is
%%complicated. 
%%Function [[succ_n]] raises [[Invalid_argument]] if [[n]]~is
%%negative or too large.  
<<graph and node observers>>=
val succ_n     : 'i node -> int -> 'i node  (* defined on any node *)
@
%%For any kind of node, we can ask for all its successors and
%%predecessors.
<<graph and node observers>>=
val preds      : 'i node -> 'i node list  (* defined on any node *)
val succs      : 'i node -> 'i node list  (* defined on any node *)
@
%%For a call node, we may want to know how many successor edges are alternate
%%returns, cuts, or unwinds.
%%Functions like [[succ_n]] returns these edges in the standard order
%%(alternate returns, normal return, unwinds, and cuts).
<<graph and node observers>>=
val altrets    : 'i node -> int           (* defined only on call nodes *)
val cuts_to    : 'i node -> int           (* defined only on call nodes *)
val unwinds_to : 'i node -> int           (* defined only on call nodes *)
@
%%We can ask about the kinds of control-flow instructions.
<<graph and node observers>>=
val is_cti     : 'i node -> bool  (* is any control-flow 'i node *)
val is_br      : 'i node -> bool  (* is direct branch *)
val is_cbr     : 'i node -> bool  (* is conditional branch *)
val is_mbr     : 'i node -> bool  (* is multiway branch *)
val is_call    : 'i node -> bool
val is_cut     : 'i node -> bool
@ 
%%If a graph node has spans attached, we can fetch them.
%%This function is only defined on call nodes and join nodes.
<<graph and node observers>>=
val spans      : 'i node -> Spans.t option
@
%%We can get an extension suitable for the kind of node.
<<graph and node observers>>=
val jx         : 'i node -> X.jx  (* defined only on join nodes *)
val fx         : 'i node -> X.fx  (* defined only on fork nodes *)
val nx         : 'i node -> X.nx  (* defined only on non-fork, non-join *)
@ 
%%\paragraph{Observing the graph}
%%We can get the entry and exit nodes.
<<graph and node observers>>=
val entry      : 'i cfg -> 'i node
val exit       : 'i cfg -> 'i node
@ 
%%We can observe all the nodes.
%%We do so by providing higher-order functions.
%%These functions work by enumerating  \emph{basic blocks}.
%%A basic block is a sequence of nodes beginning in a \emph{head node} (a join
%%point or the entry node) and ending in a control-transfer node or the exit node.
%%The basic blocks are enumerated in no particular order.
%%Within a basic block, we enumerate nodes in order.
%%If the client mutates the graph, we make no guarantees about what
%%nodes may be visited.
%%We can also fold over the nodes in the layout order using [[fold_layout]]
%%and in postorder depth-first search (following successor links from the entry node),
%%using [[postorder_dfs]].
%%Calling [[fold_layout]] may insert unconditional branches or reverse
%%conditional branches in order to satisfy layout constraints.
%%Alternatively, we can fold over the reversed graph (following predecessor links from
%%the exit node) using [[reverse_podfs]].
<<graph and node observers>>=
val iter_nodes    : ('i node -> unit)           -> 'i cfg -> unit
val iter_heads    : ('i node -> unit)           -> 'i cfg -> unit
val fold_nodes    : ('i node -> 'a -> 'a) -> 'a -> 'i cfg -> 'a
val fold_heads    : ('i node -> 'a -> 'a) -> 'a -> 'i cfg -> 'a
val fold_layout   : ('i node -> 'a -> 'a) -> 'a -> 'i cfg -> 'a
val postorder_dfs : ('i node -> 'a -> 'a) -> 'a -> 'i cfg -> 'a
val reverse_podfs : ('i node -> 'a -> 'a) -> 'a -> 'i cfg -> 'a
@ 
%%\paragraph{Observing data flow}
%%As noted above a node can contribute defs, uses, and kills to each
%%outedge, and a non-join node may contribute uses to each inedge.
%%The access to this information is carefully crafted to support
%%liveness analysis and to provide for efficient implementation in the
%%common case where there is no dataflow.
%%
%%The [[union_over_outedges]] function is written in continuation-passing
%%style.  The [[noflow]] continuation is used in the common case when an
%%edge bears no dataflow information; the [[flow]] continuation is used
%%in the general case.  Clients must guarantee that
%%[[noflow n = flow {node=n; defs=empty; kills=empty}]].
%%In the common case, [[union_over_edges]] simply applies [[noflow]] to
%%its unique successor.
%%
%%Calling [[add_inedge_uses n l]] returns the union of~[[l]] with any
%%uses on the inedge to~[[n]].
%%It is defined on \emph{all} nodes, because there are no uses on the
%%inedges of a join point.
%%In the common case, it returns its second argument.
%%Calling [[add_live_spans n l]] returns the union of~[[l]] with any
%%registers kept live in spans.
%%Spans keep register live if they may be needed to walk the stack.
<<graph and node observers>>=
val union_over_outedges : 
  'i node -> noflow:('i node -> xregs) -> flow:('i contedge -> xregs) -> xregs
val add_inedge_uses: 'i node -> xregs -> xregs
val add_live_spans : 'i node -> xregs -> xregs
@
%%We may want to print a node for debugging purposes.
<<graph and node observers>>=
val print_node : Rtl.rtl node -> string
@ 
\subsection{Mutators}
%%We can change the graph by any of the following operations:
<<graph and node mutators>>=
@ 
%%\paragraph{Transactions}
%%
%%To debug an optimizer, we perform each code improvement as a
%%\emph{transaction}.
%%A~transaction is started by [[start_cond]] or [[start_exn]] and is
%%ended by [[finish]].
%%The claim is that the observable behavior of a program should be
%%unchanged by a transaction.
%%
%%As implemented at present, the transaction mechanism does nothing
%%other than provide each client (an optimization pass) a way to abort
%%itself when 
%%the \emph{transaction limit} is reached.
%%Function [[start_cond]] tells the client to abort by returning
%%[[false]];
%%function [[start_exn]] tells the client to abort by raising
%%[[Exhausted]].
%%The idea is that a test driver can do a binary search on the limit so
%%that we can identify exactly the transaction that causes a program to
%%fail. 
%%
%%N.B.~All flow graphs in a program share a single transaction counter
%%and limit. 
%%Each transaction is named so that we can identify what part of the
%%compiler made a faulty transaction.
<<graph and node mutators>>=
module Tx : sig
  exception Exhausted
  val start_cond : string -> bool   (* returns true iff transaction OK *)
  val start_exn  : string -> unit   (* raises Exhausted iff transaction not OK *)
  val finish     : unit   -> unit   (* marks end of transaction *)

  val set_limit  : int -> unit      (* set the transaction limit *)
  val used       : unit -> int      (* say how many transactions were used *)
  val last       : unit -> string   (* string passed to the last transaction *)
end
@ 
%%\paragraph{Altering successors}
%%We alter edges either by setting successors or by splicing in graphs.
%%These functions do whatever it takes to maintain invariants, which
%%means they may insert conditional branches or join points.
%%Function [[set_succ_n]] raises [[Invalid_argument]] if [[n]]~is
%%negative or too large.  
<<graph and node mutators>>=
val set_succ   : 'i cfg -> 'i node -> succ:'i node -> unit (* defined on non-fork *)
val set_tsucc  : 'i cfg -> 'i node -> succ:'i node -> unit
  (* defined on conditional branch *)
val set_fsucc  : 'i cfg -> 'i node -> succ:'i node -> unit
  (* defined on conditional branch *)
val set_succ_n : 'i cfg -> 'i node -> int -> succ:'i node -> unit
  (* defined on any node *)
@ 
%%The special function [[invert_cbr]] swaps the true and false
%%successors of a conditional branch.
%%It also updates the instruction payload appropriately.
%%It is a checked run-time error to use [[invert_cbr]] on any
%%instruction other than a conditional branch.
<<graph and node mutators>>=
val invert_cbr    : 'i node -> unit              (* defined on conditional branch *)
@
%%\paragraph{Splicing in new subgraphs}
%%Although setting one or more successors is general enough to implement
%%any graph mutation, we provide some convenient functions for splicing in
%%a single-entry, single-exit subgraph.
%%Such a subgraph is represented by its [[entry]], which must have
%%exactly one predecessor, and its [[exit]], which must have exactly one
%%successor.
%%It is permissible that the [[entry]] and [[exit]] be the same node.
%%In [[splice_on_every_edge_between]], the exit node must have only a single possible
%%successor (i.e. the exit node may not be a multiway branch or a conditional branch).
<<graph and node mutators>>=
val splice_on_every_edge_between : 'i cfg -> entry:'i node -> exit:'i node ->
                                   pred:'i node  -> succ:'i node -> unit
         (* [[pred]] is not multiway branch, call, or cutto *)
val splice_before : 'i cfg -> entry:'i node -> exit:'i node -> 'i node -> unit
         (* node is not join *)
val splice_after  : 'i cfg -> entry:'i node -> exit:'i node -> 'i node -> unit
         (* node is not fork *)
@
%%A node may be deleted if and only if all its predecessors are illegal.
%%If a node is deleted, and its successor is
%%\begin{enumerate}
%%\item illegal: nothing happens
%%\item join: the node is removed from the join's list of predecessors
%%\item other: the node's single predecessor is set to an illegal node
%%\end{enumerate}
<<graph and node mutators>>=
val delete        : 'i cfg -> 'i node -> unit    (* must have unique pred and succ *)
@
%%\paragraph{Altering instructions}
%%If a node carries an instruction payload, this function
%%updates the instruction.
%%If a node carries no instruction payload, this function silently does
%%nothing. 
%%Changing a branch or conditional-branch instruction automatically
%%changes its successors; changing a computed goto, call, cut to, or
%%jump does not.
<<graph and node mutators>>=
val update_instr  : ('i -> 'i) -> 'i node -> unit
@ 
%%We can attach spans to a call or join node; this function is undefined on other nodes.
<<graph and node mutators>>=
val set_spans     : 'i node -> Spans.t -> unit
@
\subsection{Constructors}
%%We can make a fresh graph.
%%Because the graph can insert join points at will, the client must
%%provide a supply of private labels.
%%The supply takes as argument a string~[[s]] and returns a unique label
%%that begins with~[[s]].
%%Because the graph must be able to insert conditional branches at will,
%%it is up  to the client to supply the appropriate function on
%%instructions.
%%Undoubtedly we will have to add some information about branch negation
%%as well. 
%%Perhaps ultimately we will use an analog of the embedding/projection
%%pairs specified in the [[Target]] module.
<<graph and node constructors>>=
type       label_supply        = string -> string
type 'i instruction_info = { goto    : (label, 'i) Ep.map
                           ; branch  : (Rtl.exp * label, 'i) Ep.map
                           ; bnegate : 'i -> 'i
                           }
val mk   : 'i instruction_info -> label_supply -> 'i cfg
@ 
%%We can clone the graph, simultaneously changing the representation of
%%instructions. 
%%N.B. the result is a ``shallow'' copy, not a ``deep'' one.
%%The cloned graph may share mutable state with the original, typically
%%in the extension fields.
%%%%% ==> don't remove blank line following decl
<<graph and node constructors>>=
val copy : 'j instruction_info -> ('i -> 'j) -> 'i cfg -> 'j cfg
@
%%We can make a variety of individual nodes.
%%These functions all mutate the graph, but we classify them as constructors anyway.
<<graph and node constructors>>=
val node_labeled           : 'i cfg -> label -> 'i node
val non_local_join_labeled : 'i cfg -> label -> 'i node
@ 
%%The [[node_labeled]] and [[non_local_join]] functions return join points
%%bearing the given label.  If no such join point exists, one is created.
%%The difference between these constructors is that code can flow into a regular join,
%%whereas a non-local join may only be reached via a [[cut to]] or stack unwind.
%%We may also want a join point immediately before some node. 
%%The [[join_leading_to]] function returns its argument if it is a join point, returns
%%the predecessor if it is a join point, or inserts and returns a join point immediately
%%before the argument.
%%N.B. The golden invariant ensures the second case will not go wrong.
<<graph and node constructors>>=
val join_leading_to : succ:'i node -> 'i node
@
%%In most cases, when we create a node we supply its successors.
%%The simple instruction is, well, simple.
%%A [[stack_adjust]] is just like an instruction, except that the code
%%expander and stack freezer know to treat it specially.
%%(Don't expand it and use the unsafe simplifier.)
<<graph and node constructors>>=
val instruction  : 'i cfg -> 'i -> succ:'i node -> 'i node
val stack_adjust : 'i cfg -> 'i -> succ:'i node -> 'i node
val assertion    : 'i cfg -> 'i -> succ:'i node -> 'i node
@ 
%%\paragraph{Control-flow nodes}
%%The graph knows how to make an unconditional branch and a conditional
%%branch. 
%%Otherwise, it's up to the client to supply the instruction that does
%%the transfer.
<<graph and node constructors>>=
val branch       : 'i cfg -> target:'i node -> 'i node
val jump         : 'i cfg -> 'i -> uses:regs -> targets:string list -> 'i node
val cbranch      : 'i cfg -> Rtl.exp -> ifso:'i node -> ifnot:'i node -> 'i node
val mbranch      : 'i cfg -> 'i -> targets:'i node list -> 'i node
val call         : 'i cfg -> 'i -> altrets:'i contedge list -> succ:'i node ->
                     unwinds_to:'i contedge list -> cuts_to:'i contedge list ->
                     aborts:bool -> uses:regs -> defs:regs -> kills:regs ->
                     reads:string list option -> writes:string list option ->
                     spans:Spans.t option -> 'i node
val cut_to       : 'i cfg -> 'i -> cuts_to:'i contedge list -> aborts:bool ->
                     uses:regs -> 'i node
val return       : 'i cfg -> 'i -> uses:regs -> 'i node
@ 
%%N.B. So that a [[call]] can be composed in sequence just like an
%%[[instruction]], the ordinary return from a call is called [[succ]].
%%
%%The weird nodes.
<<graph and node constructors>>=
val impossible   : 'i cfg -> succ:'i node -> 'i node
val illegal      : 'i cfg -> 'i node  (* a node that must never be reached *)
@
%%
\section{Implementation}
<<cfg.ml>>=
open Nopoly
<<exported signatures>>
module Make (X:X) : S with module X = X = struct
  module R   = Register
  module RS  = R.Set
  type regs  = Register.Set.t  (* sets of regs for dataflow *)
  type xregs = Register.SetX.t (* sets of regs for dataflow *)
  module IS  = Set.Make (struct type t = int let compare = compare end)
  module RSX = R.SetX
  module SM  = Strutil.Map
  module X   = X

  type label = string
  type label_supply = string -> label
  type 'i instruction_info = { goto    : (label, 'i) Ep.map
                             ; branch  : (Rtl.exp * label, 'i) Ep.map
                             ; bnegate : 'i -> 'i
                             }

  type kind = (* all the kinds of nodes *)
    | Join | Instruction | StackAdjust | Branch | Cbranch | Mbranch
    | Jump  | Call | Return | CutTo
    | Entry | Exit | Assertion | Illegal | Impossible
  <<node type>>
  and  'i contedge = { kills:regs; defs:regs; node:'i node }
  and  'i cfg = { mutable entry     : 'i node
                ; mutable exit      : 'i node (*mutable for bootstrapping cfg*)
                ; mutable ill       : 'i node (*mutable for bootstrapping cfg*)
                ;         inst_info : 'i instruction_info
                ; mutable label_map : 'i node SM.t
                ;         mk_label  : label_supply
                }
  type 'i t = 'i cfg

  <<graph utilities>>
  <<graph and node observers implementation>>
  <<printing utilities>>
  <<remove node predecessors>>
  <<set node successors>>

  <<simple node constructors>>
  <<node constructors with interesting control flow edges>>
  <<graph construction and copying>>

  <<graph and node mutators implementation>>
end
@
%%
\subsection{Node Type}
%%Abbreviations:
%%\begin{quote} 
%%\noindent
%%\begin{tabular}{>{\ttfamily}ll}
%%ent& Entry\\
%%exi& Exit\\
%%joi& Join\\
%%ins& Instruction\\
%%sta& Stack adjustment\\
%%ass& Assertion\\
%%bra& Branch\\
%%cbr& Conditional branch\\
%%mbr& Multiway branch (computed goto)\\
%%cal& Call\\
%%cut& Cut to\\
%%ret& Return\\
%%jum& Jump\\
%%imp& Impossible\\
%%ill& Illegal\\
%%\end{tabular}
%%\end{quote}
%%
%%Suffixes:
%%\begin{quote} 
%%\noindent
%%\begin{tabular}{>{\ttfamily}ll}
%%i    & Instruction\\
%%num  & Unique Node Number\\
%%labels & Multiple Labels\\
%%contedges & Control-Flow Edges\\
%%cfg  & Control-Flow Graph\\
%%pred & Single Predecessor\\
%%preds& Multiple Predecessors\\
%%succ & Single Successor\\
%%succs& Multiple Successors\\
%%lpred & Layout Predecessor\\
%%lsucc & Layout Successor\\
%%jx    & Join Extension\\
%%fx    & Fork Extension\\
%%nx    & Non-Branch/Fork Extension\\
%%\end{tabular}
%%\end{quote}
<<node type>>=
type ('i, 'n)     ent = {         ent_num    : int
                        ; mutable ent_succ   : 'n 
                        ;         ent_nx     : X.nx
                        }
type ('i, 'n, 'c) exi = {         exi_num    : int
                        ; mutable exi_cfg    : 'c
                        ; mutable exi_labels : label list
                        ; mutable exi_preds  : 'n list
                        ; mutable exi_lpred  : 'n
                        ;         exi_jx     : X.jx
                        }
type ('i, 'n, 'c) joi = {         joi_num    : int
                        ;         joi_local  : bool
                        ; mutable joi_labels : label list
                        ; mutable joi_cfg    : 'c
                        ; mutable joi_preds  : 'n list
                        ; mutable joi_succ   : 'n
                        ; mutable joi_lpred  : 'n
                        ;         joi_jx     : X.jx
                        ; mutable joi_spans  : Spans.t option
                        }
type ('i, 'n)     ins = {         ins_num    : int
                        ; mutable ins_i      : 'i
                        ; mutable ins_pred   : 'n
                        ; mutable ins_succ   : 'n
                        ;         ins_nx     : X.nx
                        }
type ('i, 'n)     sta = {         sta_num    : int
                        ; mutable sta_i      : 'i
                        ; mutable sta_pred   : 'n
                        ; mutable sta_succ   : 'n
                        ;         sta_nx     : X.nx
                        }
type ('i, 'n)     ass = {         ass_num    : int
                        ; mutable ass_i      : 'i
                        ; mutable ass_pred   : 'n
                        ; mutable ass_succ   : 'n
                        ;         ass_nx     : X.nx
                        }
type ('i, 'n)     bra = {         bra_num    : int
                        ; mutable bra_i      : 'i
                        ; mutable bra_pred   : 'n
                        ; mutable bra_succ   : 'n
                        ; mutable bra_lsucc  : 'n
                        ;         bra_nx     : X.nx
                        }
type ('i, 'n)     cbr = {         cbr_num    : int
                        ; mutable cbr_i      : 'i
                        ; mutable cbr_pred   : 'n
                        ; mutable cbr_true   : 'n
                        ; mutable cbr_false  : 'n
                        ;         cbr_fx     : X.fx
                        }
type ('i, 'n)     mbr = {         mbr_num    : int
                        ; mutable mbr_i      : 'i
                        ; mutable mbr_pred   : 'n
                        ; mutable mbr_succs  : 'n array
                        ; mutable mbr_lsucc  : 'n
                        ;         mbr_fx     : X.fx
                        }
@
%%
%%Note that the different types of successor edges for a call node are not
%%maintained because they are not distinguished in the flow-graph interface.
%%If a call also aborts, the called procedure can let control flow to any
%%non-local continuations.
%%In this case, the exit node is a successor of the call node.
%%
<<node type>>=
type ('i, 'n, 'e) cal = {         cal_num        : int
                        ; mutable cal_i          : 'i
                        ; mutable cal_pred       : 'n
                        ; mutable cal_contedges  : 'e array
                        ; mutable cal_lsucc      : 'n
                        ;         cal_fx         : X.fx
                        ; mutable cal_spans      : Spans.t option
                        ; mutable cal_uses       : regs
                        ;         cal_altrets    : int
                        ;         cal_unwinds_to : int
                        ;         cal_cuts_to    : int
                        ;         cal_reads      : string list option
                        ;         cal_writes     : string list option
                        }
type ('i, 'n, 'e) cut = {         cut_num        : int
                        ; mutable cut_i          : 'i
                        ; mutable cut_pred       : 'n
                        ; mutable cut_lsucc      : 'n
                        ; mutable cut_contedges  : 'e array
                        ;         cut_fx         : X.fx
                        ; mutable cut_uses       : regs
                        }
type ('i, 'n)     jum = {         jum_num        : int
                        ; mutable jum_i          : 'i
                        ; mutable jum_pred       : 'n
                        ; mutable jum_succ       : 'n
                        ; mutable jum_lsucc      : 'n
                        ;         jum_nx         : X.nx
                        ; mutable jum_uses       : regs
                        }
type ('i, 'n)     ret = {         ret_num        : int
                        ; mutable ret_i          : 'i
                        ; mutable ret_pred       : 'n
                        ; mutable ret_succ       : 'n
                        ; mutable ret_lsucc      : 'n
                        ;         ret_nx         : X.nx
                        ; mutable ret_uses       : regs
                        }
type ('i, 'n)     imp = {         imp_num        : int
                        ; mutable imp_pred       : 'n
                        ; mutable imp_succ       : 'n
                        ; mutable imp_exit_succ  : 'n
                        ;         imp_fx         : X.fx
                        }
type ('i, 'n, 'c) ill = {         ill_num        : int
                        ;         ill_nx         : X.nx
                        ; mutable ill_cfg        : 'c
                        }


type 'i node =
  | Boot
  | Ent of ('i, 'i node)              ent  
  | Exi of ('i, 'i node, 'i cfg)      exi  
  | Joi of ('i, 'i node, 'i cfg)      joi  
  | Ins of ('i, 'i node)              ins  
  | Sta of ('i, 'i node)              sta
  | Ass of ('i, 'i node)              ass  
  | Bra of ('i, 'i node)              bra  
  | Cbr of ('i, 'i node)              cbr  
  | Mbr of ('i, 'i node)              mbr  
  | Cal of ('i, 'i node, 'i contedge) cal  
  | Cut of ('i, 'i node, 'i contedge) cut  
  | Ret of ('i, 'i node)              ret  
  | Jum of ('i, 'i node)              jum  
  | Imp of ('i, 'i node)              imp  
  | Ill of ('i, 'i node, 'i cfg)      ill  
@
%%The observers are straightforward.
<<graph and node observers implementation>>=
let kind = kind_util
let num = num_util

let is_join node = match node with
  | Joi _ | Exi _ -> true
  | _             -> false
let is_non_local_join node = match node with
  | Joi j -> not j.joi_local
  | _     -> false
let is_head node = match node with
  | Joi _ | Ent _ -> true
  | _             -> false
let is_fork node = match node with
  | Cbr _ | Mbr _ | Cal _ | Cut _ | Imp _ -> true
  | _                                     -> false

let to_instr node = match node with
  | Ins i -> Some i.ins_i
  | Sta i -> Some i.sta_i
  | Ass a -> Some a.ass_i
  | Bra b -> Some b.bra_i
  | Cbr c -> Some c.cbr_i
  | Mbr m -> Some m.mbr_i
  | Cal c -> Some c.cal_i
  | Cut c -> Some c.cut_i
  | Jum j -> Some j.jum_i
  | Ret r -> Some r.ret_i
  | Ent _ -> None
  | Exi _ -> None
  | Joi _ -> None
  | Imp _ -> None
  | Ill _ -> None
  | Boot  -> undef "to_instr or to_executable" "boot"
let to_executable node = match node with
  | Ass _ -> None
  | _     -> to_instr node
@
%%Join and exit nodes must have at least one label.
%%No other node has a label.
%%Both functions are defined only on nodes with labels.
%%For now, we have added a hook to log when somebody asks for the label of an
%%exit node.
%%It may make sense to add an observer that returns an empty list if the node
%%is not a join or exit node.
<<graph and node observers implementation>>=
let label node = match node with
  | Joi j -> (try List.hd j.joi_labels
              with Failure _ -> imposs "no labels at join")
  | Exi e -> ( log "label called on exit node"
             ; try List.hd e.exi_labels
               with Failure _ -> imposs "no labels at exit"
             )
  | _     ->  undef "label" "non-join"

let labels node = match node with
  | Joi j -> j.joi_labels
  | Exi e -> ( log "labels called on exit node" ; e.exi_labels )
  | _     -> undef "labels" "non-join"
@
%%[[pred]] is defined only on a node that must have only a single predecessor.
<<graph and node observers implementation>>=
let pred node = match node with
  | Ins i -> i.ins_pred
  | Sta i -> i.sta_pred
  | Ass a -> a.ass_pred
  | Bra b -> b.bra_pred
  | Cbr c -> c.cbr_pred
  | Mbr m -> m.mbr_pred
  | Cal c -> c.cal_pred
  | Cut c -> c.cut_pred
  | Jum j -> j.jum_pred
  | Ret r -> r.ret_pred
  | Imp i -> i.imp_pred
  | Ent _ -> undef "pred" "entry"
  | Joi _ -> undef "pred" "join"
  | Exi _ -> undef "pred" "exit"
  | Ill _ -> undef "pred" "illegal"
  | Boot  -> undef "pred" "boot"
@
%%[[tsucc]] and [[fsucc]] are defined only on conditional-branch nodes.
<<graph and node observers implementation>>=
let tsucc node = match node with
  | Cbr c -> c.cbr_true
  | _     -> undef "tsucc" "non-cond-branch"
let fsucc node = match node with
  | Cbr c -> c.cbr_false
  | _     -> undef "fsucc" "non-cond-branch"
@
%%There are two cases: nodes with a single successor and nodes with multiple
%%successors.
%%The single case is handled by returning the successor if $n = 0$.
%%The multiple case is handled by fetching the $nth$ element from the successor
%%array.
<<graph and node observers implementation>>=
let succ_n node n =
  let fail ()    = raise (Invalid_argument "succ_n: illegal index") in
  let single s n = if n = 0 then s else fail ()                     in
  let mult a n   = try a.(n) with Invalid_argument _ -> fail ()     in
  match node with
  | Joi j -> single j.joi_succ n
  | Ins i -> single i.ins_succ n
  | Sta i -> single i.sta_succ n
  | Ass a -> single a.ass_succ n
  | Bra b -> single b.bra_succ n
  | Jum j -> single j.jum_succ n
  | Ret r -> single r.ret_succ n
  | Ent e -> single e.ent_succ n
  | Mbr m -> mult m.mbr_succs n
  | Cal c -> mult (ce_getnodes c.cal_contedges) n
  | Cut c -> mult (ce_getnodes c.cut_contedges) n
  | Cbr c ->
    if n = 0 then c.cbr_true
    else if n = 1 then c.cbr_false
    else fail ()
  | Imp i -> 
    if n = 0 then i.imp_succ
    else if n = 1 then i.imp_exit_succ
    else fail ()
  | Exi _ -> undef "succ_n" "exit"
  | Ill _ -> undef "succ_n" "illegal"
  | Boot  -> undef "succ_n" "boot"
@
%%[[succ]] is defined only on non-fork nodes.
<<graph and node observers implementation>>=
let succ node = match node with
  | Ins i -> i.ins_succ
  | Sta i -> i.sta_succ
  | Ass a -> a.ass_succ
  | Joi j -> j.joi_succ
  | Bra b -> b.bra_succ
  | Jum j -> j.jum_succ
  | Ret r -> r.ret_succ
  | Ent e -> e.ent_succ
  | Mbr _ -> undef_with_node (num node) "succ" "multi branch"
  | Cbr _ -> undef_with_node (num node) "succ" "cond branch"
  | Cal _ -> undef_with_node (num node) "succ" "call"
  | Imp _ -> undef_with_node (num node) "succ" "impossible"
  | Cut _ -> undef_with_node (num node) "succ" "cut"
  | Exi _ -> undef_with_node (num node) "succ" "exit"
  | Ill _ -> undef_with_node (num node) "succ" "illegal"
  | Boot  -> undef_with_node (num node) "succ" "boot"
@
%%The cfg is stored in join points and illegal nodes.
%%We find the cfg by following the first successor until we reach a join point
%%or illegal node.
%%We also keep a list of nodes ([[badlist]]) we have visited to detect loops.
<<graph and node observers implementation>>=
let get_cfg start_node =
  let rec search n badlist =
    if List.exists (eq n) badlist then
      imposs "cycle in cfg with no join node"
    else match n with
        | Exi e -> e.exi_cfg
        | Joi j -> j.joi_cfg
        | Ill i -> i.ill_cfg
        | n     -> search (succ_n n 0) (n::badlist) in
  search start_node []
let of_node = get_cfg
@
%%We avoid showing duplicates to the client.
%%Duplicates are useful in the case when a multiway branch has multiple
%%branches to the same successor.
%%Without duplicates in the internal representation, it would be unpleasant to
%%update the succ/pred list when changing a branch.
%%
%%Internally, we provide the [[all_incoming]] function for cases where we need to see all
%%incoming edges, not just the predecessors.
%%Similarly with [[all_outgoing]] for successor edges.
<<graph and node observers implementation>>=
let all_incoming node = match node with
  | Ins i -> [i.ins_pred]
  | Sta i -> [i.sta_pred]
  | Ass a -> [a.ass_pred]
  | Bra b -> [b.bra_pred]
  | Cbr c -> [c.cbr_pred]
  | Mbr m -> [m.mbr_pred]
  | Cal c -> [c.cal_pred]
  | Cut c -> [c.cut_pred]
  | Jum j -> [j.jum_pred]
  | Ret r -> [r.ret_pred]
  | Imp i -> [i.imp_pred]
  | Joi j -> j.joi_preds
  | Exi e -> e.exi_preds
  | Ent _ -> []
  | Ill _ -> []
  | Boot  -> undef "preds" "boot"

let preds node = uniq (all_incoming node)

let all_outgoing node = match node with
  | Joi j -> [j.joi_succ]
  | Ins i -> [i.ins_succ]
  | Sta i -> [i.sta_succ]
  | Ass a -> [a.ass_succ]
  | Bra b -> [b.bra_succ]
  | Jum j -> [j.jum_succ]
  | Ret r -> [r.ret_succ]
  | Ent e -> [e.ent_succ]
  | Cbr c -> [c.cbr_false; c.cbr_true]
  | Imp i -> [i.imp_succ; i.imp_exit_succ]
  | Mbr m -> (Array.to_list m.mbr_succs)
  | Cal c -> (Array.to_list (ce_getnodes c.cal_contedges))
  | Cut c -> (Array.to_list (ce_getnodes c.cut_contedges))
  | Exi _ -> []
  | Ill _ -> []
  | Boot  -> undef "succs" "boot"
let succs node = uniq (all_outgoing node)
@
%%It may be useful to find the number of alternate returns, unwinds, or
%%[[cuts_to]] edges at a call node.
%%Functions like [[succ_n]] returns these edges in the standard order
%%(alternate returns, normal return, unwinds, and cuts).
<<graph and node observers implementation>>=
let altrets node = match node with
  | Cal c -> c.cal_altrets
  | _     -> undef "altrets" "non-call"
let cuts_to node = match node with
  | Cal c -> c.cal_cuts_to
  | _     -> undef "cuts" "non-call"
let unwinds_to node = match node with
  | Cal c -> c.cal_unwinds_to
  | _     -> undef "unwinds" "non-call"
@
%%We have several observers that check the type of a node.
%%The jump and return nodes are not interesting forms of control flow with
%%regards to a procedure's control-flow graph.
<<graph and node observers implementation>>=
let is_cti node = match node with
  | Bra _ | Cbr _ | Mbr _ | Cal _ | Cut _ -> true
  | _                                     -> false
let is_br node = match node with
  | Bra _ -> true
  | _     -> false
let is_cbr node = match node with
  | Cbr _ -> true
  | _     -> false
let is_mbr node = match node with
  | Mbr _ -> true
  | _     -> false
let is_call node = match node with
  | Cal _ -> true
  | _     -> false
let is_cut node = match node with
  | Cut _ -> true
  | _     -> false
let spans node = match node with
  | Cal c -> c.cal_spans
  | Joi j -> j.joi_spans
  | _     -> undef_with_node (num node) "spans" "non-call or non-join"
@
%%Each node has data attached to it. We hope to limit this data to join points
%%someday.
<<graph and node observers implementation>>=
let jx node = match node with
  | Joi j -> j.joi_jx
  | Exi e -> e.exi_jx 
  | _     -> undef "jx" "non-join"

let fx node = match node with
  | Cbr c -> c.cbr_fx
  | Mbr m -> m.mbr_fx
  | Cal c -> c.cal_fx 
  | Cut c -> c.cut_fx
  | Imp i -> i.imp_fx
  | _     -> undef "fx" "non-fork"

let nx node = match node with
  | Ins i -> i.ins_nx
  | Sta i -> i.sta_nx
  | Ass a -> a.ass_nx
  | Bra b -> b.bra_nx
  | Jum j -> j.jum_nx
  | Ret r -> r.ret_nx
  | Ent e -> e.ent_nx
  | Ill i -> i.ill_nx
  | _     -> undef "nx" "fork and join"

let entry cfg = cfg.entry
let exit  cfg = cfg.exit
@
%%We have several functions to iterate or fold over the nodes of the graph.
%%[[fold_heads]] folds over the entry node and the join points.
%%[[fold_nodes]] folds over all the nodes in the cfg.
<<graph and node observers implementation>>=
let fold_heads f zero cfg = List.fold_left (fun x y -> f y x) zero (heads cfg)
@ 
%%In [[fold_nodes]], we are careful to make sure we visit every single node in the graph,
%%regardless of whether it is accessible from the entry or exit nodes, via predecessors
%%or successors.
%%We first gather all the nodes in a set.
%%Although it is redundant, we have to use a set to efficiently keep track of which nodes
%%we have already visited, and keep track of the list of nodes separately.
%%We cannot use the standard OCaml [[Set]] module because it would require specializing
%%the type of the node.
%%Gathering the set guarantees that we visit each node in the cfg without allowing the
%%function [[cons]] to affect the traversal.
<<graph and node observers implementation>>=
<<join node set operations>>
let fold_nodes cons nil g =
  let cons x y = cons y x in
  let rec vchildren children k set lst = 
    match children with
    | c::rst -> vnode c (vchildren rst k) set lst
    | []     -> k set lst
  and vnode n k set lst =
    if IS.mem (num n) set then
      k set lst
    else
      let preds = preds n in
      let succs = succs n in
      vchildren succs (vchildren preds k) (IS.add (num n) set) (n::lst) in
  vnode (entry g) (fun _ lst -> List.fold_left cons nil lst)
        IS.empty []
let iter_nodes f = fold_nodes (fun n () -> f n) ()
let iter_heads f = fold_heads (fun n () -> f n) ()
@
%%[[cps_postorder_dfs]] gives us a postorder dfs over the graph.
%%[[vnode]] visits a node, which in turn visits each of the node's children
%%before acting on the node itself.
%%[[vchildren]] actually visits each of the children in turn. The visit to the
%%rest of the children is passed on as a continuation.
%%Tail-recursive.
%%NOTE: WHEN ALL NODES ARE ACCESSIBLE BY FOLLOWING PREDS FROM THE EXIT NODE, IT
%%MAY BE WORTH CONSIDERING A PREORDER DFS FROM THE EXIT NODE. POSTORDER DFS FROM
%%THE ENTRY SEEMS GOOD FOR MAKING DECISIONS AT FORK NODES, WHEREAS PREORDER DFS
%%FROM EXIT SEEMS GOOD FOR MAKING DECISIONS AT JOIN POINTS.
<<graph and node observers implementation>>=
let cps_postorder_dfs heads get_children g cons nil cont =
  let rec vnode node cont acc visited =
    if member node visited then
      cont acc visited
    else
      vchildren node (get_children node) cont acc (add node visited)
  and vchildren node children cont acc visited = 
    let rec next children acc visited = match children with
      | [] -> cont (cons node acc) visited
      | n::rst -> vnode n (next rst) acc visited in
    next children acc visited in
  let rec fold_heads heads cont acc visited =
    match heads with
    | h::rst -> vnode h (fold_heads rst cont) acc visited
    | []     -> cont acc visited in
  fold_heads heads cont nil emptyset
@
%%Note that by only taking successors or predecessors, each of these traversals may miss
%%some nodes in the cfg.
<<graph and node observers implementation>>=
let postorder_dfs cons nil g =
  cps_postorder_dfs [entry g] succs g cons nil (fun x _ -> x)
let reverse_podfs cons nil g =
  cps_postorder_dfs [exit  g] preds g cons nil (fun x _ -> x)
@
%%Edges may have control flow.
%%We need to be able to examine uses on inedges and defs/kills on outedges.
%%NOTE: I STILL FEEL THAT USES/DEFS/KILLS SHOULD BE PLACED AT THE NODE - THE
%%NODE IS RESPONSIBLE FOR THESE ACTIONS. THE EDGE DOESN'T ACTUALLY TAKE AN
%%ACTION, WHICH IS WHY THE LIVE SETS MAKE SENSE ON THE EDGES.
<<graph and node observers implementation>>=
(* should this fn be defined on exi and ill?
   when there are cont edges, do we still need to cover the regular edges?*)
let (++) = RSX.union
let union_over_outedges node ~noflow ~flow =
  let union_contedges ce =
    Array.fold_left (fun r s -> r ++ flow s) RSX.empty ce in
  match node with
  | Cal c -> union_contedges c.cal_contedges
  | Cut c -> union_contedges c.cut_contedges
  | Cbr c -> noflow c.cbr_true ++ noflow c.cbr_false
  | Imp i -> noflow i.imp_succ ++ noflow i.imp_exit_succ
  | Mbr m -> Array.fold_right (fun s -> (++) (noflow s)) m.mbr_succs RSX.empty
  | Ins i -> noflow i.ins_succ
  | Sta i -> noflow i.sta_succ
  | Ass a -> noflow a.ass_succ
  | Bra b -> noflow b.bra_succ
  | Jum j -> noflow j.jum_succ
  | Ret r -> noflow r.ret_succ
  | Ent e -> noflow e.ent_succ
  | Joi j -> noflow j.joi_succ
  | Exi e -> RSX.empty
  | Ill i -> RSX.empty
  | Boot  -> imposs "union_over_outedges undefined on boot nodes"
  
let add_inedge_uses node regs =
  let reg_add  = RS.fold (fun r rst -> RSX.add (R.Reg r) rst) in
  match node with
  | Cal c -> reg_add c.cal_uses regs
  | Cut c -> reg_add c.cut_uses regs
  | Jum j -> reg_add j.jum_uses regs
  | Ret r -> reg_add r.ret_uses regs
  | _     -> regs

let add_live_spans node regs =
  let span_add spans rst = match spans with
    | Some ss -> Spans.fold_live_locs RSX.add ss rst
    | None    -> rst in
  match node with
  | Cal c -> span_add c.cal_spans regs
  | Joi j -> span_add j.joi_spans regs
  | _     -> regs
@ 
%%Although only internally visible, the [[remove_pred]] function is vital.
%%For join and exit nodes, we remove [[node]] from the predecessor list.
%%For other nodes, we set the predecessor to the illegal node.
<<remove node predecessors>>=
let remove_pred cfg node ~old_succ =
  let rec rem_1_list lst = match lst with
    | [] -> imposs "remove_pred: predecessor to be removed not found"
    | n::rst when eq n node -> rst
    | n::rst -> n :: rem_1_list rst in
  match old_succ with
  | Joi j -> j.joi_preds <- rem_1_list j.joi_preds
  | Exi e -> e.exi_preds <- rem_1_list e.exi_preds
  | Ins i -> i.ins_pred  <- cfg.ill
  | Sta i -> i.sta_pred  <- cfg.ill
  | Bra b -> b.bra_pred  <- cfg.ill
  | Cbr c -> c.cbr_pred  <- cfg.ill
  | Mbr m -> m.mbr_pred  <- cfg.ill
  | Jum j -> j.jum_pred  <- cfg.ill
  | Cal c -> c.cal_pred  <- cfg.ill
  | Ret r -> r.ret_pred  <- cfg.ill
  | Cut c -> c.cut_pred  <- cfg.ill
  | Ass a -> a.ass_pred  <- cfg.ill
  | Imp i -> i.imp_pred  <- cfg.ill
  | Ill _ -> ()
  | Ent _ -> imposs "entry node was a successor"
  | Boot  -> imposs "boot nodes should not live to remove_pred"
@
%%
%%
%%The set successors functions are exported through the interface and also used
%%throughout the cfg implementation.
%%
%%[[node_labeled]] is fundamental to setting the successors, since join points
%%must frequently be inserted.
<<set node successors>>=
let mk_join cfg labels ~preds ~lpred ~succ ~local ~spans =
  let join = Joi { joi_num    = new_num ()
                 ; joi_local  = local
                 ; joi_labels = labels
                 ; joi_cfg    = cfg
                 ; joi_preds  = preds
                 ; joi_succ   = succ
                 ; joi_lpred  = lpred
                 ; joi_jx     = X.jx ()
                 ; joi_spans  = spans
                 } in
  List.iter (fun l -> cfg.label_map <- SM.add l join cfg.label_map) labels;
  join

let node_labeled cfg label =
  try SM.find label cfg.label_map
  with Not_found -> mk_join cfg [label] ~preds:[] ~lpred:cfg.ill ~succ:cfg.ill
                                ~local:true ~spans:None
let non_local_join_labeled cfg label =
  try let n = SM.find label cfg.label_map in
      match n with
      | Joi j when j.joi_local ->
          imposs "CFG: non_local_join_labeled called on local join"
      | Joi _ -> n
      | _     -> imposs "CFG: non-join found in label_map"
  with Not_found -> mk_join cfg [label] ~preds:[] ~lpred:cfg.ill ~succ:cfg.ill
                                ~local:false ~spans:None
@
%%[[join_leading_to]] returns [[succ]] or its predecessor if one is a join point;
%%otherwise, it inserts a join point between [[succ]] and its predecessor.
%%Since [[succ]] is not a join point, we know that [[succ]] is the sole successor of
%%its predecessor (golden invariant).
%%The join point is then returned.
%%This function can be useful for maintaining the golden invariant.
<<set node successors>>=
let rec join_leading_to ~succ =
  if is_join succ then succ
  else
    let cfg = get_cfg succ in
    if is_ill succ then 
      let join = node_labeled cfg (cfg.mk_label "join") in
      let () = set_succ cfg join ~succ:succ in
      join
    else
      let p = pred succ in (* p must not be a fork b/c succ is not a join *)
      if is_join p then p
      else let join = node_labeled cfg (cfg.mk_label "join") in
           let () = if not (is_ill p) then set_succ cfg p ~succ:join in
           let () = set_succ cfg join ~succ:succ in
           join
@
%%[[set_succ']] takes four steps to set the successor of [[node]] to [[succ]]
%%(where [[old_succ]] is [[node]]'s successor when this function is called):
%%\begin{enumerate}
%%\item
%%  If [[succ]] is a join point or an illegal node, then it is a valid
%%  successor.
%%  But otherwise, if [[succ]] already has a legal successor, then we need to
%%  insert a join point between [[succ]] and its predecessor, and use that join
%%  point as the new successor.
%%  We insert the join point by using [[join_leading_to]] in the recursive call.
%%\item
%%  Modify [[old_succ]] to remove [[node]] as a predecessor.
%%\item
%%  Modify [[succ]] to have [[node]] as a predecessor.
%%\item
%%  Modify [[node]] to have [[succ]] as a successor.
%%\end{enumerate}
%%The [[single]], [[ce_mult]], [[mult]], and [[cbr]] continuations are used to set
%%the successor of [[node]], depending on whether [[node]] is a node with a
%%single successor, multiple successors with control-flow edges, multiple
%%successors with no such edges, or a conditional branch.
<<set node successors>>=
and set_succ' cfg ~single ~ce_mult ~mult ~cbr ~node ~old_succ ~succ =
  if not (is_join succ) && not (is_ill succ) && not (is_ill (pred succ)) then
    set_succ' cfg ~single ~ce_mult ~mult ~cbr ~node ~old_succ
              ~succ:(join_leading_to succ)
  else
    begin
      ( (
   <<modify the $n$th successor of [[node]] because [[node]] is no longer a predecessor>>
     )
      ; let succ = (
         <<update [[node]]'s $n$th successor field to point to [[succ]]>>
        ) in
        (if not (is_ill succ)
         then 
          <<modify [[succ]] because [[node]] has become a predecessor>>
        )
      )
    end
@
%%Call the appropriate continuation to update [[node]]'s successor.
<<update [[node]]'s $n$th successor field to point to [[succ]]>>=
match node with
| Joi j -> j.joi_succ <- single succ; succ
| Ins i -> i.ins_succ <- single succ; succ
| Sta i -> i.sta_succ <- single succ; succ
| Ass a -> a.ass_succ <- single succ; succ
| Jum j -> j.jum_succ <- single succ; succ
| Ret r -> r.ret_succ <- single succ; succ
| Ent e -> e.ent_succ <- single succ; succ
| Mbr m -> ignore (mult m.mbr_succs        (fun _ -> succ)); succ
| Cal c ->
  let succ = join_leading_to succ in
  ignore (ce_mult c.cal_contedges (fun s -> {s with node = succ})); succ
| Cut c -> ignore (ce_mult c.cut_contedges (fun s -> {s with node = succ})); succ
| Bra b ->
  let succ = join_leading_to succ in
  ( b.bra_i <- (get_cfg node).inst_info.goto.Ep.embed (label succ)
  ; b.bra_succ <- single succ
  ; succ
  )
| Cbr c -> 
  let succ = join_leading_to succ in
  let cfg = get_cfg node in
  (if cbr () then
     c.cbr_true  <- succ
   else
     c.cbr_false <- succ
  );
  let (cond, _) = cfg.inst_info.branch.Ep.project c.cbr_i in
  c.cbr_i <- cfg.inst_info.branch.Ep.embed (cond, label c.cbr_true);
  succ
| Imp i ->
  let succ = join_leading_to succ in
  if cbr () then i.imp_succ <- succ
  else if is_exi succ then i.imp_exit_succ <- succ
  else imposs "exit_succ must be an exit node";
  succ
| Exi _ -> undef "set_succ" "exit"
| Ill _ -> undef "set_succ" "illegal"
| Boot  -> undef "set_succ" "boot"
@ 
<<modify the $n$th successor of [[node]] because [[node]] is no longer a predecessor>>=
remove_pred cfg node old_succ
@
%%Adding a predecessor.
<<modify [[succ]] because [[node]] has become a predecessor>>=
let join_pred cur_preds = match cur_preds with
  | [Ill _] -> [node]
  | _       -> node::cur_preds in
match succ with
| Ins i -> i.ins_pred  <- node
| Sta i -> i.sta_pred  <- node
| Ass a -> a.ass_pred  <- node
| Bra b -> b.bra_pred  <- node
| Jum j -> j.jum_pred  <- node
| Ret r -> r.ret_pred  <- node
| Imp i -> i.imp_pred  <- node
| Cbr c -> c.cbr_pred  <- node
| Mbr m -> m.mbr_pred  <- node
| Cal c -> c.cal_pred  <- node
| Cut c -> c.cut_pred  <- node
| Exi e -> e.exi_preds <- join_pred e.exi_preds
| Joi j -> j.joi_preds <- join_pred j.joi_preds
| Ent e -> imposs "something tried to become a predecessor of the entry node"
| Ill i -> imposs "client can make a pointer dangle, but believed to be handled above"
| Boot  -> undef "add_pred" "boot"
@
%%The continuations passed to [[set_succ']] determine the domain of the
%%function.
%%[[set_succ_n]] ensures that a node with a single successor will only modify
%%the $0th$ successor.
%%Similarly, [[set_succ]] ensures that nodes with multiple successors are never
%%modified.
<<set node successors>>=
and set_succ_n cfg node n ~succ:succ =
  set_succ' cfg
    ~single:(if n = 0 then (fun s -> s) else (fun s -> invalid_arg "successor index"))
    ~ce_mult: (fun a f -> let s = a.(n) in a.(n) <- f s; s)
    ~mult:  (fun a f -> let s = a.(n) in a.(n) <- f s; s)
    ~cbr:   (if n = 0 then (fun () -> true) else if n = 1 then (fun () -> false)
             else fun () -> invalid_arg "successor index")
    ~node ~old_succ:(succ_n node n) ~succ
and set_succ cfg node ~succ:the_succ =
  set_succ' cfg
    ~single: (fun s -> s)
    ~ce_mult:   (fun a f -> undef "set_succ" "multiple node not o/w specified")
    ~mult:   (fun a f -> undef "set_succ" "multiple node not o/w specified")
    ~cbr:    (fun () ->  undef "set_succ" "fork")
    ~node ~old_succ:(succ node) ~succ:the_succ
@
%%No sense wasting time going through [[set_succ']].
<<set node successors>>=
let set_tsucc cfg node ~succ = match node with
  | Cbr _ -> set_succ_n cfg node 0 ~succ
  | _     -> undef "set_tsucc" "non-cond-branch"
let set_fsucc cfg node ~succ = match node with
  | Cbr _ -> set_succ_n cfg node 1 ~succ
  | _     -> undef "set_fsucc" "non-cond-branch"
@
%%Transactions are not usable as yet; some useful function has not been added to
%%the interface yet.
<<graph and node mutators implementation>>=
module Tx = struct
  exception Exhausted
  type t = { mutable limit : int; mutable remaining : int; mutable last : string; }
  let ts = { limit = max_int; remaining = max_int; last = "<none>"; }

  let start_cond who =
    if ts.remaining > 0 then
      ( ts.remaining <- ts.remaining - 1; ts.last <- who; true )
    else
      false
  
  let start_exn who = if start_cond who then () else raise Exhausted

  let finish _ = ()

  let set_limit n = ts.limit <- n; ts.remaining <- n
  let used _ = ts.limit - ts.remaining
  let last _ = ts.last

  let _ = Reinit.at (fun () -> begin ts.remaining <- ts.limit; ts.last <- "<none>" end)
end
@
%%It may be useful to invert a conditional branch so that the false arm can
%%be the layout successor of the cbr.
%%The condition is inverted, as are the true branch, the false branch, and the
%%instruction.
<<graph and node mutators implementation>>=
let invert_cbr node = match node with
  | Cbr c ->
    let cfg = get_cfg node in
    let new_true = c.cbr_false in
    ( set_fsucc cfg node ~succ:c.cbr_true
    ; set_tsucc cfg node ~succ:new_true
    ; c.cbr_i <- cfg.inst_info.bnegate c.cbr_i
    )
  | _     -> undef "invert_cbr" "non-cond-branch"
@
%%We are careful to order the mutations to avoid inserting extra join points.
%%The exit node must have only a single possible successor (i.e. multiway branches and
%%conditional branches may not be the exit node).
<<graph and node mutators implementation>>=
let splice_on_every_edge_between cfg ~entry ~exit ~pred ~succ =
  let () = if not (List.exists (eq pred) (preds succ))
           then (Printf.eprintf "Splicing between pred:%d succ:%d\n" (num pred) (num
                   succ); assert false)
           else () in
  let () =
    if not (List.exists (eq succ) (succs pred))
    then imposs "splice_on_every_edge_between: succ is not a successor of pred" in
  let update_succ () = set_succ cfg exit ~succ in
  let update_pred () =
    match pred with
    | Cbr c ->
      let entry = join_leading_to entry in
      if eq succ c.cbr_true  then set_tsucc cfg pred entry; 
      if eq succ c.cbr_false then set_fsucc cfg pred entry
    | Imp i ->
      let upd_succ n entry = if eq n succ then entry else n in
      ( i.imp_succ      <- upd_succ i.imp_succ      entry
      ; i.imp_exit_succ <- upd_succ i.imp_exit_succ entry
      )
    | Mbr m -> undef "splice_on_every_edge_between" "mbranch"
    | Cal c -> undef "splice_on_every_edge_between" "call"
    | Cut c -> undef "splice_on_every_edge_between" "cut-to"
    | _     -> set_succ cfg pred ~succ:entry in
  (update_pred (); update_succ ())

let splice_before cfg ~entry ~exit node =
  let p = pred node in
  if Pervasives.(<>) (kind p) Illegal then set_succ cfg p ~succ:entry;
  set_succ cfg exit ~succ:node

let splice_after cfg ~entry ~exit node =
  let succ = succ node in
  (set_succ cfg node ~succ:entry ; set_succ cfg exit ~succ)

let delete cfg node =
  ( if   List.for_all (fun p -> kind p =*= Illegal)           (all_incoming node) 
    then List.iter    (fun s -> remove_pred cfg node ~old_succ:s) (all_outgoing node)
  ; if kind node =*= Join
    then cfg.label_map <- List.fold_right SM.remove (labels node) cfg.label_map
  )
  

let update_instr upd node = match node with
  | Ins i -> i.ins_i <- upd i.ins_i
  | Sta i -> i.sta_i <- upd i.sta_i
  | Ass a -> a.ass_i <- upd a.ass_i
  | Bra b -> b.bra_i <- upd b.bra_i
  | Jum j -> j.jum_i <- upd j.jum_i
  | Ret r -> r.ret_i <- upd r.ret_i
  | Mbr m -> m.mbr_i <- upd m.mbr_i
  | Cal c -> c.cal_i <- upd c.cal_i
  | Cut c -> c.cut_i <- upd c.cut_i
  | Cbr c -> c.cbr_i <- upd c.cbr_i
  | Joi j -> ()
  | Ent e -> ()
  | Exi _ -> ()
  | Imp i -> ()
  | Ill _ -> ()
  | Boot  -> imposs "update_instr undefined on boot nodes"
@
<<graph and node mutators implementation>>=
let set_spans n spans = match n with
  | Cal c -> c.cal_spans <- Some spans
  | Joi j -> j.joi_spans <- Some spans
  | _     -> undef_with_node (num n) "set_spans" "non-call or non-join"
@
%%We would like to be able to fold over the layout of the graph.
%%THE CURRENT SOLUTION IS NOT NECESSARILY PERMANENT:
%%We make two passes:
%%\begin{enumerate}
%%\item
%%  The first pass establishes the layout constraints.
%%  The constraints are established by ensuring that the layout successor
%%  has only the given node as a predecessor. This property can be established
%%  by adding an unconditional branch to the layout successor. Of course, for
%%  fork points, a join point must be inserted to maintain the golden invariant.
%%\item
%%  Fold over the nodes, visiting the successors in such a way as to meet layout
%%  constraints. Layout constraints are met by calling succs, which returns the
%%  layout successor as the first successor in the list.
%%\end{enumerate}
<<graph and node mutators implementation>>=
let fold_layout f zero cfg =
  let multiple_preds = function  (* N.B. branch to exit is never needed *)
    | Joi j -> (match j.joi_preds with _ :: _ :: _ -> true | _ -> false)
    | _     -> false in
  let ins_branch node = match node with
    | Cbr c ->
      if multiple_preds c.cbr_false then
        set_fsucc cfg node ~succ:(join_leading_to (branch cfg c.cbr_false))
    | Cal c ->
      if multiple_preds (succ_n node 0) then
        set_succ_n cfg node 0 ~succ:(join_leading_to (branch cfg (succ_n node 0)))
    | Imp i ->
      if multiple_preds i.imp_succ then
        set_succ cfg node ~succ:(join_leading_to (branch cfg i.imp_succ))
    | Joi _ | Ins _ | Sta _ | Ass _ | Ret _ | Ent _ ->
      if multiple_preds (succ node) then
        set_succ cfg node ~succ:(branch cfg (succ node))
    | Mbr _ | Bra _ | Cut _ | Jum _ | Exi _ | Ill _ | Boot -> () in
  let () = iter_nodes ins_branch cfg in
  let snoc node build = fun tail -> build (f node tail) in
  cps_postorder_dfs [entry cfg] succs cfg snoc (fun x -> x) (fun build _ -> build zero)
@
%%When we make exit nodes, we are careful to add the labels to the cfg's label
%%map.
<<graph construction and copying>>=
let mk_entry succ =
  Ent { ent_num  = new_num ()
      ; ent_succ = succ
      ; ent_nx   = X.nx ()
      }
let mk_exit cfg labels ~preds ~lpred =
  let exit = Exi { exi_num    = new_num ()
                 ; exi_cfg    = cfg
                 ; exi_labels = labels
                 ; exi_preds  = []
                 ; exi_lpred  = cfg.ill
                 ; exi_jx     = X.jx ()
                 } in
  List.iter (fun l -> cfg.label_map <- SM.add l exit cfg.label_map) labels;
  exit
@
%%With recursive types, we have to bootstrap the creation of the cfg.
<<graph construction and copying>>=
let mk i_info label_supply =
  let entry = match mk_entry Boot with
              | Ent e -> e
              | _     -> imposs "mk_entry returned non-entry node" in
  let cfg = { entry     = Ent entry
            ; exit      = Boot
            ; ill       = Boot
            ; inst_info = i_info
            ; label_map = SM.empty
            ; mk_label  = label_supply
            } in
  let ill = illegal cfg in
  let exit = mk_exit cfg [label_supply "exit"] ~preds:[] ~lpred:ill in
  let ()  = cfg.ill        <- ill in
  let ()  = entry.ent_succ <- ill in
  let ()  = cfg.exit       <- exit in
  cfg
@
%%We visit all the nodes in the graph via postorder dfs.
%%We make join points as necessary and reference them in the new cfg's label map.
%%Whenever a join point is used, we look up its label in this map. If not found,
%%we copy the join point from the old cfg.
<<graph construction and copying>>=
let copy info transform cfg =
  assert false (* FOLLOWING NEVER TESTED; DON'T BELIEVE THE HYPE *)
(*
  let new_cfg = { entry     = Boot
                ; exit      = Boot
                ; ill       = Boot
                ; inst_info = info
                ; label_map = SM.empty
                ; mk_label  = cfg.mk_label
                } in
  let ()  = new_cfg.ill <- illegal new_cfg in
  let lookup join =
    try SM.find (label join) new_cfg.label_map
    with Not_found -> 
      mk_join new_cfg (labels join) ~preds:[] ~lpred:new_cfg.ill
              ~succ:new_cfg.ill ~spans:join.joi_spans in
  let ce_lookup ce =
    let n' = lookup ce.node in
    {ce with node = n'} in
  let convert_contedges contedges = Array.map ce_lookup contedges in
  let convert node succ =
    match node with
    | Ins i -> instruction  new_cfg (transform i.ins_i) ~succ
    | Sta i -> stack_adjust new_cfg (transform i.sta_i) ~succ
    | Ass a -> assertion    new_cfg (transform a.ass_i) ~succ
    | Bra b -> branch       new_cfg ~target:(lookup b.bra_succ)
    | Jum j -> jump         new_cfg (transform j.jum_i) ~uses:j.jum_uses
                                    ~targets:[]
    | Cbr c ->
      let (cond, _) = cfg.inst_info.branch.Ep.project c.cbr_i in
      cbranch new_cfg cond ~ifso:(lookup c.cbr_true)
                           ~ifnot:(lookup c.cbr_false)
    | Ret r -> return      new_cfg (transform r.ret_i) ~uses:r.ret_uses
    | Imp i -> impossible  new_cfg ~succ
    | Ill i -> new_cfg.ill
    | Mbr m ->
      mbranch new_cfg (transform m.mbr_i)
       ~targets:(Array.fold_right (fun t rst -> lookup t :: rst)
                                  m.mbr_succs [])
    | Cal c ->
      let ce_lst = convert_contedges c.cal_contedges in
      mk_call (transform c.cal_i) ~pred:new_cfg.ill
              ~contedges:ce_lst ~lsucc:new_cfg.ill ~uses:c.cal_uses
              ~altrets:c.cal_altrets ~unwinds_to:c.cal_unwinds_to
              ~cuts_to:c.cal_cuts_to ~reads:c.cal_reads ~writes:c.cal_writes
              ~spans:c.cal_spans
    | Cut c ->
      let cuts_to = Array.to_list (convert_contedges c.cut_contedges) in
      cut_to new_cfg (transform c.cut_i) ~cuts_to ~aborts:false ~uses:c.cut_uses
    | Joi j ->
      let join = lookup node in
      (set_succ join succ; join)
    | Exi e ->
      let exit = mk_exit new_cfg (labels cfg.exit) ~preds:[]
                         ~lpred:new_cfg.ill in
      (new_cfg.exit <- exit; exit)
    | Ent e ->
      let ent = mk_entry succ in
      (new_cfg.entry <- ent; ent)
    | Boot  -> undef "copy" "boot" in
  let () = match postorder_dfs convert new_cfg.ill cfg with
           | Ent _ -> ()
           | _     -> imposs "postorder_dfs didn't end with entry node" in
  new_cfg
*)
@
%%The contedges add a little excitement, but nothing shocking.
%%They are added with defs/kills to each node.
%%We have to bootstrap node construction because of the way [[set_succ]] works.
<<node constructors with interesting control flow edges>>=
let join_leading_to_ce ce = {ce with node = join_leading_to ce.node}

let mk_call i ~pred ~contedges ~lsucc ~uses ~altrets ~unwinds_to ~cuts_to
    ~reads ~writes ~spans =
    Cal { cal_num        = new_num ()
        ; cal_i          = i
        ; cal_pred       = pred
        ; cal_contedges  = contedges
        ; cal_lsucc      = lsucc
        ; cal_fx         = X.fx ()
        ; cal_spans      = spans
        ; cal_uses       = uses
        ; cal_altrets    = altrets
        ; cal_unwinds_to = unwinds_to
        ; cal_cuts_to    = cuts_to
        ; cal_reads      = reads  
        ; cal_writes     = writes 
        }

let call cfg i ~altrets ~succ ~unwinds_to ~cuts_to ~aborts
               ~uses ~defs ~kills ~reads ~writes ~spans =
  let new_cedge n = {kills = kills; defs = defs; node = n} in
  let succ = match kind succ with
    | Exit -> let label = Idgen.label "postcall" in
              let join = node_labeled cfg label in
              set_succ cfg join ~succ;
              join
    | _    -> join_leading_to ~succ in
  let succ        = [new_cedge succ] in
  let altrets     = List.map join_leading_to_ce altrets in
  let unwinds_to  = List.map join_leading_to_ce unwinds_to in
  let cuts_to     = List.map join_leading_to_ce cuts_to in
  let abort       = if aborts then [new_cedge cfg.exit] else [] in
  let edgelist    = List.flatten [succ; altrets; unwinds_to; cuts_to; abort] in
  (*let edgelist    = List.flatten [altrets; succ; unwinds_to; cuts_to; abort] in*)
  let illedge     = fun {kills=k; defs=d; node=n} -> {kills=k; defs=d; node=cfg.ill} in
  let contedges   = Array.of_list (List.map illedge edgelist) in
  let cal =
    mk_call i ~pred:cfg.ill ~contedges ~lsucc:cfg.ill ~uses ~reads ~writes
              ~altrets:(List.length altrets) ~unwinds_to:(List.length unwinds_to)
              ~cuts_to:(List.length cuts_to) ~spans in
  let ()  = Auxfuns.foldri (fun i n () -> set_succ_n cfg cal i ~succ:n.node)
                       edgelist () in
  cal

let cut_to cfg i ~cuts_to ~aborts ~uses =
  let cuts_to     = List.map join_leading_to_ce cuts_to in
  let new_cedge n = {kills = RS.empty; defs = RS.empty; node = n} in
  let aborts      = if aborts then [new_cedge cfg.exit] else [] in
    (* UNKNOWN WHETHER EDGE TO EXIT MUST KILL NVR'S.  LET US HOPE NOT. *)
  let edgelist    = List.flatten [cuts_to; aborts] in
  let illedge     = fun {kills=k; defs=d; node=n} -> {kills=k; defs=d; node=cfg.ill} in
  let cut = Cut { cut_num       = new_num ()
                ; cut_i         = i
                ; cut_pred      = cfg.ill
                ; cut_lsucc     = cfg.ill
                ; cut_contedges = Array.of_list (List.map illedge edgelist)
                ; cut_fx        = X.fx ()
                ; cut_uses      = uses
                } in
  let ()  = Auxfuns.foldri (fun i n () -> set_succ_n cfg cut i ~succ:n.node) edgelist () in
  cut
@
%%
<<simple node constructors>>=
let instruction cfg i ~succ =
  let ins = Ins { ins_num  = new_num ()
                ; ins_i    = i
                ; ins_pred = cfg.ill 
                ; ins_succ = cfg.ill
                ; ins_nx   = X.nx ()
                } in
  let ()  = set_succ cfg ins ~succ:succ in
  ins

let stack_adjust cfg i ~succ =
  let sta = Sta { sta_num  = new_num ()
                ; sta_i    = i
                ; sta_pred = cfg.ill 
                ; sta_succ = cfg.ill
                ; sta_nx   = X.nx ()
                } in
  let ()  = set_succ cfg sta ~succ:succ in
  sta

let assertion cfg i ~succ =
  let ass = Ass { ass_num  = new_num ()
                ; ass_i    = i
                ; ass_pred = cfg.ill 
                ; ass_succ = cfg.ill
                ; ass_nx   = X.nx ()
                } in
  let ()  = set_succ cfg ass ~succ:succ in
  ass

let branch cfg ~target =
  let succ = join_leading_to ~succ:target in
  let bra = Bra { bra_num   = new_num ()
                ; bra_i     = cfg.inst_info.goto.Ep.embed (label succ)
                ; bra_pred  = cfg.ill
                ; bra_succ  = cfg.ill
                ; bra_lsucc = succ
                ; bra_nx    = X.nx ()
                } in
  let ()  = set_succ cfg bra ~succ in
  bra

(* SHOULD WE ASSERT THAT THESE TARGETS ARE JOIN POINTS? *)
let jump cfg i ~uses ~targets =
  let jum = Jum { jum_num   = new_num ()
                ; jum_i     = i
                ; jum_pred  = cfg.ill
                ; jum_succ  = cfg.ill
                ; jum_lsucc = cfg.ill
                ; jum_nx    = X.nx ()
                ; jum_uses  = uses
                } in
  let ()  = set_succ cfg jum ~succ:cfg.exit in
  jum

let cbranch cfg cond ~ifso ~ifnot =
  let so_succ  = join_leading_to ~succ:ifso in
  let not_succ = join_leading_to ~succ:ifnot in
  let cbr = Cbr { cbr_num   = new_num ()
                ; cbr_i     = cfg.inst_info.branch.Ep.embed
                                    (cond, (label so_succ))
                ; cbr_pred  = cfg.ill
                ; cbr_true  = cfg.ill
                ; cbr_false = cfg.ill
                ; cbr_fx    = X.fx ()
                } in
  let ()  = set_tsucc cfg cbr ~succ:so_succ  in
  let ()  = set_fsucc cfg cbr ~succ:not_succ in
  cbr

let mbranch cfg i ~targets =
  let targets = List.map (fun succ -> join_leading_to ~succ) targets in
  let succs   = Array.make (List.length targets) cfg.ill in
  let mbr     = Mbr { mbr_num   = new_num ()
                    ; mbr_i     = i
                    ; mbr_pred  = cfg.ill
                    ; mbr_succs = succs
                    ; mbr_lsucc = cfg.ill
                    ; mbr_fx    = X.fx ()
                    } in
  let () = Auxfuns.foldri (fun i n () -> set_succ_n cfg mbr i ~succ:n) targets () in
  mbr

let return cfg i ~uses =
  let ret = Ret { ret_num   = new_num ()
                ; ret_i     = i
                ; ret_pred  = cfg.ill
                ; ret_succ  = cfg.ill
                ; ret_lsucc = cfg.ill
                ; ret_nx    = X.nx ()
                ; ret_uses  = uses
                } in
  let ()  = set_succ cfg ret ~succ:cfg.exit in
  ret

let impossible cfg ~succ =
  let succ = join_leading_to succ in
  let imp  = Imp { imp_num       = new_num ()
                 ; imp_pred      = cfg.ill
                 ; imp_succ      = cfg.ill
                 ; imp_exit_succ = cfg.ill
                 ; imp_fx        = X.fx ()
                 } in
  let ()   = set_succ   cfg imp   ~succ:succ     in
  let ()   = set_succ_n cfg imp 1 ~succ:cfg.exit in
  imp

let illegal cfg = Ill { ill_num = new_num ()
                      ; ill_nx  = X.nx ()
                      ; ill_cfg = cfg
                      }
@
%%We use some simple shorthands for raising exceptions.
<<graph utilities>>=
let imposs = Impossible.impossible
let undef f n = imposs (Printf.sprintf "%s: undefined on %s nodes" f n)
let undef_with_node node_num f n =
  imposs (Printf.sprintf "%s: undefined on %s node %d" f n node_num)
@
%%Some of the utilities need to check the kind or number of a node
%%(before the observers have been defined).
<<graph utilities>>=
let kind_util = function
  | Joi _ -> Join
  | Ins _ -> Instruction
  | Sta _ -> StackAdjust
  | Bra _ -> Branch
  | Cbr _ -> Cbranch
  | Mbr _ -> Mbranch
  | Jum _ -> Jump
  | Cal _ -> Call
  | Ret _ -> Return
  | Cut _ -> CutTo
  | Ent _ -> Entry
  | Exi _ -> Exit
  | Ass _ -> Assertion
  | Ill _ -> Illegal
  | Imp _ -> Impossible
  | Boot  -> undef "kind" "boot"

let num_util node = match node with
  | Joi j -> j.joi_num
  | Ins i -> i.ins_num
  | Sta s -> s.sta_num
  | Bra b -> b.bra_num
  | Cbr c -> c.cbr_num
  | Mbr m -> m.mbr_num
  | Jum j -> j.jum_num
  | Cal c -> c.cal_num
  | Ret r -> r.ret_num
  | Cut c -> c.cut_num
  | Ent e -> e.ent_num
  | Exi e -> e.exi_num
  | Ass a -> a.ass_num
  | Ill i -> i.ill_num
  | Imp i -> i.imp_num
  | Boot  -> undef "num" "boot"
@ 
%%The string for the type of a node improves debugging messages.
<<graph utilities>>=
let name = function
  | Joi _ -> "Join"
  | Ins _ -> "Instruction"
  | Sta _ -> "StackAdjust"
  | Bra _ -> "Branch"
  | Cbr _ -> "Cbranch"
  | Mbr _ -> "Mbranch"
  | Jum _ -> "Jump"
  | Cal _ -> "Call"
  | Ret _ -> "Return"
  | Cut _ -> "CutTo"
  | Ent _ -> "Entry"
  | Exi _ -> "Exit"
  | Ass _ -> "Assertion"
  | Ill _ -> "Illegal"
  | Imp _ -> "Impossible"
  | Boot  -> "Boot"
@
%%Node equality is the most important utility of all.
%%We cannot safely compare nodes with [[==]], because the node type is
%%an algebraic data type, and the Caml implementation is free to
%%consider two nodes unequal even if they are both obtained by, e.g.,
%%[[Ins r]].
%%On the other hand, we cannot use~[[=]] because it is structural
%%equality, and it is not guaranteed to terminate when applied to a
%%structure with cycles.
%%We therefore roll our own, using [[==]] only on the mutable record
%%types, where we know it is safe.
<<graph utilities>>=
let eq node node' = match node, node' with
  | Joi r, Joi r' -> r == r'
  | Ins r, Ins r' -> r == r'
  | Sta r, Sta r' -> r == r'
  | Bra r, Bra r' -> r == r'
  | Cbr r, Cbr r' -> r == r'
  | Mbr r, Mbr r' -> r == r'
  | Jum r, Jum r' -> r == r'
  | Cal r, Cal r' -> r == r'
  | Ret r, Ret r' -> r == r'
  | Cut r, Cut r' -> r == r'
  | Ent r, Ent r' -> r == r'
  | Exi r, Exi r' -> r == r'
  | Ass r, Ass r' -> r == r'
  | Ill r, Ill r' -> r == r'
  | Imp r, Imp r' -> r == r'
  | Boot,  Boot   -> true
  | _,     _      -> false
@ 
%%We uniquely number each node when it is created.
<<graph utilities>>=
let node_num = ref 0
let new_num ()   = let n = !node_num in node_num := n + 1; n
@
%%Printing node information is useful for debugging.
<<printing utilities>>=
let show_rtl = function
    Some r -> Rtlutil.ToString.rtl r
  | None   -> ""

let printReg (s, i, w) = Printf.sprintf "%c%d" s i
let print_node node = 
      String.concat "" (List.flatten
       [ [ name node; ": "]
       ; List.flatten [ [ string_of_int (num node)
                        ; ": "
                       ]
                      ; if is_join node then labels node
                        else [show_rtl (to_instr node)]
                      ; [ "\n" ] ]
       ; ["  Preds: "]
       ; List.fold_right (fun n rst -> Printf.sprintf "%d, " (num n) :: rst)
                         (preds node) []
       ; ["Succs: "]
       ; List.fold_right (fun n rst -> Printf.sprintf "%d, " (num n) :: rst)
                         (succs node) []
       ])
@
%%If we believe that the lists passed to [[uniq]] will never be long, we may actually
%%do better with simple [[List.exists]] comparisons.
<<graph utilities>>=
let log m = ()
let uniq lst = match lst with
  | [] | [_] -> lst (* premature optimization? *)
  | _ -> fst (List.fold_left (fun (ns,set as rst) n1 ->
                                let i = num_util n1 in
                                if IS.mem i set then rst else (n1::ns, IS.add i set))
                             ([],IS.empty) lst)

let is_ill node = match node with
  | Ill _ -> true
  | _     -> false

let is_exi node = match node with
  | Exi _ -> true
  | _     -> false

let ce_getnodes ce = Array.map (fun ce -> ce.node) ce
@
%%
%%We merge two join points by combining the information in the second
%%([[keep]]) node.
%%We also mutate the first join point ([[j1]]) to share the fields of
%%the second join point.
%%NOT USED, NOT EXPOSED, NOT EXPECTED TO WORK.  
<<UNDEFINED graph utilities>>=
(*
let merge_joins j1 j2 succ lpred = match j1, j2 with
  | Joi j1, Joi j2 ->
    { joi_num    = new_num ()
    ; joi_labels = j1.joi_labels @ j2.joi_labels
    ; joi_cfg    = j1.joi_cfg
    ; joi_preds  = j1.joi_preds  @ j2.joi_preds
    ; joi_succ   = j2.joi_succ
    ; joi_lpred  = j2.joi_lpred
    ; joi_jx     = j2.joi_jx
    }
  | _                -> undef "merge_joins" "non-join"
*)
@
%%
%%Graph heads are defined as the entry node and the join points.
<<graph utilities>>=
let heads cfg =
  List.filter (fun n -> Pervasives.(<>) (kind_util n) Exit)
              (uniq (cfg.entry :: SM.fold (fun _ h rst -> h::rst) cfg.label_map []))
@
%%
%%We have some simple operations for handling sets of nodes.
<<join node set operations>>=
let emptyset              = IS.empty
let add    n set          = IS.add (num n) set
let member n set          = IS.mem (num n) set
@
%%
%%
%%Missing stuff:
%%\begin{itemize}
%%\item
%% adding impossible edges on infinite loops
%%\end{itemize}
%%
\section{[[front_cfg/cfgx.nw]]}
<<front_cfg/cfgx.ml>>=
<<cfgx.ml>>
@

<<front_cfg/cfgx.mli>>=
<<cfgx.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
<<cfgx.mli>>=
module X : Cfg.X
module M : Cfg.S with module X = X
@ 
<<cfgx.ml>>=
module X = struct
  type jx = unit
  type fx = unit
  type nx = unit
  let jx () = ()
  let fx () = ()
  let nx () = ()
end
module M = Cfg.Make(X)
@ 
\section{[[front_cfg/dag.nw]]}
<<front_cfg/dag.ml>>=
<<dag.ml>>
@

<<front_cfg/dag.mli>>=
<<dag.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=2 sw=2 et: 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% 
%%% $Id: dag.nw,v 1.1 2006-08-24 21:19:42 dias Exp $
%%
%%% ------------------------------------------------------------------ 
\section{Directed Acyclic Graph}
%%% ------------------------------------------------------------------ 
%%
%%Control-flow graphs are nice, but sometimes we want something simpler: a DAG.
%%
\subsection{Interface}
%%
%%Working with the mutable control-flow graph is awkward and
%%error-prone.
%%We therefore define some special, immutable types to represent
%%fragments of the flow graph (subgraphs) both before and after expansion.
%%What kind of fragment we have depends on what sort of flow-graph node
%%we are expanding.
%%\begin{itemize}
%%\item
%%A node that represents straight-line control flow is expanded into a
%%[[block]].
%%A~[[block]] represents a subgraph with a single entry and single exit.
%%\item
%%A~node that represents unconditional control transfer  (including
%%unconditional branch,  multiway branch, call, return, [[cut to]], etc.)
%%is expanded
%%into a [[branch]].
%%The [[branch]] consists of a (possibly empty) [[block]] followed by an
%%RTL.
%%The trailing RTL is always the control-transfer instruction.
%%A  subgraph represented by a [[branch]] has a single entry, and while
%%it may have multiple 
%%exits, all those exits are reached by the same instruction: the final
%%RTL.
%%\item
%%A conditional branch is expanded into a [[cbranch]].
%%This subgraph is somewhat more complicated because it has \emph{two}
%%exits, which are designated by the Boolean values [[true]] and
%%[[false]].
%%The subgraph represents decision logic \emph{only}; its sole job
%% is to decide on one of the two exits.\footnote
%%{Later in compilation, the peephole optimizer may combine computation
%%with decision.}
%%
%%Unlike the unconditional or multiway branches, the [[cbranch]] can
%%have multiple internal nodes that reach one or both of the exits.
%%This happens any time the condition involves the short-circuit Boolean
%%operators [[%conjoin]] or [[%disjoin]].
%%
%%Unlike the other subgraphs, the [[cbranch]] can represent a DAG, not
%%just a tree---hence the [[Shared]] node.
%%\end{itemize}
%%
<<abstract types for dags>>=
type uid
@
%%Type parameter [['a]] is instantiated with a conditional branch.
%%This may be represented as...
%%late in the game: [[exp -> rtl]] when we're waiting to plug in a
%%target address;
%%early in the game: [[exp]] when we're carrying only a guard.
%%(Talk about input and output dags.)
<<types for dags>>=
type 'a block = Rtl   of Rtl.rtl
              | Seq   of 'a block * 'a block
              | If    of 'a cbranch * 'a block * 'a block
              | While of 'a cbranch * 'a block
              | Nop
(* block ending in branch, including multiway branch *)
and  'a branch  = 'a block * Rtl.rtl
and  'a cbranch = Exit   of bool
                | Test   of 'a block * 'a cbinst
                | Shared of uid * 'a cbranch  (* don't duplicate this node *)
and  'a cbinst  = 'a * 'a cbranch * 'a cbranch
@
%%Since the only purpose of a conditional branch is to reach
%%one of the two exits, there is never any straight-line code that
%%intervenes between a conditional branch and the exit.
%%And it's possible that a conditional branch is simplified to
%%unconditional; that's what a bare [[Exit]]  means.
%%
%%Each of the constructors and types  above has a particular meaning,
%%which we explain here.
%%We also explain  under what conditions each construct is deemed to
%%satisfy the machine invariant. 
%%\begin{itemize}
%%\item [[Rtl]] wraps a \emph{non-branching} RTL.
%%It satisfies the machine invariant if the RTL  can be represented by a single
%%instruction on the target machine, with this exception:
%%\begin{itemize}
%%\item
%%\label{sec:optimism}
%%An RTL may be representible as a single instruction only under the
%%optimistic assumption that a late compile-time constant is ``small.''
%%If the assumption is violated, it must be possible for the recognizer
%%to emit a sequence of instructions that together implement the RTL.
%%Either this sequence can be generated without using an additional
%%register, or else the recognizer will have to reserve a
%%register for this purpose.
%%\end{itemize}
%%
%%\item
%%An [[rtl]] in a [[branch]] pair represents an unconditional
%%control-transfer instruction.
%%It satisfies the machine invariant if it can be represented by a
%%single instruction on the target 
%%machine, with these exceptions:
%%\begin{itemize}
%%\item
%%If the target machine has delayed control-transfer instructions
%%(branch\slash call\slash etc), we may use a single RTL to represent an atomic
%%two-instruction package consisting of the control transfer and the
%%instruction in the delay slot.
%%We do this because at present, we have no other way to constrain
%%layout.
%%
%%\item
%%For implementing [[cut to]], we use a single RTL that represents two
%%instructions: one that adjusts the stack pointer and one that
%%branches.
%%We need to package these atomically because once the stack pointer has
%%been adjusted, the internal assumptions of the compiler are no longer
%%valid.
%%For example, it is not safe to spill a register after the stack
%%pointer has been adjusted.
%%We therefore treat the two instructions as an atomic unit by packaging
%%them as one RTL.
%%\end{itemize}
%%
%%\item
%%A [[Seq]] node represents a sequence of instructions and executes
%%first the left half, then the right.
%%
%%\item
%%A [[If]] node makes a decision and executes one of its two blocks,
%%depending on the outcome of the condition.
%%The decision is represented by a [[cbranch]] node.
%%
%%\item
%%The [[While]] node corresponds to a C-style [[while]] statement:
%%as long as the decision is for the [[true]] exit, it executes the body.
%%
%%\item
%%[[Nop]] represents an empty sequence of instructions.
%%[[Nop]] may be useful in [[If]], as the first part of a [[branch]],
%%and in various places in the 
%%generic expander.
%%
%%\item
%%A [[branch]] represents a [[block]] that is followed by a branch
%%instruction, which is represented by an RTL that satisfies the machine
%%invariant for branch instructions as described above.
%%Typically the [[block]] is empty, or it computes the address used in
%%the branch.
%%
%%\item
%%A [[cbranch]] represents the ability to make a decision:
%%\begin{itemize}
%%\item
%%An [[Exit]] node makes the decision for the exit identified by the
%%Boolean.
%%\item
%%A [[Test]] node makes the decision by executing a 
%%[[block]], then a
%%conditional-branch instruction.
%%Typically the [[block]] sets condition codes.
%%\item
%%A [[Shared]] node wraps another node with a unique identifier, which
%%keeps it from being duplicated when the [[cbranch]] tree is converted
%%to a flow graph.
%%A~[[Shared]] node can be created only by the [[shared]] function
%%exported by the [[Postexpander]] interface.
%%Typically, [[Shared]] nodes are created only by the generic expander,
%%when it compiles [[%conjoin]] and [[%disjoin]].
%%But if a postexpander should use a [[cbranch]] in two different
%%contexts, it should apply [[shared]] first.
%%\end{itemize}
%%
%%\item
%%A [[cbinst]] represents a conditional-branch
%%instruction.
%%The [[exp]] must be a Boolean expression.
%%If [[cbinst = (exp, t, f)]], its semantics are that if [[exp]] is
%%true, execution continues with~[[t]]; otherwise it
%%continues with~[[f]].
%%To satisfy the machine invariant,
%%the [[cbinst]] must satisfy two properties:
%%\begin{itemize}
%%\item
%%If [[target.branch.embed]] is applied to the [[exp]] and a label, it
%%produces an RTL that can be represented as a single conditional-branch
%%instruction on the target machine.
%%\item
%%The resulting RTL can be changed with [[bnegate]] and still be
%%representable as a single instruction on the target machine.
%%\end{itemize} 
%%\end{itemize}
%%
%%An example may help with the conditional branch.
%%If the source code contains
%%\begin{verbatim}
%%if (n == 1 `disjoin` n == 2) {
%%  ...
%%} else {
%%  ...
%%}
%%\end{verbatim}
%%The generic expander may translate the [[if]] expression to the
%%following conditional branch:
%%\begin{verbatim}
%%  Test (Nop, (n == 1, Exit true, Test (Nop, (n == 2, Exit true, Exit false))))
%%\end{verbatim}
%%On many machines this subgraph would be expanded further with the help
%%of the postexpander.
%%For example, each [[Nop]] might be replaced by a compare instruction,
%%and the equality tests might be replaced by tests of the condition codes.
%%
%%Sequential composition of blocks is very useful.
%%It eliminates [[Nop]].
<<exported utility functions for dags>>=
val (<:>) : 'a block -> 'a block -> 'a block
val pr_block : ('a -> string) -> 'a block -> string
@ 
%%
<<dag.mli>>=
<<abstract types for dags>>
<<types for dags>>
<<exported utility functions for dags>>
@
%%
%%The [[shared]] function makes a node shared, so that it will not be
%%duplicated on conversion to a flow graph.
%%The [[shared]] function guarantees uniqueness of the identifier, and
%%it avoids wrapping [[Shared]] in [[Shared]].
<<exported utility functions for dags>>=
val shared : 'a cbranch -> 'a cbranch
@
%%To convert a condition for use in [[If]] or [[While]], use [[cond]]. 
<<exported utility functions for dags>>=
val cond : 'a -> 'a cbranch
@
%%
\subsection{Implementation}
%%
<<implementation of utility functions for dags>>=
let (<:>) b b' = match b, b' with
| Nop, b' -> b'
| b, Nop  -> b
| _, _    -> Seq (b, b')
@
%%To help deal with expansion of DAGs containing [[Shared]] nodes, 
%%we provide support for a set of nodes.
<<exported utility functions for dags>>=
type 'a nodeset
val empty : 'a nodeset
val lookup : uid -> 'a nodeset -> 'a   (* raises Not_found *)
val insert : uid -> 'a -> 'a nodeset -> 'a nodeset
@
<<implementation of utility functions for dags>>=
type 'a nodeset = (uid * 'a) list
let empty = []
let lookup = List.assoc
let insert i x l = (i, x) :: l
@ 
%%I'm defining a module here to contain the namespace.
%%Why don't I just use lambda? Value restriction.
<<implementation of utility functions for dags>>=
module Shared = struct
  let n = Reinit.ref 0
  let shared c = match c with
    | Shared _ -> c
    | _ -> (n := !n + 1; Shared (!n, c))
end
let shared = Shared.shared
@ 
<<implementation of utility functions for dags>>=
let cond g = Test (Nop, (g, Exit true, Exit false))
@
%%
<<dag.ml>>=
module RU = Rtlutil
module TS = RU.ToString
type uid = int
<<types for dags>>
<<implementation of utility functions for dags>>

let sprintf = Printf.sprintf

let rec pr_block pr = function
  | Rtl r -> TS.rtl r
  | Seq (b1, b2) -> pr_block pr b1 ^ pr_block pr b2
  | If (c, t, f) -> sprintf "if (%s) { %s; } else { %s; }" 
                       (pr_cbranch pr c) (pr_block pr t) (pr_block pr f)
  | While (c, b) -> sprintf "while (%s) { %s; }" (pr_cbranch pr c) (pr_block pr b)
  | Nop -> "<nop>"
and pr_cbranch pr c = match c with
| Exit p        -> if p then "true" else "false"
| Shared (_, c) -> sprintf "[%s]" (pr_cbranch pr c)
| Test (Nop, c) -> pr_cbi pr c
| Test (b, c)   -> sprintf "{%s; %s}" (pr_block pr b) (pr_cbi pr c)
and pr_cbi pr c = match c with
| a, Exit true,  Exit false -> pr a
| a, Exit false, Exit true  -> sprintf "!(%s)" (pr a)
| a, Exit true,  p -> sprintf "(%s || %s)" (pr a) (pr_cbranch pr p)
| a, p, Exit false -> sprintf "(%s && %s)" (pr a) (pr_cbranch pr p)
| a, p, q -> sprintf "(%s ? %s : %s)" (pr a) (pr_cbranch pr p) (pr_cbranch pr q)
@ 
\section{[[front_cfg/ep.nw]]}
<<front_cfg/ep.ml>>=
<<ep.ml>>
@

<<front_cfg/ep.mli>>=
<<ep.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
\section{Embedding-projection pairs}
%%
%%This code is in a separate module to make it easier to avoid circular dependencies.
<<ep.mli>>=
type ('em, 'pr) pre_map =
    { embed   : 'em
    ; project : 'pr
    }
type ('lo, 'hi) map = ('lo -> 'hi, 'hi -> 'lo) pre_map
@ 
<<ep.ml>>=
type ('em, 'pr) pre_map =
    { embed   : 'em
    ; project : 'pr
    }
type ('lo, 'hi) map = ('lo -> 'hi, 'hi -> 'lo) pre_map
@ 
\section{[[front_cfg/mflow.nw]]}
<<front_cfg/mflow.ml>>=
<<mflow.ml>>
@

<<front_cfg/mflow.mli>>=
<<mflow.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 et sw=4:
%%
\section{Machine-level control flow}
%%
%%The [[Target]] module provides for substantial generality in the
%%implementation of control flow:
%%a target can use any appropriate RTL to represent a control-flow
%%instruction.
%%But on most targets, the full generality of the abstraction is not
%%needed.
%%A~typical target works with a program counter, which it manipulates in
%%typical ways.
%%This module is intended to help reduce the burden of retargeting by providing
%%the ``standard'' implementations of
%%control flow at the machine level.
%%Basically if we know the program counter plus a few facts about return
%%address, we know enough to go on with.
%%(To get [[cutto]] right, we will have to add knowledge of the stack
%%pointer.)
%%
%%We assume that a machine has a program counter and registers.
%%Furthermore, we use two different locations to refer to the program
%%counter: one in an lvalue context and another in an rvalue context.
%%These are called [[pc_lhs]] and [[pc_rhs]] in the source; here we call
%%them \emph{nPC} (new PC or next PC) and \emph{PC}.
%%The distinction is useful to support machines with delayed branches,
%%such as the SPARC, MIPS, and HP PA-RISC.
%%
%%We also assume that the call instruction captures the return address
%%in a register, which we call \emph{RA}.
%%The ``standard'' implementations of control flow are then as
%%follows:\\
%%\begin{tabularx}{\linewidth}{@{\hskip 1.5em}lX}
%%\texttt{goto} $L$& $\mathit{nPC} \mathbin{:=} L$\\
%%\texttt{jump} $L$& $\mathit{nPC} \mathbin{:=} L$\\
%%\texttt{call} $L$& $\mathit{nPC} \mathbin{:=} L \mathrel{|}
%%                    \mathit{RA} \mathbin{:=} \mathit{PC}+k $\\
%%\texttt{branch} $p$ $L$&
%%   $p \rightarrow \mathit{nPC} \mathbin{:=} L$\\
%%\end{tabularx}
%%Note that [[cut to]] is not yet correctly implemented in this
%%interface.
%%
%%The condition in a conditional branch can be negated by calling [[bnegate]]
%%on the branch instruction.
%%
%%Also note that there is no place for [[return]] in this interface.
%%On many machines, [[return]] is simply an indirect jump, for which
%%[[goto]] can be used.
%%On other machines, there seems to be no standard way of, e.g.,
%%tagging a return for branch prediction or manipulating the stack
%%pointer during a return.
%%Targets for such machines will have to define [[return]] on an
%%individual basis.
%%
<<mflow.mli>>=
<<signatures>>
@
%%The nodes in the control-flow graph (module \module{cfg}) contain
%%{\rtl}s.  For example, a [[jump]] node takes an {\rtl} and not an
%%expression for the target.  The construction of these {\rtl}s is target
%%specific and so we provide [[embed]] functions in each target.
%%For debugging of the {\cfg} we also like to re-construct the expressions
%%from these {\rtl}s.  We provide matching [[project]] functions to obtain
%%the original expressions \emph{if the supplied {\rtl}s} were constructed
%%by the construction functions.  Any attempt to do otherwise results in
%%an unchecked run-time error. 
%%
%%We can also negate the condition in a conditional-branch by calling
%%[[bnegate]].
%%
%%The {\rtl}s do not have to represent machine instructions. It suffices
%%to create {\rtl}s that the code expander can recognize as jumps, calls,
%%and so on. 
<<signatures>>=
type ('em, 'pr) map' = ('em, 'pr) Ep.pre_map =
    { embed   : 'em
    ; project : 'pr
    }
type brtl = Rtl.exp -> Rtl.rtl
type ('a,'b) map  = ('a -> 'b -> brtl Dag.branch,  Rtl.rtl -> 'b) map'
type ('a,'b) mapc = ('a -> 'b -> brtl Dag.cbranch, Rtl.rtl -> 'b) map'

type cut_args = { new_sp : Rtl.exp; new_pc : Rtl.exp }
type 'a machine =
  { bnegate:   Rtl.rtl -> Rtl.rtl
  ; goto:      ('a, Rtl.exp) map
  ; jump:      ('a, Rtl.exp) map
  ; call:      ('a, Rtl.exp) map
  ; branch:    ('a, Rtl.exp) mapc (* condition *)
  ; retgt_br:  Rtl.rtl -> brtl Dag.cbranch
  ; move:      'a -> src:Register.t -> dst:Register.t -> brtl Dag.block
  ; spill:     'a -> Register.t     -> Rtlutil.aloc   -> brtl Dag.block
  ; reload:    'a -> Rtlutil.aloc   -> Register.t     -> brtl Dag.block
  ; cutto:     ('a, cut_args) map    (* newpc * newsp map*)
  ; return:    Rtl.rtl
  ; forbidden: Rtl.rtl   (* causes a run-time error *)
  }
@ 
%%The [[branch]] embedder takes expressions $(b, t)$ where $b$~is a
%%Boolean condition and $t$~is the branch target.
%%It produces an RTL that conditionally branches to the target.
%% 
%%The [[forbidden]] component is an RTL used to cause a run-time error.
%%This RTL is used in places control should not reach, e.g., no arm of a
%%switch statement matches the scrutinee.
<<signatures>>=
module type PC = sig
  val pc_lhs : Rtl.loc
  val pc_rhs : Rtl.loc
  val ra_reg : Rtl.loc
  val ra_offset : int   (* at call, ra_reg  := PC + ra_offset *)
end

module type S = sig
  val machine : sp:Rtl.loc -> 'a machine
    (* N.B. sp is a dynamic argument because it could differ among call conventions *)
end
@
<<mflow.mli>>=
module MakeStandard (Pc : PC) : S
@ 
<<mflow.ml>>=
<<signatures>>
module DG = Dag
module RU = Rtlutil
module R  = Rtl
module RP = Rtl.Private
module Up   = Rtl.Up
module Down = Rtl.Dn
let ( =/  ) = RU.Eq.loc
let ( =// ) = RU.Eq.exp

module MakeStandard (P : PC) = struct
  type 'a map = ('a, Rtl.rtl) Ep.map
  <<standard machine-level control flow>>
end
@ 
%%
<<standard machine-level control flow>>=
let w = RU.Width.loc P.pc_lhs
let downrtl = R.Dn.rtl
let uploc   = R.Up.loc
let upexp   = R.Up.exp
@
%%In order to negate the branch condition in [[bnegate]], [[cmpneg]] takes a
%%comparison and flips the operator when possible. If the operator is "not",
%%then the operator is discarded; if the operator has no negation, then "not" is
%%applied.
<<standard machine-level control flow>>=
let cmpneg w ~cop ~fetch =
  let flip_op flip = RP.App ((flip, [w]), fetch) in
  match cop with
  | "eq"   -> flip_op "ne"
  | "ne"   -> flip_op "eq"
  | "lt"   -> flip_op "ge"
  | "le"   -> flip_op "gt"
  | "gt"   -> flip_op "le"
  | "ge"   -> flip_op "lt"
  | "ltu"  -> flip_op "geu"
  | "leu"  -> flip_op "gtu"
  | "gtu"  -> flip_op "leu"
  | "geu"  -> flip_op "ltu"
  | "feq"  -> flip_op "fne"
  | "fne"  -> flip_op "feq"
  | "flt"  -> flip_op "fge"
  | "fle"  -> flip_op "fgt"
  | "fgt"  -> flip_op "fle"
  | "fge"  -> flip_op "flt"
  | "not"  -> (match fetch with
               | [r] -> r
               | _ -> Impossible.impossible "negation of multiple arguments")
  | _      -> RP.App (("not", [w]), fetch)
let bnegate r = match Down.rtl r with
  | RP.Rtl [RP.App((cop, [w1]), [RP.Fetch (flags, w2)]), RP.Store (pc, tgt, w3)]
    when pc =/ Down.loc P.pc_lhs && w1 = w && w2 = w && w3 = w ->
      Up.rtl (RP.Rtl [cmpneg w ~cop ~fetch:[RP.Fetch (flags, w)],
                               RP.Store (pc, tgt, w)])
  | _ -> Impossible.impossible "ill-formed conditional branch"
@ 
%%
<<standard machine-level control flow>>=
let gotor = { Ep.embed   = (fun e -> R.store P.pc_lhs e w)
            ; Ep.project = (fun r -> match downrtl r with
                                    | RP.Rtl [(_, RP.Store(_, e, _))] -> upexp e
                                    | _ -> Impossible.impossible "projected non-goto")
            } 
let goto = { Ep.embed   = (fun _ e -> (DG.Nop, gotor.Ep.embed e))
           ; Ep.project = gotor.Ep.project
           } 
let jump = goto
@ 
%%By convention, the [[cut to]] \emph{always} puts the PC on the
%%\emph{left}.
%%This convention will be necessary at least until we have recognizers
%%that cope with associative-commutative operators.
<<standard machine-level control flow>>=
let cutto ~sp =
  { Ep.embed   = (fun _ {new_sp=new_sp; new_pc=new_pc} -> 
                   let assign loc e = Rtl.store loc e w in
                   (DG.Nop, Rtl.par [assign P.pc_lhs new_pc; assign sp new_sp]))
  ; Ep.project = (fun r -> match downrtl r with
                           | RP.Rtl [ (_, RP.Store(_,  npc, _))
                                    ; (_, RP.Store(_ , nsp, _))] ->
                                { new_sp=upexp nsp; new_pc= upexp npc }
                           | _ -> Impossible.impossible "projected non-cutto")
  }
@ 
%%
<<standard machine-level control flow>>=
let ra_val = 
  let pc = R.fetch P.pc_rhs w in
  RU.addk w pc P.ra_offset

let call = { Ep.embed   = (fun _ e -> (DG.Nop, R.par [R.store P.pc_lhs e w;
                                                    R.store P.ra_reg ra_val w]))
           ; Ep.project =
              (fun r -> match downrtl r with
                 | RP.Rtl [(_, RP.Store(_, e, _)); _] -> upexp e
                 | _ -> Impossible.impossible (Printf.sprintf "projected non-call: %s"
                                                              (RU.ToString.rtl r)))
           } 
@ 
<<standard machine-level control flow>>=
let return = R.store P.pc_lhs (R.fetch P.ra_reg w) w
@ 
<<standard machine-level control flow>>=
let branch =
  { Ep.embed   = (fun _ cond ->
                    DG.cond (fun tgt -> R.guard cond (gotor.Ep.embed tgt)))
  ; Ep.project = (fun r -> match downrtl r with
                          | RP.Rtl [(b, RP.Store(_, _, _))] -> upexp b
                          | _ -> Impossible.impossible "projected non-branch")
  } 
@
<<standard machine-level control flow>>=
let forbidden = R.kill P.pc_lhs
@ 
<<standard machine-level control flow>>=
let machine ~sp =
  let fail _ = assert false in
  { bnegate = bnegate; goto = goto; jump = jump; call = call; cutto = cutto sp;
    retgt_br = fail; spill = fail; reload = fail; move = fail;
    return = return; branch = branch; forbidden = forbidden }
@ 
\section{[[front_cfg/spans.nw]]}
<<front_cfg/spans.ml>>=
<<spans.ml>>
@

<<front_cfg/spans.mli>>=
<<spans.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et sts=4
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% inc: \usepackage{alltt}
%%
%%
%%% ------------------------------------------------------------------ 
\section{Representing spans, including internal spans}
%%% ------------------------------------------------------------------ 
%%
%%This module would love to hide the representation of spans, but for
%%reasons involving horrid circular dependencies, it doesn't hide the
%%represntation very well. 
%%All the truth about what the representation means lives off in the
%%[[Runtimedata]] module.
<<spans.mli>>=
type t
type label   = string
type link    = Reloc.t
type aligned = int
val to_spans : inalloc:Rtl.loc -> outalloc:Rtl.loc -> ra:Rtl.loc ->
               users:((Bits.bits * link) list) ->
               csregs:((Register.t * Rtl.loc option) list) ->
               conts:((label * Rtl.loc * (string * int * aligned) list) list) ->
                          (* (ra, sp, parms : (hint, var number, alignment) list) *)
               sds:(Rtl.loc list)                          ->
               vars:(Rtl.loc option array)                 ->
               t
<<regrettably exposed [[rep]] type>>
val expose : t -> rep
@ 
%%That was the fig leaf.  Now we expose it.
<<regrettably exposed [[rep]] type>>=
type rep =
  { mutable inalloc  : Rtl.loc
  ; mutable outalloc : Rtl.loc
  ; mutable ra       : Rtl.loc
  ; mutable users    : (Bits.bits * link) list
  ; mutable csregs   : (Register.t * Rtl.loc option) list
  ; mutable conts    : (label * Rtl.loc * (string * int * aligned) list) list
  ; mutable sds      : Rtl.loc list
  ; mutable vars     : Rtl.loc option array
  }
@
%%To walk the stack, we need to keep the stack pointer, previous stack pointer,
%%and return address live.
%%We provide a function to fold over live locations in the span.
%%Unfortunately, the [[CFG]] needs to call this function, so it goes here.
<<spans.mli>>=
val fold_live_locs : (Register.x -> 'a -> 'a) -> t -> 'a -> 'a
@
<<spans.ml>>=
type label = string
type link  = Reloc.t
type aligned = int
<<regrettably exposed [[rep]] type>>
type t = rep
let to_spans ~inalloc ~outalloc ~ra ~users ~csregs ~conts ~sds ~vars =
  { inalloc = inalloc; outalloc = outalloc; ra = ra; users = users; csregs = csregs;
    conts = conts; sds = sds; vars = vars; }
let expose spans = spans
@
%%We apply the input function to each of the locations we need to maintain live.
<<spans.ml>>=
let fold_live_locs f spans z =
  let fold = Rtlutil.Fold.RegX.loc f in
  let foldcsreg z = function (_, Some l) -> fold l z | (_, None) -> z in
  List.fold_left foldcsreg (fold spans.inalloc (fold spans.outalloc (fold spans.ra z)))
                           spans.csregs
@

\chapter{[[front_nelab]]}

\section{[[front_nelab/elabexp.nw]]}
<<front_nelab/elabexp.ml>>=
<<elabexp.ml>>
@

<<front_nelab/elabexp.mli>>=
<<elabexp.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{Elaborating Expressions}
%%% ------------------------------------------------------------------ 
%%
%%PERHAPS [[elab_ty]] SHOULD RETURN A WIDTH, SINCE AN EXPLICITLY
%%ELABORATED TYPE IS NEVER THE BOOLEAN TYPE? CHECK USAGE IN
%%\module{nelab} TO BE SURE.
%%
%%THE TRANSLATION OF THE LINK-TIME CONSTANTS SHOULD BE DELEGATED TO AN
%%ASSEMBLER.
%%ONLY AN ASSEMBLER KNOWS WHAT LINK-TIME CONSTANTS IT CAN SUPPORT.
%%
%%The {\qcc} compiler type checks expressions and converts them to RTL
%%expressions. 
%%None of these functions ever raises an exception.
%%To elaborate an lvalue, call [[elab_loc]] in a context in which no
%%kind is permissible and [[elab_kinded_name]] in a context in which a
%%name with an
%%optional kind is expected.
%%(There are no contexts in which a kind is permitted with a general lvalue.)
%%ONE PROBLEM REMAINS: WE COULD ACCEPT A KIND ON A PRIMITIVE CALL.
%%
<<elabexp.mli>>=
type nm_or_mem = Ast.name_or_mem
type link = Reloc.t
val aligned : Metrics.t -> Rtl.width -> Ast.aligned option -> Ast.aligned
                                                                     (* raises Error *)
val elab_ty : 'a Fenv.Dirty.env' -> Ast.ty   -> Rtl.width               Error.error
val elab_loc: 'a Fenv.Dirty.env' -> nm_or_mem-> (Rtl.loc   * Rtl.width) Error.error
val elab_exp: 'a Fenv.Dirty.env' -> Ast.expr -> (Rtl.exp   * Types.ty)  Error.error
val elab_con: 'a Fenv.Dirty.env' -> Ast.expr -> (Bits.bits * Rtl.width) Error.error
val elab_link:'a Fenv.Dirty.env' -> Ast.expr -> (link      * Rtl.width) Error.error
val elab_kinded_name: 
  'a Fenv.Dirty.env' -> nm_or_mem -> (string * (Rtl.loc * Rtl.width) * int) Error.error
@ 
%%For convenience in providing better locations in error messages,
%%we provide a way to get region of a location or expression.
%%The first parameter is the default result in case the location or
%%expression does not carry a region.
<<elabexp.mli>>=
val loc_region : Ast.region -> nm_or_mem -> Ast.region
val exp_region : Ast.region -> Ast.expr  -> Ast.region
@ 
%%The [[elab_*]] functions work with incomplete information,
%%indicated by [[Error.Error]] values.  The policy is as follows:
%%\begin{itemize}
%%\item In case of a success, [[check]] returns the type of the
%%      expression at hand as a [[Error.Ok]] value.
%%\item If the type check must use an erroneous information from the
%%      environment, it propagates this error and returns [[E.Error]].
%%\item If the type check detects a new error, for example a type
%%      inconsistency, it issues an error message and returns
%%      [[E.Error]].
%%      The exception [[Error.ErrorExn]] may be used internally, but it
%%      should never be raised by a top-level function.
%%\end{itemize}
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<elabexp.ml>>=
open Nopoly

module A  = Ast
module E  = Error
module F  = Fenv.Dirty
module FE = Fenv
type nm_or_mem = Ast.name_or_mem
type link = Reloc.t

let impossf fmt = Printf.kprintf Impossible.impossible fmt

let (@<<) f g = fun x -> f (g x) (* function composition *)
    
let is2power x = x > 0 && x land (x - 1) = 0
@
%%% ------------------------------------------------------------------
\subsection{The translation of types, names, and expressions}
%%% ------------------------------------------------------------------ 
%%
<<elabexp.ml>>=
module M = Metrics
<<utilities(elabexp.nw)>>
let loc_region r l = match l with A.NameOrMemAt(_, r) -> r | _ -> r
let exp_region r l = match l with A.ExprAt     (_, r) -> r | _ -> r

let aligned metrics =
  let wordsize = metrics.M.wordsize in
  let wordmult = Cell.divides (Cell.of_size wordsize) in
  let aligned w = function
    | Some a -> alignment a
    | None   -> if wordmult w then w / wordsize else 1 in
  aligned

let exprfuns env =
  let metrics     = F.metrics env in
  let mcell       = Cell.of_size metrics.M.memsize in
  let mspace      = ('m', metrics.M.byteorder, mcell) in
  let eprint r    = E.errorRegionPrt (F.srcmap env, r) in
  let errorf fmt  = Printf.kprintf E.error fmt in
  let catch r f x = E.catch (eprint r) f x in
  let aligned     = aligned metrics in
  <<definition of [[lvalue_name]]>>
  <<definition of [[rvalue_name]]>>
  <<mutually recursive nest of [[typed_expr]] and [[lvalue]]>>
  in
  let constant simp e = E.ematch (typed_expr e) (fun (k, kt) ->
    match kt with
    | Types.Bits w -> simp k, w
    | _ -> E.error "constant expression may not be a Boolean") in
  let caught r f x = catch (r x) f x in
  let l, e = loc_region Srcmap.null, exp_region Srcmap.null in
  caught e typed_expr, caught l lvalue, caught l kinded_name,
  caught e (constant Simplify.bits), caught e (constant Simplify.link)

let elab_exp         env = let f, _, _, _, _ = exprfuns env in f
let elab_loc         env = let _, f, _, _, _ = exprfuns env in f
let elab_kinded_name env = let _, _, f, _, _ = exprfuns env in f
let elab_con         env = let _, _, _, f, _ = exprfuns env in f
let elab_link        env = let _, _, _, _, f = exprfuns env in f
@
%%
%%There are four interesting syntactic categories here:
%%\begin{itemize}
%%\item
%%A \emph{type} is interesting only for its width.
%%We have two forms: one from [[Types]] and one from [[Ast]].We provide functions [[tywidth]] and [[astwidth]].
%%\item
%%A \emph{name} may occur in an lvalue context or an rvalue context; we
%%provide [[lvalue_name_in_env]] and [[rvalue_name]].
%%Many names are meaningful only in an rvalue context.
%%\item
%%A \emph{name-or-mem} may occur in an lvalue context or an rvalue context; we
%%provide [[lvalue]] and [[rvalue_name_or_mem]].
%%\item
%%An \emph{expression} may occur only in an rvalue context; we provide
%%[[typed_expr]].
%%\end{itemize}
%%Of the functions above, only [[lvalue_name_in_env]] and [[astwidth]]
%%are parameterized 
%%by an environment.
%%The rest appear in a context (under [[exprfuns]]) in which the
%%environment is bound to [[env]].
%%
%%\subsubsection {Translation of type and conversion from type to width}
%%
%%\nwaddbox{tywidth  : 'a Types.t -> 'a}
%%\nwaddbox{astwidth : F.env -> A.ty -> int}
%%\deeperbox{2pt}
<<utilities(elabexp.nw)>>=
let tywidth a_bad_thing = function
  | Types.Bits n -> n
  | Types.Bool   -> E.error (Printf.sprintf "A boolean may not be %s" a_bad_thing)

let emap f x = E.ematch x f

let elab_full_ty env =
  let catch r = E.catch (E.errorRegionPrt (F.srcmap env, r)) in
  let rec elab = function
    | A.TyAt (x,r)    -> catch r elab x
    | A.BitsTy size   -> E.Ok (Types.Bits size)
    | A.TypeSynonym n -> snd (F.findt n env) in
  catch Srcmap.null elab

(* pad: was << but I changed it to @<<, typo in .nw file ??? *)
let astwidth msg env = emap (tywidth msg) @<< elab_full_ty env
let elab_ty env = astwidth "expressed in abstract syntax" env
@
%%\subsubsection{The meanings of names}
%%
%%Only the name of a {\PAL} register variable is meaningful in an lvalue
%%context.
%%The environment is explicit.
%%\nwaddbox{lvalue_name_in_inv : F.env -> name -> Rtl.loc * Rtl.width}
%%\deeperbox{16pt}
<<definition of [[lvalue_name]]>>=
let lvalue_name x = 
  E.ematch (snd (F.findv x env))
  (fun (den,t) ->
    let w = tywidth "assigned to" t  in
    match den with
    | FE.Variable {FE.loc=l} -> l, w
    | _ -> errorf "may not assign to %s %s" (FE.denotation's_category den) x) in
@ 
%%Any name can be meaningful in an rvalue context.
%%The environment is implicit.
%%\nwaddbox{val rvalue_name : name -> Rtl.exp * Types.t}
<<definition of [[rvalue_name]]>>=
let rvalue_name x =
  E.seq (snd (F.findv x env))
  (fun (denot, t) ->
    let w = tywidth "named variable" t in
    let rval = match denot with
    | FE.Constant bits        -> E.Ok (Rtl.bits bits w)
    | FE.Label (FE.Proc s)    -> E.Ok (Rtl.codesym s w)
    | FE.Label (FE.Code s)    -> E.Ok (Rtl.codesym s w)
    | FE.Label (FE.Data s)    -> E.Ok (Rtl.datasym s w)
    | FE.Import(_,s)          -> E.Ok (Rtl.impsym  s w)
    | FE.Continuation c       -> (c.FE.escapes <- true; E.Ok (Block.base c.FE.base))
    | FE.Label(FE.Stack addr) -> E.Ok addr  (* a fetch would be wrong *)
    | FE.Variable _           -> emap (fun (l,w) -> Rtl.fetch l w) (lvalue_name x) in
    E.Raise.left (rval, t)) in
@ 
%%\subsubsection{General lvalues}
%%
%%WE MUST CHECK TO SEE IF A KIND IS PERMITTED!
%%
%%Again, the environment is implicit.
%%\nwaddbox{lvalue : Ast.lvalue -> Rtl.loc * Rtl.width}
%%\deeperbox{14pt}
<<mutually recursive nest of [[typed_expr]] and [[lvalue]]>>=
let rec kinded_name lhs = match lhs with
  | A.NameOrMemAt(lhs,r) -> catch r kinded_name lhs
  | A.Name(kind,x,a)     -> E.ematch (lvalue_name x) (fun (loc, w) ->
                               (Auxfuns.Option.get "" kind, (loc, w), aligned w a))
  | A.Mem _              -> E.error "only a name may appear to left of a call" in
let rec lvalue lhs = match lhs with
  | A.NameOrMemAt(lhs,r)    -> catch r lvalue lhs
  | A.Name(k,x,a) -> no_kind_or_alignment k a lvalue_name x
  | A.Mem(t,addr,aligned,aliasing) ->
      let w = astwidth "value in memory" env t in
      E.ematch2 w (typed_expr addr) (fun w (addre, addrt) ->
        if tywidth "address" addrt <> metrics.M.pointersize then
          E.error "address's type is not the machine's pointer size"
        else if not (Cell.divides mcell w) then
          E.error "reference's type is not a multiple of target memsize"
        else
          Rtl.mem (assertion aligned) mspace (Cell.to_count mcell w) addre, w)
and rvalue_name_or_mem nm = match nm with
  | A.NameOrMemAt(v, r) -> catch r rvalue_name_or_mem v
  | A.Name(k, x, a)     -> no_kind_or_alignment k a rvalue_name x
  | A.Mem(_, _, _, _)   ->
      E.ematch (lvalue nm) (fun (loc, w) -> Rtl.fetch loc w, Types.Bits w)
@ 
<<utilities(elabexp.nw)>>=
let no_kind_or_alignment k a f x = match k, a with
  | None, None     -> f x
  | Some _, None   -> E.error "kind permissible only on parameter or result"
  | None, Some _   -> E.error "alignment permissible only on parameter or result"
  | Some _ ,Some _ -> 
      E.error "kind and alignment permissible only on parameter or result"
@
<<utilities(elabexp.nw)>>=
let alignment n =
  if is2power n then n else E.errorf "alignment %d is not a power of 2" n
let assertion = function
  | None -> Rtl.none
  | Some n -> Rtl.aligned (alignment n)
@ 
%%% ------------------------------------------------------------------ 
%%\subsubsection{The meaning of expressions}
%%% ------------------------------------------------------------------ 
%%
%%Although in many cases we need only the RTL associated with an
%%expression, it is simple and efficient to produce both the type and
%%the RTL at one time. 
%%\nwaddbox{typed_expr : Ast.exp -> Rtl.exp * Types.t}
<<mutually recursive nest of [[typed_expr]] and [[lvalue]]>>=
and typed_expr exp = 
  let apply tx op args =
    E.ematch (E.Raise.list (List.map typed_expr args))
    (fun args ->
      let arges, argtys = List.split args in
      let resty,  opr   = tx op argtys    in
      Rtl.app opr arges, resty) in
  let literal cvt v width = Rtl.bits (cvt v width) width, Types.Bits width in
  let literal cvt v = emap (literal cvt v) in
  let signed, unsigned, float =
    let does_not_overflow f v w =
      try (ignore (f v w); true) with Bits.Overflow -> false in
    let cvt signed what cvt v width =
      try cvt v width
      with Bits.Overflow ->
        if signed && not (v.[0] =<= '-') && does_not_overflow Bits.U.of_string v width
        then
          E.errorf "literal %s does not fit in %d signed bits, but it will\n\
                    fit in %d unsigned bits---perhaps you want '%sU'?"
            v width width v
        else
          E.errorf "%s overflow in literal %s" what v in
    cvt true  "signed-integer"   Bits.S.of_string,
    cvt false "unsigned-integer" Bits.U.of_string,
    cvt false "floating-point"   Bits.U.of_string in  (* surprising but true *)
  let const default_width = function
    | Some ty -> astwidth "literal constant" env ty
    | None    -> E.Ok default_width in
  match exp with
  | A.ExprAt(x,r)     -> catch r typed_expr x
  | A.Sint(str,t)     -> literal signed        str (const metrics.M.wordsize t) 
  | A.Uint(str,t)     -> literal unsigned      str (const metrics.M.wordsize t) 
  | A.Float(str,t)    -> literal float         str (const metrics.M.wordsize t) 
  | A.Char(int,t)     -> literal Bits.U.of_int int (const 8                  t) 
  | A.Fetch(v)        -> rvalue_name_or_mem v
  | A.BinOp (l,op,r)  -> apply Rtlop.Translate.binary op [l;r]
  | A.UnOp  (op,e)    -> apply Rtlop.Translate.unary  op [e]
  | A.PrimOp(op,args) -> let args = List.map (fun (k, x, a) -> x) args in
                         apply Rtlop.Translate.prefix op args
@ 
%%Perhaps suprisingly, [[Bits.U.of_string]] copes with all 
%%         literal formats.
%%
%%
\section{[[front_nelab/elabstmt.nw]]}
<<front_nelab/elabstmt.ml>>=
<<elabstmt.ml>>
@

<<front_nelab/elabstmt.mli>>=
<<elabstmt.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{Elaborating Statements}
%%% ------------------------------------------------------------------ 
%%
%%We could choose to attach spans here, but because the compiler has to
%%create and attach internal spans later in, it's probably not worth
%%doing here.
%%
%%We begin with the same sort of abbreviations used in [[Nast]].
<<exposed types(elabstmt.nw)>>=
type exp = Rtl.exp
type loc = Rtl.loc * Rtl.width
type rtl = Rtl.rtl

type name = string
type kind = string
type convention = string
type aligned    = int
@ 
%%
<<exposed types(elabstmt.nw)>>=
type actual = kind * exp * Rtl.width * aligned
type 'a kinded = kind * 'a * aligned
type 'a flow  = { cuts : 'a list; unwinds : 'a list; areturns : 'a list;
                  returns : bool; aborts : bool }
type 'a cflow = { ccuts : 'a list; caborts : bool }
type 'a alias = { reads : 'a; writes : 'a }
type range = Bits.bits * Bits.bits   (* lo `leu` x `leu` hi, as in manual *)
type procname = string
type label    = string
type linktime = Reloc.t

type stmt =
  | If         of exp * stmt list * stmt list
  | Switch     of range option * exp * (range list * stmt list) list
  | Label      of label
  | Cont       of name * convention * Fenv.variable kinded list
  | Span       of (Bits.bits * linktime) * stmt list
  | Assign     of rtl
  | Call       of loc kinded list * convention * exp * actual list * procname list
                * name flow * name list option alias
  | Call'      of convention * exp * actual list * procname list
                    (* the dog ate the annotations *)
  | Goto       of exp * label list
  | Jump       of convention * exp * actual list * procname list
  | Cut        of convention * exp * actual list * name cflow 
  | Return     of convention * int * int * actual list
  | Limitcheck of convention * exp * limitfailure option
and limitfailure = { failcont : exp; reccont : exp; recname : name; }
@
<<elabstmt.mli>>=
<<exposed types(elabstmt.nw)>>
val elab_stmts :
  (Rtl.rtl -> string option) -> Srcmap.map -> Ast.region -> 'a Fenv.Dirty.env' -> 
  Nast.stmt list -> stmt list Error.error
val elab_cformals : 
  Ast.region -> 'a Fenv.Dirty.env' -> Nast.cformal list ->
    Fenv.variable kinded list Error.error
val codelabels : stmt list -> label list
@ 
%%The [[elab_*]] functions work with incomplete information,
%%indicated by [[Error.Error]] values.  The policy is as follows:
%%\begin{itemize}
%%\item In case of a success, [[check]] returns the type of the
%%      expression at hand as a [[Error.Ok]] value.
%%\item If the type check must use an erroneous information from the
%%      environment, it propagates this error and returns [[E.Error]].
%%\item If the type check detects a new error, for example a type
%%      inconsistency, it issues an error message and returns
%%      [[E.Error]].
%%      The exception [[Error.ErrorExn]] may be used internally, but it
%%      should never be raised by a top-level function.
%%\end{itemize}
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<elabstmt.ml>>=
<<exposed types(elabstmt.nw)>>
module A  = Ast
module E  = Error
module F  = Fenv.Dirty
module FE = Fenv
module N  = Nast
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let is2power x = x > 0 && x land (x - 1) = 0
@
<<elabstmt.ml>>=
module M = Metrics
@ 
%%Parameter [[reachable]] means the statement is reachable by ordinary
%%control flow (i.e., not by continuation).
%%It is used to check the control-flow
%%restrictions: if a statement is reachable by ordinary control flow, it
%% had better not be a continuation.
%%Similarly, it had better not be the end of the procedure body.
<<elabstmt.ml>>=
let elab_functions validate srcmap r env =
  let eprint r    = E.errorRegionPrt (F.srcmap env, r) in
  let errorf r    = Printf.kprintf (fun s -> eprint r s; E.Error) in
  let findve r n  = E.catch (eprint r) (fun env -> snd (F.findv n env)) in
  let aligned     = Elabexp.aligned (F.metrics env) in
  let aligned r w = E.catch (eprint r) (fun a -> E.Ok (aligned w a)) in
  let exp = Elabexp.elab_exp env in
  let con = Elabexp.elab_con env in
  let loc = Elabexp.elab_loc env in
  let metrics = F.metrics env in
  <<elaboration of continuation formals>>
  let rec full_stmt r reachable s =
    <<elaboration utilities>>
    <<definitions of elaboration functions(elabstmt.nw)>>
    let rec stmt s = match s with
    | N.StmtAt (s, r) -> E.catch (eprint r) (full_stmt r reachable) s
    | N.If (c, t, f) -> 
        let c = exp c in let t = stmts r true t in let f = stmts r true f in (*order*)
        E.ematch3 c t f (fun (c, cty) t f ->
          match cty with
          | Types.Bool -> If (c, t, f)
          | Types.Bits n -> E.error "condition in `if' is not a Boolean")
    | N.Switch (range, e, arms) -> switch range e arms
    | N.Label n -> E.Ok (Label n)
    | N.Cont (name, cc, formals) ->
        let c = E.ematch (cformals formals) (fun formals -> Cont (name,cc,formals)) in
        if reachable then
          E.error "control can fall through to continuation"
        else
          c
    | N.Span (k, v, ss)   -> span k v (stmts r reachable ss)
    | N.Assign (lhs, rhs) -> assign lhs rhs
    | N.Goto (tgt, tgts)  -> goto tgt tgts
    | N.Call (lhs, conv, p, args, tgts, f, a) -> call lhs conv p args tgts f a
    | N.Jump (conv, p, args, tgts)            -> jump conv p args tgts
    | N.Cut  (conv, k, args, flow)            -> cut conv k args flow
    | N.Prim (lhs, conv, p, args, flow)       -> prim lhs conv p args flow
    | N.Return (conv, altcont, args)          -> return conv altcont args
    | N.Limitcheck (conv, cookie, cont)       -> limitcheck conv cookie cont in
    stmt s
  and stmts r reachable ss = 
    let rec stmts reachable = function
      | [] -> []
      | N.Span (_, _, []) :: ss -> stmts reachable ss
      | s :: ss ->
          let s' = full_stmt r reachable s in  (* enforce order *)
          s' :: stmts (not (jumps s)) ss in
    Error.Raise.list (stmts reachable ss)
  and jumps = function N.Goto _ | N.Jump _ | N.Cut _ | N.Return _  -> true
                     | N.Call (_, _, _, _, _, fl, _) -> List.exists never_returns fl
                     | N.StmtAt (s, _) -> jumps s
                     | N.Span (_, _, ss) -> jumpsss ss
                     | N.If (_, t, f) -> jumpsss t && jumpsss f
                     | N.Switch (_, _, arms) -> List.for_all jumpsarm arms
                     | _ -> false
  and never_returns = function
    | Ast.FlowAt (f, _) -> never_returns f
    | Ast.NeverReturns -> true
    | _ -> false
  and jumpsss = function
    | [] -> false
    | [s] -> jumps s
    | s :: N.Span (_, _, []) :: ss -> jumpsss (s :: ss)
    | _ :: ss -> jumpsss ss
  and jumpsarm (_, ss) = jumpsss ss in
  let stmts ss =
    let falls = not (jumpsss ss) in
    let ss = stmts r true ss in
    if falls then errorf r "control falls off end of procedure" else ss
  in stmts, cformals
let nullmap = Srcmap.mk ()
let nullv   = fun _ -> None
let elab_stmts    v m r env = fst (elab_functions v m           r env)
let elab_cformals     r env = snd (elab_functions nullv nullmap r env)
@ 
%%Here are a couple of basic utilities.
%%We sometimes do extra checking if an expression is just a name.
<<elaboration utilities>>=
let rec exp_as_name = function
  | A.ExprAt(x,_) -> exp_as_name x
  | A.Fetch(A.NameOrMemAt(x,_)) -> exp_as_name (A.Fetch x)
  | A.Fetch(A.Name(_,x,_)) -> Some x
  | _ -> None in
@ 
%%Lots of things have to be the native pointer type.
<<elaboration utilities>>=
let ispointer =
  function Types.Bits n when n = metrics.M.pointersize -> true | _ -> false in
let insist_pointer what t =
  if ispointer t then ()
  else E.error (what ^ " must be a bit vector of the native pointer type") in
@ 
%%We need to be able to validate an RTL at a source location.
<<elaboration utilities>>=
let vrtl r rtl =
  match validate rtl with
  | None -> rtl
  | Some msg ->
      ( Printf.eprintf "%s: Warning: %s\n" (Srcmap.Str.region r) msg; rtl ) in
@ 
%%A formal parameter to a continuation must be a local register variable.
<<elaboration of continuation formals>>=
let cformal (rgn, kind, name, a) =
  E.seq (findve rgn name env) (fun den ->
    match den with
    | FE.Variable v, Types.Bool -> impossf "Boolean variable"
    | FE.Variable v, Types.Bits w when F.is_localv name env ->
        E.ematch (aligned rgn w a) (fun a -> (kind, v, a))
    | FE.Variable _, _ ->
        errorf r "continuation parameter '%s' may not be a global variable" name
    | d, _ ->
        errorf r "continuation parameter '%s' is a %s, not a local register variable"
          name (FE.denotation's_category d)) in
let cformals formals = E.Raise.list (List.map cformal formals) in
@
%%The type of the switch expression must be matched by the guarding
%%ranges of the arms.  An empty switch-statement is an error because no
%%arm can match the value of the switch-expression at run-time.
<<definitions of elaboration functions(elabstmt.nw)>>=
let switch rg e arms =
  let rg = E.Raise.option (Auxfuns.Option.map range rg) in (* order matters *)
  let arms = E.Raise.list (List.map arm arms) in
  E.ematch3 (exp e) rg arms (fun (e, et) rg arms ->
    match et with
    | Types.Bool -> E.error "switch statement scrutinee is a Boolean"
    | Types.Bits w ->
        let rg = Auxfuns.Option.map (striprange w) rg in
        let arms = striparms w arms in
        if null arms then E.error "empty switch statement"
        else Switch(rg, e, arms)) in
@
%%A range has two constant expressions of the same width.
<<elaboration utilities>>=
let range = function
  | A.Range (l, h) ->
      let l = con l in let h = con h in (* order matters *)
      E.ematch2 l h (fun (l, lw) (h, hw) ->
      if lw = hw then (l, h), lw
      else E.errorf "constants in range %s..%s have different types bits%d and bits%d"
          (Bits.to_string l) (Bits.to_string h) lw hw)
  | A.Point e -> E.ematch (con e) (fun (n, w) -> (n, n), w) in
@ 
%%An arm is guarded by a nonempty list of ranges, each of the same width.
<<elaboration utilities>>=
let arm (rgs, ss) =
  let rgs = E.Raise.list (List.map range rgs) in (* order matters *)
  E.ematch2 rgs (stmts r true ss) (fun rgs ss ->
    match rgs with
    | [] -> E.error "case arm has an empty range list"
    | (rg, w) :: rgs ->
        let strip w (rg, w') = if w = w' then rg else 
         <<exn on range type mismatch>>
        in
        ((rg :: List.map (strip w) rgs), ss), w) in
@ 
%%The width of every range that appears in a [[switch]] arm must match
%%the type of the scrutinee ([[switch]]-expression).
%%We check this requirement and strip the width off everything in sight.
<<elaboration utilities>>=
let striprange w (rg, w') =
  if w = w' then rg else 
   <<exn on case range type mismatch>>
   in
let striparms w =
  let strip (arm, w') = if w = w' then arm else  
    <<exn on arm type mismatch>>
  in
  List.map strip in
@ 
%%
<<exn on range type mismatch>>=
E.errorf "ranges in case arm have different types bits%d and bits%d" w w'
@ 
<<exn on arm type mismatch>>=
E.errorf "case arm uses range of type bits%d but scrutinee has type bits%d" w' w
@ 
<<exn on case range type mismatch>>=
E.errorf "switch statement range has type bits%d but scrutinee has type bits%d" w' w
@ 
%%
%%
%% 
%%A [[span]] statement has key and value expressions.
%%The key must be a constant native word and the value a link-time (data)
%%pointer.  Of course, all statement inside the span must be checked as
%%well. Currently we don't check the link-time property of [[e2]].
<<definitions of elaboration functions(elabstmt.nw)>>=
let span k v ss =
  let k = con k in  (* order matters *)
  E.ematch3 k (Elabexp.elab_link env v) ss (fun (k, kw) (v, vw) ss ->
    if kw <> metrics.M.wordsize then
      E.error "span token (key) must be a bit vector of native word size";
    insist_pointer "span value" (Types.Bits vw);
    Span ((k, v), ss)) in
@
%%Two two sides of an assign statement must match: the number and types
%%of lvalues and expressions are checked against each other.  For
%%improved error messages [[List.combine]] is re-implemented. Details
%%of the left hand side are handled by the [[lvalue]] function.
%%
%%The right hand side may contain optional guarding expressions of type
%%[[bool]].
<<definitions of elaboration functions(elabstmt.nw)>>=
let assign lhs rhs =
  try E.ematch (E.Raise.list (List.map2 effect lhs rhs)) (fun es ->
    Assign (vrtl (srcmap, r) (Rtl.par es)))
  with Invalid_argument _ -> 
   <<complain about length mismatch in assignment>>
  in
@ 
<<elaboration utilities>>=
let effect lhs (guard,rhs) =
  let guard = Auxfuns.Option.map exp guard in
  E.seq2 (loc lhs) (exp rhs) (fun (loc, w) (e, ty) ->
    if Pervasives.(<>) ty (Types.Bits w) then
      errorf (Elabexp.loc_region r lhs)
        "location of type bits%d cannot hold value of type %s" w (Types.to_string ty)
    else
      let rtl = Rtl.store loc e w in
      match guard with
      | None   -> E.Ok rtl
      | Some g -> E.seq g (fun (g, ty) ->
          match ty with Types.Bool -> E.Ok (Rtl.guard g rtl)
          | _ -> errorf r "guard must have type bool, not %s" (Types.to_string ty))) in
@ 
<<complain about length mismatch in assignment>>=
if List.length lhs < List.length rhs then
  errorf r
    "assignment has %d expressions on the right but only %d locations on the left"
    (List.length rhs) (List.length lhs)
else
  errorf r
    "assignment has %d locations on the left but only %d expressions on the right"
    (List.length lhs) (List.length rhs)
@ 
%%A [[limitcheck]] just elaborates an expression or two.
<<elaboration utilities>>=
let limitcheck cconv cookie cont =
  E.seq (exp cookie) (fun (cookie, cookiety) ->
    insist_pointer "limit cookie" cookiety;
    match cont with
    | None -> Error.Ok (Limitcheck (cconv, cookie, None))
    | Some (failk, recname) ->
        let reck = A.Fetch (A.Name (None, recname, None)) in
        E.ematch2 (exp failk) (exp reck) (fun (failk, fty) (reck, rty) ->
          insist_pointer "overflow continuation" fty;
          insist_pointer "automatically generated recovery continuation" rty;
          let f = { failcont = failk; reccont = reck; recname = recname; } in
          Limitcheck (cconv, cookie, Some f))) in
@
%%A [[goto]] statement must name all possible (local) targets [[ts]] for
%%its code pointer expression [[e]].  Targets may be omitted only if the
%%expression is a statically known target, i.e.~a local code label. 
<<definitions of elaboration functions(elabstmt.nw)>>=
let goto tgt tgts =
  let tgts = E.Raise.list (List.map (goto_target r) tgts) in (* order matters *)
  E.ematch2 (exp tgt) tgts (fun (te, t) tgts ->
    insist_pointer "target of goto" t;
    if null tgts && not (exp_is_local_code_label r tgt) then
      E.error "target list omitted and target is not a local code label";
    Goto (te, tgts)) in 
@
%%A name appearing in a targets list must denote a local label,
%%as must an expression without a targets list.
%%We have two functions so we can issue suitable error messages.
<<elaboration utilities>>=
let goto_target r x = E.seq (findve r x env) (fun (d, t) ->
  match d with 
  | FE.Label (FE.Code _) when F.is_localv x env -> E.Ok x
  | FE.Label (FE.Code _) -> errorf r "may not goto %s (label in another procedure)" x
  | _ -> errorf r "may not goto %s %s" (FE.denotation's_category d) x) in
let exp_is_local_code_label r e = match exp_as_name e with
| None -> false
| Some x -> match findve r x env with
  | E.Ok (FE.Label (FE.Code _), _) when F.is_localv x env -> true
  | E.Ok _ -> false
  | E.Error -> impossf "good target name came back as error" in
@ 
%%
\subsection{Value-passing statements: calls and so on}
%%A call need not name targets;
%%the only requirement is that the expression by of the native pointer
%%type.  
%%The
%%details of the assignment in a [[Call]] context are handled by
%%[[lvalue]].  To make sure all errors are recorded in [[env]] the
%%argument to [[E.seq']] includes [[left]] and [[at]] although only the
%%type of [[exp]] is used.
<<definitions of elaboration functions(elabstmt.nw)>>=
let call left conv p args targets flows alias =
  let left  = E.Raise.list (List.map (Elabexp.elab_kinded_name env) left) in
  let args  = E.Raise.list (List.map (actual r) args) in
  let tgts  = E.Raise.list (List.map (call_target r) targets) in
  let flow  = call_flow r conv flows in
  let alias = elab_alias r alias in
  E.seq (exp p) (fun (pe, pt) ->
    reject_uncallable r p;
    E.ematch5 left args tgts flow alias (fun left args tgts flow alias ->
      insist_pointer "procedure value" pt;
      Call (left, conv, pe, args, tgts, flow, alias))) in
@ 
%%The double nesting avoids a double error (from both [[exp]] and
%%[[reject_uncallable]]) in the case when [[p]] is an unknown name.
%%But by doing [[reject_uncallable]] early, we can issue a suitable
%%message even in the case when [[p]] is a good but uncallable [[exp]]
%%and some other abstract syntax is bad as well.
%%
%%The jump expression must be a (code) pointer.
<<definitions of elaboration functions(elabstmt.nw)>>=
let jump conv p args targets =
  let args = E.Raise.list (List.map (actual r) args) in
  let tgts = E.Raise.list (List.map (call_target r) targets) in
  E.seq (exp p) (fun (pe, pt) ->
    reject_uncallable r p;
    E.ematch2 args tgts (fun args tgts ->
      insist_pointer "procedure value" pt;
      Jump (conv, pe, args, tgts))) in
@ 
%%Why is there no analog of [[reject_uncallable]]?
%%Only Christian knows\ldots
<<definitions of elaboration functions(elabstmt.nw)>>=
let cut conv k args flows =
  let args = E.Raise.list (List.map (actual r) args) in
  let flow = cut_flow r conv flows in
  E.ematch3 args (exp k) flow (fun args (k,kt) flow ->
    insist_pointer "target of 'cut to'" kt;
    Cut (conv, k, args, flow)) in
@ 
%%
%%A [[return]] may specify alternate return continuations.  The
%%expressions $e_1/e_2$ must be both of the native word type and $0 \leq
%%e1 \leq e_2$.
<<definitions of elaboration functions(elabstmt.nw)>>=
let return conv alt args =
  let args = E.Raise.list (List.map (actual r) args) in
  let i, n = match alt with
  | None -> E.Ok 0, E.Ok 0
  | Some (i, n) ->
      let okbits f x = E.Ok (Bits.S.to_int (f x)) in
      let const k = E.seq (exp k) (fun (k, kt) ->
        E.catch (eprint r) (okbits Simplify.bits) k) in
      const i, const n in
  E.ematch3 i n args (fun i n args ->
    if i >= 0 && n >= 0 && i <= n then
      Return (conv, i, n, args)
    else
      <<raise error exn with bad continuation numbers>>
    ) in
@ 
<<raise error exn with bad continuation numbers>>=
if i < 0 then
  E.errorf "in return <i/n>, i must be nonnegative but you have i = %d" i
else if n < 0 then
  E.errorf "in return <i/n>, n must be nonnegative but you have n = %d" n
else if i > n then
  E.errorf "in return <i/n>, i must be at most n but you have i = %d and n = %d" i n
else
  impossf "bad <i/n> with i = %d and n = %d, but no better error message" i n
@ 
<<elaboration utilities>>=
let actual r (kind, e, a) = E.seq (exp e) (fun (e, ty) ->
  match ty with
  | Types.Bits w -> E.ematch (aligned r w a) (fun a -> (kind, e, w, a))
  | Types.Bool   -> errorf r "an actual parameter may not be a Boolean") in
@ 
%%As target of a call or jump,
%%we reject out of hand (by raising [[E.ErrorExn]]) any name that is
%%obviously not a procedure. 
<<elaboration utilities>>=
let reject_uncallable r e = match exp_as_name e with
| None -> ()
| Some x -> match findve r x env with
  | E.Ok ((FE.Label (FE.Proc _) | FE.Import (_, _) | FE.Variable _), _) | E.Error -> ()
  | E.Ok (d, _) -> 
      E.errorf "cannot call or jump to %s %s" (FE.denotation's_category d) x in
@ 
%%\paragraph{Checking aliasing annotations}
%%Alias is at most one read and at most one write.
<<elaboration utilities>>=
let elab_alias r alias =
  let none = function None -> true | Some _ -> false in
  let rec elab r reads writes = function
    | [] -> E.Ok { reads = reads; writes = writes }
    | A.AliasAt(a,r) :: a's -> E.catch (eprint r) (elab r reads writes) (a :: a's)
    | A.Reads  ns :: a's when none reads  -> elab r (Some ns) writes a's
    | A.Writes ns :: a's when none writes -> elab r reads (Some ns) a's
    | A.Reads  _ :: _ -> errorf r "multiple 'reads' annotations on one call"
    | A.Writes _ :: _ -> errorf r "multiple 'writes' annotations on one call" in
  E.catch (eprint r) (elab r None None) alias in
@    
%%\paragraph{Checking flow annotations}
%%For the moment, we elaborate flow of names into flow of names, doing only checking.
%%But at some point we might want to elaborate flow of names into flow
%%of denotations.  This might require extending the denotations.
%%We'll know when we revise [[Ast2ir]].
<<elaboration utilities>>=
let flow r conv default_aborts default_returns =
  let as_cut_to  k = k.FE.cut_to <- true in
  let as_unwinds k = k.FE.unwound_to <- true in
  let as_returns k =
    if not (List.mem conv k.FE.returned_to) then
      k.FE.returned_to <- conv :: k.FE.returned_to in
  let rec ks r as_what prev' ns =
    let continuation n = E.seq (findve r n env) (function
      | FE.Continuation k, _ -> as_what k; E.Ok n
      | _ -> errorf r "%s is not a continuation" n) in
    match ns with
    | [] -> prev'
    | n :: ns -> ks r as_what (continuation n :: prev') ns in
  let rec flow r c' u' r' aborts returns = function
    | [] -> finish_flow c' u' r' aborts returns
    | A.FlowAt(f,r)  :: fs -> flow r c' u' r' aborts returns (f :: fs)
    | A.CutsTo    ns :: fs -> flow r (ks r as_cut_to c' ns) u' r' aborts returns fs
    | A.UnwindsTo ns :: fs -> flow r c' (ks r as_unwinds u' ns) r' aborts returns fs
    | A.ReturnsTo ns :: fs -> flow r c' u' (ks r as_returns r' ns) aborts returns fs
    | A.Aborts       :: fs -> flow r c' u' r' true returns fs
  (*| A.NeverAborts  :: fs -> flow r c' u' r' false returns fs *)
    | A.NeverReturns :: fs -> flow r c' u' r' aborts false fs 
  and finish_flow c' u' r' aborts returns =
    let list ns = E.Raise.list (List.rev ns) in
    let c = list c' in let u = list u' in let r = list r' in (* order matters *)
    E.ematch3 c u r (fun c u r ->
      { cuts = c; unwinds = u; areturns = r; aborts = aborts; returns = returns }) in
  flow r [] [] [] default_aborts default_returns in
@ 
%%The rules for flow are slightly different for calls and cuts.
<<elaboration utilities>>=
let call_flow r cc fs = flow r cc false true fs in
let null = function [] -> true | _ :: _ -> false in
let cut_flow r cc fs =
  E.seq (flow r cc true false fs) (fun f ->
    if not (null f.unwinds) then
      errorf r "'also unwinds to' is meaningless on a 'cut to'"
    else if not (null f.areturns) then
      errorf r "'also returns to' is meaningless on a 'cut to'"
    else if f.returns then
      impossf "a 'cut to' returns? I think not!"
    else
      E.Ok { ccuts = f.cuts; caborts = f.aborts }) in
@ 
%%A call target must be either a procedure or an imported symbol with
%%the native pointer type.
<<elaboration utilities>>=
let call_target r x = E.seq (findve r x env) (function
  | (FE.Label (FE.Proc _) | FE.Import _), t when ispointer t -> E.Ok x
  | d, _ -> errorf r "target %s is a %s (must be a procedure or imported pointer)"
          x (FE.denotation's_category d)) in
@
%%A call of a primitive is type checked: argument types must have the
%%expected types. This is done by [[Rtlop.Translate.check]].
<<definitions of elaboration functions(elabstmt.nw)>>=
let prim lhs conv op args flows =
  let strip_decorations = function
    | "", arg, None   -> arg
    | "", arg, Some _ ->
        E.error "call to primitive operator may not use explicit alignment"
    | s, arg,  None   ->
        E.error "call to primitive operator must use empty kind"
    | s, arg,  Some _ ->
        E.error "call to primitive operator must use empty kind and default alignment"
  in
  let lhs  = E.Raise.list (List.map (Elabexp.elab_kinded_name env) lhs) in
  let args = E.Raise.list (List.map (fun arg -> exp (strip_decorations arg)) args) in
  let flow = prim_flow r flows in
  E.ematch3 lhs args flow (fun lhs args flow ->
    match lhs with
    | [_, (result, w), aligned] ->
        let argtys  = List.map snd args in
        let argexps = List.map fst args in
        let t, opr  = Rtlop.Translate.prefix op argtys in
        if Pervasives.(<>) t (Types.Bits w) then
          <<raise error exn on primop type mismatch>>
        else
          Assign (Rtl.store result (Rtl.app opr argexps) w)
    | _ -> E.error "primitive operator produces exactly one result") in
@ 
%%
<<raise error exn on primop type mismatch>>=
Printf.kprintf E.error
  "left-hand side has type bits%d, but primitive operator produces results of type %s"
  w (Types.to_string t)
@ 
%%There should be no choice of calling convention for the application of
%%a primitive operator, so we just build in the [["C--"]] convention.
<<elaboration utilities>>=
let prim_flow r fs =
  E.seq (flow r "C--" false true fs) (fun f ->
    if not (null f.unwinds) then
      errorf r "'also unwinds to' is meaningless on a primitive operator"
    else if not (null f.cuts) then
      errorf r "'also cuts to' is meaningless on a primitive operator"
    else if not (null f.areturns) then
      errorf r "alternate returns on primitive operators are not yet implemented"
    else if f.aborts then
      errorf r "'also aborts' is meaningless on a primitive operator"
    else if not f.returns then
      errorf r "'never returns' is meaningless on a primitive operator"
    else
      E.Ok f) in
@ 
<<elabstmt.ml>>=
let codelabels ss =
  let rec adds ss labels = List.fold_left add labels ss 
  and add labels s = match s with
  | If     (_, ts, fs) -> adds ts (adds fs labels)
  | Switch (_, _, arms) ->
      List.fold_left (fun labels (_, ss) -> adds ss labels) labels arms
  | Label  l -> l :: labels
  | Cont   _ -> labels
  | Span   (_, ss) -> adds ss labels
  | Assign _ 
  | Call   _
  | Call'  _
  | Goto   _ 
  | Jump   _ 
  | Cut    _ 
  | Return _
  | Limitcheck _ -> labels in
  adds ss []

@ 
\section{[[front_nelab/memalloc.nw]]}
<<front_nelab/memalloc.ml>>=
<<memalloc.ml>>
@

<<front_nelab/memalloc.mli>>=
<<memalloc.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{Automaton-Based Memory Allocation}
%%% ------------------------------------------------------------------ 
%%
%%This module provides an applicative abstraction [[t]] to allocate a
%%memory block incrementally by a sequence of [[allocate]] and [[align]]
%%directives.  The abstraction is similar to a pointer that is advanced
%%and aligned to reserve memory. At any point the value of the  pointer
%%can be used as an address. After allocation is complete, the automaton
%%is [[frozen]] and the allocated block is returned. A [[t]] value should
%%not be used after it was frozen (allthough it is technically possible
%%and safe).
%%N.B. [[size]] is measured in units of [[memsize]].
<<memalloc.mli>>=
type t          (* immutable *)

type growth = Up | Down

val at :            start:Rtl.exp -> growth -> t       (* provide start address *)
val relative :      anchor:Rtl.exp -> dbg:string -> growth -> t (* unknown addr relative to anchor *)
val allocate :      t -> size:int -> t      (* increase block *)
val align :         t -> int -> t           (* align cursor *)
val alignment :     t -> int                (* max alignment ever requested *)
val current :       t -> Rtl.exp            (* obtain cursor *)
val freeze :        t -> Block.t            (* return allocated, aligned block *)
val num_allocated : t -> int
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<memalloc.ml>>=
type growth = Up | Down
type unchanging = 
    { start  : Rtl.exp     (* start address of block *)
    ; growth : growth
    ; exp_at : int -> Rtl.exp  (* exp at distance k from start *)
    } 
type t =
    { u             : unchanging
    ; num_allocated : int         (* size of block      *)
    ; max_alignment : int         (* max alignment ever requested *)
    }

let at ~start g =
  let w = Rtlutil.Width.exp start in
  let addk = Rtlutil.addk w start in
    { u = { start = start
          ; growth = g
          ; exp_at = match g with Up -> addk | Down -> fun k -> addk (-k)
          } 
    ; num_allocated = 0
    ; max_alignment = 1
    }

let relative ~anchor ~dbg g = 
  let w = Rtlutil.Width.exp anchor in
  at (Rtlutil.add w anchor (Rtl.late (Idgen.offset dbg) w)) g

let allocate t ~size = 
    assert (size >= 0);    
    { t with num_allocated = t.num_allocated + size }

let align    t n = (* align both size and base alignment *)
    assert (n > 0);
    { t with max_alignment = max t.max_alignment n (*SHOULD BE LEAST COMMON MULTIPLE*)
           ; num_allocated = Auxfuns.round_up_to t.num_allocated ~multiple_of:n 
    }
let current t = t.u.exp_at t.num_allocated
let alignment t = t.max_alignment

let freeze t = match t.u.growth with
| Up   -> Block.at t.u.start   t.num_allocated t.max_alignment
| Down -> let t = align t t.max_alignment in
          Block.at (current t) t.num_allocated t.max_alignment

let num_allocated t = t.num_allocated
@
\section{[[front_nelab/nast.nw]]}
<<front_nelab/nast.ml>>=
<<nast.ml>>
@

<<front_nelab/nast.mli>>=
<<nast.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
\section{Normalized Abstract-Syntax Tree}
%%
%%This is an AST, except we sort and organize everything.
%%The key types are [[stmt]], [[proc]], and~[[t]].
%%We begin with common abbreviations.
<<exposed types(nast.nw)>>=
type ty  = Ast.ty
type exp = Ast.expr
type loc = Ast.name_or_mem

type 'a marked = Ast.region * 'a

type name = string
type kind = string
type convention = string
type aligned    = int
@
%%Statements.  
<<exposed types(nast.nw)>>=
type cformal  = Ast.region * kind * name * aligned option
type actual   = kind * exp * aligned option
type flow     = Ast.flow list
type alias    = Ast.mem  list
type range    = Ast.range
type procname = string
type label    = string
type stmt =
  | StmtAt of stmt * Ast.region
  | If     of exp * stmt list * stmt list
  | Switch of range option * exp * (range list * stmt list) list
  | Label  of label
  | Cont   of name * convention * cformal list
  | Span   of exp * exp * stmt list
  | Assign of loc list * Ast.guarded list
  | Call   of loc list * convention * exp  * actual list * procname list * flow * alias
  | Prim   of loc list * convention * name * actual list * flow
  | Goto   of exp * label list
  | Jump   of convention * exp * actual list * procname list
  | Cut    of convention * exp * actual list * flow 
  | Return of convention * (exp * exp) option * actual list
  | Limitcheck of convention * exp * (exp * name) option (* (cookie,(failk,recname)) *)
@ 
%%Both compilation units and procedures can contain type and constant definitions.
%%Because these are scoped, we accumulate these definitions in each
%%procedure \emph{and} in the unit as a whole.
%%Therefore they have their own type.
<<exposed types(nast.nw)>>=
type typedefn  = ty * name list
type constdefn = ty option * name * exp
type compile_time_defns = {
  types     : typedefn  marked list;
  constants : constdefn marked list;
}
@ 
%%Here is a normalized form of procedures and of (possibly initialized) data.
%%Initialized data, as well as data in the form of [[SSpan]] and
%%[[Procedure]], are found only at top level.
<<exposed types(nast.nw)>>=
type proc = {
    region        : Ast.region;
    cc            : convention;
    name          : name;
    formals       : (kind * Ast.variance * ty * name * aligned option) marked list;
    locals        : Ast.register marked list;
    pdecls        : compile_time_defns;
    continuations : (name * convention * cformal list) marked list;
    labels        : name marked list;  (* code labels *)
    stackdata     : datum marked list;
    code          : stmt list;
  }
and  datum =
  | Datalabel  of name
  | Align      of int
  | ReserveMem of ty * Ast.memsize * Ast.init option (*init always none on stackdata*)
  | Procedure  of proc                               (* never on stackdata *)
  | SSpan      of exp * exp * datum marked list      (* never on stackdata *)
@ 
%%And last, the normal form of a compilation unit.
<<exposed types(nast.nw)>>=
type section = name * datum marked list
type t = {
  target   : Ast.arch marked list;
  imports  : (Ast.region * Ast.ty option * Ast.import list) list;
  exports  : (Ast.region * Ast.ty option * Ast.export list) list;
  globals  : Ast.register marked list;
  code_labels : name marked list list;
  udecls   : compile_time_defns;
  sections : section list
}
@ 
<<nast.mli>>=
<<exposed types(nast.nw)>>
val program : Ast.toplevel list -> t
@ 
\section{Implementation}
%%
%%One abbreviation, types, and a very important constant.
<<nast.ml>>=
module A = Ast
<<exposed types(nast.nw)>>
let default_proc_section = "text"
@ 
%%First, some simple utility functions.
<<nast.ml>>=
let id ss = ss
let null = function [] -> true | _ :: _ -> false

let rflatten xs =
  let add (r, xs) tail = List.fold_right (fun a t -> (r, a) :: t) xs tail in
  List.fold_right add xs []



let cformal (r, kind, name, aligned) = (r, Auxfuns.Option.get "" kind, name, aligned)
let formal (r, (kind, variance, ty, name, aligned)) =
  (r, (Auxfuns.Option.get "" kind, variance, ty, name, aligned))
let actual (kind, name, aligned) = (Auxfuns.Option.get "" kind, name, aligned)
let convention = Auxfuns.Option.get "C--"
@ 
%%Conversion of [[datum]].
%%The name [[fdata]] is short for ``fold data.''
<<nast.ml>>=
let rec add_datum r d ds = match d with
  | A.DatumAt (d, r) -> add_datum r d ds
  | A.Label l -> (r, Datalabel l) :: ds
  | A.Align n -> (r, Align n) :: ds
  | A.MemDecl (t, s, init) -> (r, ReserveMem (t, s, init)) :: ds

let fdata r = List.fold_right (add_datum r) 
@ 
%%The main idea in this module is CPS.
%%We have a boatload of accumulating parameters, and eventually we get a
%%program. 
%%The parameters are:
%%\begin{quote}
%%\begin{tabular}{ll}
%%[[imps]]& Imports\\
%%[[exports]]& Exports\\
%%[[lbls]]& Code labels\\
%%[[ks]]& Continuations\\
%%[[consts]]& Constant definitions\\
%%[[types]]& Type definitions\\
%%[[archs]]& Target-specific declarations\\
%%[[data]]& Initialized data or stack data\\
%%\end{tabular}
%%\end{quote}
%%Most of these accumulating parameters accumulate declarations.
%%They are gathered in a record to ensure the OCaml compiler will
%%compile calls to [[decl]] as tail calls.
%%This bug has happened -- this is not premature optimization.
<<nast.ml>>=
type ('a) accumulation_disaster =
  { imps : (A.region * A.ty option * A.import list) list
  ; exps : (A.region * A.ty option * A.export list) list
  ; lbls : 'a
  ; ks : (Ast.region * (A.name * convention * (A.region * A.hint * A.name * aligned option) list)) list
  ; consts : (A.region * (A.ty option * A.name * A.expr)) list
  ; tys : (A.region * (A.ty * A.name list)) list
  ; regs : (A.region * A.register list) list
  ; archs : (A.region * A.arch list) list
  ; data : ((A.region * datum) list) 
  }

let rec decl r accums d k = match d with
  | A.DeclAt(x,r)   -> decl r accums x k
  | A.Typedef d     -> k {accums with tys = ((r,d) :: accums.tys)}
  | A.Import (t,ii) -> k {accums with imps = ((r,t,ii)::accums.imps)}
  | A.Export (t,ee) -> k {accums with exps = ((r,t,ee)::accums.exps)}
  | A.Const d       -> k {accums with consts = ((r,d) :: accums.consts)}
  | A.Registers rs  -> k {accums with regs = ((r, rs) :: accums.regs)}
  | A.Target    t   -> k {accums with archs = ((r, t) :: accums.archs)}
  | A.Pragma        -> k accums
@ 
%%This is a generic lifting function.
%%Function [[kmap f]] turns function [[f]] from a function on~[['a]] to
%%a function on \mbox{[['a list]]}.
%%The function has to supply a value to its continuation;
%%if it doesn't, use [[kmap_none]].
<<nast.ml>>=
let rec kmap f cons r accums xs k = match xs with
  | []      -> k [] accums
  | x :: xs ->
     kmap f cons r accums xs
          (fun xs accums -> f r accums x (fun x accums -> k (cons x xs) accums))

let kmap_none f r accums xs k =
  let xk f r accums x k = f r accums x (k []) in
  kmap (xk f) (fun _ _ -> []) r accums xs (fun _ -> k)
@ 
%%And now, processing a body item, which is liftable with [[kmap]].
%%The continuation~[[k]] expects an optional statement, which is represented
%%as a value of type [[stmt list -> stmt list]].
%%If there can be no statement, [[k]]'s first argument is~[[id]].
<<nast.ml>>=
let rec body r accums b k = match b with
| A.BodyAt(b,r) -> body r accums b k
| A.DeclBody d  -> decl r accums d (k id)
| A.StmtBody s  -> (
  <<match [[stmt]] [[s]] at [[r]] and continue with [[k]]>>
 )
| A.DataBody ds -> k id {accums with data = (fdata r ds accums.data)}
and bodies r = kmap body (fun add ss -> add ss) r
@ 
%%Here are statements.
%%Because an [[Ast.stmt]] may be a declaration instead of a
%%``real'' statement, this function may or may not supply an actual statement.
%%Function [[cons]] is for the case where we do supply a statement;
%%[[id]]~is used where there is no statement.
%%Function [[atomic]] helps with the common case in which a statement
%%has no substatements, and therefore no declarations.
%%The CPS for the other cases is less scary than it looks---if you
%%understand [[If]], you understand it all.
<<match [[stmt]] [[s]] at [[r]] and continue with [[k]]>>=
let rec stmt r s k = 
  let cons s ss = StmtAt (s, r) :: ss in
  let atomic s = k (cons s) accums in
  match s with
  | A.StmtAt(s,r) -> stmt r s k
  | A.IfStmt (c,b1,b2)   ->
    bodies r accums b2
      (fun ss2 accums ->
         bodies r accums b1 (fun ss1 accums -> k (cons(If(c,ss1,ss2))) accums))
  | A.SwitchStmt (range,e,aa) ->
      arms r accums aa
        (fun aa accums ->
          let stmt = cons (Switch (range, e, aa)) in
          k stmt accums)
  | A.LabelStmt l ->
      k (cons (Label l)) {accums with lbls = ((r, l) :: accums.lbls)}
  | A.ContStmt (n, formals) ->
      let formals = List.map cformal formals in
      let cc      = convention None in
      let stmt    = cons (Cont (n, cc, formals)) in
      k stmt {accums with ks = ((r, (n,cc,formals)) :: accums.ks)}
  | A.SpanStmt(key,v,bs)   -> 
      bodies r accums bs (fun ss accums -> k (cons (Span (key,v,ss))) accums)
  | A.AssignStmt (ls, rs) ->
      atomic (Assign (ls, rs))
  | A.CallStmt (ls, cc, p, a's, tgts, flows) ->
      let add a (flows, mems) = match a with
      | A.Flow f -> (f :: flows, mems)
      | A.Alias m -> (flows, m :: mems) in
      let flows, mems = List.fold_right add flows ([], []) in
      atomic (Call (ls, convention cc, p, List.map actual a's, tgts, flows, mems))
  | A.PrimStmt (ls, cc, p, a's, flows) ->
      atomic (Prim (ls, convention cc, p, List.map actual a's, flows))
  | A.GotoStmt (e, tgts) ->
      atomic (Goto (e, tgts))
  | A.JumpStmt (cc, p, a's, tgts) ->
      atomic (Jump (convention cc, p, List.map actual a's, tgts))
  | A.CutStmt (e, a's, flows) ->
      atomic (Cut (convention None, e, List.map actual a's, flows))
  | A.ReturnStmt (cc, alt, a's) ->
      atomic (Return (convention cc, alt, List.map actual a's))
  | A.EmptyStmt
  | A.CommentStmt _   -> k id accums
  | A.LimitcheckStmt (cookie, cont) -> 
      let cc   = convention None in
      match cont with
      | None -> atomic (Limitcheck (cc, cookie, None))
      | Some cont ->
          (* construct continuation for recovery *)
          let formals = [] in
          let name = Idgen.label "overflow-recovery continuation" in
          let stmt = cons (Limitcheck (cc, cookie, Some (cont, name))) in
          k stmt {accums with ks = ((r, (name,cc,formals)) :: accums.ks)} in
stmt r s k
@ 
%%PERHAPS IT SHOULD BE POSSIBLE TO SET THE CALLING CONVENTION FOR CUT TO
%%AND FOR CONTINUATION?
%%
%%Arm of a case statement.  Nothing interesting here.
<<nast.ml>>=
and arm r accums a k = match a with
| A.ArmAt (a,r) -> arm r accums a k
| A.Case (ranges,bs) -> 
    bodies r accums bs (fun stmts accums -> k ((ranges, stmts)) accums)
and arms r = kmap arm (fun x y -> x::y) r
@
%%A section simply accumulates data, so its continuation doesn't take an
%%additional argument before [[imps]].
%%In other words, [[section]] is like [[decl]] and not like [[body]] or
%%[[stmt]]. 
<<nast.ml>>=
let rec section r accums s k = match s with
| A.SectionAt (s,r) ->
    section r accums s k
| A.Decl d ->
    decl r accums d k
| A.SSpan(key, v, ss) ->
    sections r {accums with data = []} ss
      (fun saccums ->
        let data' = (r, SSpan(key,v, saccums.data)) :: accums.data in
        k {saccums with data = data'})
| A.Datum d ->
    k {accums with data = (add_datum r d accums.data)}
| A.Procedure(cc,p,fs,bs,r) ->
    bodies r { imps = accums.imps ; exps = accums.exps
             ; lbls = [] ; ks = [] ; consts = [] ; tys = []
             ; regs  = [] ; archs = accums.archs ; data = [] }
           bs
     (fun ss paccums ->
       let cdecls = { constants = paccums.consts; types = paccums.tys } in
       let p = { cc = convention cc; name = p; formals = List.map formal fs; code = ss;
                 continuations = paccums.ks; labels = paccums.lbls; region = r;
                 locals = rflatten paccums.regs; pdecls = cdecls;
                 stackdata = paccums.data; } in
      k {accums with imps  = paccums.imps;
                     exps  = paccums.exps;
                     lbls  = paccums.lbls :: accums.lbls;
                     archs = paccums.archs;
                     data  = (r,Procedure p)::accums.data})
and sections r = kmap_none section r
@ 
%%At top level, we accumulate sections, where a section is a named list of data.
%%Again, we could have a declaration at top level, so we use [[cons]]
%%and [[id]] as before.  
<<nast.ml>>=
let rec toplevel r accums t k =
  let cons s ss = (s, r) :: ss in
  match t with
  | A.ToplevelAt(t,r) ->
      toplevel r accums t k
  | A.Section(name, ss) ->
      sections r {accums with data = []} ss
        (fun saccums -> k (cons (name, saccums.data))
                          {saccums with data = accums.data})
  | A.TopDecl d ->
      decl r accums d (k id)
  | A.TopProcedure p ->
      let t = A.Section(default_proc_section, [A.Procedure p]) in
      toplevel r accums t k

let program ts =
  let checknull what l =
    if not (null l) then Impossible.impossible ("some toplevel " ^ what) in
  kmap toplevel (fun add t -> add t)
       Srcmap.null
       { imps = [] ; exps = [] ; lbls = [] ; ks = [] ; consts = []
       ; tys = [] ; regs = [] ; archs = [] ; data = [] }
       ts
    (fun ss saccums ->
      let _ = checknull "data" saccums.data in
      let _ = checknull "continuations" saccums.ks in
      { target = rflatten saccums.archs
      ; imports = saccums.imps; exports = saccums.exps
      ; code_labels = saccums.lbls
      ; globals = rflatten saccums.regs
      ; sections = List.map fst ss
      ; udecls = { types = saccums.tys; constants = saccums.consts }
      })
@ 
\section{[[front_nelab/nelab.nw]]}
<<front_nelab/nelab.ml>>=
<<nelab.ml>>
@

<<front_nelab/nelab.mli>>=
<<nelab.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% Table of Contents
%%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%
%%This is more my idea of an elaborated representation.
<<exposed types(nelab.nw)>>=
type name    = string
type kind    = string
type aligned = int
@ 
%%Procedures and sections in nice normal form.
%%It's depressing that formals and locals don't have the same type.
<<exposed types(nelab.nw)>>=
type index = int
type linktime = Reloc.t
type 'a proc =
  { env     : 'a Fenv.Dirty.env';
    sym     : Symbol.t;  (* assembly-language symbol for this procedure *)
    cc      : string;    (* calling convention *)
    name    : name;
    spans   : (Bits.bits * linktime) list;  (* enclose whole procedure *)
    formals : (index * kind * Ast.variance * Rtl.width * name * aligned) list;
    locals  : Fenv.variable list;
    continuations : (name * Fenv.continuation) list;
    stackmem      : Block.t;
    stacklabels   : Rtl.exp list;
    code          : Elabstmt.stmt list;
    basic_block   : bool;  (* procedure represents a basic block from source *)
  } 

type 'a datum =
  | Datalabel         of Symbol.t (* must be asm level not source level *)
  | Align             of int
  | InitializedData   of (linktime * Rtl.width) list
  | UninitializedData of int  (* counts the number of mems *)
  | Procedure         of 'a proc

type 'a section = name * 'a datum list
@ 
%%And last, a compilation unit.
<<exposed types(nelab.nw)>>=
type 'a compunit = {
  globals : (name * Fenv.variable) list;
  sections : 'a section list;
}
@ 
<<nelab.mli>>=
<<exposed types(nelab.nw)>>
val program : swap:bool -> validator -> Srcmap.map -> 'a Asm.assembler -> Nast.t ->
  ('a Fenv.Dirty.env' * 'a compunit) Error.error
@ 
<<exposed types(nelab.nw)>>=
type validator = Rtl.rtl -> string option
@ 
%%To make it possible to rewrite abstract syntax without paying an
%%incredible burden in terms of tying recursive knots in types, we
%%export this horrible [[rewrite]] function, 
%%which is another name for [[Obj.magic]].
%%Only a function that is actually polymorphic should be passed in.
<<nelab.mli>>=
val rewrite : (Auxfuns.void compunit -> Auxfuns.void compunit) -> ('a compunit -> 'a compunit)
@ 
%%% ------------------------------------------------------------------ 
\section{Checking Static Semantics}
%%% ------------------------------------------------------------------ 
%%
%%To check the static semantics of a {\PAL} program the meaning of all
%%names used by it must be determined and their correct usage verified. 
%%The visibility of names in {\PAL} is controlled by name spaces and
%%scopes.  There are four name spaces:
%%\begin{enumerate}
%%\item Values (Procedures, Constants, Registers, Imports, \dots).
%%\item Types (names defined by [[typedef]]).
%%\item Primitive compile-time operators ([[%add]], \dots).
%%\item Primitive run-time operators; this a super set of the compile-time
%%      operators.
%%\end{enumerate}
%%
%%Since operators are predefined they are visible everywhere and have no
%%further scoping rules.  On the other hand, names for values and types
%%are scoped:
%%\begin{enumerate}
%%\item The scope of the compilation unit is called \textit{global}. It
%%      includes the top-level and all sections. Labels at the statement
%%      level of procedures have additionally global scope.
%%%      
%%\item The scope of a procedure is called \textit{local}.  Values and types
%%      declared inside a procedure have local scope.  Entries in the
%%      local scope shadow entries in the global scope.
%%\end{enumerate} 
%%
%%A name is visible inside its whole scope, even before its declaration.
%%Type declarations can refer to each other; compile-time computes
%%(constant) value declarations can refer to type declarations and each
%%other.  All run-time computed named values can only refer to type
%%declarations.  Before the static semantics of a scope can be checked
%%all names are resolved in a multi-step approach:
%%\begin{enumerate}
%%\item
%%Compute target metrics and create an empty fat environment
%%\item
%%Sort, evaluate, and bind type definitions
%%\item
%%Sort, evaluate, and bind constant definitions
%%\item
%%Bind each of the following declarations into the fat environment:
%%\begin{enumerate}
%%\item
%%Imported names
%%\item
%%Code labels
%%\item
%%Data labels, whether initialized data or stack data
%%\item
%%Procedures
%%\item
%%Continuations
%%\item
%%Register variables, including formal parameters
%%\end{enumerate}
%%\item
%%Check export declarations
%%\item
%%Elaborate expressions and assignments into RTL expressions and RTLs.
%%\item
%%Check other properties
%%\end{enumerate}
%%
%%% ------------------------------------------------------------------ 
\subsection{Assembler Symbols}
%%% ------------------------------------------------------------------ 
%%
%%Many names in a {\PAL} program correspond to assembler \emph{symbols}
%%after translation. For each name that corresponds later to a symbol the
%%denotation of that name includes its assembler symbol. Hence, this
%%module reserves assembler symbols for these names and enters them into
%%the fat environment.
%%
%%    
%%% ------------------------------------------------------------------ 
\subsection{Implementation -- The 30\,000 feet overview}
%%% ------------------------------------------------------------------ 
%%
<<nelab.ml>>=
open Nopoly

<<exposed types(nelab.nw)>>
module A  = Ast
module B  = Bits
module E  = Error
module F  = Fenv.Dirty
module FE = Fenv
module N  = Nast
module R  = Rtl
module RP = Rtl.Private
module Dn = Rtl.Dn
module Up = Rtl.Up
module T  = Types

let impossf fmt = Printf.kprintf Impossible.impossible fmt
@ 
%%
<<nelab.ml>>=
<<auxiliaries(nelab.nw)>>
@ 
%%The key to understand the implementation is the fat environment
%%[[Fenv.Dirty]]; it defines a symbol table that holds the type, value, and
%%target environment.  Names are chosen similar to the non-terminals
%%used in the grammar.
%%
%%An outlined in the introduction, an environment must be built up before
%%the static semantics can be checked. 
%%
%%Because type and constant declarations can refer to each other they
%%can not be simply processed in source code order.  They are collected,
%%then sorted, and finally processed.  The sort function is provided by
%%the [[Topsort.Make]] functor, which is parameterized over the
%%declarations being sorted.  In the case of type declarations, for
%%example, module [[Typedef.Decl]] provides the necessary informations
%%about type declarations. 
%% 
%%% ------------------------------------------------------------------ 
\subsection{Auxiliaries}
%%% ------------------------------------------------------------------ 
%%
%%Fold is the most frequently used higher order function in this module. 
%%We therefore like a short name.  Unlike its cousin
%%[[List.fold_right]], [[foldl]] is tail-recursive.
<<auxiliaries(nelab.nw)>>=
let foldl: ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a = List.fold_left 
@
%%To remove offending declarations from a list we use [[--]]: 
%%[[xx -- yy]] returns those elements of [[xx]] not also [[yy]]. 
%%Since we expect [[yy]] to be very short (1 to 3 elements) we have
%%chosen a naive approach for implementation.  Efficiency is also less
%%of a concern because we are dealing with a program that has errors and
%%thus nobody expects us to be fast.
<<auxiliaries(nelab.nw)>>=
let (--) xx yy = List.filter (fun x  -> List.mem x yy) xx 
@
%%For error reports we need a source-code map to resolve character
%%positions into meaningful file, line, column triples.  The source map
%%can be obtained from the fat environment.  Here is a suitable error
%%reporting function for [[E.catch]]:
<<auxiliaries(nelab.nw)>>=
let error r env msg = E.errorRegionPrt (F.srcmap env,r) msg 
@
%%Alignments must be a power of two.  This predicates is true, iff its
%%argument is a positive power of two.
<<auxiliaries(nelab.nw)>>=
let is2power x = x > 0 && x land (x - 1) = 0
@
%%% ------------------------------------------------------------------ 
\subsection{Sorting and binding type and constant declarations}
%%% ------------------------------------------------------------------ 
%%
%%
%%Here's the code to generically bind definitions that have to be
%%sorted.
%%Type~[[d]] is the declaration, which we have to be able to sort,
%%evaluate, and bind.
<<nelab.ml>>=
module type SB = sig
  type d
  module Decl : Topsort.Sortable with type decl = d N.marked
  val what : string
  type rhs
  val eval : 'a F.env' -> Decl.decl -> rhs E.error
  val bind : string -> rhs E.error N.marked -> 'a F.env' -> 'a F.env'
end
@ 
%%When a cycle is found in the list [[ds]] of declarations it is
%%removed and we sort and bind the remaining declarations.
%%Time is no object
%%because we have an illegal {\PAL} program.  When no cycle exists,
%%declarations are processed in topological order by [[bind_one]],
%%which enters them into [[env]].
<<nelab.ml>>=
module SortAndBind (D : SB) = struct
  module Sort = Topsort.Make (D.Decl)
  let bind_sortable_definitions env ds =
    <<definitions of sort-binding functions>>
    let rec bind env ds =
      try
        foldl bind_one env (Sort.sort ds)
      with Sort.Cycle offending ->
        let ds    = ds -- offending         in
        let env   = bind_to_error env offending in
        ( report_cycle env offending ; bind env ds ) in
    bind env ds
end
@
%%Because in general a definition binds multiple names, we bind them all.
<<definitions of sort-binding functions>>=
let bind_each_name rhs env ((r, _) as d) =
  foldl (fun env n -> D.bind n (r, rhs) env) env (D.Decl.defines d) in 
let bind_to_error env decls = 
  foldl (bind_each_name E.Error) (F.flagError env) decls in
@
<<definitions of sort-binding functions>>=
let rec bind_one env d =
  match D.eval env d with
  | E.Error       -> bind_each_name E.Error (F.flagError env) d
  | E.Ok _ as rhs -> bind_each_name rhs env d in
@
%%When cycles are found in the list of declarations they are reported.
%%Their source code positions were attached to them during their
%%collection. 
<<definitions of sort-binding functions>>=
let report_cycle env ds = 
  let report d =
    error (fst d) env
      (D.what ^ " definition for "^(List.hd (D.Decl.defines d))^" is cyclic") in
  List.iter report ds in
@
%%\subsubsection{Types}
%%Here's how we sort and bind type definitions.
<<nelab.ml>>=
module Type = struct
  type d = N.typedefn
  module Decl = struct
    type decl = N.typedefn N.marked
    let defines (_, (_,names)) = names
    let uses    (_, (t,_    )) =
      let rec u = function 
        | A.BitsTy _    -> []
        | A.TypeSynonym x   -> [x]
        | A.TyAt (t, _) -> u t in
      u t
  end
  let what = "type"
  type rhs = Types.ty
  let eval env (_, (t, _)) = E.ematch (Elabexp.elab_ty env t) (fun w -> Types.Bits w)
  let bind = F.bindt
end
module TypeSortBind = SortAndBind(Type)
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Constants}
%%% ------------------------------------------------------------------ 
%%
%%        EVENTUALLY, SUPPORT FOR CONSTANT EXPRESSIONS SHOULD MOVE INTO
%%        THE [[Elabexp]] MODULE.
%%
%%
%%A constant declaration must declare a value of type [[bits]]; although
%%it is syntactically and type-wise possible to declare a boolean value
%%this is not permitted. The optionally provided type must match the
%%actual type of the defining expression.
<<nelab.ml>>=
module Const = struct
  type d = N.constdefn
  <<utility functions for constants>>
  module Decl = struct
    type decl = d N.marked
    let defines (_, (t,name,expr)) = [name]
    let uses    (_, (t,name,expr)) = freeExprVars expr []
  end
  let what = "constant"
  type rhs = Bits.bits * Types.ty
  let eval env (r, (ty, name, e)) =
    let errorf x =
      Printf.kprintf (fun s -> E.errorRegionPrt (F.srcmap env, r) s; E.Error) x in
    E.seq (Elabexp.elab_con env e) (fun (b, w) ->
      match ty with
      | None -> E.Ok (b, Types.Bits w)
      | Some ty ->
          E.seq (Elabexp.elab_ty env ty) (fun w' ->
            if w = w' then E.Ok (b, Types.Bits w)
            else errorf "constant %s declared with type bits%d has actual type bits%d"
                           name w' w))
  let bind name (r, typed_exp) env = 
    F.bindv name (r, E.ematch typed_exp (fun (b, t) -> FE.Constant b, t)) env
end
module ConstSortBind = SortAndBind(Const)
@ 
%%A constant expression can refer to other constant and link-time
%%constants.  To find the right topological order it is only important
%%to find other constants.  Of course, these can not be syntactically
%%distinguished and so we will collect all free variables of an
%%expression.  This leads to used names that are not constants and that
%%appear to be undefined from the perspective of the topological
%%[[sort]] function.  But [[sort]] assumes that these undeclared names
%%do not depend on any constant---which is correct. 
%%
%%The [[freeExprVars]] function returns all names referenced in an
%%expression. A constant expression depends on all of them.
<<utility functions for constants>>=
let rec freeExprVars e tail = match e with
| A.ExprAt(x,_)     -> freeExprVars x tail
| A.Fetch(lvalue)   -> freeLValueVars lvalue tail
| A.BinOp(e1,_,e2)  -> freeExprVars e1 (freeExprVars e2 tail)
| A.UnOp(_,e)       -> freeExprVars e tail
| A.PrimOp(_,args)  -> foldl (fun t (_,e,_) -> freeExprVars e t) tail args
| A.Sint _ 
| A.Uint _           
| A.Float _         
| A.Char _          -> tail
@ 
<<utility functions for constants>>=
and freeLValueVars l tail = match l with
| A.NameOrMemAt(x,r) -> freeLValueVars x tail
| A.Mem(_,e,_, _)    -> freeExprVars e tail
| A.Name(_,name,_)   -> if List.mem name tail then tail else name :: tail
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Building the environment}
%%% ------------------------------------------------------------------ 
%%
%%We assume here the elaboration of expressions and lvalues.
%%Because of mutual recursion, we have to make two passes over procedures
%%
%%In addition to being bound and checked,
%%imports and exports have two effects
%%
<<nelab.ml>>=
type scope = Local | Global
(* pad: copy paste of Vfp.mk but brought too many dependencies *)
let vfp_mk w =
  Rtl.fetch (Rtl.reg (('V', Rtl.Identity, Cell.of_size w), 0, Rtl.C 1)) w

let program ~swap validate srcmap asm ast =
  E.seq (Metrics.of_ast ~swap srcmap ast.N.target) (fun metrics ->
    let flag        = function E.Error -> F.flagError | E.Ok _ -> (fun env -> env) in
    let eprint r s  = E.errorRegionPrt (srcmap, r) s in
    let errorf r    = Printf.kprintf (fun s -> eprint r s; E.Error) in
    let findve r n  = E.catch (eprint r) (fun env -> snd (F.findv n env)) in
    let pointerty   = Types.Bits metrics.Metrics.pointersize in
    let vfp         = 
      (* pad: was Vfp.mk but brought too many dependencies *)
      vfp_mk metrics.Metrics.wordsize
   in
    let memsize     = metrics.Metrics.memsize in
    let aligned     = Elabexp.aligned metrics in
    let aligned r w = E.catch (eprint r) (fun a -> E.Ok (aligned w a)) in
    <<definitions of name-binding functions>>
    <<definitions of elaboration functions(nelab.nw)>>
    (* phase one: create environment and bind all names *)
    let env = F.empty srcmap metrics asm in
    let env = F.push env (F.emptyscope) in  (* weird, but so it is *)
    let env = TypeSortBind. bind_sortable_definitions env ast.N.udecls.N.types in
    let env = ConstSortBind.bind_sortable_definitions env ast.N.udecls.N.constants in
    let env = foldl bind_and_remember_import env ast.N.imports in
    let env = foldl remember_export          env ast.N.exports in
    let env, globals = registers_from Global 0 ast.N.globals env in
    let env = foldl (foldl bind_code_label) env ast.N.code_labels in
    let env = foldl bind_section_names env ast.N.sections in
    (* phase two: in environment, elaborate and check the world (only flags env) *)
    let env = foldl check_export env ast.N.exports in
    let ss  = E.Raise.list (List.map (section env) ast.N.sections) in
    let env = flag ss env in
    E.ematch2 globals ss (fun globals ss ->
      (env, { globals = globals; sections = ss })))
@
%%In a procedure, labels have global scope, but they are bound a
%%second time in the local environment. This has the following advantages:
%%\begin{itemize}
%%\item The second binding clashes with any other local binding that
%%      might shadow the global binding.
%%
%%\item A [[goto]] must have a local target. Now is is possible to test
%%      for this by looking up the name of the target and using the
%%      predicate [[F.is_localv]].
%%\end{itemize}
<<definitions of procedure-processing functions>>=
let proc env spans p =
  let env = F.push env F.emptyscope in
  let env = TypeSortBind. bind_sortable_definitions env p.N.pdecls.N.types in
  let env = ConstSortBind.bind_sortable_definitions env p.N.pdecls.N.constants in
  let env, n, formals = formals_from 0 p.N.formals env in
  let env, locals = registers_from Local n p.N.locals env in
  let env = foldl bind_code_label env p.N.labels in  (* odd -- explained above *)
  let env, conts = bind_and_return_continuations env p.N.continuations in
  let stackmem, stacklabels, env = stackdata env p.N.stackdata in
  let code = Elabstmt.elab_stmts validate srcmap p.N.region env p.N.code in
  let _, den  = F.findv p.N.name env in (* lookup cannot fail *)
  E.ematch4 code locals (E.Raise.list spans) den (fun code locals spans den ->
    let sym = match den with
    | FE.Label (FE.Proc sym), _ -> sym
    | _ -> impossf "procedure %s is not a procedure?!" p.N.name in
    Procedure
      { env = env; cc = p.N.cc; name = p.N.name; sym = sym; formals = formals;
        locals = List.map snd locals; continuations = conts; spans = spans;
        stackmem = stackmem; stacklabels = stacklabels; code = code;
        basic_block = false; }) in
@ 
%%A continuation knows its address (in the form of an empty, unaligned
%%block).
%%It also maintains some mutable data, filled in by [[Elabexp]] and
%%[[Elabstmt]], that tells if the continuation is used in an expression
%%or an annotation.
<<definitions of name-binding functions>>=
let bind_and_return_continuations env conts =
  let rec bind prev' env = function
    | [] -> env, List.rev prev'
    | (r, (name, cc, formals)) :: ks ->
        match (Elabstmt.elab_cformals r env formals) with
        | E.Error -> bind prev' (F.bindv name (r, E.Error) env) ks
        | E.Ok formals ->
            let addrblock =
              Block.relative vfp ("continuation " ^ name)
              Block.at ~size:0 ~alignment:1 in
            let k = { FE.cut_to = false; FE.unwound_to = false; FE.returned_to = [];
                      FE.base = addrblock; FE.escapes = false; FE.convention = cc;
                      FE.formals = formals; } in
            let env = F.bindv name (r, E.Ok (FE.Continuation k, pointerty)) env in
            bind ((name, k) :: prev') env ks in
  bind [] env conts in
@ 
%%
%%\subsubsection{Easy stuff}
%%
%%\paragraph{Imports}
%%Imports have to be the native pointer size.
%%Code [[F.import]] remembers the [[import as]] relationship.
<<definitions of name-binding functions>>=
let bind_and_remember_import env (r, ty, imports) = 
  let import env (foreign,name) =
    let env = F.import r (Auxfuns.Option.get name foreign) name env in
    let sym = F.symbol env name in
    let den = FE.Import (Auxfuns.Option.get name foreign, sym) in
    let ty  = 
     <<convert optional importing [[ty]] as long as it is pointer size>>
    in
    F.bindv name (r, E.Raise.right (den, ty)) env in
  foldl import env imports in
@ 
%%
<<convert optional importing [[ty]] as long as it is pointer size>>=
match ty with None -> E.Ok pointerty
| Some t -> E.seq (Elabexp.elab_ty env t) (fun w ->
    if w =*= metrics.Metrics.pointersize then E.Ok pointerty
    else errorf r "imported type bits%d is inconsistent with native pointer type %s"
        w (Types.to_string pointerty))
@ 
%%\paragraph{Labels}
%%No checking for labels.  Just create the assembly-language symbol and
%%give it the native pointer type.
<<definitions of name-binding functions>>=
let bind_code_label env (r, n) = 
  F.bindv n (r, E.Ok (FE.Label(FE.Code (F.symbol env n)), pointerty)) env in
@ 
%%\subsubsection{Register variables and formal parameters}
<<to migrate to variable placer>>=
let global_base_sym = F.symbol env "Cmm.global_area" in
let global_sigbuf   = Buffer.create 128 in
let global_loc env = 
  let global_automaton = target.T.globals (Rtl.link global_base_sym pointersize) in
  fun kind ty name ->
    let kinded h =
      let w = tywidth ty in
      Printf.bprintf global_sigbuf "[%s %d]" name w
      AT.allocate t w h in
    let hardware r = 
      try
        Printf.bprintf global_sigbuf "[%s %s]" name r;
        E.Ok (AT.of_loc (Strutil.Map.find t target.T.named_locs))
      with Not_found ->
        errorf "unknown hardware register %S" r in
    function FE.Rnone   -> kinded ""
           | FE.RKind h -> kinded h
           | FE.RReg r  -> hardware r in
with Error.ErrorExn msg -> impossible msg
    in
        ( List.iter (assign env) names 
        ; AT.freeze t, Digest.string (Buffer.contents decls)    
        )
@ 
%%
<<definitions of name-binding functions>>=
let registers_from scope n rs env =
  let rec regs_from prev' n rs env = match rs with
  | [] ->
      let regs = E.ematch (E.Raise.list (List.rev prev')) (fun rs ->
        let unreg = function (n,(FE.Variable r,_)) -> (n,r)
          | _ -> impossf "nonregister" in
        List.map unreg rs) in
      env, regs
  | (rgn, (v, kind, t, name, hwreg)) :: rs ->
      let entry = E.seq (Elabexp.elab_ty env t) (fun w ->
        let loc   = (match scope with Global -> R.global | Local -> R.var) name n w in
        let reg h = { FE.index = n; FE.rkind = h; FE.loc = loc; FE.variance = v } in
        let den h = E.Ok (FE.Variable (reg h)) in
        let den = match kind, hwreg with
        | Some _, Some _ -> errorf rgn "can't have kind and hardware register"
        | Some h, None ->
            (match scope with Global -> den (FE.RKind h)
            | Local -> errorf rgn
                  "kinds permissible only on formal parameters or global variables") 
        | None,   None   -> den FE.RNone
        | None,   Some r ->
            (match scope with
            | Local  -> errorf rgn "local register can't be mapped to hardware"
            | Global -> den (FE.RReg r)) in
        E.Raise.left (den, Types.Bits w)) in
      let named = E.Raise.right (name, entry) in
      regs_from (named::prev') (n+1) rs (F.bindv name (rgn, entry) env) in
  regs_from [] n rs env in
@ 
%%
<<definitions of name-binding functions>>=
let formals_from n rs env =
  let rec formals prev' n rs env = match rs with
  | [] -> env, n, List.rev prev'
  | (r, (kind, inv, ty, name, a)) :: rs ->
      let error () = formals prev' n rs (F.bindv name (r, E.Error) env) in
      match Elabexp.elab_ty env ty with
      | E.Error -> error()
      | E.Ok w ->
          match aligned r w a with
          | E.Error -> error()
          | E.Ok a ->
              let i = { FE.index = n; FE.variance = inv;
                        FE.loc = Rtl.var name n w; FE.rkind = FE.RKind kind; } in
              let env = F.bindv name (r, E.Ok (FE.Variable i, Types.Bits w)) env in
              formals ((n, kind, inv, w, name, a)::prev') (n+1) rs env in
  formals [] n rs env in
@ 
<<definitions of name-binding functions>>=
let bind_section_names env (secname, ds) = 
  <<definitions of name-binding functions for data>>
  foldl datum env ds in
@ 
<<definitions of elaboration functions(nelab.nw)>>=
let section env (secname, ds) =
  <<definitions of procedure-processing functions>>
  <<definitions of elaboration functions for data>>
  E.Raise.right (secname, E.Raise.list (data [] ds [])) in
@ 
\subsection{Translation of \texttt{stackdata} declarations, accumulating labels}
%%
%%We process [[stackdata]] declarations to accumulate three results:
%%\begin{quote}
%%\begin{tabular}{ll}
%%[[mem]]& Memory layout for stack data\\
%%[[stacklabels']]& [[stackdata]] labels, reversed\\
%%[[env]]& Environment with bindings for stack labels\\
%%\end{tabular}
%%\end{quote}
%% 
%%The traversal is straightforward and needs little documentation.
<<definitions of name-binding functions>>=
let stackdata env =
  <<definitions of stack-data functions>>
  in
  stackdata (Memalloc.relative vfp "stackdata" Memalloc.Up) [] env in
@ 
<<definitions of stack-data functions>>=
let rec stackdata mem stacklabels' env ds = match ds with
| [] -> Memalloc.freeze mem, List.rev stacklabels', env
| d :: ds ->
    stackdatum mem stacklabels' env d
      (fun mem stacklabels' env -> stackdata mem stacklabels' env ds) 
@ 
%%Any error flags the environment and continues.
%%We don't really care if [[mem]] or [[stacklabels']] becomes bad in that case.
%%
%%A [[stackdatum]] declaration must respect some constraints:  (1)~no
%%initialized data, (2)~no [[[]]] used as a size, (3)~an
%%alignment must be a power of two. 
<<definitions of stack-data functions>>=
and stackdatum mem stacklabels' env (r, d) k =
  let errorf fmt = Printf.kprintf
      (fun s -> eprint r s; k mem stacklabels' (F.flagError env)) fmt in
  match d with
  | N.Datalabel l ->
      let loc = Memalloc.current mem in
      let env = F.bindv l (r, E.Ok (FE.Label (FE.Stack loc), pointerty)) env in
      k mem (loc :: stacklabels') env
  | N.Align n when is2power n ->
      k (Memalloc.align mem n) stacklabels' env
  | N.Align n -> errorf "alignment %d is not a power of 2" n
  | N.ReserveMem(ty,size,Some _) -> errorf "initialization not permitted for stackdata"
  | N.ReserveMem(ty,A.DynSize,_) -> errorf "illegal size for stackdata"
  | N.ReserveMem(ty,size,None) ->
      (match Elabexp.elab_ty env ty with
      | E.Error -> k mem stacklabels' env
      | E.Ok w ->
          let finish size =
            if w mod memsize = 0 then
              k (Memalloc.allocate mem (size * (w / memsize))) stacklabels' env
            else
              errorf "width %d of initialized data is not a multiple of memsize %d"
                w memsize in
          match size with 
          | A.NoSize    -> finish 1 
          | A.DynSize   -> impossf "dynamic memory size"
          | A.FixSize e ->
              match Elabexp.elab_con env e with
              | E.Ok (bits, _) -> finish (Bits.U.to_int bits)
              | E.Error        -> k mem stacklabels' (F.flagError env)
      )
  | N.Procedure _ -> impossf "nested procedures"
  | N.SSpan (_, _, _) -> impossf "span in stackdata"
@
%%
%%
%%\paragraph{Export checking}
%%
%%Not all named values can be exported: registers, continuations, and
%%stack labels are values that can't be exported. Export declarations
%%optionally can specify the type of declared symbols. Such a type must
%%match the actual type of an exported symbol.
<<definitions of name-binding functions>>=
let remember_export env (r, _, exports) = 
  let export env (name,foreign) =
    F.export r name (Auxfuns.Option.get name foreign) env in
  foldl export env exports in
@ 
%%The only thing that can happen to the environment here is that it gets
%%flagged with an error.
<<definitions of name-binding functions>>=
let check_export env (r, ty, pairs) = 
  let errorf fmt = Printf.kprintf (fun s -> eprint r s; F.flagError env) fmt in
  let check_pair env (name, foreign) =
    E.seq' env (findve r name env) (fun (den, ty) ->
      if Pervasives.(<>) ty pointerty then
        errorf "exported value must have native pointer type"
      else
        match den with
        | FE.Label (FE.Proc _ | FE.Code _ | FE.Data _) -> env
        | d -> errorf "%s '%s' can't be exported" (FE.denotation's_category d) name) in
  let check_pair env = E.catch' env (eprint r) (check_pair env) in
  let env = match ty with
  | Some t ->
      E.seq' env (Elabexp.elab_ty env t) (fun w ->
        if w <> metrics.Metrics.pointersize then
          errorf "exported value must have native pointer type"
        else
          env)
  | None -> env in
  foldl check_pair env pairs in
@
%%\subsubsection{Initialized data and other sectionish things}
%%
%%Top-level data are more complicated than stackdata.
%%
%%Any error flags the environment and continues.
%%The only environment operation for a toplevel datum is to bind labels.
%%The rest should be drawn from ast2ir.
<<definitions of name-binding functions for data>>=
let rec datum env (r, d) =
  let errorf fmt = Printf.kprintf (fun s -> eprint r s; F.flagError env) fmt in
  match d with
  | N.Datalabel l ->
      F.bindv l (r, E.Ok (FE.Label (FE.Data (F.symbol env l)), pointerty)) env
  | N.Align n when is2power n -> env
  | N.Align n -> errorf "alignment %d is not a power of 2" n
  | N.ReserveMem(ty,size,init) -> env
  | N.Procedure p ->
      let den = FE.Label (FE.Proc (F.symbol env p.N.name)) in
      F.bindv p.N.name (r, E.Ok (den, pointerty)) env
  | N.SSpan (_, _, ds) -> foldl datum env ds in
@ 
%%I want to be careful to elaborate in source-code order so as to have
%%the error messages ordered by source location.
%%THIS PROPERTY NEEDS TO BE CHECKED AND ENFORCED THROUGHOUT!!
<<definitions of elaboration functions for data>>=
let metrics = F.metrics env in
let rec data spans ds rest = match ds with
| [] -> (match rest with [] -> [] | (spans, ds) :: rest -> data spans ds rest)
| (r, d) :: ds ->
    let datalabel_meaning l = match findve r l env with
    | E.Ok (FE.Label (FE.Data sym), _) -> E.Ok (Datalabel sym)
    | E.Ok _ -> impossf "data label %s stands for something else?!" l
    | E.Error -> E.Error in
    match d with
    | N.Datalabel l -> let d = datalabel_meaning l in d :: data spans ds rest
    | N.Align n     -> let d = E.Ok (Align n)      in d :: data spans ds rest
    | N.Procedure p -> let d = proc env spans p    in d :: data spans ds rest
    | N.ReserveMem(ty,size,init) ->
        let d = reserve_mem r ty size init in d :: data spans ds rest
    | N.SSpan (k, v, ds') ->
        let span = E.seq2 (Elabexp.elab_con env k) (Elabexp.elab_link env v)
          (fun (k, kw) (v, vw) ->
            if kw <> metrics.Metrics.wordsize then
              errorf r "span token (key) must be a bit vector of native word size" 
            else if vw <> metrics.Metrics.pointersize then
              errorf r "span value must be a bit vector of native pointer size"
            else
              E.Ok ((k, v))) in
        data (span::spans) ds' ((spans, ds) :: rest)
@ 
%%It's unfortunate that spans are elaborated both here and in
%%\module{elabstmt}, but to reuse the error messages would be more
%%trouble than it is worth.
%%
%%A memory declaration has a type, a type, and optionally a number of
%%expressions to initialize the memory.  The number of expressions must
%%match the size specification, and the type of the expressions must
%%match the declared type.
<<definitions of elaboration functions for data>>=
and reserve_mem r ty size idata =
    E.seq2 (Elabexp.elab_ty env ty) (init_size r size) (fun w n ->
      match idata with
      | None ->
          if w mod memsize = 0 then
            E.Ok (UninitializedData (Auxfuns.Option.get 1 n * (w / memsize)))
          else
            errorf r "width %d of initialized data is not a multiple of memsize = %d"
              w memsize
      | Some i ->
          E.seq (init r (Types.Bits w) i) (fun inits ->
            let rcount = List.length inits in
            let lcount = Auxfuns.Option.get rcount n in
            if      rcount > lcount then errorf r "too many initial values"
            else if rcount < rcount then errorf r "too few initial values"
            else E.Ok (InitializedData inits)))
@
%%The [[init_size]] function returns the number of objects to reserve
%%memory for. Any given number must be nonnegative.
<<definitions of elaboration functions for data>>=
and init_size r = function
  | A.DynSize   -> E.Ok (None)
  | A.NoSize    -> E.Ok (Some 1)
  | A.FixSize e ->
      E.seq (Elabexp.elab_con env e) (fun (bits, _) -> 
        (try
          let size = Bits.S.to_int bits in
          if size >= 0 then E.Ok (Some size)
          else errorf r "negative count for initialized data"
        with Bits.Overflow -> errorf r "overflow computing size"))
@    
%%All initial values for a memory declaration must match the declared
%%type [[t]] of the memory declaration. The [[init]] function checks for
%%this and returns the number of initial expressions.
<<definitions of elaboration functions for data>>=
and init r ty i = 
  match i with
  | A.InitAt (x,r) -> E.catch (error r env) (init r ty) x
  | A.InitExprs(es)  ->
      E.seq (E.Raise.list (List.map (Elabexp.elab_link env) es)) (fun tes ->
        if List.for_all (fun (e, w) -> Types.Bits w =*= ty) tes then
          E.Ok tes
        else
          errorf r "type of an initial value does not match declared type %s"
            (Types.to_string ty))
  | A.InitStr s ->
      let to_texpr c = Reloc.of_const (Bits.U.of_int (Char.code c) 8), 8 in
      if ty =*= T.Bits 8 then
        E.Ok (Auxfuns.String.foldr (fun c l -> to_texpr c :: l) s [])
      else
        errorf r "initialized string must specify type bits8"
  | A.InitUStr(s) ->
      if ty =*= T.Bits 16 then
        Impossible.unimp "Unicode"
      else
        errorf r "initialized Unicode string must specify type bits16" in
@ 
<<nelab.ml>>=
let rewrite = Obj.magic
@ 
\section{[[front_nelab/simplify.nw]]}
<<front_nelab/simplify.ml>>=
<<simplify.ml>>
@

<<front_nelab/simplify.mli>>=
<<simplify.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% Come for the emacs, stay for the vim: ts=8 sw=4 et: 
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{RTL Constant Folding}
%%% ------------------------------------------------------------------ 
%%
%%An {\rtl} expression can denote a compile-time, link-time, or run-time
%%value. The goal is to evaluate any {\rtl} expression as early as
%%possible to minimize computation at run-time. This module provides
%%routines to evaluate {\rtl} expressions and to simplify {\rtl}s by
%%evaluating expressions inside of them. The promise is, that the returned
%%{\rtl}s and expressions are simpler as the ones provided.
<<simplify.mli>>=
val rtl:    Rtl.rtl -> Rtl.rtl
val exp:    Rtl.exp -> Rtl.exp
val bits:   Rtl.exp -> Bits.bits    (* Error.ErrorExn, convenient function *)
val link:   Rtl.exp -> Reloc.t
val bool:   Rtl.exp -> bool         (* Error.ErrorExn, convenient function *)
@
%%The [[Unsafe]] module provides an simplification of {\rtl}s tries to
%%evaluate guarding expressions by elimination of registers in relations
%%of the form $r+k = r+k'$. However, this elimination is not semantics
%%preserving if the $r+k$ would overflow, but $k$ not.  
<<simplify.mli>>=
module Unsafe: sig
    val rtl:    Rtl.rtl -> Rtl.rtl
end
@
%%We export the list of operators we can evaluate at compile time. 
<<simplify.mli>>=
val compile_time_ops: string list
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation relies on the following idea: we evaluate an
%%expression (or {\rtl}) bottom up as far as possible. The final result
%%will tell us whether it needs further ecaluation at link-time or
%%run-time.
<<simplify.ml>>=
open Nopoly

module BO = Bits.Ops
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module Dn = Rtl.Dn 
module Up = Rtl.Up

exception Error of string
type reloc     = Reloc.t

let error msg  = raise (Error msg)
let impossf fmt = Printf.kprintf Impossible.impossible fmt

module ToString = struct
  let exp  e = RU.ToString.exp (Up.exp e)
  let exp' e = RU.ToUnreadableString.exp (Up.exp e)
end

module Safe = struct
    <<RTL operator implementations>>
    <<traverse RTL>>
end    
@
%%The [[Unsafe]] module implements a more agressive simplification of
%%{\rtl}s that requires certain pre-conditions to be met. In particular,
%%it tries to evaluate guarding relational expressions like $r+k < r+k'$.
%%The simplification assumes that it is safe to eliminate the $r$ on both
%%sides of the $<$ operator.
<<simplify.ml>>=
module Unsafe = struct
    <<unsafe RTL simplification>>
end
@
%%The exported functions work on the public representation of {\rtl}s.
<<simplify.ml>>=
let rtl r  = try Up.rtl (Safe.rtl (Dn.rtl r))
             with Error msg -> Impossible.impossible msg

let exp e  = try Up.exp (Safe.exp (Dn.exp e))
             with Error msg -> Impossible.impossible msg

let rec location_category = function
  | RP.Mem _ -> "memory"
  | RP.Reg _ -> "a machine register"
  | RP.Var (name, _, _) | RP.Global (name, _, _) ->
      Printf.sprintf "register variable '%s'" name
  | RP.Slice (_, _, loc) -> location_category loc

let bits e =
  let rec cvt = function
    | RP.Const (RP.Bits b) -> b
    | RP.Const (RP.Bool _) -> Error.error "a constant expression may not be a Boolean"
    | RP.Const (RP.Link (s, _, _)) ->
        Error.errorf "constant %s not resolvable until link time" s#original_text
    | RP.Const (RP.Diff (_, _)) ->
        Error.errorf "difference of two constants not resolvable until link time"
    | RP.Const (RP.Late (s, _)) ->
        Error.errorf "late compile-time constant %s is not a constant yet" s
    | RP.Fetch (l, _) ->
        Error.errorf "a constant expression may not refer to %s"
          (location_category l)
    | RP.App ((opr, _), es) ->
        List.iter (fun e -> ignore (cvt e)) es;
        Error.errorf "cannot evaluate operator %%%s at compile time" opr in
  cvt (Safe.exp (Dn.exp e))
             
let bool e = match Safe.exp (Dn.exp e) with
             | RP.Const(RP.Bool(b)) -> b
             | _                    -> Error.error "not a constant condition"

let mklink kind s w = Up.exp (RP.Const (RP.Link(s, kind, w)))

let link e =
  let rec const c = match c with
  | RP.Bits b   -> Reloc.of_const b
  | RP.Link(l,kind,w) -> Reloc.of_sym (l, mklink kind) w
  | RP.Diff(c1,c2) -> Reloc.sub (const c1) (const c2)
  | _ -> Error.errorf "Bad link-time constant %s" (Rtlutil.ToString.const c) in
  let rec exp e = match e with
  | RP.App(("add",_),[x; y]) -> Reloc.add (exp x) (exp y)
  | RP.App(("sub",_),[x; y]) -> Reloc.sub (exp x) (exp y)
  | RP.Const c -> const c
  | _ -> Error.errorf "Bad link-time constant expression %s"
                      (Rtlutil.ToString.exp (Up.exp e)) in
  exp (Safe.exp (Dn.exp e)) 

let compile_time_ops = 
    [ "add"; "and"; "com"; "divu"; "eq"; "ge"; "geu"; "gt"; "gtu"; "le"; "leu";
      "lobits"; "lt"; "ltu"; "mul"; "ne"; "neg"; "or"; "shl"; "shra";
      "shrl"; " sub"; "sx"; "xor"; "zx"]
@
%%% ------------------------------------------------------------------ 
\subsection{RTL Traversal}
%%% ------------------------------------------------------------------ 
%%
%%All operator implementations have an easy way out: they just construct a
%%run-time expression from their arguments and return it. 
<<RTL operator implementations>>=
let default op w args = RP.App((op,w),args)
@ 
<<traverse RTL>>=
let app o w args = match o with
    | "NaN" 	      -> nan w args
    | "add" 	      -> add w args
    | "and" 	      -> binop o w BO.and' args
    | "bit" 	      -> bit  w args
    | "bool" 	      -> bool w args
    | "borrow" 	      -> default o w args
    | "carry" 	      -> default o w args
    | "com" 	      -> unop o w BO.com args
    | "conjoin"       -> conjoin w args
    | "disjoin"       -> disjoin w args
    | "div" 	      -> default o w args
    | "divu" 	      -> binop o w BO.divu args
    | "eq" 	      -> cmp_bits o w BO.eq args
    | "f2f" 	      -> default o w args
    | "f2i" 	      -> default o w args
    | "fabs" 	      -> default o w args
    | "fadd" 	      -> default o w args
    | "false" 	      -> false'    w args
    | "fcmp" 	      -> default o w args
    | "fdiv" 	      -> default o w args
    | "feq" 	      -> default o w args
    | "fge" 	      -> default o w args
    | "fgt" 	      -> default o w args
    | "fle" 	      -> default o w args
    | "float_eq"      -> default o w args
    | "float_gt"      -> default o w args
    | "float_lt"      -> default o w args
    | "flt" 	      -> default o w args
    | "fmul" 	      -> default o w args
    | "fmulx" 	      -> default o w args
    | "fne" 	      -> default o w args
    | "fneg" 	      -> default o w args
    | "fordered"      -> default o w args
    | "fsqrt" 	      -> default o w args
    | "fsub" 	      -> default o w args
    | "funordered"    -> default o w args
    | "ge" 	      -> cmp_bits o w (fun x y -> BO.lt  y x) args
    | "geu" 	      -> cmp_bits o w (fun x y -> BO.ltu y x) args
    | "gt" 	      -> cmp_bits o w BO.gt args
    | "gtu" 	      -> cmp_bits o w BO.gtu args
    | "i2f" 	      -> default o w args
    | "le" 	      -> cmp_bits o w (fun x y -> BO.gt  y x) args
    | "leu" 	      -> cmp_bits o w (fun x y -> BO.gtu y x) args
    | "lobits" 	      -> lobits w args
    | "lt" 	      -> cmp_bits o w BO.lt args
    | "ltu" 	      -> cmp_bits o w BO.ltu args
    | "minf" 	      -> minf w args
    | "mod" 	      -> default o w args
    | "modu" 	      -> default o w args
    | "mul"           -> binop o w BO.mul args
    | "mulux" 	      -> default o w args
    | "mulx" 	      -> default o w args
    | "mzero" 	      -> mzero w args
    | "ne" 	      -> cmp_bits o w BO.ne args
    | "neg" 	      -> unop  o w BO.neg args
    | "not" 	      -> not' w args
    | "or" 	      -> binop o w BO.or' args
    | "pinf" 	      -> pinf w args
    | "popcnt" 	      -> default o w args
    | "pzero" 	      -> pzero w args
    | "quot" 	      -> default o w args
    | "rem" 	      -> default o w args
    | "rotl" 	      -> default o w args
    | "rotr" 	      -> default o w args
    | "round_down"    -> round_down w args
    | "round_nearest" -> round_nearest w args
    | "round_up"      -> round_up w args
    | "round_zero"    -> round_zero w args
    | "shl" 	      -> binop o w BO.shl args
                            (* likely to break machine invariant on PPC? *)

    | "shra" 	      -> binop o w BO.shra args
    | "shrl" 	      -> binop o w BO.shrl args
    | "sub" 	      -> sub w args
    | "sx" 	      -> sx w args
    | "true" 	      -> true' w args
    | "unordered"     -> default o w args
    | "xor" 	      -> binop o w BO.xor args
    | "zx" 	      -> zx w args
    | "bitExtract"    -> default o w args
    | "bitInsert"     -> default o w args
    | "bitTransfer"   -> default o w args
    | "x86_carrybit"  -> x86_carrybit w args
    | o               -> default o w args
                      
let rec exp e =
    match e with
    | RP.Const _ as c       -> c
    | RP.Fetch (l, w)       -> RP.Fetch (loc l, w)
    | RP.App ((o,w),args)   -> app o w (List.map exp args) 
                            
and loc = function          
    | RP.Mem(sp, w, e, ass) -> RP.Mem(sp, w, exp e, ass)
    | RP.Slice(n,lsb,l)     -> (
      <<rewrite slice [[l@lsb:n]]>>
    )
    | RP.Reg(sp, i, w) as v -> v
    | RP.Var   (s,i,w) as v -> v
    | RP.Global(s,i,w) as v -> v
                            
let effect = function       
    | RP.Store(l,e,w)       -> RP.Store(loc l, exp e, w)
    | RP.Kill(l)            -> RP.Kill(loc l)
                            
let guarded (e, eff)        = (exp e, effect eff)
let rtl (RP.Rtl(es))        = RP.Rtl(List.map guarded es)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Unsafe Simplification}
%%% ------------------------------------------------------------------ 
%%
%%[[reg_offset]] recognizes a $r+k$ expression, where $r$ is a register
%%and $k$ a constant, and returns either boths as a pair, or [[None]].
%%
<<unsafe RTL simplification>>=
let zero w = RP.Const(RP.Bits (Bits.U.of_int 0 w))
let reg_offset = function
  | RP.App(("add", _), [RP.Fetch(RP.Reg r,_); RP.Const _ as k]) -> Some (r,k)
  | RP.Fetch(RP.Reg r, w) -> Some (r, zero w)
  | _                     -> None
@
<<unsafe RTL simplification>>=
let rec app o w args = match Safe.app o w args with
    | RP.App (("ne"|"eq"|"ltu"|"gtu"|"lt"|"gt" as op, w), [left;right]) as x ->
        ( match reg_offset left, reg_offset right with
        | Some(r1,k1), Some(r2,k2) when Register.eq r1 r2 -> 
            let r      = app op w [k1;k2] in
            let _dbg() = Printf.eprintf "Simplify2.Unsafe.app: %s `%s` %s = %s\n"
                        (ToString.exp k1) op (ToString.exp k2) (ToString.exp r) in
            r
               
        | _  -> x
        )
    | x -> x

let rec exp = function
    | RP.Const _ as c       -> c
    | RP.Fetch (l, w)       -> RP.Fetch (loc l, w)
    | RP.App ((o,w),args)   -> app o w (List.map exp args) 
                            
and loc = function          
    | RP.Mem(sp, w, e, ass) -> RP.Mem(sp, w, exp e, ass)
    | RP.Slice(w,i,l)       -> RP.Slice(w, i, loc l)
    | RP.Reg(sp, i, w) as v -> v
    | RP.Var   (s,i,w) as v -> v
    | RP.Global(s,i,w) as v -> v
                            
let effect = Safe.effect    
                            
let guarded (e, eff)        = (exp e, effect eff)
let rtl' (RP.Rtl(es))       =
  let add_guarded e es = match guarded e with
    | RP.Const(RP.Bool false), _ -> es
    | e                          -> e :: es in
  RP.Rtl(List.fold_right add_guarded es [])

(*let rtl' (RP.Rtl es) = RP.Rtl (List.map guarded es)*)

let rtl r  = try Up.rtl (rtl' (Dn.rtl r)) 
             with Error msg -> Impossible.impossible msg

@
%%
%%% ------------------------------------------------------------------ 
\subsection{RTL Operator Implementations}
%%% ------------------------------------------------------------------ 
%%
%%Here are some helper functions used below.
%%
<<RTL operator implementations>>=
let to_bool b = RP.Const (RP.Bool b) 
let const k   = RP.Const (RP.Bits k)
@
<<RTL operator implementations>>=
let false' w args = RP.Const(RP.Bool false)
let true'  w args = RP.Const(RP.Bool true)
@
%%
%%\paragraph{IEEE 754 Constants} 
%%
%%How a rounding mode is represented is
%%implementation-specific, but the values we pick have to be consistent
%%with the definitions of [[CMM_ROUND_*]] in the interpreter.
%%These values happen to be good for the Intel platform.
<<RTL operator implementations>>=
let round_down    w args = RP.Const(RP.Bits(Bits.U.of_int 1 2))
let round_up      w args = RP.Const(RP.Bits(Bits.U.of_int 2 2))
let round_nearest w args = RP.Const(RP.Bits(Bits.U.of_int 0 2))
let round_zero    w args = RP.Const(RP.Bits(Bits.U.of_int 3 2))
@ 
%%
<<RTL operator implementations>>=
let rec add ws args = 
    let w = match ws with [w] -> w | _ -> Impossible.impossible "ill-typed add" in
    match args with
    | [ RP.App(("add", ws'), [x; RP.Const (RP.Bits k)]); RP.Const (RP.Bits k') ] ->  
                assert (ws=*=ws');
                add ws [x; RP.Const (RP.Bits (Bits.Ops.add k k'))]
    | [RP.Const (RP.Bits x); RP.Const (RP.Bits y)] ->  
                RP.Const (RP.Bits (Bits.Ops.add x y))
    | [x; RP.Const (RP.Bits y)] when Bits.Ops.eq (Bits.U.of_int 0 w) y -> x
    | args  ->  default "add" ws args

let sub ws args =
  let rec remove_one y xs = match xs with
  | [] -> Impossible.impossible "did not find removable expression"
  | x :: xs when RU.Eq.exp y x -> xs
  | x :: xs -> x :: remove_one y xs in
  let w = match ws with [w] -> w | _ -> Impossible.impossible "ill-typed sub" in
  match args with
  | [RP.Const(RP.Bits x); RP.Const(RP.Bits y)] -> const (Bits.Ops.sub x y)
  | [RP.App(("add",ws'),args); e] when List.mem e args ->
    (match remove_one e args with
    | _::_::_ as rst -> add ws' rst
    | [a]            -> a
    | []             -> RP.Const(RP.Bits(Bits.zero w))
    )
  | [x; y] when RU.Eq.exp x y -> RP.Const(RP.Bits(Bits.zero w))
  | args      -> default "sub" ws args
@ 
%%
<<RTL operator implementations>>=
let binop name w op = function
    | [RP.Const(RP.Bits x); RP.Const(RP.Bits y)] -> const (op x y)
    | args       -> default name w args
@ 
%%
<<RTL operator implementations>>=
let disjoin w = function
    | [RP.Const(RP.Bool true); _] -> RP.Const(RP.Bool true)
    | [_; RP.Const(RP.Bool true)] -> RP.Const(RP.Bool true)
    | [RP.Const(RP.Bool false); p] -> p
    | [p; RP.Const(RP.Bool false)] -> p
    | args       -> default "disjoin" w args

let conjoin w = function
    | [RP.Const(RP.Bool false); _] -> RP.Const(RP.Bool false)
    | [_; RP.Const(RP.Bool false)] -> RP.Const(RP.Bool false)
    | [RP.Const(RP.Bool true); p] -> p
    | [p; RP.Const(RP.Bool true)] -> p
    | args       -> default "conjoin" w args
@ 
%%
<<RTL operator implementations>>=
let not' w = function
    | [RP.Const(RP.Bool b)] -> RP.Const(RP.Bool (not b))
    | args       -> default "not" w args
@ 
<<RTL operator implementations>>=
let cmp_bits name w op = function
    | [RP.Const(RP.Bits x); RP.Const(RP.Bits y)] -> to_bool (op x y)
    | args       -> default name w args
@ 
<<RTL operator implementations>>=
let unop name w op = function
    | [RP.Const(RP.Bits x)] -> const (op x)
    | args       -> default name w args
@ 
<<RTL operator implementations>>=
@ 
<<RTL operator implementations>>=
let or' ws args = 
    let w = match ws with [w] -> w | _ -> Impossible.impossible "ill-typed or" in
    match args with
    | [RP.Const (RP.Bits x); RP.Const (RP.Bits y)] ->  
                RP.Const (RP.Bits (Bits.Ops.or' x y))
    | [x; RP.Const (RP.Bits y)] when Bits.Ops.eq (Bits.U.of_int 0 w) y -> x
    | [RP.Const (RP.Bits x); y] when Bits.Ops.eq (Bits.U.of_int 0 w) x -> y
    | args  ->  default "or" ws args

let and' ws args = 
    let w = match ws with [w] -> w | _ -> Impossible.impossible "ill-typed and" in
    match args with
    | [RP.Const (RP.Bits x); RP.Const (RP.Bits y)] ->  
                RP.Const (RP.Bits (Bits.Ops.and' x y))
    | [x; RP.Const (RP.Bits y) as zero] when Bits.Ops.eq (Bits.U.of_int 0 w) y -> zero
    | [RP.Const (RP.Bits x) as zero; y] when Bits.Ops.eq (Bits.U.of_int 0 w) x -> zero
    | args  ->  default "and" ws args
@ 
<<RTL operator implementations>>=
let rec zx w args   = match w, args with
| [n;w],[RP.Const (RP.Bits x)] -> const (Bits.Ops.zx w x)
| [n;w],[RP.App (("zx", [n';w']), [x])] -> assert (w' = n); zx [n';w] [x]
| [n;w], [x] when n = w -> x
| _         -> default "zx" w args

let rec sx w args   = match (w,args) with
| [i;j],[RP.Const(RP.Bits x)] -> const (Bits.Ops.sx j x)
| [n;w],[RP.App (("sx", [n';w']), [x])] -> assert (w' = n); sx [n';w] [x]
| [n;w],[RP.App (("zx", [n';w']), [x])] when w' > n' -> assert (w' = n); zx [n';w] [x]
| [i;j], [x] when i = j -> x
| _         -> default "sx" w args
@ 
%%
%%
%%\paragraph{Rewriting references to fragments of large aggregates}
%%
%%Here we do some fast and loose playing with assertions, as well as
%%assume that the memsize is~8.
<<RTL operator implementations>>=
let rec lobits ws args   = match (ws,args) with
| [i;j],[RP.Const(RP.Bits x)] -> const (Bits.Ops.lobits j x)
<<cases for rewriting aggregates in big-endian or little-endian memory>>
<<cases for rewriting aggregates in big-endian or little-endian registers>>
| [i;j], [x] when i = j -> x
| _         -> default "lobits" ws args

let () = Debug.register "simp-lobits" "simplification of %lobits expressions"

let lobits =
  if Debug.on "simp-lobits" then
    (fun ws args ->
      let e = RP.App (("lobits", ws), args) in
      let answer = lobits ws args in
      Printf.eprintf "simplified %s -> %s\n" (ToString.exp e) (ToString.exp answer);
      answer)
  else
    lobits
@ 
%%
<<rewrite slice [[l@lsb:n]]>>=
match loc l with
| 
 <<big-endian memory location>>
  when Cell.divides mcell n && Cell.divides mcell lsb ->
    let w          = Cell.to_width mcell ct in
    let R.C offset = Cell.to_count mcell (w - n - lsb) in
    let addr       = Dn.exp (RU.addk (RU.Width.exp' addr) (Up.exp addr) offset) in
    let assn       = Alignment.gcd assn offset in
    RP.Mem (mspace, Cell.to_count mcell n, addr, assn)
| 
 <<little-endian memory location>>
  when Cell.divides mcell n && Cell.divides mcell lsb ->
    let R.C offset = Cell.to_count mcell lsb in
    let addr       = Dn.exp (RU.addk (RU.Width.exp' addr) (Up.exp addr) offset) in
    let assn       = Alignment.gcd assn offset in
    RP.Mem (mspace, Cell.to_count mcell n, addr, assn)
| 
  <<big-endian register location>>
  when Cell.divides rcell n && Cell.divides rcell lsb ->
    let w          = Cell.to_width rcell count in
    let R.C offset = Cell.to_count rcell (w - n - lsb) in
    RP.Reg (rspace, index + offset, Cell.to_count rcell n)
| 
  <<little-endian register location>>
  when Cell.divides rcell n && Cell.divides rcell lsb ->
    let R.C offset = Cell.to_count rcell lsb in
    RP.Reg (rspace, index + offset, Cell.to_count rcell n)
| l -> RP.Slice(n,lsb,l)
@ 
<<cases for rewriting aggregates in big-endian or little-endian memory>>=
| [w;n],[
   <<little-endian memory fetch>>
   ] when Cell.divides mcell n ->
    RP.Fetch (RP.Mem (mspace, Cell.to_count mcell n, addr, assn), n)
| [w;n],[
    <<big-endian memory fetch>>
    ] when Cell.divides mcell (w - n) ->
    let R.C offset = Cell.to_count mcell (w - n) in
    let addr = Dn.exp (RU.addk (RU.Width.exp' addr) (Up.exp addr) offset) in
    let assn = Alignment.gcd assn offset in
    RP.Fetch (RP.Mem (mspace, Cell.to_count mcell n, addr, assn), n)
| [w;n],[RP.App(("shrl", [_]),
                [
      <<little-endian memory fetch>>
      ; RP.Const(RP.Bits b)])] ->
    let shamt = Bits.U.to_int b in
    if Cell.divides mcell shamt then
      let R.C offset = Cell.to_count mcell shamt in
      let addr = Dn.exp (RU.addk (RU.Width.exp' addr) (Up.exp addr) offset) in
      let assn = Alignment.gcd assn offset in
      lobits [w-shamt; n]
        [RP.Fetch (RP.Mem (mspace, Cell.to_count mcell (w-shamt), addr, assn),w-shamt)]
    else
      default "lobits" ws args
| [w;n],[RP.App(("shrl", [_]), [
      <<big-endian memory fetch>>
     ; RP.Const(RP.Bits b)])] ->
    let shamt = Bits.U.to_int b in
    if Cell.divides mcell shamt then
      lobits [w-shamt; n]
        [RP.Fetch (RP.Mem (mspace, Cell.to_count mcell (w-shamt), addr, assn),w-shamt)]
    else
      default "lobits" ws args
@ 
<<little-endian memory fetch>>=
RP.Fetch(
  <<little-endian memory location>>
   , w')
@ 
<<little-endian memory location>>=
RP.Mem ((sp, Rtl.LittleEndian, mcell) as mspace, ct, addr, assn)
@ 
<<big-endian memory fetch>>=
RP.Fetch(
    <<big-endian memory location>>
   , w'')
@ 
<<big-endian memory location>>=
RP.Mem ((sp, Rtl.BigEndian, mcell) as mspace, ct, addr, assn)
@ 
<<cases for rewriting aggregates in big-endian or little-endian registers>>=
| [w;n],[
   <<little-endian register fetch>>
   ] when Cell.divides rcell n ->
    RP.Fetch (RP.Reg (rspace, index, Cell.to_count rcell n), n)
| [w;n],[
   <<big-endian register fetch>>
   ] when Cell.divides rcell (w - n) ->
    let R.C offset = Cell.to_count rcell (w - n) in
    let index      = index + offset in
    RP.Fetch (RP.Reg (rspace, index, Cell.to_count rcell n), n)
| [w;n],[RP.App(("shrl", [_]),
                [
    <<little-endian register fetch>>
    ; RP.Const(RP.Bits b)])] ->
    let shamt = Bits.U.to_int b in
    if Cell.divides rcell shamt then
      let R.C offset = Cell.to_count rcell shamt in
      let index      = index + offset in
      lobits [w-shamt; n]
        [RP.Fetch (RP.Reg (rspace, index, Cell.to_count rcell (w-shamt)), w-shamt)]
    else
      default "lobits" ws args
| [w;n],[RP.App(("shrl", [_]), [
      <<big-endian register fetch>>
      ; RP.Const(RP.Bits b)])] ->
    let shamt = Bits.U.to_int b in
    if Cell.divides rcell shamt then
      lobits [w-shamt; n]
        [RP.Fetch (RP.Reg (rspace, index, Cell.to_count rcell (w-shamt)), w-shamt)]
    else
      default "lobits" ws args
@ 
<<little-endian register fetch>>=
RP.Fetch(
   <<little-endian register location>>
   , w'')
@ 
<<big-endian register fetch>>=
RP.Fetch(
   <<big-endian register location>>
   , w'')
@ 
<<little-endian register location>>=
RP.Reg ((sp, Rtl.LittleEndian, rcell) as rspace, index, count)
@ 
<<big-endian register location>>=
RP.Reg ((sp, Rtl.BigEndian,    rcell) as rspace, index, count)
@ 
%%
<<RTL operator implementations>>=
let unsigned n w = RP.Const (RP.Bits (Bits.U.of_int n w))
let null = function [] -> true | _ :: _ -> false

let zero1 = Bits.U.of_int 0 1
let one1  = Bits.U.of_int 1 1
let bool w args = assert (null w); match args with
| [RP.Const (RP.Bits x)] -> RP.Const (RP.Bool (Bits.Ops.ne x zero1))
| [RP.App (("lobits", [w; 1]), [x])] ->
    RP.App (("ne", [w]), [RP.App (("and", [w]), [x; unsigned 1 w]); unsigned 0 w])
| _ -> default "bool" w args


let bit w args = assert (null w); match args with
| [RP.Const (RP.Bool b)] -> RP.Const (RP.Bits (if b then one1 else zero1))
| _ -> default "bit" w args
@
<<RTL operator implementations>>=
let pzero w args = assert (null args); match w with
| [(32|64) as w] -> const (Bits.zero w)
| _ -> default "pzero" w args

let mzero w args = assert (null args); match w with
| [(32|64) as w] -> const (BO.shl (Bits.U.of_int 1 w) (Bits.U.of_int (w-1) w))
| _ -> default "mzero" w args

let pinf w args = assert (null args); match w with
| [32] -> const (BO.shl (Bits.U.of_int 0xff  32) (Bits.U.of_int 23 32))
| [64] -> const (BO.shl (Bits.U.of_int 0x7ff 64) (Bits.U.of_int 52 64))
| _ -> default "pinf" w args

let minf w args = assert (null args); match w with
| [32|64] -> or' w [pinf w args; mzero w args]
| _ -> default "minf" w args

let nan w args =
  let swidth = function
    | 32 -> 23
    | 64 -> 52
    | _  -> Impossible.unimp "NaN at width other than 32 or 64" in
  match w, args with
  | [n;w], [x] when n = swidth w -> or' [w] [pinf [w] []; zx [n; w] [x]]
  | [n;w], [x] -> impossf "significand in NaN has width %d; should be %d" n (swidth w)
  | _ -> Impossible.impossible "ill-formed NaN"
@ 
%%
\subsection{Machine-dependent simplifications}
<<RTL operator implementations>>=
let x86_carrybit w args = match args with
| [RP.App (("x86_setcarry", _), [_; e])] -> e
| _ -> default "x86_carrybit" w args

    
@ 
\section{[[front_nelab/topsort.nw]]}
<<front_nelab/topsort.ml>>=
<<topsort.ml>>
@

<<front_nelab/topsort.mli>>=
<<topsort.mli>>
@

%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Please add grades for this module below. The line must start with % "%%".
%%
%%%%Grades: B Peripheral Later
%%
%%% ------------------------------------------------------------------ 
\section{Topological Sort}
%%% ------------------------------------------------------------------ 
%%
%%Constants and types in {\PAL} can be declared recursively:  one
%%declaration may depend on several others.  This relationship must be
%%taken into account when constants and type declarations are evaluated
%%to find the meaning of each declared name.  On way is to find an order
%%such that a name's meaning is entered into an environment before any
%%other declaration that refers to it is processed.  Such an order is
%%called a \emph{topological order}.  The idea is to collect all
%%declarations of one kind, order them topologically, and process them. 
%%The [[Topsort]] module implements topological sorting for
%%declarations.
%%
%%A type declaration ([[typedef]]) for a type $x$ can either refer to a
%%primitive type like bits8, or to another name $y$, which must be
%%defined by another [[typedef]].  In case $x$ refers to $y$, the type
%%declaration for $x$ depends on the declaration for $y$.  Bindings for
%%type-names in particular in the fat environment bind only primitive
%%types to names.  So the declaration for $y$ must be entered into the
%%environment before $x$ to resolve the meaning of $x$ with the help of
%%previously entered type declarations. The topological order of type
%%declarations with respect to their dependencies provides the right
%%order to process them.
%%
%%Constant declaration ([[const]]) are similar to type declarations:  a
%%constant expression can refer to other constants which thus must be
%%processed first.  After the dependencies for constant declarations are
%%recorded, constant declarations can be topologically sorted. This
%%module provides an abstract view on declarations and their
%%dependencies and is not tailored towards a specific kind of
%%declaration to sort.
%%
%%The topological sort faces some problems when dealing with
%%erroneous programs: 
%%
%%\begin{itemize}
%%\item Usage of undeclared names.
%%\item Circular dependencies among declarations.
%%\item Multiple declarations of the same name.
%%\end{itemize}
%%
%%All these problems must be reported as checked compile-time errors.
%%But we don't want to do this during sorting declarations but after
%%they are sorted and while processing them. However, each of the problems
%%mentioned above prevent a proper sorting. In order to be able to do
%%still much as work as possible in the presence of these problems we
%%make some assumptions and decisions:
%%
%%\begin{itemize}
%%\item An undeclared name depends on no other declaration.
%%\item A name declared multiple times depends on the union of
%%      dependencies of its individual declarations.
%%\item A circular definitions is broken up by removing one declaration.
%%      This permits to sort the remaining declarations. 
%%\end{itemize}
%%
%%For a list of circular declarations no topological order exists.  This
%%case is reported as an exception with a list of declarations that are
%%part of a cycle.  The client of this module then has to redo the
%%sorting with these declaration removed from the input.
%%
%%This topological sort supports the case that one declaration may
%%declare multiple names.  For example, a [[typedef]] can define
%%multiple names for the same type.
%%
%%% ------------------------------------------------------------------ 
\subsection{Interface}
%%% ------------------------------------------------------------------ 
%%
%%The [[Topsort]] module is parameterized over the declarations it can
%%sort.  In case of circular declarations a list of offending
%%declarations is reported with a [[Cycle]] exception.  In the normal
%%case a list of declarationis is returned such that no declaration
%%depends on any later declaration in the list.  Or, stated positively,
%%all declarations depend only on their predecessors in the list.
%%
<<signature S>>=
module type S = sig
    type decl
    exception Cycle of decl list
    val sort: decl list -> decl list (* raises Cycle *)
end
@
%%
%%A declaration [[defines]] multiple names and may [[use]] several other
%%names in its body.  Aside from this, a declaration is abstract.
%%
<<signature Sortable>>=
module type Sortable = sig
    type decl
    val defines : decl -> string list
    val uses    : decl -> string list
end
@
%%
<<topsort.mli>>=
<<signature S>>
<<signature Sortable>>

module Make (S: Sortable) : (S with type decl = S.decl)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation uses a modified \emph{depth first search} for
%%topological sorting as it is outlined by Paulsen in \emph{{\small ML}
%%for the working Programmer} \cite{paulson:91:ml}.
%%
<<topsort.ml>>=
open Nopoly

<<signature S>>
<<signature Sortable>>

module ID       = struct type t=string let compare=compares end
module IDMap    = Map.Make(ID)

module Make (S: Sortable) = struct
    type decl = S.decl
    exception Cycle of decl list 

    <<functions>>
end
@
%%
%%Multiple definitions can define the same name; this is an error but it
%%should not affect the sorting. A map points to all declarations that
%%declare that name.
%%
<<functions>>=
let declmap decls =
    let find key  map    = try IDMap.find key map with Not_found -> [] in
    let add  d map key   = IDMap.add key (d :: find key map) map       in
    let add' map d       = List.fold_left (add d) map (S.defines d)    in
        List.fold_left add' IDMap.empty decls
@
%%The [[succ]] function calculates all declarations a given declaration
%%depends on with the help of [[S.uses]] and the previously calculated
%%[[map]]:  [[S.uses]] returns the names used by [[x]] and the [[map]]
%%translates these to the declarations for these names.
<<functions>>=
let succ map x =
    let find map n = try IDMap.find n map with Not_found -> [] in
    List.concat (List.map (find map) (S.uses x))
@
%%The map [[m]] contains for every name the declarations that define
%%this name.  Correct {\PAL} programs will use only one definition to
%%define a name.  This algorithm is difficult to understand -- please
%%refer to \emph{{\small ML} for the working Programmer}
%%\cite{paulson:91:ml} by Paulson for an explanation. 
<<functions>>=
let sort decls =
    let m             = declmap decls                               in
    let nv x (v,c)    = x::v ,c                                     in
    let rec sort todo path (visited, cycles) =
        match todo with
        | []    -> visited, cycles
        | x::xs ->
            let vc = if List.mem x path         then visited, x::cycles
                     else if List.mem x visited then visited, cycles
                     else nv x (sort (succ m x) (x::path) (visited,cycles))
                                                                    in
                sort xs path vc
                                                                    in
    match sort decls [] ([],[]) with
    | dd, [] -> List.rev dd
    | dd, cc -> raise (Cycle cc)
@
%%
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Test}
%%% ------------------------------------------------------------------ 
%%
%%The module [[Topsorttest]] provides a tiny example for declarations
%%from the \emph{{\small ML} for the working Programmer}.  It was used
%%interactively during development.
%%
<<topsorttest.ml>>=
module D = struct
    type decl = string list * string list
    
    let defines (x,_) = x
    let uses    (_,y) = y
end

module DSort = Topsort.Make(D)

(*   DEFINED               USED BY DEFINITION *)
let regular =
    [ ["wake"]            , ["shower"; "eat" ]
    ; ["shower"]          , ["dress"] 
    ; ["dress"]           , ["go"]
    ; ["eat"]             , ["wash-up"]
    ; ["wash-up"]         , ["go"]
    ; ["go"]              , []
    ]
@ 
%%
<<topsorttest.ml>>=
let multi_lhs1 =
    [ ["wake"]            , ["shower"; "eat" ]
    ; ["shower"; "bath"]  , ["dress"] 
    ; ["dress"]           , ["go"]
    ; ["eat"; "drink"]    , ["wash-up"]
    ; ["wash-up"]         , ["go"]
    ; ["go"]              , []
    ]
@ 
<<topsorttest.ml>>=
let multi_lhs2 =
    [ ["wake"]            , ["shower"; "eat" ]
    ; ["shower"; "bath"]  , ["dress"] 
    ; ["bath"]            , ["dress"] 
    ; ["dress"]           , ["go"]
    ; ["eat"; "drink"]    , ["wash-up"]
    ; ["wash-up"]         , ["go"]
    ; ["go"]              , []
    ; ["go"]              , []
    ]
@ 
<<topsorttest.ml>>=
let undefs =
    [ ["wake"]            , ["shower"; "eat" ]
    ; ["shower"; "bath"]  , ["dress"] 
    ; ["bath"]            , ["dress"] 
    ; ["dress"]           , ["go"]
    ; ["eat"; "drink"]    , ["wash-up"]
    ; ["wash-up"]         , ["go"]
    ]
@ 
<<topsorttest.ml>>=
let cycle1 =
    [ ["wake"]            , ["shower"; "eat" ]
    ; ["shower"; "bath"]  , ["dress"] 
    ; ["bath"]            , ["dress"] 
    ; ["dress"]           , ["go";"wake"]
    ; ["eat"; "drink"]    , ["wash-up"]
    ; ["wash-up"]         , ["go"]
    ; ["go"]              , []
    ; ["go"]              , []
    ]
@

\chapter{[[front_target]]}

\section{[[front_target/automaton.nw]]}
<<front_target/automaton.ml>>=
<<automaton.ml>>
@

<<front_target/automaton.mli>>=
<<automaton.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et:
%%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% $Id: automaton.nw,v 1.82 2006-08-24 21:19:41 dias Exp $
%%
%%%%Grades: A Central Later
%%
%%
%%% ------------------------------------------------------------------ 
\section{Automaton-Based Slot Allocation}
%%% ------------------------------------------------------------------ 
%%
%%\emph{The predicates for [[choice]] and [[first_choice]] take [[width]]
%%and [[kind]] in different orders. Maybe we should define an extra type
%%alias. --CL}
%%
%%This module supports Bailey-Davidson automata for allocating locations
%%for value-passing.
%%An automaton manages a set of hardware locations, which it uses to
%%satisfy allocation requests.
%%In the Bailey-Davidson framework, the set of locations is split into
%%two parts:
%%\begin{itemize}
%%\item
%%A finite set of locations, which may be managed arbitrarily
%%\item
%%An infinite set of locations, which must be allocated sequentially and
%%contiguously
%%\end{itemize}
%%We call the infinite set of locations the \emph{overflow block}.
%%
%%The overflow block has a number of properties.
%%\begin{itemize}
%%\item
%%The overflow block has a \emph{maximum alignment}.
%%This alignment is the maximum possible alignment of any location in
%%the block, and it is a function of the calling convention.
%%\item
%%The overflow block has a \emph{direction of growth}.
%%\item
%%The overflow block has a \emph{number of bytes allocated}.
%%\end{itemize}
%%The maximum alignment and direction of growth are fixed when the
%%overflow block is created; the number of bytes allocated increases
%%monotonically during allocation.
%%
%%The Bailey-Davidson automaton has two parts: a finite-state control
%%that manages the finite set of locations, and an infinite-state
%%control for the overflow block.
%%The infinite set of states is mapped to a finite set by considering
%%only the number of bytes allocated modulo the maximum alignment.
%%We use a value of type [[Memalloc.t]] to manage this part of the
%%automaton.
%%
%%The interface exports abstract types, concrete types, and values.
<<automaton.mli>>=
<<abstract types>>
<<exposed types(automaton.nw)>>
<<registration types>>
<<exported values>>
@ 
%%
\subsection{Standard kinds}
%%
%%We might use these kinds:\\
%%\begin{tabular}{>{\ttfamily}ll}
%%signed& Signed integer\\
%%unsigned& Unsigned integer\\
%%address&  Address\\
%%float&    Floating-point value\\
%%\end{tabular}\\
%%A missing or empty kind is assumed to be [[unsigned]].
%%
\subsection{Observer-Mutator interface}
%%An [[Automaton.t]] encapsulates mutable state.  
%%Allocating a location mutates its state.
%%After allocation is completed, an automaton is \emph{frozen},
%%and it can no longer be mutated.
%%A~frozen automaton gives us an overflow block, its state, and the set
%%of locations handed out.
%%The set implicitly includes every location in the overflow block; the
%%rest of the set is explicit.
<<abstract types>>=
type t
@ 
<<exposed types(automaton.nw)>>=
type result =
  { overflow    : Block.t
  ; regs_used   : Register.Set.t
  ; mems_used   : Rtl.loc list
  ; align_state : int   (* final alignment state of overflow block *)
  }
@ 
%%We allocate a location by identifying a value's type, which in {\PAL}
%%is a width and a kind.
<<exported values>>=
val allocate : t -> width:int -> kind:string -> align:int -> loc
val freeze   : t -> result
@
%%In some conventions, a value must be split between two registers or
%%between registers and memory.
%%Accordingly, we need a special type of location: an object with fetch
%%and store methods.
<<exposed types(automaton.nw)>>=
type width = int
type kind  = string
type loc = Rtlutil.aloc =
    { fetch  : width -> Rtl.exp
    ; store  : Rtl.exp -> width -> Rtl.rtl
    }
@ 
<<exported values>>=
val fetch  : loc ->            width -> Rtl.exp
val store  : loc -> Rtl.exp -> width -> Rtl.rtl
@ 
%%Most locations are easy.
<<exported values>>=
val of_loc : Rtl.loc -> loc
@ 
%%
\subsection{Constructor interface}
%%Most clients will simply use an automaton, but some will need to
%%create one.
%%For these a representation with two functions: an allocator, and
%%something that implements [[freeze]].
%%The allocator takes an additional alignment, which it uses if it has
%%to put the value in memory.
%%If called directly from [[val allocate]], the alignment is always~$1$,
%%but it may be changed by upstream implementations.
%%The [[freeze]] function accumulates information about locations handed
%%out, which information it passes to the right. 
%%At the very end is the overflow block.
<<exposed types(automaton.nw)>>=
type methods =
    { allocate : width: int -> alignment: int -> kind: string -> loc
    ; freeze   : Register.Set.t -> Rtl.loc list -> result
    } 
@ 
%%To get an instance of an automaton, we need to provide a memory
%%space and a start address for the overflow block.
%%(I'M CONCERNED THAT WE USE A START ADDRESS HERE BUT TYPICALLY USE A
%%BASE ADDRESS ELSEWHERE.  THIS DIFFERENCE MAY CAUSE PROBLEMS FOR THINGS
%%THAT GROW DOWN.) 
<<exported values>>=
val at         : Rtl.space -> start:Rtl.exp -> stage -> t
val of_methods : methods -> t
@ 
%%The idea is that we build an implementation by a composition of
%%stages.
%%We provide stages that change alignment, adjust widths, hand out
%%locations, and so on.
%%In addition, we expect that a client might write its own stages.
<<abstract types>>=
type stage
@ 
<<exported values>>=
val ( *> ) : stage -> stage -> stage
@ 
%%Because it's a nuisance to manage the threading of the [[start]]
%%parameter through the stages, we provide a function that lets clients
%%build their own stages.
<<exported values>>=
val wrap   : (methods -> methods) -> stage
@ 
%%\paragraph{The overflow block, if any}
%%The final stage in any implementation is the overflow block.
%%To make an overflow block, you need a bunch of information about the
%%machine and a bunch of information about the convention.
<<exported values>>=
val overflow : growth:Memalloc.growth -> max_alignment:int -> stage
@ 
%%It is possible to have {no} overflow block.
%%In this case, it's up to clients to gather that only finitely many
%%requests are made and that the automaton satisfies all of them.
%%Such an automaton is useful for conventions in which only finitely 
%%many values can be passed,  such as the C~return
%%convention.
%% 
%%\paragraph{Selection and adjustment of width}
%%The [[widths]] stage can restrict the convention to satisfy only
%%requests naming a listed width.
<<exported values>>=
val widths : int list -> stage
@
%%
%%The [[widen f]] stage  alters a request for a
%%width~[[w]] so it has a width [[f w]], which must be at least as large as~[[w]].
%%The widening operation depends on the kind.
%%For a little-endian machine passing values in memory, widening an
%%unsigned integer or address is
%%equivalent to adding padding.
%%For a big-endian machine, it isn't.
%%It is an unchecked run-time error for [[f]] to return a result that is
%%less than its argument.
<<exported values>>=
val widen  : (int -> int) -> stage
@ 
%%We expect stages such as
%%[[Automaton.widen (Auxfuns.round_up_to ~multiple_of:32)]] 
%%to be useful.
%%
%%\paragraph{Adjustment of alignment}
%%If a value must be allocated in memory, it needs an alignment.
%%All alignments start out at~1, but we can provide a function that
%%maps a width to an alignment.
%%Danger Will Robinson!
%%The argument to the function is a width in \emph{bits}, but the
%%alignment is a size in \emph{bytes} (actually the unit is not the byte
%%but the cell size of target memory).
<<exported values>>=
val align_to : (int -> int) -> stage
@ 
%%
%%\paragraph{Allocation of registers}
%%Although it may not be terribly useful, we provide a simple stage that
%%hands out registers sequentially.
%%To satisfy a request, the stage takes the first~$n$ registers, where
%%$n$~is chosen such that the number of bits in these registers is
%%exactly the number of bits in the request.
%%If there is no such~$n$, it barfs with an error message.
<<exported values>>=
val useregs : Register.t list -> bool -> stage
@ 
%%The [[useregs]] stage is stateful; a register handed out in response
%%to an earlier request cannot be used to satisfy a later request.
%%
%%See the paper for these.
%%(The boolean value that [[regs_by_bits]] and [[regs_by_args]]
%%expect to receive indicates whether you would like normal semantics
%%or "reserve" semantics: allocate a register if available, pass
%%request on to successive stages, throw away any allocations they
%%make, and return the register.  [[false]] indicates normal semantics
%%and [[true]] turns on reserve semantics.)
<<abstract types>>=
type counter = string
type counterenv
@ 
<<exported values>>=
val bitcounter  : counter -> stage
val regs_by_bits: counter -> Register.t list -> bool -> stage

val argcounter  : counter -> stage
val regs_by_args: counter -> Register.t list -> bool -> stage

val pad         : counter -> stage
@ 
%%And this is documented nowhere, not even in the paper.  It is used
%%to post-process the results from a [[freeze]] request.  For example,
%%\module{mipscall.nw} uses [[postprocess]] to require that the overflow
%%block is padded with an extra 16-byte block.
<<exported values>>=
val postprocess : stage -> (result -> result) -> stage
@
%%\paragraph{Combination of multiple stages}
%%It can be useful to hand out different registers from different piles.
%%For example, we might want to use floating-point registers to satisfy
%%[["float"]] requests and integer registers to satisfy other requests.
%%The following combinator makes it possible to use different stages for
%%different requests.
%%Because the stages don't communicate, it is probably not too useful
%%for describing C~conventions (C~varargs hell), but it should be useful
%%for {\PAL} conventions.
%%
%%The idea is that for an allocation, we use the first stage for which
%%the predicate is satisfied.
%%It is a checked run-time error if no predicate is satisfied.
<<exposed types(automaton.nw)>>=
type choice_predicate = int -> string -> counterenv -> bool
@ 
<<exported values>>=
val choice : (choice_predicate * stage) list -> stage
@ 
%%To help create predicates we provide several convenience functions.
<<exported values>>=
val counter_is : counter -> (int -> bool) -> choice_predicate
val is_kind    : kind                     -> choice_predicate
val is_width   : int                      -> choice_predicate
val is_any     :                             choice_predicate
@ 
%%\paragraph{Using an automaton as a stage}
%%
%%Although it is not necessary for calling conventions, we have found it
%%convenient to abuse the abstraction by using an automaton [[inner]] as
%%a stage in an [[outer]] automaton.
%%The idea is to use [[as_stage inner]] as a stage.
%%When this stage receives an allocation request, it passes the request
%%to the [[inner]] automaton.  
%%Thus [[as_stage inner]] behaves like an overflow block: it is the
%%final stage in its automaton, and it has no successor.
%%But when the [[outer]] automaton is frozen, it has no effect on the
%%[[inner]] automaton, which can continue to satisfy allocation
%%requests.
<<exported values>>=
val as_stage : t -> stage
@
%%\paragraph{Other forms of history}
%%
%%Most calling conventions keep track of little history beyond knowing
%%what locations have been used.
%%The MIPS convention is unusual in that the placement a second
%%parameter, if of floating-point type, may be placed in one of two
%%different available locations depending on the type of the first
%%parameter. 
%%My solution is to enable an automaton to ``become'' another on the
%%basis of the first allocation request.
%%Because these things can be chained, I~believe the solution may be
%%general.
%%
%%The first time an allocation reaches this stage, we select the
%%first alternative satisfying the predicate.
%%Thereafter \emph{the whole automaton behaves as this alternative}.
%%If no choice is ever made, the automaton freezes as the first
%%alternative.
%%It is a checked run-time error if no predicate is satisfied.
<<exported values>>=
val first_choice : (choice_predicate * stage) list -> stage
@ 
%%
%%QUESTION FOR MARK BAILEY: HAS HE CAREFULLY ANALYZED WHAT CLASS OF
%%AUTOMATA CAN BE SPECIFIED IN CCL?
%%
%%\paragraph{The unit stage}
%%The [[unit]] stage does nothing, passing on an allocation
%%or freeze request straight to the stages that follow it in the pipeline.
%%It may be useful either as a default stage within a [[choice]] stage
%%(along with the [[is_any]] primitive) to make sure we don't fall off
%%the end of the [[choice]], or with [[List.fold_right]] in OCaml to compose a
%%list of stages into one stage (using the [[*>]] operator).
%%
<<exported values>>=
val unit : stage
@
%%\paragraph{Debugging}
<<exported values>>=
val debug : counter -> (int -> string -> int -> int -> unit) -> stage
@ 
%%\paragraph{Lua Registration of Calling Conventions}
%%Ideally it would be nice for these types to sit in some other module
%%(maybe \module{call.nw}?) but there are some dependency issues that force
%%it to be in here for now.
<<registration types>>=
type cc_spec  = { call : stage; results : stage; cutto : stage }
type cc_specs = (string * cc_spec) list
@
<<exported values>>=
val init_cc : cc_specs
@ 
\section{Implementation}
%%
%%Those internal types not fully defined in the interface:
<<hidden types>>=
type counter    = string
type counterenv = string -> int ref option
@ 
<<hidden types that refer to [[methods]]>>=
type t = methods
type implementation = I of (start:Rtl.exp -> space:Rtl.space -> ctrs:counterenv -> t)
type stage = S of (implementation -> implementation)
@ 
%%
%%During a debugging session I reviewed the [[Exclude]] submodule and
%%believe it is correct. However, I did not review the handling of
%%[[cellcount]]. --CL
%%
<<automaton.ml>>=
open Nopoly

<<hidden types>>
<<exposed types(automaton.nw)>>
<<hidden types that refer to [[methods]]>>

module R   = Rtl
module RS  = Register.Set
module B   = Block
module M   = Memalloc
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let unimp  = Impossible.unimp
@ 
%%
%%The big idea here is hooking up the end of the pipeline:
<<automaton.ml>>=
let ( *> ) (S f1) (S f2) = S (fun rhs -> f1 (f2 rhs))

let pipeline_end = I (
  fun ~start ~space ~ctrs -> 
    let block = Block.at ~base:start ~size:0 ~alignment:1 in
    { allocate = (fun ~width ~alignment ~kind -> impossf
                  "fell off end of pipeline -- multiple return values from C?")
    ; freeze   =
      (fun regs mems -> 
       {overflow = block; regs_used = regs; mems_used = mems; align_state = 0})
    })
@
%%All the work of the implementation is in the closures.
<<automaton.ml>>=
let at space ~start (S s) =
  let I f = s pipeline_end in
    f ~start ~space ~ctrs:(fun _ -> None)

let of_methods t                     = t
let allocate   t ~width ~kind ~align = t.allocate width align kind
let freeze     t                     = t.freeze Register.Set.empty []

let fetch  loc = loc.fetch
let store  loc = loc.store
let of_loc loc = { fetch  = R.fetch loc; store = R.store loc }
@ 
%%
\subsection{Wrapping etc.}
%%
%%There's substantial bookkeeping in passing the start address around.
%%We prefer to program in terms of [[methods]] rather than
%%implementation.
%%\nwaddbox{wrap         : (methods                   -> methods) -> stage}
%%\nwaddbox{swrap        : (methods -> start:Rtl.exp -> space:Rtl.space -> ctrs:counterenv -> methods) -> stage}
%%\nwaddbox{wrap_choice  : (('a*(methods->methods)) list -> methods -> ctrs:counterenv -> methods) -> ('a * stage) list -> stage}
%%\nwaddbox{wrap_counter : (Rtl.space -> int ref -> methods -> methods) -> counter -> stage}
%%\deeperbox{40pt}
<<automaton.ml>>=
let wrap  f = S (fun (I next) -> I (fun ~start ~space ~ctrs ->
                                    f (next ~start ~space ~ctrs)))
let swrap f =
  S (fun (I next) -> I (fun ~start ~space ~ctrs ->
                           f (next ~start ~space ~ctrs) ~start ~space ~ctrs))
let wrap_choice f choices = S (fun (I next) ->
  let apply (I f) = f in
  let downchoice c ~start ~space ~ctrs =
   fun meths -> apply (c (I (fun ~start ~space ~ctrs -> meths))) ~start ~space ~ctrs in
  I (fun ~start ~space ~ctrs ->
   let choices = List.map (fun (p,(S c)) ->
                            (p, downchoice c ~start ~space ~ctrs))
                 choices
   in f choices (next ~start ~space ~ctrs) ~ctrs))
@
%%The overflow block is slightly interesting.
<<automaton.ml>>=
type state = { mutable mem       : M.t; mutable frozen : bool
             ; mutable mems_list : R.loc list  }
let overflow ~growth ~max_alignment next =
  fun ~start ~space:((_, byteorder, memsize) as space) ~ctrs ->
    let mem = M.at start growth in
    let state = { mem = mem; frozen = false; mems_list = [] } in
    <<functions [[allocate]] and [[freeze]] for the overflow block>>
    { allocate = allocate; freeze = freeze }
let overflow ~growth ~max_alignment = 
  swrap (overflow ~growth ~max_alignment) 
@ 
%%To allocate, we align and increment the memory block.
%%The address of the new location depends on the direction of stack growth.
<<functions [[allocate]] and [[freeze]] for the overflow block>>=
let allocate ~width ~alignment ~kind =
  if not (Cell.divides memsize width) then
   impossf "width %d not multiple of memsize %d" width (Cell.size memsize);
  if max_alignment mod alignment <> 0 then
   impossf "max alignment %d not multiple of alignment %d" max_alignment alignment;
  if state.frozen then impossf "Allocation from a frozen overflow block";
  let (R.C c) as count = Cell.to_count memsize width in
  let mem  = state.mem in
  let mem  = M.align mem alignment in
  let mem' = M.allocate mem c in
  let addr = M.current (match growth with M.Up -> mem | M.Down -> mem') in
  let loc  = (R.mem (R.aligned alignment) space count addr) in
  state.mems_list <- loc :: state.mems_list;
  state.mem <- mem';
  of_loc loc in
@ 
%%To freeze, we have to adjust the block alignment if the stack grows down.
%%We might not want to be appending lists, but we do so now for simplicity.
<<functions [[allocate]] and [[freeze]] for the overflow block>>=
let freeze regs mems =
  state.frozen <- true;
  let mem    = state.mem in
  let astate = M.num_allocated mem mod max_alignment in
  let mem    = match growth with 
               M.Up -> mem | M.Down -> M.align mem (M.alignment mem) in
  let block  = M.freeze mem in
  { overflow = block; regs_used = regs; mems_used = state.mems_list @ mems
  ; align_state = astate } in
@ 
%%\paragraph{Higher-order functions for request transformers}
%%
<<automaton.ml>>=
type allocator = width: int -> alignment: int -> kind: string -> loc
let txstage f  = wrap (fun next -> 
                        { allocate = f next.allocate; freeze = next.freeze })
let _ = (txstage : (allocator -> allocator) -> stage)
@ 
<<automaton.ml>>=
let widths ws = txstage
  (fun nalloc ~width ~alignment ~kind ->
    if   List.exists ((=) width) ws then nalloc width alignment kind
                                    else Unsupported.automaton_widths width)
@   
%%Narrowing and widening.
<<automaton.ml>>=
let narrower = 
  let narrow nopname wopname ~w ~n loc =
     let widen  = R.opr wopname [n; w] in 
     let narrow = R.opr nopname [w; n] in 
       { fetch  = (fun n   -> R.app narrow [loc.fetch w])
       ; store  = (fun e n -> loc.store (R.app widen [e]) w)
       } in
  function
  | "signed" -> narrow "lobits" "sx"
  | "float"  -> narrow "f2f_implicit_round" "f2f_implicit_round"
  | "unsigned" | "address" | "" | _ -> narrow "lobits" "zx"
let narrowf = narrower "float"

let widen f = txstage 
  (fun nalloc ~width:n ~alignment ~kind ->
    let w   = f n in
    let loc = nalloc w alignment kind in
    if w = n then loc else narrower kind ~n ~w loc)

let align_to f =
  txstage (fun nalloc ~width:w ~alignment ~kind -> nalloc w (f w) kind)
@
%%
%%\paragraph{Choice and First Choice Stages}
%% 
%%The dataflow here is kind of interesting.  
%%For the [[allocate]] method, we have a fan-out and fan-in, with a fork
%%and join point, so it passes through exactly \emph{one} choice.
%%But for the [[freeze]] method, we thread the call straight through the
%%whole list, so it passes through \emph{all} choices.
<<automaton.ml>>=
let choice choices next ~ctrs =
    let add (p, stage) alternative =
      let follows_choice = { allocate = next.allocate
                           ; freeze   = alternative.freeze } in
      let choice = stage follows_choice in
      let alloc ~width ~alignment ~kind =
        let alloc = if p width kind ctrs then choice.allocate 
                                         else alternative.allocate in
        alloc width alignment kind in
      { allocate = alloc; freeze = choice.freeze } in
    List.fold_right add choices
      { allocate = (fun ~width -> impossf "fell off end of choice stage")
      ; freeze = next.freeze }
let choice = wrap_choice choice

let first_choice choices next ~ctrs =
  let choices = List.map (fun (p, c) -> (p, c next)) choices in
  let myself = ref next in (* temporary *)
  let allocate ~width ~alignment ~kind = 
    (!myself).allocate width alignment kind in
  let freeze regs mems = (!myself).freeze regs mems in
  let first_allocate ~width ~alignment ~kind =
    let choice =
      try snd (List.find (fun (p, _) -> p width kind ctrs) choices)
      with Not_found -> impossf "missing choice" in
    myself := choice;
    allocate width alignment kind in
  let () = try
    myself := { allocate = first_allocate
              ; freeze   = (snd (List.hd choices)).freeze }
  with Failure _ -> impossf "no first choice" in
  { allocate = allocate; freeze = freeze }
let first_choice = wrap_choice first_choice

let counter_is c f _ _ env = match env c with Some i -> f (!i) | None -> false
let is_kind    h'  w h _   = h =$= h'
let is_width   w'  w h _   = w = w'
let is_any         w h _   = true
@ 
%$
%%\paragraph{Register assignment}
<<automaton.ml>>=
let wrap_counter f label =
  S (fun (I next) ->
       I (fun ~start ~space ~ctrs ->
           let (ctr, ctrs) = (match ctrs label with
           | Some n -> (n, ctrs)
           | None   ->
              let n = ref 0 in
              (n, fun s -> if s =$= label then Some n else ctrs s)) in
           f space ctr (next ~start ~space ~ctrs)))

let counter of_width =
  let f ctr nalloc ~width ~alignment ~kind =
    let loc = nalloc ~width ~alignment ~kind in
    (ctr := !ctr + of_width width ; loc)
  in (fun ctr next -> { allocate = f ctr next.allocate; freeze = next.freeze })
@ 
%$
%%
%%The [[allow_agg]] and [[reserve]] arguments to [[reg_placer]] control
%%register allocation semantics.
%%The first specifies whether location aggregation is allowed for values
%%that don't fit within one register, and the second specifies whether
%%we also need to reserve space in a later stage but throw it away.
<<automaton.ml>>=
type regstate = { mutable used  : Register.Set.t }

<<definition of [[combine_loc]]>>

let reg_placer of_width agg n regs reserve next =
  let state = { used = RS.empty } in
  let getreg = function
  | []      -> raise (Failure "get register")
  | r :: rs -> (state.used <- RS.add r state.used; r) in

  let rec drop i regs = if i <= 0 then regs else match regs with
  | r :: rest -> drop (i - of_width (Register.width r)) rest
  | []        -> [] in

  let rec alloc ~width ~alignment ~kind =
    try
      let ((_, _, ms), _, c) as r = getreg (drop !n regs) in
      let w = Cell.to_width ms c in
      if w = width then
         let allocated = of_loc (R.reg r) in
         ( if reserve then ignore (next.allocate width alignment kind)
         ; allocated )
      else if w < width then match agg with
             | Some endianness ->
                let w'  = width - w in
                let _   = n := !n + w in
                let ell = combine_loc endianness
                             (of_loc (R.reg r)) w
                             (alloc ~width:w' ~alignment ~kind) w'
                in ( n := !n - w ; ell )
             | None -> Unsupported.automaton_widen ~have:width ~want:w
      else unimp "auto-widening for register requests"
    with Failure _ -> next.allocate width alignment kind in
  let freeze regs mems = next.freeze (RS.union state.used regs) mems in
  { freeze = freeze; allocate = alloc }

let bitcounter   = counter (fun w -> w)
let regs_by_bits = reg_placer (fun w -> w)

let useregs regs reserve = 
  swrap (fun next ~start ~space:(_, byteorder, _) ~ctrs -> let c = ref 0 in
          (bitcounter c) ((regs_by_bits (Some byteorder) c regs reserve) next))

let bitcounter   = wrap_counter (fun _ -> bitcounter)
let regs_by_bits label rs reserve =
    wrap_counter (fun (_,bo,_) ctr -> regs_by_bits (Some bo) ctr rs reserve) label

let argcounter   = wrap_counter (fun _ -> counter (fun w -> 1))
let regs_by_args = reg_placer (fun w -> 1) None
let regs_by_args label rs reserve = 
    wrap_counter (fun _ ctr -> regs_by_args ctr rs reserve) label

let pad = 
  let padcounter space ctr next =
    let (_, _, memsize) = space in
    let f nalloc ~width ~alignment ~kind =
      let al = Cell.to_width memsize (R.C alignment) in
      ctr := Auxfuns.round_up_to ~multiple_of:al !ctr;
      nalloc ~width ~alignment ~kind
    in { next with allocate = f next.allocate }
  in wrap_counter padcounter
@ 
%%
%%And now we need to actually define the helper [[combine_loc]] that can
%%combine multiple hardware resources into one abstract `location'.
<<definition of [[combine_loc]]>>=
<<shift and mask functions>>
let combine msb msw lsb lsw =
  { fetch  = (fun ww -> assert (ww = msw + lsw);
                    orb ww (zx lsw ww (fetch lsb lsw))
                           (shl ww (zx msw ww (fetch msb msw)) lsw))
  ; store  = (fun exp ww -> assert (ww = msw + lsw);
                    R.par [ store lsb (lobits ww lsw exp              ) lsw
                          ; store msb (lobits ww msw (shrl ww exp lsw)) msw ])
  }

let combine_loc = function
  | Rtl.Identity     -> impossf "split without byte-ordering"
  | Rtl.LittleEndian -> (fun b1 w1 b2 w2 -> combine b2 w2 b1 w1)
  | Rtl.BigEndian    -> combine
@ 
%%
<<shift and mask functions>>=
let const w k = R.bits (Bits.U.of_int k w) w
let zx n w v = R.app (R.opr "zx" [n; w]) [v]
let orb w x y = R.app (R.opr "or"  [w]) [x; y]
let shl  w x k = R.app (R.opr "shl"  [w]) [x; const w k]
let shrl w x k = R.app (R.opr "shrl" [w]) [x; const w k]
let lobits w n x = R.app (R.opr "lobits" [w; n]) [x]
@ 
%%
%%
%%\paragraph{Using an automaton as a stage}
%%
%%To us an automaton as a stage, we pass on an allocation request but
%%ignore a freeze request.
<<automaton.ml>>=
let as_stage inner next = 
  fun ~start ~space ~ctrs ->
    let freeze regs mems =
      { regs_used = regs; mems_used = mems;
        overflow = Block.at start 0 0; align_state = 0 } in
    { allocate = inner.allocate; freeze = freeze }
let as_stage inner = swrap (as_stage inner)
@
%%
%%\paragraph{The unit stage}
<<automaton.ml>>=
let unit = wrap (fun next -> next)
@ 
%%\paragraph{Debugging}
<<automaton.ml>>=
let debug f _ ctr next =
  let allocate ~width ~alignment ~kind =
    f width kind alignment (!ctr);
    next.allocate ~width ~alignment ~kind in
  { allocate = allocate; freeze = next.freeze }

let debug counter f = wrap_counter (debug f) counter
@ 
%%
%%\paragraph{Postprocessing a result}
<<automaton.ml>>=
let postprocess (S stage) f = S (fun imp ->
  let I i = stage imp in
  I (fun ~start ~space ~ctrs ->
      let m = i start space ctrs in
      { allocate = m.allocate
      ; freeze = (fun rs ms -> f (m.freeze rs ms))
      } ))
@ 
%%
%%\paragraph{Lua Registration of Calling Conventions}
<<automaton.ml>>=
type cc_spec  = { call : stage; results : stage; cutto : stage }
type cc_specs = (string * cc_spec) list
let init_cc = []
@ 
\section{[[front_target/box.nw]]}
<<front_target/box.ml>>=
<<box.ml>>
@

<<front_target/box.mli>>=
<<box.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: sw=4 ts=8 et:
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Please add grades for this module below. The line must start with % "%%".
%%% 
%%
%%%%Grades: 
%%
%%% ------------------------------------------------------------------ 
\section{Boxing}
%%% ------------------------------------------------------------------ 
%%Sometimes we need to store data in a context where an \rtl\ is expected.
%%In these cases, we can enclose the fragment within an \rtl~$box$.
%%A [[BOXER]] is a module that provides embedding ([[box]]) and projection
%%  ([[unbox]]) functions for a particular type of data.
<<BOXER type>>=
module type BOXER = sig
  type t
  val box   : t -> rtl
  val unbox : rtl -> t (* possible assertion failure *)
end
@
%%We define a boxer for expressions and one for a list of expressions.
%%We also have a boxer for guards.
%%Even though a guard is just an \rtl\ expression, we treat this case specially because
%%  some parts of the compiler make a distinction, such as the widener.
%%We also provide a functor that combines two boxers;
%%  there is a subtle restriction on the first argument to the functor: it may not
%%  box values into an \rtl\ with multiple effects.
%%The current implementation of [[ExpList]] is not a suitable first argument to
%%  [[Combine]].
%%THIS SHOULD BE FIXED.
%%Finally, we have a boxing module that pairs a guard and an effect.
<<box.mli>>=
type rtl = Rtl.rtl
<<BOXER type>>
module Exp      : BOXER with type t = Rtl.exp
module ExpList  : BOXER with type t = Rtl.exp list
module Guard    : BOXER with type t = Rtl.exp
module Combine (Box1 : BOXER) (Box2 : BOXER) : BOXER with type t = Box1.t * Box2.t
module GuardExp : BOXER with type t = Rtl.exp * Rtl.exp
@
%%We provide a function [[assert_not_boxed]] that raises an assertion failure on any
%%  \rtl\ that is the image of a boxing function.
<<box.mli>>=
val assert_not_boxed : rtl -> unit
@
%%We embed [[exp]]s in a store instruction.
<<exp boxer>>=
type t = R.exp
let box e = R.store (R.reg (x, 0, (R.C 1))) e 32
let unbox r = match Dn.rtl r with
  | RP.Rtl [(RP.Const (RP.Bool true),
             RP.Store (RP.Reg (('\000',_,_), _, _), e, 32))] -> Up.exp e
  | _ -> assert false
@
%%We embed [[exp]]s in a parallel store instruction.
<<explist boxer>>=
type t = Rtl.exp list
let box es = R.par (List.map Exp.box es)
let unbox r = match Dn.rtl r with
  | RP.Rtl gs -> List.map (fun g -> Exp.unbox (Up.rtl (RP.Rtl [g]))) gs
@
%%Some compiler components distinguish between expressions found as guards and
%%  expressions found on the right-hand-side of an \rtl.
%%Hence, we have a separate boxer for guards.
<<guard boxer>>=
type t = R.exp
let box g = R.guard g (R.store (R.reg (x, 0, (R.C 1))) (R.bits (Bits.zero 32) 32) 32)
let unbox r = match Dn.rtl r with
  | RP.Rtl [(g, RP.Store (RP.Reg (('\000',_,_), _, _), _, 32))] -> Up.exp g
  | _ -> assert false
@
%%Sometimes, it's useful to combine two boxing modules.
%%The implementation assumes that the [[box]] function for the first
%%  boxer does not produce \rtls\ with multiple effects.
<<Combine>>=
module Combine (Box1 : BOXER) (Box2 : BOXER) = struct
  type t = Box1.t * Box2.t
  let box (v1, v2) =
    let b1 = Box1.box v1 in
    let () = match Dn.rtl b1 with | RP.Rtl [_] -> () | _ -> assert false in
    R.par [b1; Box2.box v2]
  let unbox r = match Dn.rtl r with
    | RP.Rtl (g::gs) ->
        (Box1.unbox (Up.rtl (RP.Rtl [g])), Box2.unbox (Up.rtl (RP.Rtl gs)))
    | _ -> assert false
end
@
%%For now, we can get away with a simple check: does the reserved ``boxing'' space
%%  appear on the left-hand-side of an assignment?
<<[[assert_not_boxed]]>>=
let assert_not_boxed r =
  let check = function
    | (_, RP.Store (RP.Reg (('\000',_,_), _, _), _, _)) -> assert false
    | _ -> () in
  match Dn.rtl r with
  | RP.Rtl gs -> List.iter check gs
@
<<box.ml>>=
module Dn = Rtl.Dn
module R  = Rtl
module RP = Rtl.Private
module Up = Rtl.Up
type rtl = R.rtl
let x = (Space.Standard32.x R.LittleEndian [32]).Space.space
<<BOXER type>>
module Exp = struct
  <<exp boxer>>
end
module ExpList = struct
  <<explist boxer>>
end
module Guard = struct
  <<guard boxer>>
end
<<Combine>>
module GuardExp = Combine (Guard) (Exp)
<<[[assert_not_boxed]]>>
@
\section{[[front_target/float.nw]]}
<<front_target/float.ml>>=
<<float.ml>>
@

<<front_target/float.mli>>=
<<float.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
\section{Support for floating-point numbers}
%%
%%Different targets may have different support for floating-point
%%computation.
%%We encapsulate this support as [[Float.t]].
%%A~[[Float.t]] represents a specification of the semantics of all
%%floating-point operations, as well as translation from literals to bit
%%vectors. 
%%
%%At present, a [[Float.t]] has a name, which can be compared with a
%%[[target]] declaration in a {\PAL} program.
%%And function [[of_string t]] can convert a floating-point literal to a
%%bit vector.
<<float.mli>>=
type t

val name      : t -> string
val of_string : t -> string -> Rtl.width -> Bits.bits

val ieee754 : t    (* standard IEEE 754 semantics *)
val none    : t    (* for machines without floating-point support *)
@ 
%%The implementation does not exist.
<<float.ml>>=
type t = string
let name n = n
let of_string _ _ _ = Impossible.unimp "Float.t"
let ieee754 = "ieee754"
let none = "none"
@ 
\section{[[front_target/space.nw]]}
<<front_target/space.ml>>=
<<space.ml>>
@

<<front_target/space.mli>>=
<<space.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: sw=4 ts=8 et:
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Please add grades for this module below. The line must start with % "%%".
%%% 
%%
%%%%Grades: B Peripheral Later
%%
%%%
%%% Todo: define rounding mode register (names: fp_mode) in space 'c';
%%% extend 'location' location type. Since 'c' is 32 bits wide, but the
%%% rounding mode only 2 bits wide, we take slices: RP.slice (2, 0,
%%% fp_mode) when using it.
%%%
%%
%%
%%% ------------------------------------------------------------------ 
\section{RTL-Spaces}
%%% ------------------------------------------------------------------ 
%%
%%The {\rtl} framework groups memory cells (main memory, registers,
%%temporaries) into named spaces. The cells forming a space share
%%properties but the {\rtl} framework does not announce them. This module
%%provides a type to describe an {\rtl} space. 
%%
%%The function [[checked]] asserts that its argument satisfies a few
%%simple invariants, then returns that argument.
<<space.mli>>=
<<definitions of exported types, including [[t]]>>
val checked : t -> t
<<definition of signature [[Standard]]>>
module Standard32 : Standard
module Standard64 : Standard
@
%%The module [[Standard]] provides support for common spaces with
%%standard names.  Memory uses 8-bit cells, and other units use 32-bit
%%cells.  
%%Byte order and available aggregate widths must be specified by the
%%client. 
%%As of October 2004, temporary registers cannot be aggregated; the byte
%%order specified for 
%%a temporary space is the byte order of the underlying hardware space,
%%and exactly one width is supported.
<<definition of signature [[Standard]]>>=
module type Standard = sig
  type generator  = Rtl.aggregation -> Rtl.width list -> t
  type tgenerator = Rtl.aggregation -> Rtl.width      -> t
  val m   :               generator          (* standard 8-bit memory *)
  val r   :  count:int -> generator          (* registers *)
  val t   :               tgenerator         (* register temps *)
  val f   :  count:int -> generator          (* floats *)
  val u   :               tgenerator         (* float temps *)
  val a   :  count:int -> generator          (* address registers *)
  val v   :               tgenerator         (* address temps *)
  val p   :  count:int -> generator          (* predicate registers *)
  val w   :               tgenerator         (* predicate temps *)
  val c   :  count:int -> generator          (* control and special registers *)
  val vf  :               generator          (* virtual frame pointer *)
  val x   :               generator          (* boxed rtls *)
  val s   :  int       -> tgenerator         (* stack-slots temporaries *)
  
  type 'a locations = 
    { pc:       'a
    ; npc:      'a
    ; cc:       'a
    ; fp_mode:  'a  (* FP rounding mode   *)
    ; fp_fcmp:  'a  (* FP %fcmp results   *)
    }

  val locations : c:t -> Rtl.loc locations
        (* apply to c space to get standard locations *)
  val indices : int locations (* standard indices in c space *)
  val vfp : Rtl.exp  (* the virtual frame pointer, $V[0] *)
end
@ 
%$
%%To define spaces, we must first define [[classification]] and
%%[[location_set]].
%%A [[Rtl.space]] denotes a memory space, the details of a particular
%%space are covered by a space descriptor [[t]].
<<definitions of exported types, including [[t]]>>=
<<definition of type [[location_set]]>>
<<definition of type [[classification]]>>
type t  =
    { space:            Rtl.space       (* space being described *)
    ; doc:              string          (* informal doc string *)       
    ; indexwidth:       int             (* bits *)
    ; indexlimit:       int option      (* None = 2 ** indexwidth *)
    ; widths:           int list        (* bit widths of supported aggregates *)
    ; classification:   classification  
    }
@
%%\begin{itemize}
%%\item [[doc]]:          Informal documentation string.
%%\item [[indexwidth]]:   Width of an address in this space. A memory
%%                        space could have 32 bit wide addresses, a
%%                        register space 5 bit wide addresses.
%%\item [[indexlimit]]:   Upper bound for an address in this space: $0,
%%                        \dots, [[indexlimit]]$. 
%%\item [[widths]]:       Widths of supported aggregates. For example, 
%%                        if an  memory space 8~bits wide supports 8-, 16-, and
%%                        32-bit words, [[widths]] would be [[[8;16;32]]].
%%\item [[classification]]: Classification of a space, see below.
%%\end{itemize}
%%
%%A space falls into one of the following classifications: memory-like,
%%register-like, fixed, or temporary. 
<<definition of type [[classification]]>>=
type classification = 
    | Mem               
    | Reg               
    | Fixed
    | Temp of location_set
@ 
%%Memory-like, register-like, and fixed spaces contain real hardware
%%locations.
%%A~temporary space contains only locations that stand in for hardware
%%locations.
%%All temporary locations are removed before code generation is
%%complete. 
%%(This is the job of the register allocator.)
%%
%%The classification of a space depends on the binding time of the
%%expressions used to index cells in that space.
%%\begin{itemize}
%%\item
%% If an {\rtl} operand addressing the space denotes a value that
%%      cannot be computed until run time, the space is memory-like.
%%      An example of such an expression is $\mathit{SP}+12$.
%%      The standard \texttt{m}~space is memory-like.
%%\item
%% If every {\rtl} operand addressing the space is a compile-time
%% constant, and if the constant can ever be chosen by the compiler,
%% then the space is register-like. 
%% (In machine-language terms, a space is register-like if the values of its
%% indexing expressions can be computed from the operands of the
%% instructions that use the space.)
%% Most standard spaces are register-like, including \texttt{r},
%% \texttt{f}, and~\texttt{a}.
%%\item
%% If every {\rtl} operand addressing the space is a fixed
%% constant determined by the nature of the instruction, with no choice
%% available to the compiler,
%% then the space is fixed. 
%% (In machine-language terms, a space is fixed if the values of its
%% indexing expressions are determined by the instructions that use the
%% space, and the operands of those instructions are irrelevant.)
%% The standard \texttt{c}~space is fixed.
%%\item
%%   A temporary space is a register-like space that is infinitely large
%%   and not provided by the hardware.
%%   A~location in a temporary space denotes one of a set of locations
%%   drawn from a real register-like space.
%%   The set is
%%      characterized by a [[location_set]] value. Example: on the
%%   SPARC, the \texttt{t}~space is
%%      a space over \texttt{r}, where the address of an \texttt{r} cell
%%      is not zero.  
%%   The register allocator ultimately replaces each temporary location
%%   with a real hardware location.
%%\end{itemize}
<<definition of type [[location_set]]>>=
type location_set =
    { stands_for : Register.t -> bool  (* what registers we stand for *)
    ; set_doc    : string     (* informal description *)    
    }
@ 
%%We make it easy to build a simple predicate.
<<space.mli>>=
val stands_for : char -> Register.aggregation -> Register.width -> (Register.t -> bool)
@    
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<space.ml>>=
open Nopoly

<<definitions of exported types, including [[t]]>>
<<definition of signature [[Standard]]>>
@
%%
<<space.ml>>=
let indexwidth n =
  let rec wid = function
    | 0 -> 0
    | n -> 1 + wid (n lsr 1)  in
  wid (n-1)
let checked s =
  begin
    let (_, agg, cell) = s.space in
    assert (match s.widths with [] -> false | _ :: _ -> true);
    List.iter (fun w -> assert (Cell.divides cell w)) s.widths;
    (match agg with
    | Rtl.Identity -> assert(s.widths =*= [Cell.to_width cell (Cell.C 1)])
    | _ -> ());
    (match s.indexlimit with
    | Some n -> assert (indexwidth n <= s.indexwidth)
    | _ -> ());
    s
  end
let stands_for s agg w =
  (fun ((s', agg', c), _, Register.C ct) ->
    s' =<= s && agg =*= agg' && ct = 1 && Cell.size c = w)
@
%%
%%A set of standard spaces can now be constructed from a simple functor
%%argument. Maybe we need to extend the argument signature for 64-bit
%%architectures.
%%
<<space.ml>>=
module Standard(A:sig val width: int end) = struct
  type generator  = Rtl.aggregation -> Rtl.width list -> t
  type tgenerator = Rtl.aggregation -> Rtl.width      -> t
  let m agg ws = checked 
    { space          = ('m', agg, Cell.of_size 8)
    ; doc            = "memory"
    ; indexwidth     = A.width 
    ; indexlimit     = None
    ; widths         = ws
    ; classification = Mem
    } 

  let r ~count agg ws = checked 
    { space          = ('r', agg, Cell.of_size A.width)
    ; doc            = "general-purpose registers"
    ; indexwidth     = indexwidth count
    ; indexlimit     = Some count
    ; widths         = ws
    ; classification = Reg
    } 
  let f ~count agg ws = checked 
    { space         = ('f', agg, Cell.of_size A.width)
    ; doc           = "floating-point registers"
    ; indexwidth    = indexwidth count
    ; indexlimit    = Some count
    ; widths        = ws
    ; classification = Reg
    }
    
  let a ~count agg ws = checked 
    { space         = ('a', agg, Cell.of_size A.width)
    ; doc           = "address registers"
    ; indexwidth    = indexwidth count
    ; indexlimit    = Some count
    ; widths        = ws
    ; classification = Reg
    } 
  
  let p ~count agg ws = checked 
    { space          = ('p', agg, Cell.of_size 1)
    ; doc            = "predicate registers"
    ; indexwidth     = indexwidth count
    ; indexlimit     = Some count
    ; classification = Reg
    ; widths         = ws
    }
    

    (* CHECK THAT count IS LARGE ENOUGH TO COVER indicies BELOW -- CL*)
  let c ~count agg ws = checked 
    { space         = ('c', agg, Cell.of_size A.width)
    ; doc           = "control and special"
    ; indexwidth    = indexwidth count
    ; indexlimit    = Some count
    ; widths        = ws
    ; classification = Fixed
    } 

  let vf agg ws =
    let doc = "virtual frame pointer" in
    checked { space          = ('V', agg, Cell.of_size A.width)
            ; doc            = doc
            ; indexwidth     = 1
            ; indexlimit     = Some 1
            ; widths         = ws
            ; classification = Fixed
            } 

  let x agg ws = checked 
    { space          = ('\000', agg, Cell.of_size A.width)
    ; doc            = "boxed rtls"
    ; indexwidth     = 1
    ; indexlimit     = Some 1
    ; widths         = ws
    ; classification = Reg
    } 

  let tempspace letter ~forspace doc agg w = checked 
    { space         = (letter, Rtl.Identity, Cell.of_size w);
      doc           = doc;
      indexwidth    = A.width;
      indexlimit    = None;
      widths        = [w];
      classification = Temp  
        { stands_for = stands_for forspace agg w;
          set_doc    = doc;
        };
    } 

  let t = tempspace 't' ~forspace:'r' "general-purpose temporaries"
  let u = tempspace 'u' ~forspace:'f' "floating-point temporaries"
  let v = tempspace 'v' ~forspace:'a' "address temporaries"
  let w = tempspace 'w' ~forspace:'p' "predicate temporaries"
  
  let s align = tempspace (char_of_int align) ~forspace:'m' 
      (string_of_int align ^ " aligned stack-slots temporaries")

  type 'a locations = 
    { pc:       'a
    ; npc:      'a
    ; cc:       'a
    ; fp_mode:  'a  (* FP rounding mode   *)
    ; fp_fcmp:  'a  (* FP condition codes *)
    }
  
  let locations ~c = match c with    
    |   { space       = ('c',bo,_) as space
        ; indexwidth  = iw 
        } ->
            let reg n = Rtl.reg (space, n, Rtl.C 1) in
            { pc      = reg 0
            ; npc     = reg 1
            ; cc      = reg 2 
            ; fp_mode = Rtl.slice 2 0 (reg 4)   
            ; fp_fcmp = Rtl.slice 2 0 (reg 5) 
            }
    |   { space = (s,_,_) } -> Impossible.impossible 
            ( "Standard locations from space " ^ Char.escaped s)
                                 
  
  let indices = { pc = 0; npc = 1; cc = 2; fp_mode = 4 ; fp_fcmp = 5 }
  let vfpcell = Cell.of_size A.width
  let vfp = Rtl.fetch (Rtl.reg (('V',Rtl.Identity,vfpcell), 0, Rtl.C 1)) A.width
end
module Standard32 = Standard(struct let width = 32 end)
module Standard64 = Standard(struct let width = 64 end)

@
%%
\section{[[front_target/target.nw]]}
<<front_target/target.ml>>=
<<target.ml>>
@

<<front_target/target.mli>>=
<<target.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%
%%% ------------------------------------------------------------------ 
\section{Target Platform Description}
%%% ------------------------------------------------------------------ 
%%
%%{\qcc} is a cross compiler:  code can be generated for a target
%%platform different from the platform the compiler is executed on.  The
%%target platform can be chosen at run-time of the compiler. 
%%Consequently, targets must be described by an {\ocaml} value that can
%%be passed at run-time (rather than by a module, which can not). 
%%
<<target.mli>>=
<<map and machine types>>
val boxmach : unit machine
<<type cc>>
<<auxiliary types used to define type [[t]]>>
<<type t(target.nw)>>

<<exported functions>>
val space : ('pr, 'au, 'cc) t -> Rtl.space -> Space.t
@ 
%%The [[space]] function returns information about a particular space.
%%It is a checked run-time error to ask about a space not on the list
%%for the target.
%% 
<<type t(target.nw)>>=
type ('proc, 'automaton, 'cc) t = { 
  <<components of [[t]]>>
 }
@
%%Every target has a descriptive name.
<<components of [[t]]>>=
name: string;
@
%%A target is described by many small informations like pointer sizes
%%and one bigger chunk that describe calling conventions.  A single
%%platform can implement many calling conventions, which are identified
%%by names.  Calling conventions are not only selected at run-time, we
%%also intend to construct them at run-time.  For the time being,
%%however, we will rely on a fixed set of calling conventions.  
%%
%%% ------------------------------------------------------------------ 
\subsection{Calling Convention}
%%% ------------------------------------------------------------------ 
%%
%%A calling convention includes specifications for automata that
%%implement calling conventions.  In {\PAL} parameters are passed in
%%three different contexts:  into procedures, into continuations, and
%%out of both using [[return]].  Therefore, three different
%%specifications exist.
%%
%%The [[allocatable]] field is mutable so that it can easily be modified by
%%a backplane function. This is useful for running tests and specifying a set
%%of registers.
<<type cc>>=
type 'automaton cc' =      
    { sp:           Rtl.loc         (* stack pointer                      *)
    ; return:       Rtl.rtl         (* machine instr passed to Cfg.return *)
       (* NEEDS TO TAKE ALTS AND INDEX AS PARAMETER *)
    ; proc:         'automaton  (* pass parameter to a procedure      *)
    ; cont:         'automaton  (* pass parameter to a continuation   *)
    ; ret:          'automaton  (* return values                      *)
    ; mutable allocatable:  Register.t list (* regs for reg-allocation            *)
    (* THIS TYPE SHOULD INCLUDE INFORMATION ABOUT ALTERNATE RETURN CONTINUATIONS,
       IN PARTICULAR, HOW BIG IS EACH SLOT, AND DOES IT HOLD AN INSTRUCTION OR
       AN ADDRESS? *)
    ; stack_slots:  'automaton (* where private data go *)
    }
@ 
%%Continuations, spill locations and other private data of a procedures
%%lives on the run-time stack. These locations are issued by an
%%[[Automaton2.t]] value. The specification for that automaton is
%%determined by the calling convention.
%%
%%To obtain a calling convention, pass its name to the [[cc]] component
%%which will return the convention response.  It is a checked run-time
%%error to ask for an unknown calling convention.
%%WOULD Not\_found BE A BETTER EXCEPTION TO RAISE? THE ERROR MODULE BELONGS
%%TO THE FRONTEND.
%%
<<components of [[t]]>>=
mutable cc_specs: Automaton.cc_specs;
cc_spec_to_auto: string -> Automaton.cc_spec -> 'cc;
@ 
%%Even though the stack pointer depends on the calling convention, the
%%virtual frame pointer is the same everywhere.
%%(Its width is target-dependent.)
<<components of [[t]]>>=
vfp : Rtl.exp;   (* the (immutable) virtual frame pointer *)
   (* always equal to Vfp.mk T.pointersize *)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Bits and Pieces}
%%% ------------------------------------------------------------------ 
%%
%%Many of the following characteristics of a target are more or less
%%obvious.  A {\PAL} source can name hardware registers for variables. 
%%The [[register]] component provides the location for a given name.  We
%%could remember the width for type checking as well but we are wearing
%%our assembler hats for now.
%%
%%Field [[alignment]] is the alignment required to load or store a word
%%of size [[pointersize]].
<<components of [[t]]>>=
byteorder:      Rtl.aggregation   ; (* big/little endian, id *)
wordsize:       int               ; (* bits *)
pointersize:    int               ; (* bits *)
alignment:      int               ; (* alignment of word access *)
memsize:        int               ; (* smallest addressable unit, typically 8 *)
memspace:       Rtl.space         ; (* redundant with byte order, word size *)
float:          Float.t           ; (* floating pt name and semantics    *)
charset:        string            ; (* "latin1"  character encoding      *)
globals:        'automaton   ; (* Automaton to allocate global vars *)
@
%%We need to know how big a value can be loaded using an unaligned load
%%instruction. 
<<components of [[t]]>>=
max_unaligned_load : Rtl.count;  (* how many cells to load unaligned *)
@
%%
%%A target has many address spaces:  main memory, different register
%%sets, temporaries.  A [[Rtl.loc]] value describes a location within
%%such a space.  Each space is homogeneous in the sense that all its
%%cells have the same width.  When cells within one space are aggregated,
%%a common aggregation scheme is used, described by a space-specific
%%[[Rtl.aggregation]] value.  The cells within a space are addressed by
%%an integer expression denoting their \emph{address}.  All address
%%expressions for a space share a common width.  For example, memory
%%might by addressed by 32-bit wide addresses, registers by 5-bit wide
%%addresses. 
%%                
%%The [[spaces]] list enumerates all spaces used to compile for the
%%machine, including temporary spaces as well as the real hardware
%%spaces.
%%No space appears more than once on the list.
<<components of [[t]]>>=
spaces:          Space.t list;
@
%%The [[reg_ix_map]] tells us how many ($n$) fixed and hardware registers are in the
%%target machine and provides a mapping from these registers to integers from
%%$[0..n-1]$.
<<components of [[t]]>>=
reg_ix_map :     int * int Register.Map.t;
@
%%Variable placers may or may not need to distinguish between integer
%%and address spaces, depending on this flag.
<<components of [[t]]>>=
distinct_addr_sp:  bool;
@
<<components of [[t]]>>=
data_section:   string;          (* ASM section for global regs *)
@
%%
%%Code goes into the \emph{text} section, memory allocated for global
%%registers goes into the [[data_section]].
%%
%%% ------------------------------------------------------------------ 
\subsection{Identify Special Locations}
%%% ------------------------------------------------------------------ 
%%
%%We wish every target had a global register for the current
%%floating-point rounding mode.
%%The register is needed in the generic expander to deal with the
%%so-called ``implicit rounding mode'' floating-point conversions.
%%It must always be safe to compare [[rounding_mode]] for equality.
%%
%%The register may be available as a named hardware register.
<<components of [[t]]>>=
rounding_mode : Rtl.loc;
@ 
%%
%%On a machine without floating point, this register has to be defined
%%to some bogus value, which probably would make things go horribly
%%wrong.
%%One possibility would be to make this value have 
%%type [[Rtl.loc option]], but this might complicate the generic
%%expander.
%%Still, it's probably a good idea to do this, especially since the
%%front end could then detect and complain about use of floating-point
%%operators. 
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Named Hardware Registers}
%%% ------------------------------------------------------------------ 
%%
%%If a target provides names hardware registers, a user can request them
%%for a global {\PAL} register. A target advertises a map of known
%%hardware registers. 
<<components of [[t]]>>=
named_locs:    Rtl.loc Strutil.Map.t;
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Temporaries, Register indices, and Register Allocation}
%%% ------------------------------------------------------------------ 
%%
%%The register allocator (see \module{ocolorgraph.nw}) needs
%%target-specific informations about hardware registers and temporaries.
%%In particular:
<<exported functions>>=
val is_tmp : ('pr, 'au, 'cc) t -> Rtl.space -> bool  (* partially apply me *)
val fits:    ('pr, 'au, 'cc) t -> Rtl.space -> Register.t -> bool
@
%%\begin{itemize}
%%\item [[fits t sp r]] is true, if (hardware) register [[r]] can hold any 
%%      value from space [[sp]].  It is an unchecked run-time error
%%      unless [[sp]] is a temporary space from the target~[[t]].
%%
%%\item [[is_tmp t sp]] is true, if [[sp]] denotes a {\rtl} space that
%%      holds temporaries.  It should be partially applied for efficiency.
%%\end{itemize}
%%
%%We need to map hardware registers to small integers.
%%The registers in fixed and hardware spaces are sorted in increasing alphanumeric order,
%%first by the space identifier, then by index within the space.
%%The sorted list of $n$ registers is then mapped to the integers $[0 ... n-1]$.
%%The first element of the pair is the number $n$ of registers.
<<exported functions>>=
val mk_reg_ix_map : Space.t list -> (int * int Register.Map.t)
@
%%The RTLs should be returned in \emph{execution order}, i.e., the first
%%element of the list is the first to be executed.  \emph{ALERT! Perhaps
%%we ought to revisit these interfaces, since the role of the first
%%argument is baffling. ---NR} 
%%
%%
\subsection{The recognizer}
%%
%%For optimization, we need to know what an instruction is.
<<components of [[t]]>>=
is_instruction: Rtl.rtl -> bool;
@ 
%%
\subsection{Control-flow operations}
%%Several modules, including the expander, need to produce control-flow instructions.
%%For each target, we collect the control-flow functions in a [[machine]] record.
%%The machine record is synthesized by the expander, which makes use of the functions
%%  in the postexpander to fill out the machine record.
<<map and machine types>>=
type ('em, 'pr) map' = ('em, 'pr) Ep.pre_map =
    { embed   : 'em
    ; project : 'pr
    }
type brtl = Rtl.exp -> Rtl.rtl
type ('a,'b) map  = ('a -> 'b -> brtl Dag.branch, Rtl.rtl -> 'b) map'
type ('a,'b) mapc = ('a -> 'b -> brtl Dag.cbranch, Rtl.rtl -> 'b) map'

type 'a machine = 'a Mflow.machine =
  { bnegate:   Rtl.rtl -> Rtl.rtl
  ; goto:      ('a, Rtl.exp) map
  ; jump:      ('a, Rtl.exp) map
  ; call:      ('a, Rtl.exp) map
  ; branch:    ('a, Rtl.exp) mapc (* condition *)
  ; retgt_br:  Rtl.rtl -> brtl Dag.cbranch
  ; move:      'a -> src:Register.t -> dst:Register.t -> brtl Dag.block
  ; spill:     'a -> Register.t -> Rtlutil.aloc -> brtl Dag.block
  ; reload:    'a -> Rtlutil.aloc -> Register.t -> brtl Dag.block
  ; cutto:     ('a, Mflow.cut_args) map    (* newpc * newsp map*)
  ; return:    Rtl.rtl
  ; forbidden: Rtl.rtl   (* causes a run-time error *)
  }
@
<<components of [[t]]>>=
machine : 'proc machine;
@
%%We also define a generic target record, which uses boxing to store the \rtl\ fragments.
%%The branch negate operation of the boxed machine should never be called.
%%Similarly, the [[return]] and [[forbidden]] \rtls\ are meaningless.
<<boxed machine>>=
let boxmach =
  let fail _ = assert false in
  let crmap = { embed = (fun () e -> (DG.Nop, Box.Exp.box e))
              ; project = Box.Exp.unbox } in
  let x = (Space.Standard32.x R.LittleEndian [32]).Space.space in
  let bogus  = R.kill (R.reg (x, 0, (R.C 1))) in
  { bnegate = (fun _ -> assert false)
  ; goto = crmap
  ; jump = crmap
  ; call = crmap
  ; cutto = { embed =
                (fun _ ca -> (DG.Nop, Box.ExpList.box [ca.M.new_sp; ca.M.new_pc]))
            ; project = (fun box -> match Box.ExpList.unbox box with
                           | [sp; pc] -> {M.new_sp = sp; M.new_pc = pc}
                           | _ -> assert false)}
  ; branch = { embed   = (fun _ g -> DG.cond (fun _ -> Box.Guard.box g))
             ; project = (fun box -> Box.Guard.unbox box)}
  ; retgt_br  = fail
  ; move      = fail
  ; spill     = fail
  ; reload    = fail
  ; M.return  = bogus
  ; forbidden = bogus
  }
@
%%
%%% ------------------------------------------------------------------
\subsection{Code-generation assist}
%%% ------------------------------------------------------------------
%%
%%Some back ends (notably the \texttt{gcc} back end) want to transform
%%an AST before translating to~IR.
%%This translation is implemented by the [[tx_ast]] component.
%%Such a component should be polymorphic; that is, the type 
%%should actually be
%%[[\/'a . 'a Nelab.compunit -> 'a Nelab.compunit]],
%%but because this type isn't expressible in Caml, 
%%we use [[Auxfuns.void]] instead, and [[Nelab.rewrite]] 
%%will (unsafely) cast such a function back to a polymorphic type.
<<components of [[t]]>>=
tx_ast : Auxfuns.void Nelab.compunit -> Auxfuns.void Nelab.compunit;
@ 
%%% ------------------------------------------------------------------
\subsection{Code-generation capabilities}
%%% ------------------------------------------------------------------
%%
%%The [[capabilities]] record explains the code-generation capabilities
%%of the back end.
%%It can be used for several purposes:
%%\begin{itemize}
%%\item
%% Tell Kevin's widener which operators can be widened and how far
%%\item
%% Emit an informal explanation of what code a front end should generate
%%\item
%% Emit code for helping to test implementations of operators.
%%\end{itemize}
%%The capability record says what source code a back end promises to handle.
<<components of [[t]]>>=
capabilities: capabilities;
@ 
<<auxiliary types used to define type [[t]]>>=
type capabilities = {
    operators   : Rtl.opr   list;  (* operators that can be used *)
    literals    : Rtl.width list;  (* literals that can be used *)
    litops      : Rtl.opr   list;  (* operators usable on literals only *)
    memory      : Rtl.width list;  (* memory refs that can be used *)
    block_copy  : bool;            (* OK to copy large variables, large refs? *)
    itemps      : Rtl.width list;  (* what integer temporaries can be computed with *)
    ftemps      : Rtl.width list;  (* what floating temporaries can be computed with *)
    iwiden      : bool;            (* use int ops and literals at narrow widths? *)
    fwiden      : bool;            (* use float ops literals at narrow widths? *)
  }
@ 
%%The capability record is intended as information for front ends.
%%We also use it to generate test code.
%%But information in the capability record also has implications for the
%%promises made in a back end:
%%\begin{itemize}
%%\item
%%[[itemps]] means the postexpander promises to handle integer
%%operations on temporaries of these widths.
%%\item
%%[[ftemps]] means the postexpander promises to handle floating-point
%%operations on temporaries of these widths.
%%\item
%%[[iwiden]] means we promise to widen integer operators up to the
%%largest width in [[itemps]] (should be replaced with a list of
%%operator names)
%%\item
%%[[fwiden]] means we promise to widen floating-point operators up to the
%%largest width in [[ftemps]] (should be replaced with a list of
%%operator names)
%%\item
%%[[block_copy]] means we can generate copies between any two locations
%%of type [[bits]]$k$, where $k$~is a multiple of the target
%%[[memsize]].
%%By ``location'' we mean either a memory reference or a declared
%%variable.
%%\item
%%[[memory]] lists the widths at which the postexpander promises to
%%compile either ordinary loads and stores or extending loads and
%%low-bit stores.
%%\item
%%[[literals]] presumably identifies what size literals the postexpander
%%can handle in [[li]].
%%\item
%%[[operators]] means all the operators the postexpander can handle,
%%\emph{plus} operators that are handled in the generic expander or the
%%simplifier.
%%For some ideas about what operator is what, see the [[Opshape]]
%%module.
%%\item
%%[[litops]] lists operators that can't be handled by the postexpander,
%%but that can be evaluated at compile time by the simplifier (and so
%%can be applied to literals).
%%\end{itemize}
%%
%%An incapable back end has no capabilities whatever.
<<target.mli>>=
val incapable : capabilities  (* the completely useless back end *)
@
%%
%%[[minimal_capabilities]] returns a minimal set of capabilities, given the word size.
<<target.mli>>=
val minimal_capabilities: int -> capabilities
@ 
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation does not hold any surprises. We use module [[Map]]
%%to implement lookup tables for registers and calling conventions.
<<target.ml>>=
<<map and machine types>>
module DG = Dag
module M  = Mflow
module R  = Rtl
module S  = Space
module RP = Rtl.Private
module RU = Rtlutil
<<type cc>>
<<auxiliary types used to define type [[t]]>>
<<type t(target.nw)>>
<<boxed machine>>
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let incapable = { operators = []; literals = []; litops = []; memory = []; itemps = [];
                  ftemps = []; block_copy = false; iwiden = false; fwiden = false; }
let minimal_capabilities wordsize =
 { literals = [wordsize]
        ; block_copy = false
        ; itemps = [wordsize]
        ; ftemps = []
        ; iwiden = false
        ; fwiden = false
        ; litops = []
 ; memory = [wordsize]
 ; operators = List.map Rtl.Up.opr [
                         "sx",      [ 1; wordsize]
                       ; "zx",      [ 8; wordsize]
          (* for some reason, -interp always generates 8->32 zx instructions *)
                       ; "lobits",  [wordsize;  1]
                       ; "lobits",  [wordsize; wordsize]
                       ; "add",     [wordsize]
                       ; "addc",    [wordsize]
                       ; "and",     [wordsize]
                       ; "borrow",  [wordsize]
                       ; "carry",   [wordsize]
                       ; "com",     [wordsize]
                       ; "div",     [wordsize]
                       ; "divu",    [wordsize]
                       ; "false", []
                       ; "mod",     [wordsize]
                       ; "modu",    [wordsize]
                       ; "mul",     [wordsize]
                       ; "mulx",    [wordsize]
                       ; "mulux",   [wordsize]
                       ; "neg",     [wordsize]
                       ; "or",      [wordsize]
                       ; "quot",    [wordsize]
                       ; "popcnt",  [wordsize]
                       ; "rem",     [wordsize]
                       ; "rotl",    [wordsize]
                       ; "rotr",    [wordsize]
                       ; "shl",     [wordsize]
                       ; "shra",    [wordsize]
                       ; "shrl",    [wordsize]
                       ; "sub",     [wordsize]
                       ; "subb",    [wordsize]
                       ; "true", []
                       ; "xor",     [wordsize]
                       ; "eq",      [wordsize]
                       ; "ge",      [wordsize]
                       ; "geu",     [wordsize]
                       ; "gt",      [wordsize]
                       ; "gtu",     [wordsize]
                       ; "le",      [wordsize]
                       ; "leu",     [wordsize]
                       ; "lt",      [wordsize]
                       ; "ltu",     [wordsize]
                       ; "ne",      [wordsize]

                       ;  "add_overflows",  [wordsize]
                       ;  "div_overflows",  [wordsize]
                       ;  "mul_overflows",  [wordsize]
                       ;  "mulu_overflows", [wordsize]
                       ;  "quot_overflows", [wordsize]
                       ;  "sub_overflows",  [wordsize]
                       ; "not",     []
                       ; "bool",    []
                       ; "disjoin", []
                       ; "conjoin", []
                       ; "bit",     []
                   ];}

@
<<target.ml>>=
let space t s = 
  try List.find (fun x -> RU.Eq.space x.Space.space s) t.spaces
  with Not_found ->
    let (s, _, _) = s in
    impossf "Space '%c' not found in target '%s'\n" s t.name
@
<<target.ml>>=
let is_tmp { spaces = spaces } =
  List.fold_right
    (fun s rest ->
      match s.Space.classification with
      | Space.Temp _ -> (fun c -> RU.Eq.space c s.Space.space || rest c)
      | _ -> rest)
    spaces
    (fun _ -> false)
@ 
%%Given a list of spaces, it is quite easy to map the fixed or hardware registers
%%to small integers.
<<target.ml>>=
let mk_reg_ix_map spaces =
  let space_to_regs space =
    let rec list_to n =
      if n <= 0 then [0]
      else n :: list_to (n-1) in
    List.map (fun i -> (space.S.space, i, R.C 1))
             (list_to (match space.S.indexlimit with
                       | Some l -> l
                       | None   -> 1 lsl space.S.indexwidth)) in
  let regspaces =
    let keep s = match s.S.classification with S.Reg | S.Fixed -> true | _ -> false in
    List.filter keep spaces in
  Register.reg_int_map (List.concat (List.map space_to_regs regspaces))
@
<<target.ml>>=
let space_fits tmp =
  match tmp.Space.classification with
  | Space.Temp {Space.stands_for=ok} -> ok
  | _ -> let (sp, _, _) = tmp.Space.space in
         impossf "space_fits called on non-temp of space '%c'" sp

let fits t space =
  try space_fits (List.find (fun s -> RU.Eq.space s.Space.space space) t.spaces)
  with Not_found -> impossf "space not found in Target.fits"
@ 
\subsection{Lua support for exposing target capabilities}
%%
%%
%%Our main goal here is to explain the target informally to a front-end writer.
<<Lua utility functions written in Lua>>=
function w (...)  -- a valuable abbreviation
  write(Util.call(format, arg))
end

function Target.explain(t)
  t = t or backend or error('default back end did not get set')
  if type(t) == 'table' then t = t.target end
  if type(t) ~= 'userdata' then
    error(tostring(t) .. ' is not a target')
  end
  local cap = Target.capabilities(t)
  local name = Target.name(t)

  local ops = cap.operators
  w('==== Advertised capabilities of target %s ====\n\n', name)

  w('target %s has these metrics:\n', name)
  Target.emitmetrics(t, '  ')
  w('\n')

  w('target %s supports memory references in these sizes:\n', name)
  Target.showtypes('  %-6s[...]\n', cap.memory, '\n')

  w('target %s supports literal bit vectors in these sizes:\n', name)
  Target.showtypes('  nnnn :: %-6s\n', cap.literals, '\n')

  w('target %s can compute with C-- variables declared at these sizes:\n', name)
  Target.showtypes('  %-6s n;    // integer variable\n', cap.itemps);  
  Target.showtypes('  %-6s x;    // floating-point variable\n', cap.ftemps, '\n');  

  w('target %s implements these operators:\n', name)
  local defined = { }
  local i = 1
  while ops[i] do
    defined[ops[i].name] = 1
    Target.showop(ops[i])
    i = i + 1
  end
  w('\n')

  w('target %s can apply these operators to compile-time constant expressions only:\n',
    name)
  local defined = { }
  local i = 1
  local litops = cap.litops
  while litops[i] do
    defined[litops[i].name] = 1
    Target.showop(litops[i])
    i = i + 1
  end
  w('\n')

  w('target %s does *not* implement these operators:\n', name)
  i = 1
  local allops = Rtlop.opnames ()
  while allops[i] do
    if not defined[allops[i]] then
      write(format('  %%%s\n', allops[i]))
    end
    i = i + 1
  end

  if cap.iwiden then Target.widen_ok (name, 'integer')        end
  if cap.fwiden then Target.widen_ok (name, 'floating-point') end
  if cap.block_copy then <<announce block-copy support>> end
end
@ 
%%These utility functions help us emit repetitive messages.
<<Lua utility functions written in Lua>>=
function Target.showtypes(fmt, ts, s)
  local i = 1
  while ts[i] do
    w(fmt, Target.showty(ts[i]))
    i = i + 1
  end
  w(s or '')
end
@ 
%%
<<Lua utility functions written in Lua>>=
function Target.widen_ok(name, kind)
  w([[
The %s back end includes a 'widener' that allows you to declare %s
variables and write %s computations at widths smaller than the
natural widths shown above.  Your code is automatically rewritten to use
the natural width of the machine.
]], name, kind, kind)
end
@ 
%%
<<announce block-copy support>>=
w([[
The %s back end supports block copies.  This means you can declare
very wide variables and very wide memory references, but the only
thing you can do with them is copy the bits from one place to another.
For example, here is a mighty big swap operation:
  bits128 n, m;
  n = bits128[p];
  m = bits128[p+16];
  bits128[p]    = m;
  bits128[p+16] = n;
It should also be possible to pass such large variables as parameters
and return them as results.  Attempts to do arithmetic or other operations
very wide variables are doomed to failure.
]], name)
@ 
%%Return the source-language representation of a type.
<<Lua utility functions written in Lua>>=
function Target.showty(t)
  if type(t) == 'number' then
    return 'bits' .. t
  else
    return t
  end
end
@ 
%%To show an operator, we show its argument and result types.
%%If the argument is a width changer, we need to make the result width
%%part of its name, so we build the set of width changers.
<<Lua utility functions written in Lua>>=
Target.width_changers =
  Util.set { 'NaN', 'sx', 'zx', 'lobits', 'f2f', 'f2i', 'i2f' }

function Target.showop(op)
  local args, result = Rtlop.mono(op)
  if result then
    local ty = Target.showty
    w('  %-6s %%%s', ty(result), op.name)
    if Target.width_changers[op.name] then w(result) end
    w('(')
    local i = 1
    local pfx = ""
    while args[i] do
      w('%s%s', pfx, ty(args[i]))
      pfx = ', '
      i = i + 1
    end
    w(')\n')
  else
    w('  nonstandard operator %%%s\n', op.name)
  end
end
@ 
<<Lua utility functions written in Lua>>=
function Target.emitmetrics(t, pfx)
  local m = Target.metrics(t)
  pfx = pfx or ''
  w('%starget byteorder %s;\n', pfx, m.byteorder)
  w('%starget wordsize %d pointersize %d memsize %d;\n',
    pfx, m.wordsize, m.pointersize, m.memsize)
  w('%starget float "%s" charset "%s";\n', pfx, m.float, m.charset)
end

@ 

\chapter{[[front_zipcfg]]}

\section{[[front_zipcfg/avail.nw]]}
<<front_zipcfg/avail.ml>>=
<<avail.ml>>
@

<<front_zipcfg/avail.mli>>=
<<avail.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
\section{Available expressions}
%%
%%The purpose of this module is to help compute a set of ``available
%%expressions.''
%%This set is really a set of equalities that represent facts we know
%%about the state of the machine at a program point.
%%Each such equality identifies the contents of some location with the
%%value of some expression.
%%The equalities can drive both redundancy elimination and forward
%%substitution (peephole optimization).
%%
%%Here are the constructors.
%%If~[[a]] is the set of expressions available immediately before an
%%RTL~[[r]], then [[forward a r]] is the set of expressions available
%%immediately after~[[r]].
<<avail.mli>>=
type t   (* a set of available expressions *)
val forward : Rtl.rtl -> t -> t
val invalidate : Register.SetX.t -> t -> t  (* anything that depends on the set *)
val unknown : t  (* the unknown set (aka the infinite set: top) *)
val join : t -> t -> t (* effectively set intersection *)
val smaller : old:t -> new':t -> bool  (* has a set shrunk? (unknown at top) *)
@ 
%%To observe for forward substitution, we need to know what expression a
%%location holds.
%%To observe for redundancy elimination, we need to know what location
%%holds an expression.
<<avail.mli>>=
val in_loc  : t -> Rtl.Private.loc -> Rtl.Private.exp option
val has_exp : t -> Rtl.Private.exp -> Rtl.Private.loc option
@ 
%%We can substitute for locations that are known to be available.
%%When calling [[subst_exp a ls e]], it is a checked run-time error for
%%list [[ls]] to contain a location that is not available in~[[a]].
<<avail.mli>>=
val subst_exp : t -> Rtl.Private.loc list -> Rtl.Private.exp -> Rtl.Private.exp
@ 
%%We can print a set for debugging:
<<avail.mli>>=
val to_string : t -> string
@ 
%%
%%
\subsection{Implementation}
%%
%%
<<avail.ml>>=
module R   = Rtl
module RP  = Rtl.Private
module RU  = Rtlutil
module Up  = Rtl.Up
module Dn  = Rtl.Dn
module S   = RU.ToString
let () = Debug.register "avail" "available expressions"
let debug = Debug.on "avail"
@ 
%%The implementation is designed to try to maximize sharing and minimize
%%allocation, not for fast lookup.
%%Notice the lattice inversion!
%%A~``smaller'' fact has \emph{more} equalities!
<<avail.ml>>=
type t = Unknown | Known of (RP.loc * RP.exp) list
let unknown = Unknown
let smaller ~old ~new' =
  match old with
  | Unknown -> (match new' with Unknown -> false | Known _ -> true)
  | Known olds ->
      (match new' with
      | Unknown -> false
      | Known news -> List.length news < List.length olds)
@ 
<<avail.ml>>=
let in_loc t l = match t with
| Unknown -> None
| Known pairs -> try Some (List.assoc l pairs) with Not_found -> None

let has_exp t e = match t with
| Unknown -> None
| Known pairs ->
    try Some (fst (List.find (fun (_, e') -> RU.Eq.exp e e') pairs))
    with Not_found -> None
@ 
<<avail.ml>>=
let join a a' = match a, a' with
| Unknown, a' -> a'
| a, Unknown  -> a
| Known ps, Known ps' ->
    let primed (l, e) =
      List.exists (fun (l', e') -> RU.Eq.loc l l' && RU.Eq.exp e e') ps' in
    Known (List.filter primed ps)
@ 
%%THIS CODE IS BROKEN FOR THE CASE WHEN A LEFT-HAND SIDE ALSO APPEARS ON
%%A RIGHT-HAND SIDE.
%%IN SUCH A CASE, WE NEED TO SUBSTITUTE FOR THE EXISTING VALUE OF THE
%%LHS OR WE NEED TO GIVE UP.
%%(A less serious problem is that we may get multiple equivalents for
%%the same expression, and it is not clear which one(s) to use.)
<<avail.ml>>=
<<kills>>
<<substitution>>
<<invalidation>>
let forward rtl t =
  let pairs = match t with Unknown -> [] | Known ps -> ps in
  let locs = locs_killed rtl in
  let alocs = List.map RU.MayAlias.locs' locs in
  let aexps = List.map RU.MayAlias.exp'  locs in
  let add_new_pair l r new_pairs =
    if List.exists (fun aexp -> aexp r) aexps then
      <<if all interfering locations can be substituted, keep [[l, r]]; otherwise not>>
    else
      (l, r) :: new_pairs in
  let pairs = invalidate_pairs alocs aexps pairs in
  (* massive pessimism: do registers only *)
  let extend guarded pairs = match guarded with
  | RP.Const (RP.Bool true), RP.Store(RP.Reg _ as l, r, _) -> add_new_pair l r pairs
  | _ -> pairs in
  let RP.Rtl effects = Dn.rtl rtl in
  let pairs = List.fold_right extend effects pairs in
  if debug then
    begin
      Printf.eprintf "avail: forwarding past %s yields\n" (S.rtl rtl);
      List.iter
        (fun (l, r) -> Printf.eprintf "avail:   %s == %s\n"
                                      (S.loc (Up.loc l)) (S.exp (Up.exp r))) pairs;
    end;
  Known pairs
@ 
<<if all interfering locations can be substituted, keep [[l, r]]; otherwise not>>=
let badlocs = List.filter (fun l -> RU.MayAlias.exp' l r) locs in
if List.for_all (fun l -> List.mem_assoc l pairs) badlocs then
  (l, subst_exp (Known pairs) badlocs r) :: new_pairs
else
  new_pairs
@ 
%%We never remember a memory location, so we need only to identify
%%registers that are killed.
<<kills>>=
let locs_killed rtl =
  let add l locs = if List.mem l locs then locs else l :: locs in
  RU.FullReadWriteKill.fold ~write:add ~kill:add ~read:(fun _ locs -> locs)
    rtl []
@ 
<<substitution>>=
let subst_exp t ls e = match t, ls with
| _, [] -> e
| Known pairs, _ :: _ ->
    RU.Subst.Fetch.exp' ~guard:(fun l -> List.mem l ls)
      ~fetch:(fun l w -> List.assoc l pairs) e
| Unknown, _ :: _ -> Impossible.impossible "substitution with no available expressions"
@ 
<<invalidation>>=
let invalidate_pairs alocs aexps pairs =
  let invalidated (l, r) =
    List.exists (fun aloc -> aloc l) alocs || List.exists (fun aexp -> aexp r) aexps in
  if List.exists invalidated pairs then
    List.filter (fun p -> not (invalidated p)) pairs
  else
    pairs

let invalidate locs_killed t = match t with
| Unknown -> Unknown
| Known pairs ->
    let add l locs = Dn.loc (Rtl.regx l) :: locs in
    let locs = Register.SetX.fold add locs_killed [] in
    let alocs = List.map RU.MayAlias.locs' locs in
    let aexps = List.map RU.MayAlias.exp'  locs in
    Known (invalidate_pairs alocs aexps pairs)
@ 
<<avail.ml>>=
let to_string = function
  | Unknown -> "<?>"
  | Known [] -> "<nothing-available>"
  | Known les ->
      let print (l, e) =
        Printf.sprintf "\n  %s = %s"
          (RU.ToString.loc (Up.loc l)) (RU.ToString.exp (Up.exp e)) in
      String.concat "" (List.map print les)
@ 
\section{[[front_zipcfg/property.nw]]}
<<front_zipcfg/property.ml>>=
<<property.ml>>
@

<<front_zipcfg/property.mli>>=
<<property.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%
<<property.mli>>=
<<exposed representation>>
<<exported module types>>
@ 
%%
<<exported module types>>=
module type S = sig
  type 'a t   (* a property *)

  type list
  val list  : unit -> list    (* fresh, empty property list *)
  val clear : list -> unit   (* remove all properties *)

  val get    : 'a t -> list -> 'a
  val set    : 'a t -> list -> 'a -> unit
  val remove : 'a t -> list -> unit

  val prop : 'a matcher -> 'a t
end
@ 
<<exposed representation>>=
type rep =
  | Live_in      of Register.SetX.t  (* to be extended... *)
  | Vfp          of (Rtl.Private.exp * int)
  | Avail        of Avail.t
  | VarInMap     of Varmap.t
  | VarOutMap    of Varmap.t
  | VarOutMap'   of Varmap.y
  | VarCallInMap of Varmap.t
  | AllocPrefs   of (Register.t Register.Map.t * Register.t list Register.Map.t)
  | Distances of
     (int * (int * Varmap.def_dist Register.Map.t * Varmap.use_dist Register.Map.t))
    
type 'a matcher = { embed : 'a -> rep; project : rep -> 'a option; is : rep -> bool; }
@ 
%%
<<property.mli>>=
module M : S
@ 
<<property.ml>>=
let impossf fmt = Printf.kprintf Impossible.impossible fmt
<<exposed representation>>
<<exported module types>>

module M = struct
  <<implementation>>
end
@ 
%%
<<old implementation>>=
  type hcontainer = { uid : int; update : unit -> unit; }
  type 'a container = { make : 'a -> hcontainer;
                        pred : hcontainer -> bool;
                        peek : hcontainer -> 'a option; }
        
  let container = 
    let n = Reinit.ref 0 in
    fun () ->
      let id = !n in
      let () = n := id + 1 in
      let r = ref None in
      let make v = { uid = id; update = (fun () -> r := Some v); } in
      let peek c =
        if c.uid = id then
          let () = c.update() in
          let v = !r in
          let () = r := None in
          v
        else
          None in
      let pred c = c.uid = id in
      { make = make; pred = pred; peek = peek; }
        
  type void = Void of void

(*  let (_ : void -> hcontainer) = container *)

@ 
%%
<<implementation>>=
type 'a plist = 'a list
type list = { mutable props : rep plist }

let list () = { props = [] }
let length t = List.length t.props
let eq t t' = t == t'
let clear t = t.props <- []


let numPeeks: int ref = Reinit.ref 0
let numLinks: int ref = Reinit.ref 0
let maxLength: int ref = Reinit.ref 0
   
let stats () =
  Printf.eprintf "numPeeks = %d; maxLength = %d; avg pos = %4.2f"
    (!numPeeks) (!maxLength) (float (!numLinks) /. float (!numPeeks))


let get matcher list = 
  let rec loop l n =
    let update () =
      begin
        numLinks := n + !numLinks;
        if !numLinks < n then impossf  "property list numLinks overflow";
        if n > !maxLength then maxLength := n;
      end in
    match l with
    | [] -> (update (); raise Not_found)
    | e :: l ->
        match matcher.project e with
        | Some r -> (update (); r)
        | None -> loop l (n+1) in
  numPeeks := 1 + !numPeeks;
  if !numPeeks < 1 then impossf "propery list numPeeks overflow";
  loop list.props 0 

let remove matcher list =
  list.props <- List.filter (fun p -> not (matcher.is p)) list.props 
let add matcher list v = list.props <- matcher.embed v :: list.props
let set matcher list v = (remove matcher list; add matcher list v)

type 'a t = 'a matcher
let prop m = m
@ 
%%
%%
<<junk(property.nw)>>=

==> het-container.sig <==
(* Copyright (C) 1999-2002 Henry Cejtin, Matthew Fluet, Suresh
 *    Jagannathan, and Stephen Weeks.
 *
 * MLton is released under the GNU General Public License (GPL).
 * Please see the file MLton-LICENSE for license information.
 *)
signature HET_CONTAINER =
   sig
      type t

      val new: unit -> {make: 'a -> t,
			pred: t -> bool,
			peek: t -> 'a option}
   end

==> property-list.sig <==
(* Copyright (C) 1999-2002 Henry Cejtin, Matthew Fluet, Suresh
 *    Jagannathan, and Stephen Weeks.
 *
 * MLton is released under the GNU General Public License (GPL).
 * Please see the file MLton-LICENSE for license information.
 *)
type int = Int.t

signature PROPERTY_LIST = 
   sig
      type t

      (* remove all properties from the list *)
      val clear: t -> unit
      (* pointer equality of property lists *)
      val equals: t * t -> bool
      val length: t -> int
      (* create an empty property list *)
      val new: unit -> t
      (* create a new property *)
      val newProperty:
	 unit -> {
                  (* See if a property is in a property list.
		   * NONE if it isn't.
		   *)
		  peek: t -> 'a option,
		  (* Add the value of the property -- must not already exist. *)
		  add: t * 'a -> unit,
		  (* Remove a property from a property list.
		   * Noop if the property isn't there.
		   *)
		  remove: t -> unit
		  }
      val stats: unit -> Layout.t
   end

==> het-container.fun <==
(* Copyright (C) 1999-2002 Henry Cejtin, Matthew Fluet, Suresh
 *    Jagannathan, and Stephen Weeks.
 *
 * MLton is released under the GNU General Public License (GPL).
 * Please see the file MLton-LICENSE for license information.
 *)
functor ExnHetContainer():> HET_CONTAINER =
   struct
      type t = exn

      fun 'a new() =
	 let exception E of 'a
	 in {make = E,
	     pred = fn E _ => true | _ => false,
	     peek = fn E x => SOME x | _ => NONE}
	 end
   end

functor RefHetContainer():> HET_CONTAINER =
   struct
      type t = unit ref * (unit -> unit)

      fun 'a new() =
	 let
	    val id = ref()
	    val r: 'a option ref = ref NONE
	    fun make v = (id, fn () => r := SOME v)
	    fun peek(id', f) =
	       if id = id' then (f(); !r before r := NONE)
	       else NONE
	    fun pred(id', _) = id = id'
	 in {make = make, pred = pred, peek = peek}
	 end
   end

==> property-list.fun <==
(* Copyright (C) 1999-2002 Henry Cejtin, Matthew Fluet, Suresh
 *    Jagannathan, and Stephen Weeks.
 *
 * MLton is released under the GNU General Public License (GPL).
 * Please see the file MLton-LICENSE for license information.
 *)
functor PropertyList (H: HET_CONTAINER):> PROPERTY_LIST =
struct

datatype t = T of H.t list ref

fun new (): t = T (ref [])

fun length (T r) = List.length (!r)

val equals = fn (T r, T r') => Ref.equals (r, r')

fun clear (T hs) = hs := []

val numPeeks: int ref = ref 0
val numLinks: int ref = ref 0
val maxLength: int ref = ref 0
   
fun stats () =
   let open Layout
   in align
      [seq [str "numPeeks = ", Int.layout (!numPeeks)],
       seq [str "maxLength = ", Int.layout (!maxLength)],
       seq [str "average position in property list = ",
	    str let open Real
		in format (fromInt (!numLinks) / fromInt (!numPeeks),
			   Format.fix (SOME 3))
		end]]
   end

fun 'a newProperty () =
   let
      val {make, pred, peek = peekH} = H.new ()
      fun peek (T hs) =
	 let
	    fun loop (l, n) =
	       let
		  fun update () =
		     ((numLinks := n + !numLinks
		       handle Overflow => Error.bug "property list numLinks overflow")
		      ; if n > !maxLength
			   then maxLength := n
			else ())
	       in case l of
		  [] => (update (); NONE)
		| e :: l =>
		     case peekH e of
			r as SOME _ => (update (); r)
		      | NONE => loop (l, n + 1)
	       end
	    val _ =
	       numPeeks := 1 + !numPeeks
	       handle Overflow => Error.bug "propery list numPeeks overflow"
	 in
	    loop (!hs, 0)
	 end

      fun add (T hs, v: 'a): unit = hs := make v :: !hs

      fun remove (T hs) = hs := List.remove (!hs, pred)
   in
      {add = add, peek = peek, remove = remove}
   end

end
@
\section{[[front_zipcfg/unique.nw]]}
<<front_zipcfg/unique.ml>>=
<<unique.ml>>
@

<<front_zipcfg/unique.mli>>=
<<unique.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=2 sw=2 et: 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% 
%%% $Id: unique.nw,v 1.3 2005-06-03 02:02:19 nr Exp $
%%
%%% ------------------------------------------------------------------ 
\section{Unique identifiers, maps, and sets}
%%% ------------------------------------------------------------------ 
%%
<<unique.mli>>=
type uid
val eq : uid -> uid -> bool
val uid : unit -> uid
val distinguished_uid : uid    (* distinct from any other *)
<<exposed types(unique.nw)>>
module Map : MAP
module Set : SET
module Array : ARRAY
module Prop : Property.S with type list = uid
@ 
%%
<<exposed types(unique.nw)>>=
module type MAP = sig
  type 'a t
  val empty : 'a t
  val is_empty : 'a t -> bool
  val mem   : uid -> 'a t -> bool
  val add   : uid -> 'a -> 'a t -> 'a t
  val find  : uid -> 'a t -> 'a 
  val split : uid -> 'a t -> 'a * 'a t
    (* split k m = (find k m, remove k m) *)
  val splitp: (uid -> 'a -> bool) -> 'a t -> 'a * 'a t
    (* split based on predicate *)
  val union : 'a t -> 'a t -> 'a t          (* keep larger set on the right *)
  val fold  : (uid -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
  val iter  : ('a -> unit) -> 'a t -> unit
  val size  : 'a t -> int

  val map   : ('a -> 'b) -> ('a t -> 'b t)
end
@ 
%%
<<exposed types(unique.nw)>>=
module type SET = sig
  type t
  val empty : t
  val mem : uid -> t -> bool
  val add : uid -> t -> t
end
@ 
<<exposed types(unique.nw)>>=
module type ARRAY = sig
  type 'a t
  val make : uid list -> 'a -> 'a t
  val get  : 'a t -> uid -> 'a
  val set  : 'a t -> uid -> 'a -> unit
  val update : 'a t -> uid -> ('a -> 'a) -> unit
end
@ 
%%
\subsection{Implementation}
<<unique.ml>>=
module P = Property.M
type uid = int * P.list
let uid =
  let n = Reinit.ref 1 in
  fun () -> let u = !n in (n := u + 1; (u, P.list()))
let distinguished_uid = (0, P.list())

<<exposed types(unique.nw)>>

module Ord = struct
  type t = uid
  let compare : t -> t -> int = fun (u, _) (u', _) -> compare u u'
end
module Set = Set.Make (Ord)
module M = Map.Make (Ord)
module Map : MAP = struct
  include M
  let split u m = (find u m, remove u m)
  let splitp p m =
    let scan u v (yes, no) = match yes with
    | None when p u v -> (Some v, no)
    | _ -> (yes, add u v no) in
    match fold scan m (None, empty) with
    | (Some v, m) -> v, m
    | (None, _) -> raise Not_found
  let union m m' =
    let add u v m =
      if mem u m then
        raise (Invalid_argument (Printf.sprintf "Unique.Map.union dup key %d" (fst u)))
      else
        add u v m in
    fold add m m'
  let size m = fold (fun _ _ n -> n + 1) m 0
  let iter f m = iter (fun _ v -> f v) m
end

module Array : ARRAY = struct
  type 'a t = int Map.t * 'a array
  let make uids init =
    let rec build uids i map = match uids with
    | [] -> map, Array.make i init
    | u :: us -> build us (i+1) (Map.add u i map) in
    build uids 0 Map.empty

  let get (map, a) u   = Array.get a (Map.find u map)
  let set (map, a) u v = Array.set a (Map.find u map) v
  let update (map, a) u f =
    let i = Map.find u map in
    Array.set a i (f (Array.get a i))
end

let eq ((u,_):uid) (u',_) = u = u'

module Prop = struct
  type 'a t = 'a P.t
  type list = uid
  let list = uid
  let clear (_, l) = P.clear l
  let get p (_, l) = P.get p l
  let set p (_, l) v = P.set p l v
  let remove p (_, l) = P.remove p l
  let prop = P.prop
end

@ 
\section{[[front_zipcfg/varmap.nw]]}
<<front_zipcfg/varmap.ml>>=
<<varmap.ml>>
@

<<front_zipcfg/varmap.mli>>=
<<varmap.mli>>
@

%%%cg. -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% inc: \usepackage{alltt}
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%-------------------------------------------------------------------
\subsection{Variable Maps}
%-------------------------------------------------------------------
%%The variable map is the fundamental data structure that maps variables to locations
%%(registers and slots on the stack).
%%It is a dynamic, unchecked invariant that only temps (not hardware registers) are in
%%the domain of a variable map.
%%
%-------------------------------------------------------------------
%%\subsubsection{Interface}
%-------------------------------------------------------------------
%%We have some simple types for temps, locations, and location sets.
<<varmap.mli>>=
type reg  = Register.t
type rset = Register.Set.t
type temp = Register.t
type loc_pair  = { reg  : Register.t option; mem  : Rtlutil.aloc option }
type loc_pair' = { reg' : Register.t option; mem' : bool }
<<types for tracking defs and uses>>
@
%%The variable map supports standard map operations, as well as some unique operations
%%that help with register allocation.
%%
%%We have simple constructors to create and empty map, add a temp to a map, and remove a
%%temp from a map.
<<varmap.mli>>=
type t
val empty            : t
val add_reg          : temp -> Register.t   -> t -> t
val add_mem          : temp -> Rtlutil.aloc -> t -> t
val spill            : temp -> Rtlutil.aloc -> t -> t
val remove_reg       : temp -> Register.t   -> t -> t
val remove_mem       : temp -> Rtlutil.aloc -> t -> t

type y
val emptyy           : y
val is_empty'        : y -> bool
val add_reg'         : temp -> Register.t   -> y -> y
val add_mem'         : temp -> y -> y
val remove_mem'      : temp -> y -> y
val remove_reg'      : temp -> y -> y
val spill'           : temp -> y -> y
val join             : y -> y -> y
val eq'              : old:y -> new':y -> bool
@
%%We can also fold over a map, fold over each location a temp is in (the range), observe
%%the locations where a temp is stored, observe the temp stored in a register, or print a
%%map.
<<varmap.mli>>=
val fold             : (temp -> Register.t   -> 'a -> 'a) ->
                       (temp -> Rtlutil.aloc -> 'a -> 'a) -> t -> 'a -> 'a
val fold'            : (temp -> Register.t   -> 'a -> 'a) ->
                       (temp -> 'a -> 'a) -> y -> 'a -> 'a
val filter           : (temp -> bool) -> t -> t
val var_locs'        : t -> temp -> loc_pair
val var_locs''       : y -> temp -> loc_pair'
val temp_loc'        : y -> temp -> reg  option
val reg_contents     : t -> reg  -> temp option
val reg_contents'    : y -> reg  -> temp list
val print            : string -> t -> unit
val print'           : string -> y -> unit
@
%%The variable map also provides functions to determine which registers are available at
%%a given node.
<<varmap.mli>>=
val free_reg_inregs  : rset -> rset -> rset -> t -> rset -> bool -> reg -> bool
val free_reg_outregs : rset -> rset -> t -> rset -> bool -> reg -> bool
val alloc_inreg  : reg list -> rset -> rset -> rset -> t -> rset -> bool ->
                   temp -> reg
val alloc_outreg : reg list -> rset -> rset ->         t -> rset -> bool ->
                   temp -> reg
@
%%We also provide a function that makes two variable maps consistent.
%%The first map (the inmap) holds the variable that are live\_in to the node, and the
%%second map (the outmap) holds the variables that are live\_out of the node.
%%Because the second map may require spills to be inserted before the node, the maps have
%%to be synchronized.
<<varmap.mli>>=
val sync_maps : t -> t -> t * t
@
%-------------------------------------------------------------------
%%\subsubsection{Implementations}
%-------------------------------------------------------------------
%%We currently have only one implementation of a variable map.
%%This implementation allows each temp to be stored in only one location at a time.
%%Our representation keeps a map from temps to locations and register locations to temps
%%(to facilitate the spilling function, [[reg_contents]]).
<<varmap.ml>>=
open Nopoly

type reg  = Register.t
type rset = Register.Set.t
type temp = Register.t
type loc_pair  = { reg  : Register.t option; mem  : Rtlutil.aloc option }
type loc_pair' = { reg' : Register.t option; mem' : bool }
<<types for tracking defs and uses>>
module RM = Register.Map
module RS = Register.Set

type t = loc_pair  RM.t * temp RM.t
type y = loc_pair' RM.t * temp list RM.t
let impossf fmt = Printf.kprintf Impossible.impossible fmt
@
%%The constructors and observers are simple.
<<varmap.ml>>=
let empty_pair       = {reg = None; mem = None}
let def_reg pair r   = {pair with reg = r}
let def_mem pair m   = {pair with mem = m}
let pair_map_find    t   m = try RM.find t m with Not_found -> empty_pair


let empty            = (RM.empty, RM.empty)
let emptyy           = (RM.empty, RM.empty)
let is_empty' (vm, lm) = RM.is_empty vm && RM.is_empty lm
let remove_reg t r (vm, lm) =
  let lm' = RM.remove r lm in
  try match (RM.find t vm).mem with
      | None   -> (RM.remove t vm, lm')
      | Some m as m'-> (RM.add t {reg = None; mem = m'} vm, lm')
  with Not_found -> Impossible.impossible "DLS: Tried to remove unknown reg"
let filt r lst = List.filter (fun r' -> not (Register.eq r r')) lst
let lm_rem' r t lm = try RM.add r (filt t (RM.find r lm)) lm with Not_found -> lm
let lm_add' r t lm = RM.add r (t :: try RM.find r lm with Not_found -> []) lm
let remove_reg' t (vm, lm) =
  try let lp = RM.find t vm in
      match lp.reg' with
      | Some r -> let lm' = lm_rem' r t lm in
                  if lp.mem' then (RM.add t {reg' = None; mem' = true} vm, lm')
                  else (RM.remove t vm, lm')
      | None -> Impossible.impossible "DLS: Tried to remove unknown reg"
  with Not_found -> Impossible.impossible "DLS: Tried to remove unknown reg"

let remove_mem t _ (vm, lm) =
  try match (RM.find t vm).reg with
      | None   -> (RM.remove t vm, lm)
      | Some r as r' -> (RM.add t {reg = r'; mem = None} vm, lm)
  with Not_found -> Impossible.impossible "DLS: Tried to remove unknown mem"
let remove_mem' t (vm, lm as m) =
  try match (RM.find t vm).reg' with
      | None -> (RM.remove t vm, lm)
      | Some r as r' -> (RM.add t {reg' = r'; mem' = false} vm, lm)
  with Not_found -> m
@
%%We allow each temp to be in only one register and one memory location at a time.
%%There's an interesting time vs. memory tradeoff here:
%%we could change the remove function such that if it is asked to remove a
%%temp from a register, it verifies that the [[vm]] map also binds the temp
%%to the register -- that way, the add function need not change the [[lm]] map,
%%possibly saving memory.
%%location of the temp in the [[vm]] map
<<varmap.ml>>=
let add_reg t r (vm, lm) =
  try let lp = RM.find t vm in
      let lm' = match lp.reg with
                | Some r_old -> RM.remove r_old lm
                | None -> lm in
      (RM.add t {lp with reg = Some r} vm, RM.add r t lm')
  with Not_found -> (RM.add t {reg = Some r; mem = None} vm, RM.add r t lm)
let add_reg' t r (vm, lm) =
  try let lp = RM.find t vm in
      let lm' = match lp.reg' with
                | Some r_old -> lm_rem' r_old t lm
                | None -> lm in
      (RM.add t {lp with reg' = Some r} vm, lm_add' r t lm')
  with Not_found -> (RM.add t {reg' = Some r; mem' = false} vm, lm_add' r t lm)

let add_mem t m (vm, lm) =
  try (RM.add t {(RM.find t vm) with mem = Some m} vm, lm)
  with Not_found -> (RM.add t {reg = None; mem = Some m} vm, lm)
let add_mem' t (vm, lm) =
  try (RM.add t {(RM.find t vm) with mem' = true} vm, lm)
  with Not_found -> (RM.add t {reg' = None; mem' = true} vm, lm)

let spill t m (vm, lm) =
  let fail () = Impossible.impossible "DLS: can not spill temp" in
  try match RM.find t vm with
      | {reg = Some r} -> (RM.add t {reg = None; mem = Some m} vm, RM.remove r lm)
      | _ -> fail ()
  with Not_found -> fail ()
let spill' t (vm, lm) =
  let fail () = Impossible.impossible "failed to spill temp" in
  try match RM.find t vm with
      | {reg' = Some r} -> (RM.add t {reg' = None; mem' = true} vm,
                            lm_rem' r t lm)
      | _ -> fail ()
  with Not_found -> fail ()

let var_locs'  (vm, _) temp = RM.find temp vm
let var_locs'' (vm, _) temp = RM.find temp vm
let temp_loc' (vm, _) t = try (RM.find t vm).reg' with Not_found -> None
let reg_contents  (_, lm) reg = try Some (RM.find reg lm) with Not_found -> None
let reg_contents' (_, lm) reg = try RM.find reg lm with Not_found -> []
let fold f_r f_m (vm, _) zero =
  let app f t v z = match v with Some s -> f t s z | None -> z in
  RM.fold (fun t lp z -> app f_m t lp.mem (app f_r t lp.reg z)) vm zero
let fold' f_r f_m (vm, _) zero =
  let app  f t v z = match v with Some s -> f t s z | None -> z in
  let app' f t v z = match v with true -> f t z | false -> z in
  RM.fold (fun t lp z -> app' f_m t lp.mem' (app f_r t lp.reg' z)) vm zero

let filter f (vm, _ as maps) =
  let remove temp {reg = reg} (vm, lm as maps) =
    if f temp then maps
    else (RM.remove temp vm, match reg with Some r -> RM.remove r lm | None -> lm) in
  RM.fold remove vm maps
@
%%
%%Printing is easy.
<<varmap.ml>>=
let printReg ((s,_,_), i, Register.C n) =
  if n = 1 then Printf.sprintf "%c%d" s i
  else Printf.sprintf "%c%d:%d" s i n
let print msg (_, lm as map) =
  ( Printf.eprintf "%s\nOneLocVarMap:\n" msg
  ; fold (fun t (r:Register.t) () -> Printf.eprintf "%s -> %s\n" (printReg t) (printReg r))
         (fun t m () -> Printf.eprintf "%s -> mem_loc\n" (printReg t))
         map ()
  ; Printf.eprintf "  Reverse map:\n"
  ; RM.iter (fun r t -> Printf.eprintf "  %s -> %s\n" (printReg r) (printReg t)) lm
  ; flush stderr
  )
let print' msg (_, lm as map) =
  ( Printf.eprintf "%s\nOneLocVarMap:\n" msg
  ; fold' (fun t (r:Register.t) () -> Printf.eprintf "%s -> %s\n" (printReg t) (printReg r))
          (fun t () -> Printf.eprintf "%s -> mem_loc\n" (printReg t))
          map ()
  ; Printf.eprintf "  Reverse map:\n"
  ; RM.iter (fun r ts -> Printf.eprintf "  %s -> " (printReg r);
                         List.iter (fun t -> Printf.eprintf "%s, " (printReg t)) ts;
                         Printf.eprintf "\n") lm
  ; flush stderr
  )
@
%%If the outmap spills a temp that is assigned to a register in the inmap,
%%then the spill must happen in the inmap.
%%Note: We fold over the outmap, with the inmap as the accumulating parameter.
<<varmap.ml>>=
let sync_maps inmap (om_vm,_ as outmap) =
  (RM.fold (fun temp loc_pair (im_vm',_ as inmap') ->
              match loc_pair.mem with
              | Some m ->
                if Auxfuns.Option.is_none (pair_map_find temp im_vm').mem then
                  add_mem temp m inmap'
                else
                  inmap'
              | None   -> inmap')
           om_vm inmap, outmap)
@
%%Any registers explicitly allocated to hardware registers are unavailable.
%%Otherwise, the availability of registers depends on whether they have been assigned to
%%temps (as shown by the variable map).
<<varmap.ml>>=
let free_reg_inregs defs live_in live_out (_, lm) regs_used t_live_past_uses r =
  let not_in set = not (RS.mem r set) in
  not (RM.mem r lm) && not_in regs_used && not_in live_in &&
  not (t_live_past_uses && (RS.mem r defs || RS.mem r live_out))

let free_reg_outregs defs live_out (_, lm) regs_used _ r =
  let not_in set = not (RS.mem r set) in
  not (RM.mem r lm) && not_in regs_used && not_in defs && not_in live_out


(* If we have found a register to spill, we may only be able to use it for the
   live-in part of the instruction, or it may be good long-term. *)
type spill = NoneYet
           | LiveInOnly of Register.t
           | LongTerm   of Register.t
let alloc_inreg allregs defs live_in live_out (_, lm)
                regs_used live_past_use t =
(*printTempList "alloc_outreg allregs: " allregs;
printTempSet "regs_used: " regs_used;
printTempSet "live_out: " live_out;
printTempSet "defs: " defs;
*)
  let rec try_regs rs bst = match rs with
    | [] -> (match bst with LongTerm r -> r | LiveInOnly r -> r
             | NoneYet -> impossf "no register available for temp %s" (printReg t))
    | r::rs ->
        let liveinonly r = match bst with NoneYet -> LiveInOnly r | _ -> bst in
        let longterm r = match bst with LongTerm _ -> bst | _ -> LongTerm r in
        let not_in set = not (RS.mem r set) in
        if not_in regs_used && not_in live_in &&
              (not live_past_use || not_in live_out && not_in defs) then
          if RM.mem r lm then try_regs rs (longterm r)
          else r
        (* won't be live out: *)
        else if not_in regs_used && not_in live_in then try_regs rs (liveinonly r)
        else try_regs rs bst in
  try_regs allregs NoneYet

let alloc_outreg allregs defs live_out (_, lm) regs_used _ t =
(*printTempList "alloc_outreg allregs: " allregs;
printTempSet "regs_used: " regs_used;
printTempSet "live_out: " live_out;
printTempSet "defs: " defs;
*)
  let rec try_regs rs bst = match rs with
    | [] -> (match bst with LongTerm r -> r | LiveInOnly r -> r
             | NoneYet -> impossf "no register available for temp %s" (printReg t))
    | r::rs ->
        let longterm r = match bst with LongTerm _ -> bst | _ -> LongTerm r in
        let not_in set = not (RS.mem r set) in
        if not_in regs_used && not_in live_out && not_in defs then
          if RM.mem r lm then try_regs rs (longterm r)
          else r
        else try_regs rs bst in
  try_regs allregs NoneYet
@
%%A simple join, where a memory location is the join of two conflicting registers.
<<varmap.ml>>=
let join (m1, _) (m2, _) =
  let upd t lp1 lp2 maps = match (lp1, lp2) with
  | ({reg' = Some r1; mem' = false}, {reg' = Some r2; mem' = false})
      when Register.eq r1 r2 -> add_reg' t r1 maps
  | ({reg' = Some r1; mem' = true}, {reg' = Some r2; mem' = true})
      when Register.eq r1 r2 -> add_mem' t (add_reg' t r1 maps)
  | _ -> add_mem' t maps in
  RM.fold (fun temp lp z -> upd temp lp (try RM.find temp m2 with Not_found -> lp) z)
          m1 empty

let eq' ~old:(m2, _) ~new':(m1, _) =
  let is_eq m' t lp1 b =
    b && try let lp2 = RM.find t m' in
             (match (lp1.reg', lp2.reg') with
              | (Some r1, Some r2) -> Register.eq r1 r2
              | (None, None) -> true
              | _ -> false) &&
             (lp1.mem' =:= lp2.mem')
         with Not_found -> false in
  RM.fold (is_eq m2) m1 true (* only equality on a subset... *)
@
%%
%%The register allocators can do a better job if they have some idea when a temp is used
%%or defined. Basically, we keep track of the distance from the current instruction to
%%the next use or definition.
%%
%%These type definitions really don't belong here, but I need somewhere that won't
%%trigger a recursive module error. I should probably just start a new file.
%%
%%We want two pieces of information about the use of a temp:
%%  when is the next use, and when is the last use.
<<types for tracking defs and uses>>=
type use_dist = Use of (int * int)
@
%%Now some complications in an attempt to improve copy coalescing.
%%I'm not sure they're worth the trouble.
%%
%%For definitions, we're tracking not just the next definition but the (possibly empty)
%%sequence of copies terminated by a non-copy definition.
%%To keep this sequence accurate, we need to be able to identify specific definition
%%sites in the cfg. We identify the definition by two integers: one that is associated
%%with the basic block (by some mechanism we don't specify) and one that identifies the
%%particular definition within the basic block.
%%The basic block may be unknown (and filled in later), thus the option type.
<<types for tracking defs and uses>>=
type hwdef_num = (int * int option) (* (n, m):  nth def in basic block m *)
type hwdef = Copy    of (hwdef_num * int * Register.t * hwdef)
           | NonCopy of int
@
%%Finally, a definition is either of a hardware register or of a temporary, in which case
%%we keep just the next two definitions, using [[maxint]] if there is no such definition.
<<types for tracking defs and uses>>=
type def_dist = HW of hwdef
              | Temp of (int * int)

@ 
\section{[[front_zipcfg/zipcfg.nw]]}
<<front_zipcfg/zipcfg.ml>>=
<<zipcfg.ml>>
@

<<front_zipcfg/zipcfg.mli>>=
<<zipcfg.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=2 sw=2 et: 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% 
%%% $Id: zipcfg.nw,v 1.11 2006-08-24 21:19:43 dias Exp $
%%
%%% ------------------------------------------------------------------ 
\section{Applicative Control-Flow Graph, Based on Huet's Zipper}
%%% ------------------------------------------------------------------ 
%%
%%
%%\citet{huet:zipper} describes a generalization of a tree that enables
%%a program to focus on a single node while enabling the context (e.g.,
%%parents) to be represented by an explicit, reified value (as opposed
%%to being captured in an implicit continuation).
%%We investigate this idea for a control-flow graph.
%%
%%Every graph has a single entry and zero or more exits.
%%(For example, the graph for a procedure has no exits, the graph
%%for an expanded instruction has one exit, and the graph for an
%%expanded conditional branch has two exits.)
%%A~[[graph]] is a set of basic blocks, one of which is distinguished as the
%%entry block.
%%Every other block is tagged by a
%%unique id, which may correspond to a string label.\footnote
%%{Maintaining a mapping between strings and unique ids is not the
%%  responsibility of this module.}
%%
%%An exit is typically represented by explicit control flow to a unique id,
%%which corresponds to a block in another graph.
%%Exits also include special nodes that stop control flow, such as a
%%``return'' node or a ``forbidden'' node.
%%Finally, a graph may have at most one ``default exit,'' by which
%%control flows out of the graph when not otherwise directed.
%%A~default exit is useful only in a subgraph; because control may not
%%fall off the end of a {\PAL} procedure, the graph for an entire
%%procedure should not have a default exit.
%%
%%
%%A~[[zgraph]] is a graph with the \emph{focus} on one particular edge.
%%It supports at least the following kinds of operations:
%%\begin{itemize}
%%\item
%%Insert a new node at the focus, and maintain the focus on the current edge.
%%\end{itemize}
%%Here are some basic types and operations:
<<zipcfg.mli>>=
type uid = Unique.uid
type label = uid * string

type regs  = Register.SetX.t  (* sets of regs for dataflow *)
type contedge = { kills:regs; defs:regs; node:label; assertion:Rtl.rtl }

module Rep : sig
  <<exposed types for [[Rep]] module>>
  <<declarations of [[Rep]]'s public functions>>
end

type graph
type zgraph

val empty   : graph
val entry   : graph -> zgraph           (* focus on edge out of entry node *)
val exit    : graph -> zgraph           (* focus on edge into default exit node *)
val focus   : uid -> graph -> zgraph    (* focus on edge out of node with uid *)
val unfocus : zgraph -> graph           (* lose focus *)
@ 
%%%%  Subgraph replacement:
%%%%  we replace the node at the focus with a graph.
%%%%  The number of exits in the replacement graph must be equal to the
%%%%  number of successors of the focus node; otherwise it is a checked run-time
%%%%  error. 
%%%%  After replacement, the focus looks at the successor of the replacement
%%%%  graph's entry node.
%%%%  <zipcfg.mli>=
%%%%  val replace_focus : zgraph -> graph -> zgraph
%% 
%%We can insert a single-entry, single-exit subgraph at
%%the current focus.
%%The new focus can be at either the entry edge or the exit edge.
<<zipcfg.mli>>=
val splice_focus_entry : zgraph -> graph -> zgraph
val splice_focus_exit  : zgraph -> graph -> zgraph
@ 
%%Sometimes we just want to add blocks to an existing graph~[[g]].
%%We do it by creating a fresh graph~[[gz]]; the focus should be on the
%%edge leaving the entry node, which becomes unreachable.
%%The exit node of the new graph should also be unreachable.
%%The code is used in [[Ast2ir]] to add a continuation's prolog.
%%
%%This is pretty ugly; it's a consequence of our being willing to insert
%%new nodes only following an entry node.  Maybe something less ugly is
%%lurking somewhere.  
<<zipcfg.mli>>=
val add_blocks : graph -> zgraph -> graph
@ 
%%Building a graph.
%%The entry plays a dual role here; every constructor effectively
%%requires the focus be on the edge leaving the entry node and inserts a
%%new node at that edge.
%%After insertion, the focus remains on the edge leaving the entry node.
%%
%%Here we also introduce the [[nodes]] type, which is equal to
%%[[zgraph -> zgraph]].
%%The idea is that we represent a sequence of nodes~$L$ by a function
%%that takes the successor~$S$ and produces the sequence~$LS$.
%%This representation is inspired by John Hughes's similar
%%representation of lists, which supports append in constant time.
<<zipcfg.mli>>=
val uid : unit -> uid
type exp_of_lbl = label -> Rtl.exp (* exp of code label *)
type 'a machine = 'a * 'a Mflow.machine * exp_of_lbl (* useful pairing *)
type nodes      = zgraph -> zgraph (* sequence of nodes in Hughes's representation *)
type cbranch    = ifso:label -> ifnot:label -> nodes (* ability to branch conditionally *)

val label        : 'a machine -> label -> nodes  (* spans? *)
val instruction  : Rtl.rtl -> nodes
val stack_adjust : Rtl.rtl -> nodes
val branch       : 'a machine -> label -> nodes
val jump         : 'a machine -> Rtl.exp -> uses:regs -> targets:string list -> nodes
val cbranch      : 'a machine -> Rtl.exp -> cbranch
val mbranch      : 'a machine -> Rtl.exp -> targets:label list -> nodes
val call         : 'a machine -> Rtl.exp -> altrets:contedge list -> 
                     unwinds_to:contedge list -> cuts_to:contedge list ->
                     aborts:bool -> uses:regs -> defs:regs -> kills:regs ->
                     reads:string list option -> writes:string list option ->
                     spans:Spans.t option -> succ_assn:Rtl.rtl -> nodes
val cut_to       : 'a machine -> Mflow.cut_args -> cuts_to:contedge list ->
                              aborts:bool -> uses:regs -> nodes
val return       : Rtl.rtl -> exit:int -> uses:regs -> nodes
val forbidden    : 'a machine -> nodes
  (* control should not reach; causes checked RTE *)
@ 
%%As a convenience, we provide code generation for if-then-else and while-do.
<<zipcfg.mli>>=
val if_then_else : 'a machine -> cbranch -> t:nodes -> f:nodes -> nodes
val while_do     : 'a machine -> cbranch -> body:nodes -> nodes
@ 
%%A limitcheck is a degenerate form of [[if]] with a special label.
<<zipcfg.mli>>=
val limitcheck : 'a machine -> cbranch -> t:nodes -> nodes
@ 
%%Sometimes we need to make the current focus (which must be the edge
%%leaving the entry)
%%a branch target to be used later.
%%Calling [[make_target gz]] returns a new graph and a unique identifier
%%to which the entry flows in.
<<zipcfg.mli>>=
val make_target : 'a machine -> zgraph -> label * zgraph
@ 
%%Mutation---ugh!
<<zipcfg.mli>>=
val set_spans : zgraph -> Spans.t -> unit  (* set spans at node preceding focus *)
@ 
%%We can also make a graph out of a single [[middle]] or [[last]] node.
<<zipcfg.mli>>=
val single_middle : Rep.middle -> graph
val single_last   : Rep.last   -> graph
@ 
%%\subsubsection{Exposure}
%%
%%A basic block is a [[first]] node, followed by zero or more [[middle]]
%%nodes, followed by a [[last]] node.
<<exposed types for [[Rep]] module>>=
type 'a edgelist = 'a list (* could be array *)
<<node types>>
type labelkind
  = Userlabel  (* user-written; cannot be deleted *)
  | Genlabel   (* generated; can be deleted *)
  | Limitlabel (* generated after limit check; cannot be deleted *)

type first
  = Entry
  | Label of label * labelkind * Spans.t option ref

type middle
  = Instruction  of Rtl.rtl
  | Stack_adjust of Rtl.rtl

type last
  = Exit
  | Branch  of Rtl.rtl * label
  | Cbranch of Rtl.rtl * label * label    (* true, false *)
  | Mbranch of Rtl.rtl * label edgelist (* possible successors *)
  | Call    of call  
  | Cut     of Rtl.rtl * contedge edgelist * regs  (* out edges, registers used *)
  | Return  of exit_num * Rtl.rtl * regs
  | Jump    of Rtl.rtl * regs * string list  (* inst, registers used, targets *)
  | Forbidden of Rtl.rtl (* cause a run-time error *)
and exit_num = int
@ 
%%In a complete graph for a procedure, the [[Exit]] node should not
%%appear, but it is useful in a subgraph (e.g., replacement for a node).
%%
%%To sequence these things,
%%a~[[head]] is a [[first]] followed by zero or more [[middle]]s.
%%A~[[tail]] is  zero or more [[middle]]s followed by a [[last]].
<<exposed types for [[Rep]] module>>=
type head = First of first | Head of head * middle
type tail = Last  of last  | Tail of middle * tail
@
%%And now the zipper.  The focus is between the head and tail.
%%Notice we cannot ever focus on an inter-block edge.
<<exposed types for [[Rep]] module>>=
type zblock = head * tail
@
%%A block need not be in zipper form:
<<exposed types for [[Rep]] module>>=
type block = first * tail
@ 
%%We expose some utility functions:
<<declarations of [[Rep]]'s public functions>>=
val id  : block -> uid
val blocklabel : block -> label option (* entry block has no label *)
val blockkind  : block -> labelkind option (* entry block has no kind  *)
val fid : first -> uid
val entry_uid : uid

val zip   : zblock -> block
val unzip : block  -> zblock

val first      : zblock -> first
val last       : zblock -> last
val goto_start : zblock -> first * tail
val goto_end   : zblock -> head  * last
@ 
%%Some ways to combine parts:
<<declarations of [[Rep]]'s public functions>>=
val ht_to_first : head -> tail -> first * tail
val ht_to_last  : head -> tail -> head  * last
val zipht       : head -> tail -> block
@ 
%%We can splice a single-entry, single-exit graph onto a head or a tail.
%%For a head, we have a head~[[h]] followed by a graph~[[g]].
%%The entry node of~[[g]] gets joined to~[[h]], forming the entry into
%%the new graph.  The exit of~[[g]] becomes the new head.
%%For both arguments and results, the order of values is the order of
%%control flow: before splicing, the head flows into the graph; after
%%splicing, the graph flows into the head.
%%Splicing a tail is the dual operation.
%%(In order to maintain the order-means-control-flow convention, the
%%orders are reversed.)
<<zipcfg.mli>>=
val splice_head : Rep.head -> graph -> graph * Rep.head
val splice_tail : graph -> Rep.tail -> Rep.tail * graph
@ 
%%We can also splice a single-entry, no-exit graph into a head.
<<zipcfg.mli>>=
val splice_head_only : Rep.head -> graph -> graph
@ 
%%Finally, we can find the entry node of a graph and remove it, leaving
%%a tail leading into the rest of the graph:
<<zipcfg.mli>>=
val remove_entry : graph -> Rep.tail * graph
@ 
%%Access to the representation:
<<zipcfg.mli>>=
val to_blocks : graph -> Rep.block Unique.Map.t
val of_blocks : Rep.block Unique.Map.t -> graph  (* cheap *)
val of_block_list : Rep.block list -> graph  (* expensive *)
val openz : zgraph -> Rep.zblock * Rep.block Unique.Map.t
val tozgraph : Rep.zblock * Rep.block Unique.Map.t -> zgraph
@
%%Traversal: [[postorder_dfs]] returns a list of blocks reachable from
%%the entry node.
%%The postorder depth-first-search order means the list is in roughly
%%first-to-last order, as suitable for use in a forward dataflow problem.
<<zipcfg.mli>>=
val postorder_dfs : graph -> Rep.block list
@ 
%%For layout, we fold over pairs of type [[block * label option]] in
%%layout order.
%%The [[label]], if any, identifies the block that will be the layout
%%successor of the current block.
%%This may be useful to help an emitter omit the final [[goto]] of a
%%block that flows directly to its layout successor.
<<zipcfg.mli>>=
val fold_layout : (Rep.block -> label option -> 'a -> 'a) -> 'a -> graph -> 'a
@ 
%%We can also fold and iterate over blocks.
<<zipcfg.mli>>=
val fold_blocks : (Rep.block -> 'a -> 'a) -> 'a -> graph -> 'a
val iter_blocks : (Rep.block -> unit) -> graph -> unit
@ 
<<zipcfg.mli>>=
val expand : (Rep.middle -> graph) -> (Rep.last -> graph) -> graph -> graph
@ 
%%
%%\paragraph{Observing nodes}
%%Successors.
<<declarations of [[Rep]]'s public functions>>=
val succs : last -> uid list
val fold_succs : (uid -> 'a -> 'a) -> last -> 'a -> 'a
val iter_succs : (uid -> unit) -> last -> unit
@
<<declarations of [[Rep]]'s public functions>>=
val mid_instr  : middle -> Rtl.rtl
val last_instr : last -> Rtl.rtl  (* may be nop for, e.g., [[Exit]] *)
@ 
%%No [[first]] node is executable, some [[middle]] nodes are executable,
%%and all [[last]] nodes are executable.
<<declarations of [[Rep]]'s public functions>>=
val is_executable : middle -> bool
@ 
<<zipcfg.mli>>=
val iter_spans : (Spans.t -> unit) -> graph -> unit
val fold_spans : (Spans.t -> 'a -> 'a) -> graph -> 'a -> 'a
@ 
%%Fold from first to last
<<declarations of [[Rep]]'s public functions>>=
val fold_fwd_block :
  (first -> 'a -> 'a) -> (middle -> 'a -> 'a) -> (last -> 'a -> 'a) ->
  block -> 'a -> 'a
@ 
<<zipcfg.mli>>=
val iter_nodes :
  (Rep.first -> unit) -> (Rep.middle -> unit) -> (Rep.last -> unit) -> graph -> unit
val iter_rtls : (Rtl.rtl -> unit) -> graph -> unit
@ 
<<zipcfg.mli>>=
val map_rtls : (Rtl.rtl -> Rtl.rtl) -> graph -> graph
val map_nodes :
  (Rep.first -> Rep.first) -> (Rep.middle -> Rep.middle) -> (Rep.last -> Rep.last) ->
  graph -> graph
@ 
<<zipcfg.mli>>=
val new_rtlm : Rtl.rtl -> Rep.middle -> Rep.middle
val new_rtll : Rtl.rtl -> Rep.last   -> Rep.last
val map_rtlm : (Rtl.rtl -> Rtl.rtl) -> Rep.middle -> Rep.middle
val map_rtll :
  map_rtl:(Rtl.rtl -> Rtl.rtl) -> map_assn:(Rtl.rtl -> Rtl.rtl) -> Rep.last -> Rep.last
@ 
%%\paragraph{Observing data flow}
%%As noted above a node can contribute defs, uses, and kills to each
%%outedge, and a non-join node may contribute uses to each inedge.
%%The access to this information is carefully crafted to support
%%liveness analysis and to provide for efficient implementation in the
%%common case where there is no dataflow.
%%
%%The [[union_over_outedges]] function is written in continuation-passing
%%style.  The [[noflow]] continuation is used in the common case when an
%%edge bears no dataflow information; the [[flow]] continuation is used
%%in the general case.  Clients must guarantee that
%%[[noflow n = flow {node=n; defs=empty; kills=empty}]].
<<zipcfg.mli>>=
val union_over_outedges :
  Rep.last -> noflow:(uid -> regs) -> flow:(contedge -> regs) -> regs
@ 
%%Function [[union_over_outedges]] is good for backward problems; the
%%corresponding function for forward problems is [[iter_outedges]].
<<zipcfg.mli>>=
val iter_outedges :
  Rep.last -> noflow:(uid -> unit) -> flow:(contedge -> unit) -> unit
@
%%Calling [[add_inedge_uses n l]] returns the union of~[[l]] with any
%%uses on the inedge to~[[n]].
%%It is defined on \emph{all} nodes, because there are no uses on the
%%inedges of a join point.
%%In the common case, it returns its second argument.
%%Calling [[add_live_spans n l]] returns the union of~[[l]] with any
%%registers kept live in spans.
%%Spans keep register live if they may be needed to walk the stack.
<<zipcfg.mli>>=
val add_inedge_uses : Rep.last  -> regs -> regs
val add_live_spansl : Rep.last  -> regs -> regs
val add_live_spansf : Rep.first -> regs -> regs
@ 
%%
%%\paragraph{Conversion from a DAG}
%%Parts of the compiler work with DAG's for convenience, but eventually we need to
%%  convert the DAGs to CFGs.
<<zipcfg.mli>>=
val block_before : 'a machine -> (Rtl.exp -> Rtl.rtl) Dag.block -> zgraph ->
                     (zgraph * bool)
val block2cfg    : 'a machine -> (Rtl.exp -> Rtl.rtl) Dag.block -> (zgraph * bool)
val cbranch2cfg  : 'a machine -> (Rtl.exp -> Rtl.rtl) Dag.cbranch ->
                     ifso:label -> ifnot:label -> zgraph -> (zgraph * bool)
@
%%
%%\clearpage
\subsection{Implementation}
%%
<<zipcfg.ml>>=
open Nopoly

module DG  = Dag
module M   = Mflow
module R   = Rtl
module RSX = Register.SetX
module U   = Unique
module UM  = Unique.Map
module US  = Unique.Set

let impossf fmt = Printf.kprintf Impossible.impossible fmt
let unimpf  fmt = Printf.kprintf Impossible.unimp      fmt
let ( **> ) f x = f x

type uid        = U.uid
type label      = uid * string
type exp_of_lbl = label -> Rtl.exp (* exp of code label *)
type 'a machine = 'a * 'a Mflow.machine * exp_of_lbl (* useful pairing *)
let uid         = U.uid
@ 
%%\paragraph{Nodes and basic blocks}
%%It is OK to open [[Rep]] because the definition is sitting right
%%here---this [[open]] does not create the stereotypical problem of a
%%mysterious [[open]] from a separately compiled module.
<<zipcfg.ml>>=
type regs = Register.SetX.t (* sets of regs for dataflow *)
type contedge = { kills:regs; defs:regs; node:label; assertion: Rtl.rtl }

module Rep = struct
  let entry_uid = U.distinguished_uid
  <<exposed types for [[Rep]] module>>
  <<definitions of [[Rep]]'s public functions>>
end
open Rep
@ 
%%
<<node types>>=
type call = {         cal_i          : Rtl.rtl
            ;         cal_contedges  : contedge edgelist
            ;         cal_spans      : Spans.t option
            ; mutable cal_uses       : regs
            ;         cal_altrets    : int
            ;         cal_unwinds_to : int
            ;         cal_cuts_to    : int
            ;         cal_reads      : string list option
            ;         cal_writes     : string list option
            }
@
%%
%%\paragraph{Block manipulations}
<<definitions of [[Rep]]'s public functions>>=
let fid = function Entry -> entry_uid | Label ((u, _), _, _) -> u
let id (f, t) = fid f
let blocklabel (f, t) = match f with
| Entry -> None
| Label (l, _, _) -> Some l
let blockkind (f, t) = match f with 
| Entry -> None
| Label (_, k, _) -> Some k
@ 
%%Convert block between forms.
%%These functions are tail-recursive, so we can go as deep as we like
%%without fear of stack overflow.  
<<definitions of [[Rep]]'s public functions>>=
let rec ht_to_first head tail = match head with
  | First f -> f, tail
  | Head (h, m) -> ht_to_first h (Tail (m, tail)) 

let goto_start (h, t) = ht_to_first h t

let rec ht_to_last head tail = match tail with
| Last l -> head, l
| Tail (m, t) -> ht_to_last (Head (head, m)) t 

let goto_end (h, t) = ht_to_last h t

let zip = goto_start
let zipht = ht_to_first
let unzip (n, ns) = (First n, ns)
@ 
%%
<<definitions of [[Rep]]'s public functions>>=
let rec lastt = function (Last l) -> l | Tail (_, t) -> lastt t 
let last (h, t) = lastt t
let first =
  let rec first = function (First f) -> f | Head (h, _) -> first h in
  fun (h, t) -> first h
@ 
%%
%%\paragraph{Graph}
%%For the graph, we want to be able to look up a block efficiently by
%%its unique id.  
%%For the time being, we use a list:
<<zipcfg.ml>>=
module type BLOCKS = sig
  type t
  val empty  : t
  val insert : block -> t -> t
  val find   : t -> uid -> block 
  val focus  : t -> uid -> block * t
  val focusp : t -> (block -> bool) -> block * t
  val union  : t -> t -> t
        (* keep larger set on the right *)

  val fold   : (block -> 'a -> 'a) -> t -> 'a -> 'a
  val iter   : (block -> unit) -> t -> unit
end

module Blocks : BLOCKS with type t = block UM.t = struct
  type t = block UM.t
  let empty = UM.empty
  let insert block = UM.add (id block) block 
  let find blocks u = UM.find u blocks
  let focusp blocks p = UM.splitp (fun _ b -> p b) blocks
  let focus blocks u = UM.split u blocks
  let union = UM.union
  let fold f blocks z = UM.fold (fun _ b z -> f b z) blocks z
  let iter = UM.iter
end
@ 
<<zipcfg.ml>>=
type graph  = Blocks.t
type zgraph = zblock * Blocks.t
type nodes   = zgraph -> zgraph (* sequence of nodes in Hughes's representation *)
type cbranch = ifso:label -> ifnot:label -> nodes (* ability to branch conditionally *)

let of_blocks g = g
let to_blocks g = g
let openz z = z
let tozgraph z = z
@ 
<<zipcfg.ml>>=
let empty = Blocks.insert (Entry, Last Exit) Blocks.empty

let focus uid blocks =
  let (b, bs) = Blocks.focus blocks uid in
  unzip b, bs
let entry blocks = focus entry_uid blocks
let exit g =
  let is_exit b = match last (unzip b) with Exit -> true | _ -> false in
  let (b, bs) = Blocks.focusp g is_exit in
  let (h, l) = goto_end (unzip b) in
  ((h, Last l), bs)

let unfocus (bz, bs) = Blocks.insert (zip bz) bs
@ 
%%
<<zipcfg.ml>>=
let consm middle ((h, t), blocks) = ((h, Tail (middle, t)), blocks)

let instruction  rtl g = consm (Instruction  rtl) g
let stack_adjust rtl g = consm (Stack_adjust rtl) g

let unreachable = function
  | Last (Branch _ | Forbidden _ | Exit) -> ()
  | t ->
      let pr s = Debug.eprintf "zipcfg" s in
      pr "warning: unreachable code?\n";
      let rec warn = function
        | Tail (m, t) -> pr "  %s\n" (Rtlutil.ToString.rtl (mid_instr m)); warn t
        | Last l -> pr "  %s\n"  (Rtlutil.ToString.rtl (last_instr l)) in
      warn t

let consl last ((head, tail), blocks) = unreachable tail; ((head, Last last), blocks)
@
<<mutually recursive graph construction>>=
let rec consl' m b last ((head, tail), blocks) =
  unreachable tail;
  fst (block_before m b ((head, Last last), blocks))
and branch (p, machine, l2e as m) target =
  let (b, r) = machine.M.goto.M.embed p (l2e target) in
  consl' m b (Branch (r, target))
and jump (p, machine, l2e as m) e ~uses ~targets =
  let (b, r) = machine.M.jump.M.embed p e in
  consl' m b (Jump (r, uses, targets))
@
<<mutually recursive graph construction>>=
and cbranch (p, machine,l2e as m) guard ~ifso ~ifnot succ =
  let cbr = machine.M.branch.M.embed p guard in
  fst (cbranch2cfg m cbr ~ifso ~ifnot succ)
and mbranch (p, machine, l2e as m) e ~targets ((head, tail), blocks) =
  let (b, r) = machine.M.goto.M.embed p e in
  unreachable tail;
  fst (block_before m b ((head, Last (Mbranch (r, targets))), blocks))
and cut_to (p, machine, l2e as m) cut_args ~cuts_to ~aborts ~uses =
  let (b, r) = machine.M.cutto.M.embed p cut_args in
  consl' m b (Cut (r, cuts_to, uses))
@ 
%%
<<zipcfg.ml>>=
let return  rtl ~exit ~uses  = consl (Return (exit, rtl, uses))
let forbidden (_, machine,_) = consl (Forbidden machine.M.forbidden)
@ 
%%
<<mutually recursive graph construction>>=
and label' user (p, machine, l2e as m) lbl ((head, tail), blocks) =
  let (b, r) = machine.M.goto.M.embed p (l2e lbl) in
  fst (block_before m b ((head, Last (Branch (r, lbl))),
       Blocks.insert (Label (lbl, user, ref None), tail) blocks))
@ 
%%
<<mutually recursive graph construction>>=
and label        x = label' Userlabel x
and privatelabel x = label' Genlabel x
and limitlabel   x = label' Limitlabel x
@ 
<<zipcfg.ml>>=
let check_single_exit g =
  let check block found = match last (unzip block) with
  | Exit when not found -> true
  | _ -> found in
  if not (Blocks.fold check g false) then
    impossf "graph does not have an exit"
@ 
<<mutually recursive graph construction>>=
and make_target machine ((b, bs) as gz) = match b with
| First (Label (u, _, _)), _        -> u, gz
| First Entry, Last (Branch (_, u)) -> u, gz
| First Entry, _ ->
    let lbl = (uid (), Idgen.label "branch target") in
    let gz = branch machine lbl **> privatelabel machine lbl **> gz in
    lbl, gz
| _ -> impossf "focus not on entry"
@ 
<<mutually recursive graph construction>>=
and if_then_else machine cbranch ~t ~f g =
  let endif, g = make_target machine g in
  let not,   g = make_target machine (f g) in
  let        g = branch      machine endif g in
  let so,    g = make_target machine (t g) in
  cbranch ~ifso:so ~ifnot:not g
@ 
<<mutually recursive graph construction>>=
and while_do machine cbranch ~body g =
  let lbl = (uid (), Idgen.label "loop head") in
  let endwhile, g = make_target machine g in
  let body,     g = make_target machine (body (branch machine lbl g)) in
  let g = cbranch ~ifso:body ~ifnot:endwhile g in
  label machine lbl g
@ 
<<mutually recursive graph construction>>=
and limitcheck machine cbranch ~t g =
  let endif = (uid (), Idgen.label "post-limitcheck label") in
  let g = limitlabel machine endif g in
  let so, g = make_target machine (t g) in
  cbranch ~ifso:so ~ifnot:endif g
@ 
<<mutually recursive graph construction>>=
and call (p, machine,l2e as m) exp ~altrets ~unwinds_to ~cuts_to ~aborts
               ~uses ~defs ~kills ~reads ~writes ~spans ~succ_assn succ =
  let lbl = (uid (), Idgen.label "call successor") in
  let succ_ce = { kills = kills; defs = defs; node = lbl; assertion = succ_assn } in
  let edgelist = succ_ce :: List.flatten [altrets; unwinds_to; cuts_to] in
  let (b, r) = machine.M.call.M.embed p exp in
  let call = 
    { cal_i = r; cal_contedges = edgelist; cal_spans = spans;
      cal_uses = uses; cal_altrets = List.length altrets;
      cal_unwinds_to = List.length unwinds_to; cal_cuts_to = List.length cuts_to;
      cal_reads = reads; cal_writes = writes; } in
  let succ = privatelabel m lbl succ in
  match succ with
  | (First Entry, Last (Branch (_, lbl'))), blocks when lbl' =*= lbl -> 
      fst (block_before m b ((First Entry, Last (Call call)), blocks))
  | _ -> impossf "internal error in call constructor"
@ 
<<zipcfg.ml>>=
let set_spans (bz, blocks) spans = match bz with
| First (Label (l, u, r)), _ -> r := Some spans
| _ -> impossf "setting spans on non-label"
@ 
<<zipcfg.ml>>=
let iter_spans f g =
  let span s = match s with Some s -> f s | None -> () in
  let first = function Label (_, _, s) -> span (!s) | _ -> () in
  let block (f, t) =
    first f;
    match lastt t with
    | Call c -> span c.cal_spans
    | _ -> () in
  Blocks.iter block g
@ 
<<zipcfg.ml>>=
let fold_spans f g z =
  let span s z = match s with Some s -> f s z | None -> z in
  let first f z = match f with Label (_, _, s) -> span (!s) z | _ -> z in
  let block (f, t) z =
    let z = first f z in
    match lastt t with
    | Call c -> span c.cal_spans z
    | _ -> z in
  Blocks.fold block g z
@ 
<<zipcfg.ml>>=
let add_blocks blocks (focus, newblocks) =
  match focus with
  | First Entry, Last (Branch _ | Forbidden _ | Exit) ->
      let rec add block blocks = match goto_end (unzip block) with
      | First (Label _), Exit -> blocks
      | _, Exit -> impossf "exit contains nontrivial code"
      | _ -> Blocks.insert block blocks in
      Blocks.fold add newblocks blocks
  | First Entry, _ -> impossf "entry contains nontrivial code"
  | _ -> impossf "focus not on entry"
@ 
<<definitions of [[Rep]]'s public functions>>=
let succs = function
  | Exit                  -> []
  | Branch  (_, l)        -> [fst l]
  | Cbranch (_, t, f)     -> [fst f; fst t]  (* order meets layout constraint *)
  | Mbranch (_, edges)    -> List.map fst edges
  | Call    c             -> List.map (fun e -> fst e.node) c.cal_contedges
  | Cut     (_, edges, _) -> List.map (fun e -> fst e.node) edges
  | Return  _   -> []
  | Jump    _   -> []
  | Forbidden _ -> []

let fold_succs f t z = match t with
  | Exit                  -> z
  | Branch  (_, l)        -> f (fst l) z
  | Cbranch (_, te, fe)   -> f (fst te) (f (fst fe) z) (* order meets layout constraint *)
  | Mbranch (_, edges)    -> List.fold_left (fun z e -> f (fst e) z) z edges
  | Call    c             -> List.fold_left (fun z e -> f (fst e.node) z) z c.cal_contedges
  | Cut     (_, edges, _) -> List.fold_left (fun z e -> f (fst e.node) z) z edges
  | Return  _   -> z
  | Jump    _   -> z
  | Forbidden _ -> z

let iter_succs f t = fold_succs (fun t () -> f t) t ()
@
<<zipcfg.ml>>=
let postorder_dfs g =
  let entry, blocks = entry g in
  let rec vnode block cont acc visited =
    let u = id block in
    if US.mem u visited then
      cont acc visited
    else
      vchildren block (get_children block) cont acc (US.add u visited)
  and get_children block =
    let uids = succs (last (unzip block)) in
    (*List.map (Blocks.find blocks) uids*)
    List.fold_left (fun rst bid -> try Blocks.find blocks bid :: rst
                                   with Not_found -> rst) [] uids
  and vchildren block children cont acc visited = 
    let rec next children acc visited = match children with
      | [] -> cont (block :: acc) visited
      | n::rst -> vnode n (next rst) acc visited in
    next children acc visited in
  vnode (zip entry) (fun acc _visited -> acc) [] US.empty
@ 
<<zipcfg.ml>>=
let fold_layout f z g =
  let nextlabel (f, t) = match f with
    | Entry -> impossf "entry as successor"
    | Label (l, _, _) -> Some l in
  let rec fold blocks z = match blocks with
  | [] -> z
  | [b] -> f b None z
  | b1 :: b2 :: bs -> fold (b2 :: bs) (f b1 (nextlabel b2) z) in
  fold (postorder_dfs g) z
@ 
<<definitions of [[Rep]]'s public functions>>=
let fold_fwd_block first middle last (f, t) z =
  let z = first f z in
  let rec tail t z = match t with
  | Tail (m, t) -> tail t (middle m z)
  | Last l      -> last l z in
  tail t z
@ 
%%
<<zipcfg.ml>>=
let iter_nodes first middle last g =
  let block (f, t) =
    let () = first f in
    let rec tail t = match t with
    | Tail (m, t) -> (middle m; tail t)
    | Last l -> last l in
    tail t in
  UM.iter block g

let iter_rtls rfun g =
  iter_nodes
    (fun f -> ()) (fun m -> rfun (mid_instr m)) (fun l -> rfun (last_instr l)) g
@ 
<<zipcfg.ml>>=
let fold_blocks f z bs = UM.fold (fun _ -> f) bs z
let iter_blocks = UM.iter
@ 
<<zipcfg.ml>>=
let new_rtll rtl l = match l with
| Exit -> l
| Branch  (r, l) -> Branch (rtl, l)
| Cbranch (r, t, f) -> Cbranch (rtl, t, f)
| Mbranch (r, tgts) -> Mbranch (rtl, tgts)
| Call    c -> Call { c with cal_i = rtl }
| Cut     (r, es, uses) -> Cut (rtl, es, uses)
| Return  (i, r, uses) -> Return (i, rtl, uses)
| Jump    (r, uses, tgts) -> Jump (rtl, uses, tgts)
| Forbidden r -> Forbidden (rtl)

let new_rtlm rtl m = match m with
| Instruction r  -> Instruction rtl
| Stack_adjust r -> Stack_adjust rtl
@ 
<<zipcfg.ml>>=
let map_rtll ~map_rtl ~map_assn l =
  let map_ces ces =
    List.map (fun ce -> { ce with assertion = map_assn ce.assertion }) ces in
  match l with
  | Exit -> l
  | Branch  (r, l) -> Branch (map_rtl r, l)
  | Cbranch (r, t, f) -> Cbranch (map_rtl r, t, f)
  | Mbranch (r, tgts) -> Mbranch (map_rtl r, tgts)
  | Call    c -> Call { c with cal_i = map_rtl c.cal_i ;
                               cal_contedges = map_ces c.cal_contedges }
  | Cut     (r, es, uses) -> Cut (map_rtl r, map_ces es, uses)
  | Return  (i, r, uses) -> Return (i, map_rtl r, uses)
  | Jump    (r, uses, tgts) -> Jump (map_rtl r, uses, tgts)
  | Forbidden r -> Forbidden (map_rtl r)

let map_rtlm map m = match m with
| Instruction r  -> Instruction (map r)
| Stack_adjust r -> Stack_adjust (map r)

let map_rtls map g =
  let block (f, t) =
    let rec tail t = match t with
    | Tail (m, t) -> Tail (map_rtlm map m, tail t)
    | Last l -> Last (map_rtll ~map_rtl:map ~map_assn:map l) in
    (f, tail t) in
  UM.map block g
@ 
%%
<<zipcfg.ml>>=
let map_nodes first middle last g =
  let block (f, t) =
    let rec tail t = match t with
    | Tail (m, t) -> Tail (middle m, tail t)
    | Last l -> Last (last l) in
    (first f, tail t) in
  UM.map block g
@ 
<<zipcfg.ml>>=
(* should this fn be defined on exi and ill?
   when there are cont edges, do we still need to cover the regular edges?*)
let (++) = RSX.union
let union_over_outedges node ~noflow ~flow =
  let noflow (u, l) = noflow u in
  let union_contedges ce = List.fold_left (fun r s -> r ++ flow s) RSX.empty ce in
  match node with
  | Call c -> union_contedges c.cal_contedges
  | Cut (_, es, _) -> union_contedges es
  | Cbranch (c, t, f) -> noflow t ++ noflow f
  | Mbranch (_, ls) -> List.fold_left (fun r s -> r ++ noflow s) RSX.empty ls
  | Branch (_, l) -> noflow l
  | Return (_, _, regs) -> regs 
  | Jump _
  | Exit 
  | Forbidden _ -> RSX.empty
  
let iter_outedges node ~noflow ~flow =
  let noflow (u, l) = noflow u in
  match node with
  | Call c -> List.iter flow c.cal_contedges
  | Cut (_, es, _) -> List.iter flow es
  | Cbranch (c, t, f) -> (noflow t; noflow f)
  | Mbranch (_, ls) -> List.iter noflow ls
  | Branch (_, l) -> noflow l
  | Jump _
  | Return _
  | Exit 
  | Forbidden _ -> ()
  
let add_inedge_uses node regs =
  let reg_add  = RSX.fold RSX.add in
  match node with
  | Call c -> reg_add c.cal_uses regs
  | Cut (_, _, uses) -> reg_add uses regs
  | Jump (_, uses, _) -> reg_add uses regs
  | Return (_, _, uses) -> reg_add uses regs
  | Exit | Branch _ | Cbranch _ | Mbranch _ | Forbidden _ -> regs

let span_add spans rst = match spans with
| Some ss -> Spans.fold_live_locs RSX.add ss rst
| None    -> rst 

let add_live_spansl node regs = match node with
| Call c -> span_add c.cal_spans regs
| _ -> regs

let add_live_spansf node regs = match node with
| Label (_, _, sp) -> span_add (!sp) regs
| Entry -> regs
@ 
<<definitions of [[Rep]]'s public functions>>=
let mid_instr m = match m with
| Instruction  r -> r
| Stack_adjust r -> r

let is_executable _ = true

let nop = Rtl.par [] 
let last_instr l = match l with
| Exit    -> nop
| Branch  (r, _) -> r
| Cbranch (r, _, _) -> r
| Mbranch (r, _) -> r
| Call    c -> c.cal_i  
| Cut     (r, _, _) -> r
| Return  (_, r, _) -> r
| Jump    (r, _, _) -> r
| Forbidden r -> r
@ 
<<zipcfg.ml>>=
let of_block_list blocks =
  List.fold_left (fun m b -> Blocks.insert b m) Blocks.empty blocks 
@ 
%%\paragraph{Splicing support}
%%
%%We want to be able to scrutinize a single-entry, single-exit graph for
%%splicing purposes. 
%%There are two useful cases: the graph is a single block or it isn't.
%%We use continuation-passing style.
<<zipcfg.ml>>=
let prepare_for_splicing graph single multi =
  let gentry, gblocks = Blocks.focus graph entry_uid in
  if UM.is_empty gblocks then
    ((match last (unzip gentry) with Exit -> () | _ -> impossf "bad single block");
     single (snd gentry)
    )
  else
    let gexit, gblocks = exit gblocks in
    let gh, gl = goto_end gexit in
    (match gl with Exit -> () | _ -> impossf "exit is not exit?!");
    multi ~entry:(snd gentry) ~exit:gh ~others:gblocks

let _ = (prepare_for_splicing :
  graph -> 
  (Rep.tail -> 'answer) -> 
  (entry:Rep.tail -> exit:Rep.head -> others:Rep.block Unique.Map.t -> 'answer) ->
  'answer)
@ 
<<zipcfg.ml>>=
let splice_head head g =
  check_single_exit g;
  let splice_one_block tail' = match ht_to_last head tail' with
  | head, Exit -> Blocks.empty, head
  | _ -> impossf "spliced graph without exit" in
  let splice_many_blocks ~entry ~exit ~others =
    Blocks.insert (zipht head entry) others, exit in
  prepare_for_splicing g splice_one_block splice_many_blocks
@ 
%%
<<zipcfg.ml>>=
let splice_tail g tail =
  check_single_exit g;
  let splice_one_block tail' =  (* return tail' .. tail *)
    match ht_to_last (First Entry) tail' with
    | head', Exit ->
        (match ht_to_first head' tail with
        | Entry, t -> (t, Blocks.empty)
        | _ -> impossf "entry in; garbage out")
    | _ -> impossf "spliced single block without Exit" in
  let splice_many_blocks ~entry ~exit ~others =
    (entry, Blocks.insert (zipht exit tail) others) in
  prepare_for_splicing g splice_one_block splice_many_blocks
@ 
<<zipcfg.ml>>=
let splice_focus_entry ((head, tail), blocks) g =
  let tail, blocks' = splice_tail g tail in
  ((head, tail), Blocks.union blocks' blocks)

let splice_focus_exit ((head, tail), blocks) g =
  let blocks', head = splice_head head g in
  ((head, tail), Blocks.union blocks' blocks)
@ 
<<zipcfg.ml>>=
let splice_head_only head graph =
  let gentry, gblocks = Blocks.focus graph entry_uid in
  match gentry with
  | Entry, tail -> Blocks.insert (zipht head tail) gblocks
  | _ -> impossf "splice graph does not start with entry"
@ 
<<zipcfg.ml>>=
let remove_entry graph =
  let gentry, gblocks = Blocks.focus graph entry_uid in
  match gentry with
  | Entry, tail -> tail, gblocks
  | _ -> impossf "removing nonexistent entry"
@ 
%%
%%\paragraph{Graph expansion}
%%
%%This probably duplicates some other splicing stuff.
%%And I'm not too happy even with the local redundancy.
<<zipcfg.ml>>=
let expand expand_middle expand_last graph =
  let expand_block block expanded =
    let rec expand_tail h t expanded = match t with
    | Tail (m, t) ->
        let g, h = splice_head h (expand_middle m) in
        expand_tail h t (Blocks.union g expanded)
    | Last l ->
        Blocks.union (splice_head_only h (expand_last l)) expanded in
    let (f, t) = block in
    expand_tail (First f) t expanded in
  Blocks.fold expand_block graph Blocks.empty 
@ 
<<zipcfg.ml>>=
let single_middle m =
  let block = (Entry, Tail (m, Last Exit)) in
  Blocks.insert block Blocks.empty

let single_last l =
  let block = (Entry, Last l) in
  Blocks.insert block Blocks.empty
@ 
%%
%%\paragraph{DAG conversion}
%%
%%The following functions convert DAGs to graph fragments.
%%The conversion functions also return a boolean value that indicates whether
%%  the graph is modified during the conversion.
%%
%%There's probably a better way to do this:
%%  I'm polluting the namespace and exposing my mutable variable...
%%  hence, this code is not re-entrant.
%%Free reference [[modified]] is set only if a new node is added to the graph.
%%IT MAY BE NECESSARY TO REASSOCIATE TO AVOID REPLACING INSTRUCTION $i$
%%WITH $i; \mathtt{Nop}$. 
<<zipcfg.ml>>=
let modified = ref false
@ 
%%
<<mutually recursive graph construction>>=
and block_before' m block succ =
  let rec before b = match b with
  | DG.Seq (DG.Nop, b) -> before b
  | DG.Seq (b, DG.Nop) -> before b
  | DG.Rtl i        -> modified := true; instruction i succ
  | DG.Seq (b, b')  -> block_before' m b (before b')
  | DG.If (c, t, f) ->
     if_then_else m (cbranch2cfg' m c) ~t:(block_before' m t) ~f:(block_before' m f)
                   succ
  | DG.While (c, b) -> while_do m (cbranch2cfg' m c) ~body:(block_before' m b) succ
  | DG.Nop -> succ in
  before block 
and block2cfg' machine block = block_before' machine block (entry empty)
@
%%N.B. the sharing works only for a DAG---the graph must be acyclic.
%%(Guaranteed by the rep.)
%%
<<mutually recursive graph construction>>=
and cbranch2cfg' (_, _, l2e as machine) c ~ifso ~ifnot succ =
  let nodemap = ref DG.empty in
  let rec cbi (br, tk, fk) succ =
    let tlbl, succ = cbr tk succ in
    let flbl, succ = cbr fk succ in
    consl (Cbranch (br (l2e tlbl), tlbl, flbl)) succ
  and cbr c succ = match c with
    | DG.Exit p        -> (if p then ifso else ifnot), succ
    | DG.Test   (b, i) -> make_target machine (block_before' machine b (cbi i succ))
    | DG.Shared (u, c) -> shared u c succ
  and shared u c succ =
    try DG.lookup u (!nodemap), succ with
    | Not_found ->
        let lbl, succ = cbr c succ in
        nodemap := DG.insert u lbl (!nodemap);
        (lbl, succ) in
  modified := true;
  let lbl, g = cbr c succ in
  branch machine lbl g
and block_before m b s =
  modified := false;
  (block_before' m b s, !modified)
and block2cfg m b =
  modified := false;
  (block2cfg' m b, !modified)
and cbranch2cfg m c ~ifso ~ifnot s =
  modified := false;
  (cbranch2cfg' m c ifso ifnot s, !modified)
@
<<zipcfg.ml>>=
<<mutually recursive graph construction>>
@

\chapter{[[front_ir]]}

\section{[[front_ir/ast2ir.nw]]}
<<front_ir/ast2ir.ml>>=
<<ast2ir.ml>>
@

<<front_ir/ast2ir.mli>>=
<<ast2ir.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et sts=4
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%%%Grades: C Central Immediate
%%
%%% inc: \usepackage{alltt}
%%
%%
%%WORK STILL TO BE DONE:
%%\begin{itemize}
%%\item
%%RECORD SET OF THINGS DEFINED AT THE ``UNWOUND TO'' ENTRY POINT OF A CONTINUATION.
%%THERE IS A PROBLEM HERE, BECAUSE WE HAVE NO WAY TO RECORD
%%A DEFINITION OF A VARIABLE, BUT THIS IS WHAT THE UNWIND OPERATION
%%DOES.
%%PERHAPS THE ASSERTION NODE WILL DO THE TRICK.
%%\end{itemize}
%%
%%
%%
%%
%%% ------------------------------------------------------------------ 
\section{Translation to Intermediate Representation}
%%% ------------------------------------------------------------------ 
%%
%%This module does \emph{lots} of translation: 
%%each procedure to a [[Proc.t]], and everything else down to the
%%assembly level.
%%The [[Proc.t]] is embedded into the assembly program as a single
%%instruction. 
%%
%%We put the [[Target.t]] parameter first always because we first put
%%the less-specific information before the more-specific information.
%%
%%We have to tie a horrible knot for the recursive types [[Proc.t]] and [[Target.t]].
%%We introduce type synonyms here that are used in several other modules of the compiler.
<<type imports>>=
type tgt = Preast2ir.tgt = 
  T of (basic_proc, (Rtl.exp -> Automaton.t), Call.t) Target.t
and basic_proc = Preast2ir.basic_proc
type proc      = Preast2ir.proc
type old_proc  = Preast2ir.old_proc
@ 
%%
<<ast2ir.mli>>=
<<type imports>>
val set_headroom : int -> unit
val translate : tgt
                -> proc Fenv.Clean.env'
                -> optimizer: (proc -> unit)
                -> defineglobals: bool
                -> proc Nelab.compunit
                -> unit   (* side-effects the assembler in the environment *)
@
%%
%%% ------------------------------------------------------------------ 
\section{Implementation: Translate to intermediate representation}
%%% ------------------------------------------------------------------ 
%%
\subsection{Abbreviations, utilities, and type definitions}
%%
%%We use these abbreviations.
<<ast2ir.ml>>=
module A  = Ast
module AT = Automaton
module C  = Call
module Dn = Rtl.Dn
module E  = Error
module F  = Fenv.Clean
module FE = Fenv
module G  = Zipcfg
module N  = Nelab
module R  = Rtl
module RO = Rewrite.Ops
module RP = Rtl.Private
module RU = Rtlutil
module RS = Register.Set
module RSX= Register.SetX
module S  = Elabstmt
module SM = Strutil.Map
module SP = Spans
module T  = Target
module Up = Rtl.Up
module W  = Rtlutil.Width

type aligned = int
type label   = G.uid * string 
let genlabel s =
  let s = Idgen.label s in
  (G.uid (), s)
@ 
%%Utility functions and so on.
<<ast2ir.ml>>=
<<utilities(ast2ir.nw)>>
@ 
%%We have a problem with register sets.
%%Formerly, we mostly kept sets of registers, but for liveness analysis,
%%we went finer grain and tracked slices.
%%Crossing this boundary seemed to be expensive, so we move the crossing
%%here, to the creation of the flow graph.
%%From here down, the flow graph works with slices.
<<utilities(ast2ir.nw)>>=
let rsx = Register.rset_to_rxset
@ 
%%Here are 
%%some of the usual suspects.
<<utilities(ast2ir.nw)>>=
let (<<) f g  = fun x -> f (g x) (* function composition *)
let impossf x = Printf.kprintf Impossible.impossible x
let unimpf x = Printf.kprintf Impossible.unimp x
@ 
%%The [[**>]] function is an infix, right-associative function that
%%makes it easy to create sequences of flow-graph nodes.
%%(I'm always amazed at how useful it is to have an infix,
%%right-associative form of the identity function.)
<<utilities(ast2ir.nw)>>=
let ( **> ) f x = f x
@
%%Some of these type definitions are called for in the interface; others
%%are internal.
%%The types in module [[K]] are used to translate continuations.
<<ast2ir.ml>>=
<<type imports>>
<<module [[K]], for continution info>>
<<types for nonvolatile registers>>
@ 
\subsection{Overall structure of the translation}
%%
%%The translator has two major layers: the top-level layer, shown
%%here, and the single-procedure layer, shown in chunk
%%[[<<definition of [[proc]], which translates one procedure>>]].
%%Each layer comes with its own scope; we have top-level scope and
%%procedure scope. 
%%The denotation of an expression depends on what scope it's in, but we
%%prefer \emph{not} to pass a scope or environment everywhere.
%%Instead, we define a higher-order function [[exprfuns]], which gets
%%the scope information and returns three functions: [[expr]], 
%%[[typed_expr]], and [[lvalue]].
%%We use [[exprfuns]] to instantiate these three functions in two places:
%%once at top level and once inside each procedure.
%%The first instantiation is visible here; the second appears in 
%%[[<<definition of [[proc]], which translates one procedure>>]].
<<ast2ir.ml>>=
(* I have to choose the value  *)
let headroom = ref 1024 
let set_headroom n = headroom := n
<<definition of type [[blocklists]]>>
let translate target env ~optimizer ~defineglobals =
  let T target = target in
  let pointersize = target.T.pointersize in
  let asm = F.asm env in
  <<environment-independent support for formals, actuals, and results>>
  in
  <<definition of [[proc]], which translates one procedure>>
  in
  <<definition of [[globals]]>>
  in
  <<function [[datum]], for initialized and uninitialized data>>
  in
  <<function [[program]], which translates an entire program>>
  in
  program
@
%%
%%% ------------------------------------------------------------------
\subsection{The translation of actual parameters, formal parameters, and results}
%%% ------------------------------------------------------------------ 
%%
%%For actuals, formals, or results, we need a sequence of
%%kind/width/alignment triples
%%to feed to the calling convention.
%%For a formal or result, we need the corresponding location, and for each
%%actual, the corresponding value.
%%We do the dirty work with a higher-order function.
%%Argument [[kind_parm_aligned]] splits the abstract syntax into a kind, 
%%a ``parameter'', and an alignment.
%%Argument [[cvt]] takes a ``parameter'' and produces a converted
%%parameter (location or expression), plus the width of the parameter.
%%The later parameter [[conv]] is a calling convention, which we apply
%%here for convenience.
%%THIS OLD FUNCTION MAY BE SLATED FOR REPLACEMENT!!!
<<environment-independent support for formals, actuals, and results>>=
let convert_parms kind_parm_aligned cvt =
  let add x (wkas, parms) =
    let kind, parm, a = kind_parm_aligned x in
    let parm, w = cvt parm in
    (w, kind, a) :: wkas, parm :: parms in
  fun conv l ->
    let hws, parms = List.fold_right add l ([], []) in
    conv hws parms 
@ 
%%We instantiate this code four ways.
%%For an actual parameter, the [[cvt]] parameter is the function [[ew]],
%%which compiles an AST expression into an RTL expression plus a width.
%%For a formal parameter or result, we use [[lvalue_name_in_env]].
%%The environment must be a parameter, since we don't have it at the
%%time these functions are defined.
%%
\subsection{The translation of continuations and flow annotations}
%%\label{ast2ir.sec:cont-trans}
%%
%%Historically, 
%%we needed three passes to translate continuations.
%%THIS NUMBER CAN PROBABLY BE REDUCED, BUT WE HAVEN'T GOT AROUND TO IT YET.
%%IN ANY CASE, THIS EXPLANATION IS ALMOST CERTAINLY OBSOLETE.
%%\begin{enumerate}
%%\item
%%The first pass finds each continuation and builds the first part of
%%its translation: representation, labels, and incoming-parameter
%%handling.
%%\item
%%The second pass, which is the main translation of a procedure, 
%%identifies the code point (flow-graph node) associated with each
%%continuation in the source code.
%%\item
%%The third pass checks how each continuation is used and adds
%%flow-graph code as needed to implement that continuation.
%%It also inserts any initializations that are needed.
%%\end{enumerate}
%%
%%Here is the information we accumulate about each continuation.
%%There are potentially three entry points into a continuation: by cut,
%%by unwind, and by alternate return.
%%We eagerly assign a label to each potential entry point, even though
%%not every entry point is necessarily needed.
%%We provide mutable fields so that the second pass can track how a
%%continuation is actually used and therefore know which entry points
%%are needed.
%%If an entry point is needed, the third pass of translation ensures
%%that the
%%relevant label is associated with real flow-graph nodes that do
%%things.
%%
%%When we encounter a continuation, we also have its formal parameters,
%%so we run the calling convention, again knowing that we may not need
%%the results.
%%We also compute the representation of the continuation in case it is
%%cut to or it escapes.
%%The [[return_pcs]] field is needed because 
%%potentially each calling convention puts the overflow parameters in a
%%different place (or adjusts the stack differently), so therefore we
%%need to return to a different lable for each calling convention.
%%\nextchunklabel{ast2ir.K.t}%
<<module [[K]], for continution info>>=
module K = struct
  type convention = string
  type 'i t =
    {         unwind_pc   : label       (* uids may or may not be used *)
    ;         unwind_sp   : Rtl.loc
    ;         cut_pc      : label
    ; mutable return_pcs  : (convention * label list) list
    ;         escapes     : bool        (* properties of how it is used *)
    ;         cut_to      : bool
    ;         unwound_to  : bool
    ;         formals     : (string * FE.variable * aligned) list
                            (* args (kind, variable index) to the continuation *)
    ;         cut_in      : (Block.t -> Rtl.rtl) C.answer
                                                (* move vals at cut (uses rep) *)
    ;         return_in   : (Block.t -> Rtl.rtl) C.answer
                                                (* move vals at also returns *)
    ;         rep         : Contn.t     (* representation as C-- value (incl block) *)
    ;         base        : Block.t     (* base address; to be composed with rep *)
    ;         convention  : string
    ;         succ        : label       (* filled in by 2nd pass time *)
    ; mutable spans       : (Bits.bits  * Reloc.t) list
                            (* user-defined spans at the continuation *)
    }
  <<definition of [[K.mk]], which initializes continuation information>>
end
@
%%
%%\subsubsection{First-pass translation of continuations}
%%
%%Our state of knowledge when we first encounter a continuation.
<<definition of [[K.mk]], which initializes continuation information>>=
let mk to_cc name den rep base ~formals ~cut_in ~return_in ~unwind_sp =
  let ccname cc = (to_cc cc).C.name in
  { escapes     = den.FE.escapes
  ; cut_to      = den.FE.cut_to
  ; unwound_to  = den.FE.unwound_to
  ; unwind_pc   = genlabel "unwind_entry"
  ; unwind_sp   = unwind_sp
  ; cut_pc      = genlabel "cut_entry"
  ; return_pcs  = 
    <<set the return pcs>>
  ; rep         = rep
  ; base        = base
  ; convention  = den.FE.convention
  ; formals     = formals
  ; cut_in      = cut_in
  ; return_in   = return_in
  ; succ        = genlabel "start of continuation code"
  ; spans       = []
  }
@ 
%%
%%The unfortunate state of affairs is that we must generate an alternate return
%%entry point for each call site that may make an alternate return to a continuation.
%%To ensure that each entry point is used only once, we only add an entry label when
%%we encounter each call site that makes an alternate return to this continuation.
<<set the return pcs>>=
List.map (fun cc -> (ccname cc,[])) den.FE.returned_to
@
%%
<<definition of [[K.mk]], which initializes continuation information>>=
let get_return_pc cc k =
  let labels = try List.assoc cc.C.name k.return_pcs
               with Not_found -> impossf "Unknown alt-return convention %s" cc.C.name in
  let new_label = genlabel "return_entry" in
  let new_entry = (cc.C.name, new_label :: labels) in
  k.return_pcs <- new_entry :: (List.remove_assoc cc.C.name k.return_pcs);
  new_label
@
%%It's a simple matter of finding the calling convention, running the
%%automata, and building the rep and the continuation.
<<function [[extend_cont]], for adding flow-graph info to continuations>>=
let extend_cont name den = 
  let cc        = Call.get_cc target den.FE.convention in
  let args      = den.FE.formals in
  let cut_in    = cformals cc.C.cut_parms.C.in' args in
  let return_in = cformals cc.C.results.C.in'   args in
  let rep       = Contn.with_overflow target cut_in.C.overflow in
  K.mk (Call.get_cc target) name den rep den.FE.base ~formals:args ~cut_in ~return_in
       ~unwind_sp:(to_mloc proc_cc.C.stable_sp_loc) in
@
%%\subsubsection{Second pass: continuations and flow annotations}
%%The second pass fills in the mutable fields.
%%First, when we encounter the statement for the second time, we set its
%%successor.
%%We return an illegal node since nothing may fall through to a continuation.
<<supporting functions for translating statements>>=
let rec contStmt2 label succ =
  let k = continuation label in
  k.K.spans <- props;
  G.forbidden m **>
  G.label m k.K.succ **>
  succ
@ 
%%As continuations appear in flow annotations, we set the [[cut_to]],
%%[[unwound_to]], and [[returned_to]] fields as needed.
%%We use the labels stored with the continuation to associate the
%%correct entry point with 
%%each continuation, depending on how the continuation is used.
%%This code appears in a context in which the [[continuation]] function
%%looks up a continuation by name.
<<function [[continuations]], which translates flow annotations>>=
let continuations cc ast =
  let volregs = cc.C.volregs in                 (* volatile registers *)
  let allregs = RS.union volregs cc.C.pre_nvregs in (* all registers *)
  let (--)    = RS.diff in
  let as_cut_to k =
    let defs  = k.K.cut_in.C.regs in
    { G.defs  = rsx defs; G.kills = rsx (allregs -- defs); G.node = k.K.cut_pc
    ; G.assertion = k.K.cut_in.C.insp (Contn.rep k.K.rep) } in
  let as_unwinds k =
    { G.defs  = RSX.empty; G.kills = rsx volregs; G.node = k.K.unwind_pc
    ; G.assertion = proc_cc.C.sp_on_unwind proc_cc.C.stable_sp_loc } in
    (* defs are vars and so can't be a register set. See [[splice_in_unwind_to_entry]] *)
  let as_returns k =
    let pc = K.get_return_pc cc k in
    let defs  = k.K.return_in.C.regs in
    { G.defs  = rsx defs; G.kills = rsx (volregs -- defs); G.node = pc
    ; G.assertion = k.K.return_in.C.insp k.K.return_in.C.overflow } in
  let contmap f = List.map (f << continuation) in
  { S.cuts     = contmap as_cut_to  ast.S.cuts;
    S.unwinds  = contmap as_unwinds ast.S.unwinds;
    S.areturns = contmap as_returns ast.S.areturns;
    S.returns  = ast.S.returns; S.aborts = ast.S.aborts; } in
let ccontinuations cc ast =
  let ast' = { S.cuts = ast.S.ccuts; S.aborts = ast.S.caborts;
               S.unwinds = []; S.areturns = []; S.returns = false; } in
  let c = continuations cc ast' in
  { S.ccuts = c.S.cuts; S.caborts = c.S.aborts }
@
%%\subsubsection{Third pass: code for initializing and entering continuations}
%% 
%%The rest of the compilation happens at the end of the procedure.
%%There are three steps:
%%\begin{itemize}
%%\item
%%Store spans at each escaping continuation (for use by the runtime system).
%%\item
%%Initialize any escaping continuations ([[insert_init_cont_nodes]])
%%\item
%%Compile entry points for continuations as needed ([[finish_compiling_continuation]])
%%\end{itemize}
%%
%%For each continuation we have reserved memory on the stack that must be
%%initialized when the procedure is entered. The following function
%%inserts code to do the initialization.
%%
%%We also attach spans to each continuation that escapes.
<<definition of [[insert_init_cont_nodes]]>>=
let insert_init_cont_nodes contmap init_label g =
  let one_node cname k g = 
    if k.K.escapes then
      let pc    = exp_of_code_label k.K.cut_pc in
      let sp    = proc_cc.C.stable_sp_loc      in
      let spans = SP.to_spans ~inalloc ~outalloc:(to_mloc sp) ~ra:saved_ra
                              ~users:k.K.spans ~csregs:nvr_temps ~conts:[]
                              ~sds:sd_locs ~vars:(var_array ()) in
      let cut_g = G.focus (fst k.K.cut_pc) (G.unfocus g) in
      let () = G.set_spans cut_g spans in
      let blockname block =
        match G.Rep.blocklabel block with
        | Some (_, s) -> s
        | None -> "<entry block>" in
      let _focused_blockname g =
        let b, _ = G.openz g in
        let b = G.Rep.zip b in
        blockname b in
      let pc_sp = { Mflow.new_pc = pc; Mflow.new_sp = sp } in
      let init = G.instruction (Contn.init_code k.K.rep pc_sp) (G.entry G.empty) in
      G.splice_focus_entry g (G.unfocus init)
    else
      g in
  G.unfocus (Strutil.Map.fold one_node contmap (G.focus (fst init_label) g))
@ 
%%When we finish compiling a continuation, we make sure any label that
%%is used leads to sensible code.
%%A continuation that escapes but is never cut to presents a dilemma: 
%%it has to have a value (because it escapes), but the front end has
%%promised never to use that value in a [[cut to]].
%%As per discussion including Simon and Norman in the restaurant of Washington DC's 
%%Melrose Hotel, an continuation that is not [[cut to]] should not be used -- and
%%therefore, it should not even escape.
%%This error should really be detected elsewhere.
<<functions that translate statements, including [[stmts]]>>=
let rec finish_compiling_continuation k g =
  let g = 
    if k.K.cut_to then
      splice_in_cut_to_entry k g
    else if k.K.escapes then
      impossf "Continuation escapes but is not annotated with also cuts to"
    else g in
  let g = splice_in_return_to_entries k g in
  let g = if k.K.unwound_to then splice_in_unwind_to_entry k g else g in
  g
@ 
%%If we cut to a continuation, the overflow parameters live in its
%%representation on the stack, so we need only shuffle and manage the
%%stack pointer.
%%(I really don't believe this any more.  We need to visit the big
%%picture of continuations.)
%%\begin{itemize}
%%\em
%%\item
%%Multiple entry points
%%\item
%%What prolog for each entry point
%%\item
%%When each prolog is inserted into the graph
%%\end{itemize}
<<functions that translate statements, including [[stmts]]>>=
and splice_in_cut_to_entry k g =
  let in' = k.K.cut_in in
  let prolog =
    G.label m k.K.cut_pc **>
    G.stack_adjust in'.C.pre_sp   **>
    G.instruction  in'.C.shuffle  **>
    G.stack_adjust in'.C.post_sp  **>
    G.branch m k.K.succ     **>
    G.entry G.empty in
  G.add_blocks g prolog
@ 
%%If we return to a continuation, we must remember the overflow block.
%%
%%When we unwind, the argument variables are set by the run-time system's unwinding code;
%%we just need to worry about setting the stack pointer.
<<functions that translate statements, including [[stmts]]>>=
and splice_in_return_to_entries k g = 
  let gen cc g label =
    let in' = k.K.return_in in
    let ()  = add youngblocks cc.C.overflow_alloc.C.result_allocator in'.C.overflow in
    let prolog =
      G.label m label **>
  (* NR IS BEHIND THE TIMES AND NEEDS TO BE REMINDED WHAT HAPPENED TO ASSERTIONS *)
  (* WE LOST:  G.assertion    g (in'.C.insp in'.C.overflow)    *)
      G.stack_adjust in'.C.pre_sp    **>
      G.instruction  in'.C.shuffle   **>
      G.stack_adjust in'.C.post_sp   **>
      G.branch m k.K.succ     **>
      G.entry G.empty in
    G.add_blocks g prolog in
  let gen_labels g (ccname, labels) =
    List.fold_left (gen (Call.get_cc target ccname)) g labels in
  List.fold_left gen_labels g k.K.return_pcs
@ 
%%When we unwind, the argument variables are set by the run-time
%%system's unwinding code. 
%%It is not possible to represent this fact by [[defs]] on the relevant
%%control-flow edge, because the things being defined are {\PAL}
%%variables, and the only things we can put on a [[defs]] edge are
%%registers.
%%
%%\begin{quote}
%%In an earlier version on the compiler, to ensure that each formal
%%parameter had a location, 
%%we asserted, for each variable, an assignment of that variable to a
%%bogus location. 
%%But now instead, we plan to revise the run-time system to do nothing
%%if a particular formal happens to be dead.
%%
%%A more serious question, not solved, is what to do about reaching
%%definitions when variables can be mutated by the run-time system.
%%\end{quote}
<<functions that translate statements, including [[stmts]]>>=
and splice_in_unwind_to_entry k g = 
  let prolog =
    G.label m k.K.unwind_pc **>
  (* NR IS BEHIND THE TIMES AND NEEDS TO BE REMINDED WHAT HAPPENED TO ASSERTIONS *)
  (* WE LOST: G.assertion g (proc_cc.C.sp_on_unwind proc_cc.C.stable_sp_loc) **> *)
    G.branch m k.K.succ     **>
    G.entry G.empty in
  G.add_blocks g prolog
(*
  let bogus_space = ('z', Rtl.Identity, Cell.of_size 1) in
  let use_var (h,v,a) succ =
    let w = RU.Width.loc v.FE.loc in
    G.assertion g (RU.store (R.mem R.none bogus_space (R.C w)
                                   (R.bits (Bits.S.of_int 0 w) w))
                            (R.fetch (R.var "" v.FE.index w) w)) succ in
  ... (List.fold_right use_var k.K.formals k.K.succ) ...
*)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Translations of statements}
%%
%% 
%%\subsubsection{Simple statements}
%%
%%We do the simple statements inline,
%%but interprocedural control flow is complicated enough to warrant
%%out-of-line functions (as will [[switch]]).
<<functions that translate statements, including [[stmts]]>>=
and stmts props ss succ = List.fold_right (stmt props) ss succ
and _stmt' props s  succ =
  Printf.eprintf "Translating %s\n" (
  match s with
  | S.If (e, so, not) -> "If"
  | S.Label n              -> "Label " ^ n
  | S.Switch _             -> "Switch"
  | S.Cont (name, _, _)    -> "Cont"
  | S.Span (kv, bs)        -> "Span"
  | S.Assign rtl           -> "Assign"
  | S.Call  (lhs, cc, e, args, targets, conts, alias) -> "Call"
  | S.Call' _                                         -> "Call'"
  | S.Goto (e, labels) -> "Goto"
  | S.Jump  (cc, e, args, targets)  -> "Jump"
  | S.Cut (cc, k, args, conts)      -> "Cut"
  | S.Return (cc, i, n, args)       -> "Return"
  | S.Limitcheck (cc, cookie, cont) -> "Limitcheck");
  stmt props s succ
@ 
%%
<<functions that translate statements, including [[stmts]]>>=
and stmt  props s  succ =
  <<supporting functions for translating statements>>
  in
  match s with
  | S.If (e, so, not)      ->
      let cb ~ifso ~ifnot = G.cbranch m e ~ifso ~ifnot in
      G.if_then_else m cb ~t:(stmts props so) ~f:(stmts props not) succ
  | S.Label n              -> G.label m (uid_of n, n) succ 
  | S.Switch (rg, e, arms) -> switchStmt rg e arms props succ
  | S.Cont (name, _, _)    -> contStmt2 name succ
  | S.Span (kv, bs)        -> stmts (kv :: props) bs succ
  | S.Assign rtl           -> G.instruction rtl succ
  | S.Call  (lhs, cc, e, args, targets, conts, alias) ->
      call lhs cc e args targets conts alias succ
  | S.Call' (cc, e, args, targets) ->
      jump ~stack:false cc e args targets succ
  | S.Goto (e, labels) ->
      (match Dn.exp e with
      | RP.Const (RP.Link (sym, _, w)) ->
          let lbl = sym#original_text in
          G.branch m (uid_of lbl, lbl) succ
      | _ -> (*let instr   = machine.T.goto.T.embed e in*)
             let targets = List.map (fun l -> (uid_of l, l)) labels in
             G.mbranch m e targets succ)
  | S.Jump  (cc, e, args, targets)  -> jump ~stack:true cc e args targets succ
  | S.Cut (cc, k, args, conts)      -> cut cc k args conts succ
  | S.Return (cc, i, n, args)       -> return cc i n args succ
  | S.Limitcheck (cc, cookie, cont) -> limitcheck cc cookie cont
@
%%
%%\paragraph{[[switch]] statements}
%%
%%We compile a switch statement into a simple sequence of if-then-else
%%tests, so there's no use for the optional range.
%%If we were to compile into jump tables, then the optional range might
%%tell us how big the jump tables would have to be.
%%N.B.~For efficiency, we rely on [[disjoin]] being suitably short-circuited.
<<supporting functions for translating statements>>=
and switchStmt range e arms props stmt_succ =
  let w = RU.Width.exp e in
  let e_in_interval (lo, hi) =
    if Bits.Ops.eq lo hi then
      RO.eq w e (Rtl.bits lo w)
    else
      RO.conjoin (RO.leu w (Rtl.bits lo w) e) (RO.leu w e (Rtl.bits hi w)) in
  let endswitch, g = G.make_target m stmt_succ in
  let default,   g = G.make_target m (G.forbidden m g) in
  let do_arm (ranges, body) (next_test, g) =
    let condition =
      Simplify.exp (
        List.fold_left (fun cond range -> RO.disjoin (e_in_interval range) cond)
                       (Rtl.bool false) ranges) in
    let arm, g = G.make_target m (stmts props body (G.branch m endswitch g)) in
    G.make_target m (G.cbranch m condition ~ifso:arm ~ifnot:next_test g) in
  let (first_test, g) = List.fold_right do_arm arms (default, g) in
  g
@
%%\subsubsection{Statements that go between procedures}
%%
%%\paragraph{Jumps}
%%The outgoing overflow parameters passed by a tail call go into the
%%\emph{young} end of the current activation.
%%N.B.~We don't use the [[targets]] list, which is there for future
%%interprocedural optimization and call-graph analysis.
<<supporting functions for translating statements>>=
and jump ~stack cconv e args targets g = 
    let stack_adjust = if stack then G.stack_adjust else fun _ succ -> succ in
    let cc      = Call.get_cc target cconv in
    let out     = actuals cc.C.call_parms.C.out args in
    let ra_out  = cc.C.ra_on_exit saved_ra out.C.overflow temps in
    let jump_sp = cc.C.sp_on_jump out.C.overflow temps in
    let () = add oldblocks cc.C.overflow_alloc.C.parameter_deallocator out.C.overflow in
    stack_adjust   out.C.pre_sp                                  **>
    G.instruction  out.C.shuffle                                 **>
    G.instruction  restore_nvrs                                  **>
    G.instruction  (RU.store ra_out (RU.fetch saved_ra))         **>
    G.instruction  (RU.store cc.C.jump_tgt_reg e)                **>
    stack_adjust   jump_sp                                       **>
    G.jump         m (RU.fetch cc.C.jump_tgt_reg) ~targets
                   ~uses:(rsx (RS.union out.C.regs nvregs)) **>
    g
@
%%
%%\paragraph{Calls}
<<supporting functions for translating statements>>=
and call lhs cconv e args _targets conts alias succ = 
  let cc    = Call.get_cc target cconv in
  let out   = actuals cc.C.call_parms.C.out args in
  let in'   = results cc.C.results.C.in' lhs     in
  let unwind_conts =
    let f_to_cont (h,v,a) = (h,v.FE.index,a) in
    let unwind_k kname =
      let k = continuation kname in
      let args = List.map f_to_cont k.K.formals in
      (k.K.unwind_pc, k.K.unwind_sp, args) in
    List.map unwind_k conts.S.unwinds in
  let conts = continuations cc conts in
  add youngblocks cc.C.overflow_alloc.C.parameter_deallocator out.C.overflow;
                                        (* outgoing overflow parms *)
  add youngblocks cc.C.overflow_alloc.C.result_allocator      in'.C.overflow;
                                        (* incoming overflow results *)
  let outalloc = match cc.C.overflow_alloc.C.parameter_deallocator with
    | C.Caller -> to_mloc (young_end cc out.C.overflow)
    | C.Callee -> to_mloc (old_end   cc out.C.overflow) in
  let label ((uid, l), x, y) = (l, x, y) in
  let spans = SP.to_spans ~inalloc ~outalloc ~ra:saved_ra
                          ~users:props ~csregs:nvr_temps
                          ~conts:(List.map label unwind_conts)
                          ~sds:sd_locs ~vars:(var_array ()) in
  let succ_assn = if conts.S.returns then in'.C.insp in'.C.overflow else R.par [] in
  G.stack_adjust out.C.pre_sp                                        **>
  G.instruction  out.C.shuffle                                       **>
  G.stack_adjust out.C.post_sp                                       **>
  G.call m e
    ~uses:(rsx out.C.regs) ~defs:(rsx in'.C.regs) ~kills:(rsx cc.C.volregs)
    ~altrets:conts.S.areturns ~unwinds_to:conts.S.unwinds
    ~cuts_to:conts.S.cuts ~aborts:conts.S.aborts
    ~reads:alias.S.reads ~writes:alias.S.writes ~spans:(Some spans) ~succ_assn **>
  (if conts.S.returns then
    G.stack_adjust in'.C.pre_sp              (* DOUBTS ABOUT THIS *) **>
    G.instruction  in'.C.shuffle                                     **>
    G.stack_adjust in'.C.post_sp succ
   else
    G.forbidden m succ)
@
%%
%%\paragraph{Returns}
%%In the presence of tail calls, [[f]] might call [[g]] with
%%convention~$A$,
%%[[g]]~might tail-call [[h]] with convention~$B$, and [[h]]~would need
%%to return to~[[f]] with convention~$A$.
%%Therefore, it is not only sensible but necessary to annotate the
%%[[return]] with its own convention.
%%
<<supporting functions for translating statements>>=
and return cconv i n args g = 
  let cc  = Call.get_cc target cconv in
  let out = actuals cc.C.results.C.out args  in
  <<verbosely announce the registers used by the return>>
  let ra_out = cc.C.ra_on_exit saved_ra out.C.overflow temps in
  let w      = Rtlutil.Width.loc saved_ra in
  let upd_ra = if i > 0 then RU.store saved_ra (RU.addk w (RU.fetch saved_ra)
                                                          (i * asm#longjmp_size ()))
               else R.null in
  let reti   = cc.C.return i n (RU.fetch ra_out) in
  add oldblocks cc.C.overflow_alloc.C.result_allocator out.C.overflow;
                      (* outgoing jump overflow = incoming *)
  G.instruction  upd_ra                  **>
  G.stack_adjust out.C.pre_sp            **>
  G.instruction  out.C.shuffle           **>
  G.instruction  (RU.store ra_out (RU.fetch saved_ra))  **>
  G.instruction  restore_nvrs            **>
  G.stack_adjust out.C.post_sp           **>
  G.return       ~exit:i reti ~uses:(rsx (RS.union out.C.regs nvregs)) **>
  g
@
%%The code above is safe only so long as the outgoing area doesn't
%%overlap with the spill area.
%%This restriction is unfortunate, as if we could atomically shuffle
%%nonvolatile registers, outgoing parameters, and the return address
%%all in one go, we could overlap the two areas---except for spills.
%%
<<verbosely announce the registers used by the return>>=
let () =
  if Debug.on "return-regs" then
    let regstring ((s,_,_), i, R.C c) =
      if c = 1 then Printf.sprintf "%c%d" s i else Printf.sprintf "%c%d:%d" s i c in
    let used = List.map regstring (RS.elements out.C.regs) in
    Printf.eprintf "return statement uses regs: %s\n" (String.concat ", " used) in
@ 
<<ast2ir.ml>>=
let () = Debug.register "return-regs" "show registers used by return statememt"
@
%%
%%\paragraph{Cut to}
%%The overflow block is part of the representation of the continuation
%%and is placed in the stack elsewhere, but we need to remember any
%%constraints associated with this block.
<<supporting functions for translating statements>>=
and cut cc k args conts g = 
  let cc       = Call.get_cc target cc in
  let out      = actuals (cc.C.cut_parms.C.out k) args in
  let cut_args = Contn.cut_args target ~contn:k in
  let ()       = add_constraints (Block.constraints out.C.overflow) in
  let conts    = ccontinuations cc conts in
  G.instruction out.C.shuffle **>
  G.cut_to m cut_args ~cuts_to:conts.S.ccuts ~aborts:conts.S.caborts
           ~uses:(rsx out.C.regs) **>
  g
@ 
%%A couple of notes:
%%The constraints from [[out.C.overflow]] have to get to the solver in
%%order to resolve the addresses used in [[out.C.shuffle]].
%%Because the overflow block [[out.C.overflow]] is not part of the stack
%%frame, these constraints could go to the solver independently (and
%%right away).
%%But because the names used in each block are unique, it's just as
%%safe, and perhaps easier, to send these constraints to the solver
%%along with all the other constraints of this activation.
%%
%%\paragraph{Stack-limit check}
%%
%%If the stack is exhausted, pass control to the continuation given.
<<supporting functions for translating statements>>=
and limitcheck cconv cookie cont =
  let w  = W.exp vfp in
  let cc = Call.get_cc target cconv in
  let growth = cc.Call.stack_growth in
  let younger = match growth with
  | Memalloc.Down -> Rewrite.Ops.lt w
  | Memalloc.Up -> Rewrite.Ops.gt w in
  let _extremum = unimpf "old end of stack frame" in
  let overflows = younger vfp cookie in
  let ovnode ~ifso ~ifnot = G.cbranch m overflows ~ifso ~ifnot in
  G.limitcheck m ovnode (limitcheck_fails cconv cont) succ
and limitcheck_fails cconv cont succ = match cont with
| None -> G.forbidden m succ
| Some failure ->
    let failflow = { S.caborts = true; S.ccuts = [failure.S.recname] } in
    cut cconv failure.S.reccont [] failflow **>
    contStmt2 failure.S.recname **>
    succ
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Translating a procedure}
%%% ------------------------------------------------------------------ 
%%
%%This section is a big ball of hair.
%%There are too many constraints about order.
%% 
%%\paragraph{Broadly useful values}
%%The procedure calling convention and virtual frame pointer are everywhere.
%%The temporaries are not everywhere, but it's convenient to have them
%%here anyway.
<<definition of [[proc]], which translates one procedure>>=
let proc global_map proc =
  let proc_cc  = Call.get_cc target proc.N.cc in
  let vfp      = target.T.vfp in (* virtual frame pointer *)
  let temps    = Talloc.Multiple.for_spaces target.T.spaces in
@ 
%%We'll remember labels, too.
<<definition of [[proc]], which translates one procedure>>=
  let uidmap =
    let add map l = SM.add l (G.uid ()) map in
    List.fold_left add SM.empty (Elabstmt.codelabels proc.N.code) in
  let uid_of s = 
    try SM.find s uidmap with Not_found -> impossf "unknown code label" in
@ 
%%\paragraph{Setting up the control-flow graph}
%%First step is to set up  the control-flow graph.
%%We use [[exp_of_label]] below, but once symbols are expunged, it
%%should be simple enough to drop it (reducing the cognitive load on the
%%reader). 
<<definition of [[proc]], which translates one procedure>>=
  let exp_of_code_label (u,l) = R.codesym ((F.asm env)#local l) pointersize in
  let machine = T.boxmach in
  let m = (), machine, exp_of_code_label in
@ 
%%\paragraph{Managing mutable state: blocks, constraints, and call site information}
%%The important state here is [[youngblocks]], [[oldblocks]], and
%%[[constraints]]. 
%%
<<definition of type [[blocklists]]>>=
type 'a blocklists = { mutable caller : 'a list; mutable callee : 'a list }
@ 
<<definition of [[proc]], which translates one procedure>>=
  let youngblocks        = { caller = []; callee = [] } in
  let oldblocks          = { caller = []; callee = [] } in
  let add blocks party b = match party with
  | C.Caller -> blocks.caller <- b :: blocks.caller
  | C.Callee -> blocks.callee <- b :: blocks.callee in
  let constraints         = ref [] in
  let add_constraints  c  = constraints  := c :: !constraints        in
  let ptrcount =
    let _, _, c = target.T.memspace in Cell.to_count c target.T.pointersize in
  let to_mloc exp =
    R.mem (R.aligned target.T.alignment) target.T.memspace ptrcount exp in
@ 
<<definition of [[proc]], which translates one procedure>>=
  let low_end  block = Block.base block in
  let high_end block =
    let base = Block.base block in
    Rtlutil.addk (W.exp base) base (Block.size block) in
  let young_end cc = match cc.C.stack_growth with
  | Memalloc.Down -> low_end
  | Memalloc.Up   -> high_end in
  let old_end cc = match cc.C.stack_growth with
  | Memalloc.Down -> high_end
  | Memalloc.Up   -> low_end in
@   
%%\paragraph{Setting up the environment and functions that use it (stack
%%data, continuations, expressions, parameters)}
%%Here we rebind [[env]] to include local variables, stack data,
%%continuations, and so on.
%%We also bind a separate [[contenv]], which maps the name of a
%%continuation to its information as type [[K.t]] (see
%%chunk~\subpageref{ast2ir.K.t}). 
%%The [[stackdata]] function includes the first pass of translation of
%%continuations. 
<<definition of [[proc]], which translates one procedure>>=
let formals  = convert_parms (fun ((_, k, _, w, _, a) as parm) -> k, parm, a)
                             (fun (i, _, _, w, n, _) -> AT.of_loc (R.var n i w), w) in
let cformals = convert_parms (fun p -> p)
                             (fun v -> AT.of_loc v.FE.loc, RU.Width.loc v.FE.loc) in
let actuals  = convert_parms (fun ((k, _, _, a) as parm) -> k, parm, a)
                             (fun (_, e, w, _) -> e, w) in
let results  = convert_parms (fun p -> p) (fun (l, w) -> AT.of_loc l, w) in
@ 
%% 
%%We provide a lookup of continuation by name.
%%If a continuation is used as an rvalue, we get the address of its
%%representation.  
%%We also mark the continuation as escaping.
<<definition of [[proc]], which translates one procedure>>=
  <<function [[extend_cont]], for adding flow-graph info to continuations>>
  let contenv =
    let add env (n, k) = Strutil.Map.add n (extend_cont n k) env in
    List.fold_left add Strutil.Map.empty proc.N.continuations in
  let continuation l =
    try Strutil.Map.find l contenv with _ -> impossf "lost cont %s" l in
@ 
%%\paragraph{Nonvolatile registers, which are affected by incoming parameters}
%%We place a restriction on calling conventions supported by C--: a
%%parameter register is never nonvolatile.  
%%Therefore, for any particular procedure, we get the nonvolatile
%%registers for \emph{that} procedure by subtracting off those registers
%%used as parameters.
%%This choice constrains the set of calling conventions we can express,
%%but it makes it easy to express, e.g., the ``lightweight'' calling
%%convention, in which every register not a parameter is nonvolatile.
%%N.B. for a return or a jump, it is up to the specification of the
%%calling convention to avoid a conflict between result registers and
%%nonvolatile registers.
%%
%%To figure out which registers are nonvolatile, we run the automaton
%%for the incoming parameters, putting results in~[[in']]. 
%%Don't overlook it.
%%
%%For each nonvolatile register, we track the hardware register in
%%[[reg]] and the temporary location in [[tmp]].
%%If we ever want to save nonvolatile registers in conventional
%%locations, we will add two more pieces of information: a block for
%%the register and a mutable flag that tells whether the register is
%%spilled to that block.
<<types for nonvolatile registers>>=
type 'a nvr = { reg : 'a; tmp : 'a }   (* for callee-saves info *)
@ 
%%
<<definition of [[proc]], which translates one procedure>>=
  let proc_in'  = formals proc_cc.C.call_parms.C.in' proc.N.formals  in
  let nvregs    = RS.diff proc_cc.C.pre_nvregs proc_in'.C.regs in
  let nvr_temps = 
    RS.fold (fun r i -> (r, Some (proc_cc.C.saved_nvr temps r)) :: i) nvregs [] in
  let convert (r,t) = match t with Some t -> {reg = R.reg r; tmp = t}
                                 | None   -> impossf "Some nvr_temp expected" in
  let nvr_info  = List.map convert nvr_temps in
  let save_nvrs =
    R.par (List.map (fun i -> RU.store i.tmp (RU.fetch i.reg)) nvr_info) in
  let restore_nvrs =
    R.par (List.map (fun i -> RU.store i.reg (RU.fetch i.tmp)) nvr_info) in
  let save_ra, saved_ra =
    let ra_in = proc_cc.C.ra_on_entry proc_in'.C.overflow in
    let loc   = proc_cc.C.where_to_save_ra ra_in temps in
    R.store loc ra_in pointersize, loc in
@
%%For each procedure, we create a span that represents the location of
%%the point in the stack that marks the
%%space that must be deallocated by the procedure.
<<definition of [[proc]], which translates one procedure>>=
  let inalloc =
    match proc_cc.C.overflow_alloc.C.parameter_deallocator with
    | C.Callee -> to_mloc (old_end   proc_cc proc_in'.C.overflow)
    | C.Caller -> to_mloc (young_end proc_cc proc_in'.C.overflow) in
@ 
%%We also generate an array of variable locations.
%%The current method is totally bogus: I'm only using the variable numbers.
<<definition of [[proc]], which translates one procedure>>=
  let nvars = List.length proc.N.formals + List.length proc.N.locals in
  (* I DON'T KNOW HOW TO GET A VAR'S NAME!!!! SEE ELSEWHERE ALSO *)
  let var_array () = Array.init nvars (fun i -> Some (R.var "" ~index:i 0)) in
@ 
%%Perhaps we can save some memory allocation if we only convert the stackdata expressions
%%to locations one time.
<<definition of [[proc]], which translates one procedure>>=
  let sd_locs = List.map to_mloc proc.N.stacklabels in
@
%%\paragraph{Supporting procedures}
%%We now have enough information in scope to drop in the definitions of
%%the translations for flow annotations, statements, and initialization
%%of continuations.
<<definition of [[proc]], which translates one procedure>>=
  <<function [[continuations]], which translates flow annotations>>
  in
  <<functions that translate statements, including [[stmts]]>>
  in
  <<definition of [[insert_init_cont_nodes]]>>
  in
@ 
%%\paragraph{Translation of the procedure body}
%%
%%This is the ``second pass'' of section~\ref{ast2ir.sec:cont-trans}; it
%%builds most of the flow graph.
%%The initialization of continuations is delayed to a third pass, so we
%%create a label node [[initcont]] as a placeholder.
%%The initialization code is inserted at [[initcont]] after the translation.
%%WE OUGHT TO BE ABLE TO DO WITHOUT ONE OF THESE LABEL NODES.
<<definition of [[proc]], which translates one procedure>>=
  let bodylbl = genlabel "proc body start" in
  let contlbl = genlabel "initialize continuations" in
  let () = add oldblocks proc_cc.C.overflow_alloc.C.parameter_deallocator
                         proc_in'.C.overflow in
  let stack_adjust =
    if proc.N.basic_block then (fun _ succ -> succ) else G.stack_adjust in
  let g = 
    G.unfocus                         **>
    stack_adjust proc_in'.C.pre_sp    **>
    G.instruction  proc_in'.C.shuffle **>
    stack_adjust proc_in'.C.post_sp   **>
    G.instruction  save_nvrs          **>
    G.instruction  save_ra            **>
    G.label m contlbl                 **>
    G.label m bodylbl                 **>
    stmts proc.N.spans proc.N.code    **>
    G.entry G.empty in 
@ 
%%And as promised, the third pass.
%%We initialize continuations, finish compiling them, and accumulate
%%their blocks into [[contblocks]].
%%CAN'T WE HAVE JUST ONE INSERTION POINT?
%%AND WOULDN'T IT BE NICER JUST TO CONCATENATE BLOCKS DIRECTLY RATHER
%%THAN MAKE A LIST AND THEN CONCATENATE?
<<definition of [[proc]], which translates one procedure>>=
  let contblocks, g =
    if proc.N.basic_block then
      Block.cathl_list pointersize [], g
    else
      let addblock name k (blocks, g) =
        let g = finish_compiling_continuation k g in
        let blocks =
          if k.K.escapes then Block.cathl (Contn.rep k.K.rep) k.K.base :: blocks
          else blocks in
        blocks, g in
      let blocks, g = Strutil.Map.fold addblock contenv ([], g) in
      Block.cathl_list pointersize blocks, g in
  let g =
    if proc.N.basic_block then
      g  (* continuations already initialized in prolog of original proc *)
    else
      insert_init_cont_nodes contenv contlbl g in
@ 
%%\paragraph{the spilling automaton}
%%The value [[space]] is an infinite supply of registers that stand for
%%memory locations. We use those registers for spilling. The reason is that
%%it helps us to build a private block with a better layout by register
%%allocating those temporaries registers to stack locations.
%%the alignment of the blxok should probably depend on the alignment of the
%%stack pointer.
%%we are going provide several spaces, wich will be chosen depending on the alignment
<<definition of [[proc]], which translates one procedure>>=
  let index = ref 0 in
  let _allocate = fun ~width -> fun ~alignment -> fun ~kind ->
    let () = index := !index + 1 in 
    let spaceId = char_of_int alignment in 
    let cell = Cell.of_size target.Target.wordsize in
    let space = (spaceId, target.Target.byteorder, cell) in  
    AT.of_loc (Rtl.reg (space, !index, Cell.to_count cell width)) 
  and _freeze arg = Impossible.impossible "you must not freeze this automaton" in
 
  (*   
     let index = ref 0 in
     let blocks = ref [] in
     let allocate = fun ~width -> fun ~alignment -> fun ~kind ->
     let () = index := !index + 1 in 
     let spaceId = char_of_int alignment in 
     let cell = Cell.of_size target.Target.wordsize in
     let space = (spaceId, target.Target.byteorder, cell) in
     let block = Block.relative vfp "spills block" Block.at ~size:width ~alignment:alignment in
     let () = blocks := block :: !blocks in
     AT.of_loc (Rtl.reg (space, !index, Cell.to_count cell width))
     and freeze arg1 arg2 = 
     let l = !blocks in
     let () = blocks := [] in
     { AT.overflow = Block.cathl_list target.Target.pointersize l 
     ; AT.regs_used = RS.empty
     ; AT.mems_used = []
     ; AT.align_state = 1   (* oyh oyh oyh  *)
     }
     
     in
   *)
@ 
%%
%%\paragraph{Building and optimizing the [[Proc.t]]}
%%We take everything we know and combine it into a [[Proc.t]].
%%Then function [[optimize]], which is passed in, runs the rest of the
%%compiler. 
%%The main thing here is dealing with all the blocks.
<<definition of [[proc]], which translates one procedure>>=
  let formals =
    List.map (fun (i, h, v, w, n, a) -> i, (Some h, v, Ast.BitsTy w, n, Some a))
    proc.N.formals in
  let (i : proc) =    
    g,
    { Proc.symbol      = proc.N.sym
    ; Proc.cc          = proc_cc
    ; Proc.target      = T target
    ; Proc.formals     = formals
    ; Proc.temps       = temps
    ; Proc.mk_symbol   = Fenv.Clean.symbol env
    ; Proc.cfg         = ()
    ; Proc.oldblocks   = (* parms must be first, so call List.rev *)
        { C.callee = List.rev (oldblocks.callee); 
          C.caller = List.rev (oldblocks.caller); }
    ; Proc.youngblocks = (* order doesn't matter *)
        { C.callee = youngblocks.callee; 
          C.caller = youngblocks.caller; }
    ; Proc.stackd         = proc.N.stackmem     (* stack data block *)

    ; Proc.priv           = Block.relative vfp "private"
                            (aligned_mem ~align:proc_cc.C.sp_align) target
(*
    ; Proc.priv           = AT.of_methods {AT.allocate = allocate ; AT.freeze = freeze}
*)
    ; Proc.sp             = Block.at proc_cc.C.stable_sp_loc 0 proc_cc.C.sp_align 
    ; Proc.eqns           = List.concat (!constraints)
    ; Proc.conts          = contblocks
    ; Proc.vars           = nvars              (* number of variables *)
    ; Proc.nvregs         = RS.cardinal nvregs (* number of non-volatile regs *)
    ; Proc.var_map        = Array.make nvars None
    ; Proc.global_map     = global_map
    ; Proc.bodylbl        = bodylbl
    ; Proc.headroom       = !headroom
    ; Proc.exp_of_lbl     = exp_of_code_label
    } in
@ 
%%Before running the optimizer, we trim away any unreachable code,
%%as well as spans associated with unreachable code.
<<definition of [[proc]], which translates one procedure>>=
  (* pad: *)
  print_string "TODO: pad reput Optimize.trim_unreachable_code\n";
  (* let i, _ = Optimize.trim_unreachable_code () i in *)
  optimizer i (* runs optimizer, freezes, and assembles proc *)
@ 
%%We define an automaton to allocate suitably aligned locations. 
<<utilities(ast2ir.nw)>>=
let aligned_mem ~align ~base target = 
  let ( *> ) = AT.( *> ) in
  AT.at target.T.memspace ~start:base (
    AT.align_to (fun w -> min align (w / target.T.memsize)) *>
    AT.overflow ~growth:Memalloc.Up ~max_alignment:align)
@
%%      
%%% ------------------------------------------------------------------ 
\subsection{Initialized and uninitialized data}
%%% ------------------------------------------------------------------ 
%%
%%Initialized and uninitialized data translate to assembly directives.
%%
%%A [[datum]] can appear globally inside a section or a section-level
%%[[span]] and locally inside a procedure as \texttt{stackdata}.  
%%This code translates global data into assembly actions;
%%the [[stackdata]] function handles stack data.
<<function [[datum]], for initialized and uninitialized data>>=
let rec datum global_map asm = 
  function
    | N.Datalabel l -> asm#label l  
    | N.Align n     -> asm#align n
    | N.InitializedData es -> List.iter (fun (k, t) -> asm#addr k) es
    | N.UninitializedData n -> asm#zeroes n
    | N.Procedure p -> proc global_map p
@
%%
%%
\subsection{Global Registers}
%%% ------------------------------------------------------------------ 
%%
%%A global register either specifies a hardware register, or not. The
%%hardware register is looked up in the [[named_locs]] table and entered
%%into the register's symbol-table entry. A register without a hardware
%%register are pushed trough the [[globals]] automaton and the resulting
%%location is entered into the register's symbol table entry. 
%%
%%All compilation units in a program must declare exactly the same global
%%registers. We compute a cryptographic hash value for all global-register
%%declarations as a fingerprint. The fingerprint is a string of 16
%%characters, which may not be printable.
%%
%%Function [[globals]] returns the enriched environment, the block of
%%memory that holds overflow global variables, and a fingerprint of the
%%declarations.
<<definition of [[globals]]>>=
let globals (base:Rtl.exp) vars =
    let t           = target.T.globals base in
    let decls       = Buffer.create 128 in (* initial size - grows as needed *)
    let rec assign bindings (name, var) = match var.FE.rkind with
    | FE.RNone | FE.RKind _ -> 
        (* global register w/o hardware annotation *)
        let w     = RU.Width.loc var.FE.loc in
        let sig'  = Printf.sprintf "[%s %d]" name w in
        let ()    = Buffer.add_string decls sig' in
        let loc   = AT.allocate t w "" 1 in
        (var.FE.index, loc) :: bindings   (* could do even better here *)
    | FE.RReg hw ->
        (* global register with h/w annotation *)
        (try
          let loc   = AT.of_loc (Strutil.Map.find hw target.T.named_locs) in
          let sig'  = Printf.sprintf "[%s %s]" name hw in            
          let ()    = Buffer.add_string decls sig' in
          (var.FE.index, loc) :: bindings
        with Not_found -> impossf "unknown hardware register \"%s\"" hw) in
    let bindings = List.fold_left assign [] vars in
    let gmap =
      let var n = try List.assoc n bindings
                  with Not_found -> impossf "no global register %d" n in
      Array.init (List.length vars) var in
    gmap, AT.freeze t, Digest.string (Buffer.contents decls)    
@
%%We have to deal somehow with the global-register area, i.e., make it consistent.
%%The fingerprint [[digest]] for global register declarations is a
%%16-character string of unprintable characters. We make it printable by 
%%calling [[idcode]]; using [[String.escaped]] produces identifiers that
%%are too long for the linker.
<<supporting functions for fooling with the global-register area>>=
let emit_global_register_area ~export =
  let areaname = "Cmm.global_area" in
  let base_sym = if export then asm#export areaname else F.symbol env areaname in
  let base     = Rtl.datasym base_sym pointersize in 
  let gmap, area, digest = globals base prog.N.globals in
  let area     = area.AT.overflow in
  let digest   = "Cmm.globalsig." ^ Idcode.encode digest in
  let asm      = F.asm env in
  let digest   = if export then asm#export digest else asm#import digest in
  (* must move to placevars and use gmap as a replacement map *)
  let _ = 
    if export then 
      begin
        asm#section (target.T.data_section);
        asm#comment "memory for global registers";
        asm#align (Block.alignment area);
        asm#label digest;     (* ensures desired definition is present *)
        asm#label base_sym;   (* ensures no multiple inconsistent definitions *)
        asm#addloc (Block.size area);
        asm#globals (List.length prog.N.globals);
      end
    else
      let localref = asm#local "Cmm.ref_to_global_area" in
      begin
        asm#section (target.T.data_section);
        asm#label localref;
        asm#comment "reference to global-register signature";
        asm#addr (Reloc.of_sym (digest, Rtl.impsym) pointersize);
      end in
  gmap
@
%% 
%%% ------------------------------------------------------------------ 
\subsection{Translating a full compilation unit}
%%% ------------------------------------------------------------------ 
%%
%%To translate a program, we work our ghastly magic on the
%%global-register overflow area, then emit all the sections.
%%
%%THE TREATMENT OF THE GLOBAL-REGISTER AREA IS NOT YET CORRECT.
%%\begin{itemize}
%%\item
%%    The memory block for global registers should go into one compilation
%%    unit and be imported by all others.  OR PERHAPS IT SHOULD BE
%%    SUPPLIED AT RUN TIME BY THE FRONT END?
%% Currently we just emit it
%%    because we are far from linking several {\PAL} compilation units.
%%\item
%%We don't correctly manage the fingerprint of the global-register
%%declarations.
%%\end{itemize}
%%
<<function [[program]], which translates an entire program>>=
let program prog =
  let prog = N.rewrite target.T.tx_ast prog in
  <<supporting functions for fooling with the global-register area>>
  in
  let global_map = emit_global_register_area defineglobals in
  if defineglobals then
    Runtimedata.emit_global_properties target asm;
  let section asm (name, data) =
    asm#section name; List.iter (datum global_map asm) data in
  List.iter (section asm) prog.N.sections
@
\section{[[front_ir/automatongraph.nw]]}
<<front_ir/automatongraph.ml>>=
<<automatongraph.ml>>
@

<<front_ir/automatongraph.mli>>=
<<automatongraph.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 et sw=4
%%%
%%% $Id: automatongraph.nw,v 1.20 2006-03-08 22:33:11 nr Exp $
%%%
%%
%%% ------------------------------------------------------------------ 
\section{Automaton-Graph}
%%% ------------------------------------------------------------------ 
%%
%%The Quick {\PAL} compiler represents a calling convention as an
%%automaton [[Automaton.t]]. When a client supplies a \emph{type} to an
%%automaton it advances to a new state. A type is a triple:
%%a width, a kind, and an alignment.
%%The state
%%of an automaton comprises a set of register locations and the alignment
%%of a memory block. We are interested in a graph representation of the
%%reachable states: states form the nodes, and transitions the edges of
%%the graph. For any realistic calling convention the set of reachable
%%states in its automaton and the corresponding edges should be finite.
%%The module traverses the state graph and emits it for analysis.
%%
%%Function [[print]] takes a function [[mk]] and a list of types.
%%The [[mk]] argument creates an automaton in
%%its initial state.
%%Function [[print]] prints all
%%edges of the automaton to [[stdout]] in the Dot language.  The types
%% are used to construct requests: in every state of the
%%automaton, every type is explored to reach
%%a new state.
%%
%%Function [[paths]] works like [[print]] but emits all ``interesting''
%%argument lists. An argument list corresponds to a path in an automaton.
%%Together, all argument lists cover every pair of an incoming and
%%outgoing edge at a node.
%%
%%Function [[summary]] prints the number of nodes, edges, and paths.
<<automatongraph.mli>>=
type ty = int * string * int (* width * kind * alignment *)
val print: mk:(unit -> Automaton.t) -> ty list -> unit
val paths: mk:(unit -> Automaton.t) -> ty list -> unit
val summary : what:string -> mk:(unit -> Automaton.t) -> ty list -> unit
@
%%I now realize that the [[graph]] type defined in the implementation is
%%basically an isomorphism of the automaton defined in \module{automaton}.
%%Given the graph, the underlying automaton can be simulated.  After this
%%realization I changed the type definition of [[graph]] to make
%%simulation easy. This should help to apply Bailey's algorithm to
%%automatongraph.ml.
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The basic idea is simple: we start from the initial state of an
%%automaton and explore all outgoing edges. An edge is labeled with a
%%type, which is a triple of width, kind, and alignment. As long as we find new
%%edges we continue depth first. The graph should be finite because a
%%typical calling convention has only a limited set of registers and a
%%limited set of stack alignments. Once the graph is explored, we can
%%print it.
%%
%%The state of an automaton can only be observed after is was
%%\emph{frozen}. This presents a small difficulty: to observe a given
%%state, we have to freeze it. But to follow a new edge we need an
%%unfrozen automaton. Thus, we have to re-construct the automaton's
%%current state such that we can make the transition. To do that, we
%%maintain a \emph{path} of types that allows to reconstruct the state of
%%the automaton, starting from the initial state of an automaton. This in
%%turn requires to create an automaton in its initial state when needed.
%%
%%
<<automatongraph.ml>>=
module A    = Automaton
let sprintf = Printf.sprintf
let printf  = Printf.printf
@
%%A type is a width, kind, and alignment.
%%Types label edges in the graph.
%%A path is a list of types that indirectly describes the state of an
%%automaton: starting from the initial state, the types are forming a
%%path. When they are fed into the automaton, the automaton advances its
%%state accordingly. (The same state may be represented by different
%%paths.)
%%
<<automatongraph.ml>>=
type ty = int * string * int (* width * kind * alignment *)
type path =     ty list                         (* leads to a node *)
@
%%A [[node]] is the observable state of an automaton. It comprises the set
%%of allocated registers and the alignment of the next slot in the
%%overflow memory block. The register set inside a node forces us to
%%define a [[compare_nodes]] function since sets have no normal form.
<<automatongraph.ml>>=
type node    =  { regs:     Register.Set.t
                ; align:    int
                }

let compare_nodes (x:node) (y:node) =
    ( match compare x.align y.align with
    | 0 -> Register.Set.compare x.regs y.regs
    | x -> x
    )
@
%%An [[edge]] is a node where an edge originates and a label that
%%identifies the outgoing edge.  The destination of the edge is uniquely
%%defined in the [[graph]], but is not part of the [[edge]] type.
<<automatongraph.ml>>=
type edge =     node * ty

let compare_edges (x:edge) (y:edge) =
    ( match Pervasives.compare (snd x) (snd y) with
    | 0 -> compare_nodes (fst x) (fst y)
    | x -> x
    )
@
%%A [[graph]] value records for every [[edge]] its endpoint in [[edges]],
%%The map models a transition function $\mathit{node} \times \mathit{type}
%%\to \mathit{node}$. An [[edge]] is therefore only meaningful in the
%%context of a [[graph]] which provides the map. In addition, the
%%[[graph]] maintains a set of all nodes, and a [[start]] node,
%%corresponding to the start state of the automaton.
<<automatongraph.ml>>=
module NS = Set.Make (struct type t=node let compare=compare_nodes end)
module ES = Set.Make (struct type t=edge let compare=compare_edges end)
module T  = Map.Make (struct type t=edge let compare=compare_edges end)

type graph =    { nodes:    NS.t            (* all the nodes *)
                ; start:    node            (* start node    *)
                ; edges:    node T.t        (* transition: node*ty => node *)
                }

let graph node = { nodes = NS.add node NS.empty
                 ; start = node
                 ; edges = T.empty
                 }
@
%%
%%Several other definitons of [[graph]] would have been possible. This
%%definition is close to the underlying automaton such that it is easy to
%%follow edges in the same way the automaton changes its state.
%%
%%We have a membership predicate for edges and a function to [[add]]
%%edges. We maintain the following invariant: the origin of an edge is
%%already in the set of node when we call [[add]], we thus only have to
%%add the destination node.
%%
<<automatongraph.ml>>=
let mem edge graph = T.mem edge graph.edges     (* is edge in graph? *)
let add (n,t as edge) node graph =              (* add endpoint of edge *)
    assert (NS.mem n graph.nodes);
    { graph with edges = T.add edge node graph.edges
               ; nodes = NS.add node graph.nodes }
@
%%
%%For debugging, the [[ToString]] module provides us with a function to
%%represent all our types as strings. Feel free to improve this. 
%%
<<automatongraph.ml>>=
module ToString = struct
    let register ((sp,_,_),i,_) = sprintf "$%c%i" sp i
    let ty (width,kind,a) = sprintf "%s::%d@%d" kind width a
    let align n           = sprintf "%i:" n
    let node s            = let regs = Register.Set.elements s.regs in
                            String.concat "" 
                                ((align s.align):: List.map register regs)
    let edge src label dst= sprintf "%s --%s--> %s"
                                (node  src)
                                (ty    label)
                                (node  dst)
    let path p            = String.concat " "  (List.map ty p) 
    let paths ps          = String.concat "\n" (List.map path ps)
    let graph g = 
        let add_edge (src,label) dst strs = edge src label dst :: strs in
        let edges = T.fold add_edge g.edges [] in
            String.concat "\n" edges
end
@
%$
%%Below is a rather ugly emitter for the AT\&T graph layouter Dot. This is
%%now the standard output format.
<<automatongraph.ml>>=
module ToDot = struct
    let size = function
        | 32 -> ""
        | 64 -> "q"
        | n  -> sprintf ":%d" n
        
    let register ((sp,_,ms),i,c) = sprintf "$%c%i%s" sp i (size (Cell.to_width ms c))
    let ty (width,kind,a) = sprintf "%s::%d@%d" kind width a
    let node s            = let regs = Register.Set.elements s.regs in
                            sprintf "\"%i:%s\"" 
                                        s.align 
                                        (String.concat "" 
                                            (List.map register regs))
    let edge src label dst= printf "%s -> %s [label=\"%s\"]\n"
                                (node  src)
                                (node  dst)
                                (ty    label)
    
    let path p            = String.concat " "  (List.map ty p) 
    let paths ps          = List.iter (fun s -> printf "%s\n" s)
                                                (List.map path ps)
    
    let graph g = 
        ( printf "digraph \"calling convention\" {\n"
        ; printf "// nodes=%d \n" (NS.cardinal g.nodes)
        ; printf "size=\"9,6\"\n"
        ; printf "ratio=fill\n"
        ; let print_edge (src,label) dst () = edge src label dst  in
            T.fold print_edge g.edges () 
        ; printf "}\n"
        )
end
@
%$
%%[[goto]] takes a function [[mk]] that creates an automaton in its initial
%%state, and a [[path]] (of types). It feeds [[path]] through the automaton,
%%and returns the reached state as a [[node]].
<<automatongraph.ml>>=
let goto mk path =
    let t    = mk ()                        in
    let ()   = List.iter (fun (w,h,a) -> ignore (A.allocate t w h a)) path in
    let res  = A.freeze t in
        { regs  = res.A.regs_used     
        ; align = res.A.align_state
        }
@
%%Given an abstract location, we would like to know the registers it
%%contains. To find out, we use a trick: we store a (possibly ill-sized)
%%constant into the location and receive an {\rtl} for this operation.
%%This we can analyse and should find the registers we are looking for.
<<automatongraph.ml>>=
let registers loc =
    let c   = Rtl.bits (Bits.zero 32) 32 in
    let rtl = A.store loc c 32 in
    let (read, written) = Rtlutil.ReadWrite.sets rtl in
        written
@    
%%The heart of the algorithm are two mutually recursive functions, [[dfs]]
%%and [[follow]]. The depth-first search function [[dfs]] explores a
%%[[graph]] in all direction, starting from [[node]]. [[Follow]]
%%specifically explores a [[node]] by following a potentially new edge
%%labeled with [[ty]].
%%
%%Both functions take common arguments [[mk]], [[dirs]], [[path]], and the
%%current [[graph]]. [[mk]] creates the automaton under investigation in
%%its initial state when applied to [[()]]. [[dirs]] is the list of all
%%labels for outgoing edges that are explored from the current node.
%%[[path]] allows to reconstruct the state of the current [[node]] by
%%passing it with [[mk]] to [[goto]].
%%
%%From the current node, we follow an edge labeled with [[ty]]. If this
%%edge hasn't been seen before, we add it to the graph and then follow it
%%(reaching [[node']]) From there we explore all outgoing edges
%%recursively depth first.
%%
%%Allocating a location for [[ty]] has led us from [[node]] to [[node']].
%%We like to check that the location for [[ty]] wasn't used before:
%%\begin{itemize}
%%\item 
%%If [[ty]] is passed in a register, [[node'.regs]] must include it;
%%more specifically, [[node.regs]] must be a subset of [[node'.regs]].
%%\item 
%%If [[ty]] is passed in memory, the alignment of [[node']] should
%%differ from [[node]]. However, this is not 100\% sure. There may exist
%%parameters that are so large that they cause to alignment to wrap in
%%which case we cannot observe a difference. This corresponds to a seld
%%loop in the automaton. 
%%\end{itemize}
<<automatongraph.ml>>=
let rec follow (mk:unit->Automaton.t) (dirs: ty list) graph path node ty =
    let path  = path @ [ty]  in
    let node' = goto mk path in
    let edge  = (node,ty)    in
    if mem edge graph then
        graph
    else
        (* assert (Register.Set.subset node.regs node'.regs) *)
        dfs mk dirs (add edge node' graph) path node'

and dfs mk dirs graph path node =   (* call this *)
    List.fold_left 
        (fun graph ty -> follow mk dirs graph path node ty) graph dirs
@
%%Finally, here is the function we export. 
%%Function
%%[[mk]] creates an automaton in its initials state. The initial graph
%%contains the node corresponding to the initial state and is otherwise
%%empty.
<<automatongraph.ml>>=
let _dump g = print_endline (ToString.graph g)

let print ~mk dirs =
    let init    = {regs=Register.Set.empty; align=0}   in
    let g       = graph init            in
    let g       = dfs mk dirs g [] init in
    ToDot.graph g
@
%%
%%% ------------------------------------------------------------------ 
\subsection{automatongraph.ml}
%%% ------------------------------------------------------------------ 
%%
%%To test a calling convention, we like to find interesting parameter
%%lists, which correspond to automatongraph.ml in a [[graph]]. The goal is
%%to find enough paths such that for any node, each pair of incoming and
%%outgoing edge is covered by at leat one path. This criterion was
%%proposed by Bailey in his Ph.D.~thesis. The parameter list that
%%corresponds to a path is simply the list of edge labels. 
%%
%%The alogithm by Bailey is a variant of a depth-first search: we move
%%along edges and collect their labels in a list called [[path]]. When we
%%come to a node, we build (reversed) parameter lists by taking our path
%%and prefixing it with each of the labels of the node's outgoing edges:
%%say, our current path is $w$ and the labels of the outgoing edges are
%%$a$, $b$, and $c$, so we build the parameter lists $aw$, $bw$ and $cw$.
%%Next we mark the edge on which we reached the node.  This implies that
%%we have generated parameter lists that cover our incoming edge and all
%%outgoing edges of the node we just reached.  We continue on all
%%\emph{unmarked} outgoing edges; we extend our path with the label of the
%%chosen edge, as we move along.  The algorithms carries two main results:
%%the set of visited edges, and the generated argument lists. The
%%functional implementation passes them around; a more imperative
%%algorithm could also use global state.  
%%
%%[[next]] returns the [[node]] at the end of an edge.
%%
<<automatongraph.ml>>=
let next graph edge = T.find edge graph.edges
@
%%
%%[[outgoing]] returns the labels (types) on outgoing edges of a given
%%[[node]].
%%
<<automatongraph.ml>>=
let outgoing graph node =
    let add_label (src, label) dst labels =
        if compare_nodes src node = 0 then label :: labels else labels
    in    
        T.fold add_label graph.edges []
@
%%
%%All paths and parameter lists are reversed, because we append results in
%%the front.
%%
%%The [[explore]] function implements the depth-first algorithm explained
%%above. 
%%\begin{itemize}
%%\item [[visited]] is the set of visited (or marked) edges. We never
%%       follow a marked edge to reach new nodes.
%%\item [[path]] is the reversed list of types that lead from the start
%%      node of the graph to the current [[node]].
%%\item [[paths]] are constructed parameter lists. For efficiency, it is a
%%      list of path lists that is flattened later.
%%\item [[node]] is the node we just reached having followed [[path]].       
%%\item [[labels]] are the labels on outgoing edges of [[node]].
%%\end{itemize}
%%
%%The [[follow]] function follows an edge to a new node. It
%%carries the visited edges and parameter lists constructed so far. If the
%%current edge is already marked, it is not followed, but the current
%%result is just returned. Otherwise the edge is marked, the current path
%%extened and the reached recursively explored.
%%
<<automatongraph.ml>>=
let rec explore graph (visited:ES.t) (path:path) (paths:path list list) node =
    let labels  = outgoing graph node in
    let paths  = (List.map (fun l -> l::path) labels) :: paths in
    let follow (node, ty as edge) visited paths =
        if ES.mem edge visited then
            (paths, visited)    (* do nothing, return result *)
        else
            explore 
                graph (ES.add edge visited) (ty::path) paths (next graph edge)
    in
        List.fold_left 
            (fun (paths,visited) edge -> follow edge visited paths)
            (paths,visited)
            (List.map (fun ty -> (node,ty)) labels)
@
%%
%%I have tested this code by looking at the number of paths generated for
%%a graph: for every node with $i$ incoming and $o$ outgoing edges,
%%$i\times o$ paths are generated. The start node has only $n$ outgoing
%%edges, for each of which one paths is generated. Overall, $n+i\times o$
%%paths must be generated. For the single test case with 13 nodes and 54
%%paths, the result was correct. 
%%
%%The main function extracts the parameter lists, flattens and reverses
%%them.
<<automatongraph.ml>>=
let interesting_paths graph = 
    let (paths,_) = explore graph ES.empty [] [] graph.start in
        List.map List.rev (List.concat paths)

let paths ~mk dirs =
    let init    = {regs=Register.Set.empty; align=0}   in
    let g       = graph init           in
    let g       = dfs mk dirs g [] init in
        ToDot.paths (interesting_paths g)

let mapsize m = T.fold (fun _ _ n -> n + 1) m 0

let summary ~what ~mk dirs =
    let init    = {regs=Register.Set.empty; align=0}   in
    let g       = graph init           in
    let g       = dfs mk dirs g [] init in
    Printf.printf "Automaton graph for %s has %d nodes, %d edges, %d paths\n" what
      (NS.cardinal g.nodes) (mapsize g.edges) (List.length (interesting_paths g))

@ 
\section{[[front_ir/call.nw]]}
<<front_ir/call.ml>>=
<<call.ml>>
@

<<front_ir/call.mli>>=
<<call.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et sts=4
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%%%Grades: C Peripheral Soon
%%
%%\emph{On the Alpha, caller and callee do not seem to agree where the
%%stack pointer points after a return. Can this inconsistency be avoided?}
%%
\section{Calling conventions}
%%
\subsection{Discussion}
%%
%%Here's what needs to be done at various sorts of places in the code.
%%\begin{itemize}
%%\item
%%\emph{Outgoing parameters at a call site}
%%\begin{enumerate}
%%\item
%%Run convention feeding widths/kinds/alignments and get locations plus block.
%%(Stack layout must fit block into frame in the right place.)
%%\item
%%Provide binding of where stack pointer must be just before the call
%%instruction. 
%%\item
%%Emit conditional assignment to the stack pointer.
%%The move is required if it will enlarge the stack, and to compute the
%%condition we must know the direction of stack growth.
%%For example, if the stack is to point at~$L$ and the stack is growing
%%down, we emit the conditional assignment 
%%$\sp>L \rightarrow \sp \gets L$. 
%%Although the condition mentions the contents of a run-time location
%%($\sp$), it should be possible to evaluate the condition once late
%%compile-time constants are known.
%%It may
%%help the simplifier to write the condition as as $\sp-L>0$. 
%%\item
%%Emit shuffle for putting actuals into locations.
%%\item
%%Take locations defined by shuffle and retain them so we can create a
%%dataflow node asserting that these locations are used by the call.
%%(Will go on the call's \emph{outgoing} edges for reasons I've
%%forgotten.) 
%%\item
%%Unconditionally set the stack pointer to where it must be.
%%In the example above, this means $\sp \gets L$.
%%\end{enumerate}
%%\item
%%\emph{Normal return from a call site.}
%%\begin{enumerate}
%%\item
%%Run convention feeding widths/kinds/alignments and get locations plus block.
%%(Stack layout must fit block into frame in the right place.)
%%\item
%%Provide binding of where stack pointer will be left just after return.
%%\item
%%Emit conditional assignment to the stack pointer.
%%\item
%%Emit shuffle for putting result locations into LHS variables.
%%\item
%%Take locations read during the shuffle and retain them so we can
%%assert (on the edge out of the call) that these locations are defined
%%by the call.
%%\item
%%Emit assertion node asserting location of stack pointer where left by
%%callee. 
%%\end{enumerate}
%%\item
%%\emph{Alternate return to a continuation}.
%%Each continuation will have one entry point for each calling
%%convention for which it is used as an alternate return continuation.
%%On this entry point:
%%\begin{enumerate}
%%\item
%%Dataflow node asserting definition of locations in which incoming parameters
%%are delivered.
%%\item
%%Shuffle to move actuals from the conventional locations into their
%%variables.
%%\item
%%Flow into the code following the continuation label.
%%\end{enumerate}
%%\item
%%\emph{Unwind to a continuation}.
%%If unwound to, a continuation will have an entry point unwinding calls.
%%On this entry point:
%%\begin{enumerate}
%%\item
%%Dataflow node asserting definition of the variables that are the
%%continuation's formal parameters.
%%\item
%%No shuffling code is needed; it is up to the {\PAL} run-time system to
%%put parameters in their conventional locations.
%%\item
%%Flow into the code following the continuation label.
%%\end{enumerate}
%%\item
%%\emph{Cut to a continuation}.
%%If cut to, a continuation will have an entry point that goes into the
%%PC/SP pair that represents the continuation.
%%On this entry point:
%%\begin{enumerate}
%%\item
%%Run convention feeding widths/kinds/alignments and get locations plus block.
%%(Stack layout must fit block into frame in the right place.)
%%\item
%%Provide binding of where stack pointer must be just before the call
%%instruction.  (????? senseless?????)
%%\item
%%Emit shuffle for putting actuals into locations.
%%\item
%%Take locations defined by shuffle and retain them so we can create a
%%dataflow node asserting that these locations are used by the call.
%%(Will go on the call's \emph{outgoing} edges for reasons I've
%%forgotten.) 
%%\item
%%Set stack pointer to where it must be.
%%MORE TO COME.
%%\end{enumerate}
%%\end{itemize}
%%
\subsection{Interface}
<<call.mli>>=
<<exported type definitions(call.nw)>>
@ 
<<exported type definitions(call.nw)>>=
type kind    = string
type width   = int
type aligned = int
type types = (width * kind * aligned) list

type 'insp answer =
  { 
(* locs     : Automaton2.loc list *)  (* where passed values reside *)
    overflow : Block.t              (* includes all locs for values passed in mem *)
(*    ; sploc    : Rtl.exp              (* where sp is required when values are passed *) *)
  ; insp     : 'insp                (* specify sp when overflow block is introduced;
                                       used in assertions entries from calls, cuts *)
  ; regs     : Register.Set.t       (* set of locations defined (used) by partner *)
  ; pre_sp   : Rtl.rtl              (* conditional SP adjustment pre-shuffle *)
  ; shuffle  : Rtl.rtl              (* shuffle parms where they go *)
  ; post_sp  : Rtl.rtl              (* unconditional SP adjustment post-shuffle *)
  }
@ 
%%Responsibility for actions on the stack is split between the caller and
%%the callee. A [[party]] value identifies one of them.
<<exported type definitions(call.nw)>>=
type party = Caller | Callee
@
%%In particular, either one can allocate a block for results or deallocate
%%the parameter overflow block. Who does what has implications for tail
%%calls.
<<exported type definitions(call.nw)>>=
type overflow = 
    { parameter_deallocator:    party
    ; result_allocator:         party
    }
@
%%When parameters have a choice of allocation or deallocation, we keep
%%records of both.
<<exported type definitions(call.nw)>>=
type ('a, 'b) split_blocks = { caller : 'a; callee : 'b }
@ 
<<exported type definitions(call.nw)>>=
type outgoing = types -> Rtl.exp       list -> unit    answer
type incoming = types -> Automaton.loc list -> (Block.t -> Rtl.rtl) answer
type ('inc, 'out) pair' = { in' : 'inc ; out : 'out }
type pair     = (incoming, outgoing)              pair'
type cut_pair = (incoming, (Rtl.exp -> outgoing)) pair'

type t = (* part of a calling convention *)
  (* we get 3 dual pairs *)
  { name           : string   (* canonical name of this cc *)
  ; overflow_alloc : overflow
  ; call_parms     : pair
  ; results        : pair
  ; cut_parms      : cut_pair
       (* exp is continuation val; used to address overflow block *)
                  
  ; stable_sp_loc : Rtl.exp
       (* address where sp points after prolog, sits between calls,
          and should be set to on arrival at a continuation *)

  ; jump_tgt_reg : Rtl.loc
       (* When jumping through a register, we need a hardware register -- otherwise
          we might try to spill a temp after moving the sp, which would be very bad. *)

  ; stack_growth   : Memalloc.growth
  ; sp_align       : int             (* alignment of stack pointer at call/cut *)
  <<fields to support the return address>>
  <<fields to support jumps>>
  ; sp_on_unwind   : Rtl.exp -> Rtl.rtl
  ; pre_nvregs     : Register.Set.t          (* registers preserved across calls *)
  ; volregs        : Register.Set.t          (* registers not preserved across calls *)
  ; saved_nvr      : Talloc.Multiple.t -> Register.t -> Rtl.loc (* where to save NVR *)
  ; return         : int -> int -> ra:Rtl.exp -> Rtl.rtl    (* alternate return *)
(*  ; alt_return_table : node list -> node *)
  (* these next two encapsulate knowledge of which reg. is sp *)
  ; replace_vfp    : Zipcfg.graph -> Zipcfg.graph * bool
  } 
@ 
%%N.B. the [[pre_nvregs]] are all possible nonvolatile registers.
%%The actual nonvolatile registers are those [[pre_nvregs]] that are not
%%used for parameters.
%%
%%The return address has to be supported throughout its life cycle.
%%To know where to find it on entry, we might have to supply an overflow
%%block.
<<fields to support the return address>>=
; ra_on_entry     : Block.t -> Rtl.exp
@ 
%%Next, we have to decide where to save it.
%%For that, we say where we found it and we provide a supply of temps.
<<fields to support the return address>>=
; where_to_save_ra : Rtl.exp -> Talloc.Multiple.t -> Rtl.loc
@ 
%%Finally we need to say where to put it on exit.  This probably means
%%leaving it where it is, putting it near an overflow block, or
%%allocating it to a fresh temporary.
%%(The reason a fresh temporary is useful is that it will have a very
%%short lifetime and will therefore be unlikely to be spilled. 
%%The problem with reusing the temporary from [[where_to_save_ra]] is
%%that it is quite likely to be spilled, and the register allocator has
%%been observed to insert the reload \emph{after} the stack frame has
%%been deallocated, which is bad.)
<<fields to support the return address>>=
; ra_on_exit      : Rtl.loc -> Block.t -> Talloc.Multiple.t -> Rtl.loc
@ 
%%The [[sp]] may need special handling on a tail call, in particular if the return
%%address is maintained on the stack.
%%For example, the [[x86]] stores the return address on the stack
%%and uses the call and return instructions to push and pop it from the stack.
%%Because of this implicit push and pop, the callee expects the return address to be
%%on the stack, below the incoming overflow block.
%%This setup breaks down with tail calls because we no longer use the call instruction,
%%so we have to set the [[sp]] and place the [[ra]] in its conventional location before
%%the jump instruction.
<<fields to support jumps>>=
; sp_on_jump      : Block.t -> Talloc.Multiple.t -> Rtl.rtl
@ 
%%EXTENSIONS:
%%\begin{itemize}
%%\item
%%Type [[t]] to have [[grow_stack_to]] and [[set_stack_to]], which
%%conditionally adjust the stack pointer.
%%\item
%%Trim the answer to have just one piece of information about the stack
%%pointer: its location.  On incoming, this is asserted, and on
%%outgoing, it is first grown to and then set.
%%\item
%%For outgoing answers, there's no need for both [[autosp]] and
%%[[postsp]], since the only value we use is 
%%[[postsp $ autosp $ freeze $ a]].
%%(N.B.  [[epilog]] use [[postsp]] that subtracts~4, but it could be
%%done in [[autosp]].)
%%\item
%%For incoming prolog, [[postsp]] gives the standard stack-pointer
%%location. 
%%Also true for incoming results and incoming cuts to.
%%\item
%%In default spec for calling convention, stack pointer should point to
%%young end of overflow block, plus~$k$, where $k$~is a parameter.
%%\item
%%Calls must agree on the direction of stack growth.
%%\item
%%In the current implementation, calls must also agree on which register
%%is the stack pointer.
%%\end{itemize}
%%
%%
%%We have the beginnings of an implementation that computes incoming and
%%outgoing stuff.  The [[relative_to]] parameter is pure hell and not obvious
%%to the amateur.  The [[postsp]] parameter is a bit tricky too.
%%PROBLEM: [[autosp]] SEEMS TO BE RELEVANT ONLY FOR INCOMING CASE??
%%NOT CLEAR.
<<call.mli>>=
val outgoing :
     growth:Memalloc.growth -> sp:Rtl.loc -> mkauto:valpass ->
     autosp:(Automaton.result -> Rtl.exp) ->
     postsp:(Automaton.result -> Rtl.exp -> Rtl.exp) -> outgoing
val incoming : 
     growth:Memalloc.growth -> sp:Rtl.loc -> mkauto:valpass ->
     autosp:(Automaton.result -> Rtl.exp) ->
     postsp:(Automaton.result -> Rtl.exp -> Rtl.exp) ->
     insp:(Automaton.result -> Rtl.exp -> Block.t -> Rtl.exp) -> incoming
@ 
%%
<<exported type definitions(call.nw)>>=
type valpass = unit -> Automaton.t
@ 
%%
\subsection{Registration of Calling Conventions from Lua}
%%We also now have some code to allow the registration of new calling conventions
%%from Lua.
<<call.mli>>=
type 'a tgt = ('a, (Rtl.exp -> Automaton.t), t) Target.t

val register_cc : 
    'a tgt -> string -> call:Automaton.stage ->
    results:Automaton.stage ->
    cutto:Automaton.stage -> unit

(* val get_cc : ('a, 'cc) Target.t -> string -> 'cc *)
val get_cc : ('p, 'a, 'cc) Target.t -> string -> 'cc
@
%%
%%We provide a general mechanism for analyzing calling convention automata.
<<call.mli>>=
val dump_proc      : 'a tgt -> string -> types -> unit
val dump_return    : 'a tgt -> string -> types -> unit
val dump_cutto     : 'a tgt -> string -> types -> unit
val paths_proc     : 'a tgt -> string -> types -> unit
val paths_return   : 'a tgt -> string -> types -> unit
val paths_cutto    : 'a tgt -> string -> types -> unit
val summary_proc   : 'a tgt -> string -> types -> unit
val summary_return : 'a tgt -> string -> types -> unit
val summary_cutto  : 'a tgt -> string -> types -> unit

val path_2_in_overflow : 'a tgt -> string -> unit
@ 
%%Diagnostic procedures.
%%Both look up a convention in a target by name.
%%Both then take a signature.
%%The first returns a list of locations used to pass values;
%%a value may occupy more than one location.
%%The second prints this information in suitable diagnostic form.
<<call.mli>>=
val run_cc_on_sig_and_return :
  (Automaton.cc_spec -> Automaton.stage) -> 'a tgt -> string -> types -> string list list
val run_cc_on_sig_and_print :
  (Automaton.cc_spec -> Automaton.stage) -> 'a tgt -> string -> types -> unit
@ 
%%
\subsection{Implementation}
%%
%%A consummation most devoutly to be wished.
<<call.ml>>=
module A  = Automaton
module Dn = Rtl.Dn
module R  = Rtl
module RP = Rtl.Private
module RS = Register.SetX
module RU = Rtlutil
module Up = Rtl.Up
<<exported type definitions(call.nw)>>
@ 
%%
<<call.ml>>=
let ignore r s = s

let too_small growth sp target =
  let w = RU.Width.loc sp in
  let ( >* ) x y = R.app (R.opr "gt" [w]) [x; y] in
  let ( <* ) x y = R.app (R.opr "lt" [w]) [x; y] in
  match growth with
  | Memalloc.Down -> RU.fetch sp >* target
  | Memalloc.Up   -> RU.fetch sp <* target

let ne sp target = R.app (R.opr "ne" [RU.Width.loc sp]) [RU.fetch sp; target]

let outgoing ~growth ~sp ~mkauto ~autosp ~postsp types actuals =
    let a = mkauto () in
    let crank effects' (w, k, aligned) actual =
      let l = A.allocate a ~width:w ~kind:k ~align:aligned in
      A.store l actual w :: effects' in
    let shuffle = R.par (List.rev (List.fold_left2 crank [] types actuals)) in
    let a = A.freeze a in
    let autosp = autosp a in
    let postsp = postsp a autosp in
    let setsp  = RU.store sp postsp in
    { overflow = a.A.overflow
    ; insp     = ()
    ; regs     = a.A.regs_used
    ; shuffle  = shuffle
    ; post_sp  = R.guard (ne sp postsp)               setsp
    ; pre_sp   = R.guard (too_small growth sp postsp) setsp
    }

let incoming ~growth ~sp ~mkauto ~autosp ~postsp ~insp types formals =
    let a = mkauto() in
    let crank effects' (w, k, aligned) formal =
      let l = A.allocate a ~width:w ~kind:k ~align:aligned in
      A.store formal (A.fetch l w) w :: effects' in
    let shuffle = R.par (List.rev (List.fold_left2 crank [] types formals)) in
    let a = A.freeze a in
    let autosp = autosp a in
    let postsp = postsp a autosp in
    let insp   = insp a autosp in
    let setsp  = RU.store sp postsp in
    { overflow = a.A.overflow
    ; insp     = (fun b -> RU.store sp (insp b))
    ; regs     = a.A.regs_used
    ; shuffle  = shuffle
    ; post_sp  = R.guard (ne sp postsp)               setsp
    ; pre_sp   = R.guard (too_small growth sp postsp) setsp
    }
@
%%
%%Some utilities.  DOCO HERE.
<<call.ml>>=
type 'a tgt = ('a, (Rtl.exp -> Automaton.t), t) Target.t

let add_cc specs name ~call ~results ~cutto = 
  let base = List.remove_assoc name specs in
    (name, { A.call    = call
           ; A.results = results
           ; A.cutto   = cutto
           }
    ) :: base

let register_cc t name ~call ~results ~cutto =
   let newspecs = add_cc t.Target.cc_specs name ~call ~results ~cutto
   in t.Target.cc_specs <- newspecs ; ()

let get_ccspec tgt name =
  try  List.assoc name tgt.Target.cc_specs
  with Not_found -> Unsupported.calling_convention name

let get_cc tgt name =
  tgt.Target.cc_spec_to_auto name (get_ccspec tgt name)

let dump what autofun target ccname =
  let wordsize  = target.Target.wordsize  in
  let automaton = autofun (get_ccspec target ccname) in
  what ~mk:(fun () -> 
            A.at ~start:(R.bits (Bits.zero wordsize) wordsize) 
                  target.Target.memspace  automaton)
        
let dump_proc    x = dump Automatongraph.print (fun s -> s.A.call) x
let dump_return  x = dump Automatongraph.print (fun s -> s.A.results) x
let dump_cutto   x = dump Automatongraph.print (fun s -> s.A.cutto) x
let paths_proc   x = dump Automatongraph.paths (fun s -> s.A.call) x
let paths_return x = dump Automatongraph.paths (fun s -> s.A.results) x
let paths_cutto  x = dump Automatongraph.paths (fun s -> s.A.cutto) x
let summary_proc x =
  dump (Automatongraph.summary ~what:"parameters") (fun s -> s.A.call) x
let summary_return x =
  dump (Automatongraph.summary ~what:"results")    (fun s -> s.A.results) x
let summary_cutto  x =
  dump (Automatongraph.summary ~what:"cont parms") (fun s -> s.A.cutto) x
@ 
%%
%%And now we generate signatures that cause 1 and 2 parameters, respectively,
%%to end up in an overflow block.
<<call.ml>>=
let findpath_1_in_overflow autofun target ccname =
  let wordsize  = target.Target.wordsize  in
  let automaton = autofun (get_ccspec target ccname) in
  let rec find_overflow_1 tys =
    let an  = A.at ~start:(R.bits (Bits.zero wordsize) wordsize) 
                   target.Target.memspace automaton in
    let tys = (wordsize, "unsigned") :: tys in
    let _   = List.map (fun (w,h) -> A.allocate an ~width:w ~kind:h) tys in
    let res = A.freeze an in
    if res.A.mems_used == [] then find_overflow_1 tys else tys in
  find_overflow_1 []

let findpath_2_in_overflow autofun target ccname =
  (target.Target.wordsize, "unsigned") :: 
  (findpath_1_in_overflow autofun target ccname)

let path_2_in_overflow target ccname =
  List.iter (fun (h,w) -> Printf.printf "%d/int " target.Target.wordsize)
    (findpath_2_in_overflow (fun s -> s.A.call) target ccname);
  Printf.printf "\n"

let locs aloc w =
  let RP.Rtl gs = Dn.rtl (A.store aloc (Rtl.bits (Bits.zero w) w) w) in
  let getloc = function RP.Store (l, _, _) -> l | RP.Kill l -> l in
  let rec add_locs l locs = match l with
  | RP.Reg (s, n, RP.C c) when c <= 0 -> locs
  | RP.Reg (s, n, RP.C c) -> Up.loc l :: add_locs (RP.Reg (s, n+1, RP.C (c-1))) locs
  | l -> Up.loc l :: locs in
  List.fold_right (fun (_,  e) locs -> add_locs (getloc e) locs) gs []

let run_cc_on_sig_and_return autofun target ccname tys =
  let loc2strs l (w, k, a) = List.map Rtlutil.ToString.loc (locs l w) in
  let wordsize = target.Target.wordsize  in
  let auto   = autofun (get_ccspec target ccname) in
  let an     = A.at ~start:(Rtl.late "ovflw" wordsize) target.Target.memspace auto in
  let allocs = List.map (fun (w,k,a) -> A.allocate an ~width:w ~kind:k ~align:a) tys in
  List.map2 loc2strs allocs tys

let run_cc_on_sig_and_print autofun target ccname tys =
  let locs = run_cc_on_sig_and_return autofun target ccname tys in
  let print (w, k, a) ls =
    Printf.printf "\"%s\":%d@%d => { %s }\n" k w a (String.concat "," ls) in
  List.iter2 print tys locs
@ 
%%
\subsection{Potential new constructors for \texttt{Call.t}}
%%
%%The idea is to have an easier way for a client to build a value of
%%type [[Call.t]].
%%The hope is we need change nothing above this line.
%%
%%THIS STUFF IS PARTIALLY MIGRATED TO \module{Callspec}.
%%CLONED AND MODIFIED BROKEN WINDOWS!  HOW EMBARRASSING\ldots
%%
<<call.ml>>=
<<specification for a calling convention>>
@ 
%%
<<specification for a calling convention>>=
type call_t = t
module type SPEC = sig
  type party = Caller | Callee
  type overflow = { parm_deallocator : party
                  ; result_allocator : party
                  } 
  val c_overflow    : overflow
  val tail_overflow : overflow
  type nvr_saver    = Talloc.Multiple.t -> Register.t -> Rtl.loc
  val save_nvrs_anywhere : Space.t list -> nvr_saver
     (* save h/w register in suitable temp space from the list *)
     (* one day: add [[save_nvrs_in_conventional_locations]] *)

  module ReturnAddress : sig
    type style =
      | KeepInPlace       (* leave the RA where it comes in --- probably on stack *)
      | PutInTemporaries  (* put the RA in temporaries *)

    (* values for the three RA-related functions in the Call.t *)
    (* these functions are not needed by a client but will be used to convert
       a Spec.t into a Call.t.  Some client may want to use such functions to 
       modify a Call.t *)
    val enter_in_loc : Rtl.loc -> Block.t -> Rtl.exp (* in_loc l b = fetch l *)
    
    val save_in_temp : Rtl.exp -> Talloc.Multiple.t -> Rtl.loc
    val save_as_is   : Rtl.exp -> Talloc.Multiple.t -> Rtl.loc

    val exit_in_temp : Rtl.exp -> Block.t -> Talloc.Multiple.t -> Rtl.loc
    val exit_as_is   : Rtl.exp -> Block.t -> Talloc.Multiple.t -> Rtl.loc
  end

  type t =
    { name          : string   (* canonical name of this cc *)
    ; stack_growth  : Memalloc.growth
    ; sp            : Register.t
    ; sp_align      : int             (* alignment of stack pointer at call/cut *)
    ; allregs       : Register.Set.t           (* registers visible to the allocator *)
    ; nvregs        : Register.Set.t           (* registers preserved across calls *)
    ; saved_nvr     : nvr_saver
    ; ra            : Rtl.loc * ReturnAddress.style
                                        (* where's the RA and what to do with it *)
    } 

  val to_call : t -> call_t
end
@ 
\section{[[front_ir/context.nw]]}
<<front_ir/context.ml>>=
<<context.ml>>
@

<<front_ir/context.mli>>=
<<context.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% ------------------------------------------------------------------ 
\section{Operator Contexts}
%%% ------------------------------------------------------------------ 
%%
%%A machine has several location spaces; like spaces for integers,
%%adddresses, or floating point value, and their respective temporaries. A
%%context is an abstraction that identifies a set of spaces where a value
%%can live. For example, the \emph{integer} context could contain all
%%integer registers plus their temporaries. 
%%
%%An operator context describes for each operand of an operator and its
%%result, in which context a value lives. For example, the [[add]]
%%operator of a particular machine might expect both its operands to be
%%living in integer contexts, and produce a value in the integer context.
%%We don't care about the representation of a context, so we make it a
%%type parameter.
<<context.mli>>=
type 'c op = string * 'c list * 'c        (* op, arguments, result *)
@ 
%%Because postexpanders need not deal with Boolean operators, on most
%%machines operators can be described by three contexts: integer, 
%%floating point, and, rounding mode.
%%The [[nonbool]]
%%function returns a list giving standard argument and
%%result contexts for each non-Boolean {\rtl} operator.
%%The [[full]] function includes Boolean operators.
%%For both functions, the [[overrides]] parameter is a list of exceptional or
%%nonstandard cases.
<<context.mli>>=
val nonbool  : int:'c -> fp:'c -> rm:'c -> overrides:'c op list -> 'c op list
val full     : int:'c -> fp:'c -> rm:'c -> bool:'c -> overrides:'c op list -> 'c op list
@  
%%Many machines will be able to define a context by taking the
%%[[nonbool]] context plus a few exceptions, e.g.,
%%[[except (nonbool i f r) [exn_list]]].
%%
%%Everything above is quite general, but the specific context that the
%%expander wants is this:
<<context.mli>>=
type t = (Talloc.Multiple.t -> int -> Register.t) * (Register.t -> bool)
@
%%We can build a context from a single temporary space or from a list of
%%temporary spaces.
%%The context allocates from the space(s), accepts any temporary from
%%the space(s), and accepts any hardware register that is acceptable to
%%(any of) the space(s).
<<context.mli>>=
val of_space  : Space.t      -> t
val of_spaces : Space.t list -> t
@ 
%%Finally, we can create the functions that the expander needs.
<<context.mli>>=
val functions : t op list -> (Rtl.Private.opr -> t list) * (Rtl.Private.opr -> t)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
<<context.ml>>=
open Nopoly

let impossf fmt = Printf.kprintf Impossible.impossible fmt

type 'c op = string * 'c list * 'c        (* op, arguments, result *)
let nonboolops ~int ~fp ~rm =
    [ "add"           , [int; int], int
    ; "addc"          , [int; int; int], int
    ; "and"           , [int; int], int
    ; "bitExtract"    , [int; int], int
    ; "bitInsert"     , [int; int; int], int
    ; "bitTransfer"   , [int; int; int; int; int], int
    ; "borrow"        , [int; int; int], int
    ; "carry"         , [int; int; int], int
    ; "com"           , [int], int
    ; "div"           , [int; int], int
    ; "divu"          , [int; int], int
    ; "f2f"           , [fp; rm], fp
    ; "f2f_implicit_round"     , [fp], fp
    ; "f2i"           , [fp; rm], fp  (* conversion done in float unit?? *)
    ; "fabs"          , [fp], fp
    ; "fadd"          , [fp; fp; rm], fp
    ; "fcmp"          , [fp; fp], fp
    ; "fdiv"          , [fp; fp; rm], fp
    ; "float_eq"      , [], fp
    ; "float_gt"      , [], fp
    ; "float_lt"      , [], fp
    ; "fmul"          , [fp; fp; rm], fp
    ; "fmulx"         , [fp; fp], fp
    ; "fneg"          , [fp], fp
    ; "fsqrt"         , [fp; rm], fp
    ; "fsub"          , [fp; fp; rm], fp
    ; "i2f"           , [fp; rm], fp  (* conversion done in float unit? *)
    ; "lobits"        , [int], int
    ; "minf"          , [], fp
    ; "mod"           , [int; int], int
    ; "modu"          , [int; int], int
    ; "mul"           , [int; int], int
    ; "mulux"         , [int; int], int
    ; "mulx"          , [int; int], int
    ; "mzero"         , [], fp
    ; "NaN"           , [int], int  (* implemented in simplifier using integer ops *)
    ; "neg"           , [int], int
    ; "or"            , [int; int], int
    ; "pinf"          , [], fp
    ; "popcnt"        , [int], int
    ; "pzero"         , [], fp
    ; "quot"          , [int; int], int
    ; "rem"           , [int; int], int
    ; "round_down"    , [], rm
    ; "round_nearest" , [], rm
    ; "round_up"      , [], rm
    ; "round_zero"    , [], rm
    ; "rotl"          , [int; int], int
    ; "rotr"          , [int; int], int
    ; "shl"           , [int; int], int
    ; "shra"          , [int; int], int
    ; "shrl"          , [int; int], int
    ; "sub"           , [int; int], int
    ; "subb"          , [int; int; int], int
    ; "sx"            , [int], int
    ; "unordered"     , [], fp
    ; "xor"           , [int; int], int
    ; "zx"            , [int], int
    ]

let boolops ~int ~fp ~bool =
    [ "add_overflows" , [int; int], bool
    ; "bit"           , [bool], int
    ; "bool"          , [int], bool
    ; "conjoin"       , [bool; bool], bool
    ; "disjoin"       , [bool; bool], bool
    ; "div_overflows" , [int; int], bool
    ; "eq"            , [int; int], bool
    ; "feq"           , [fp; fp], bool
    ; "fge"           , [fp; fp], bool
    ; "fgt"           , [fp; fp], bool
    ; "fle"           , [fp; fp], bool
    ; "flt"           , [fp; fp], bool
    ; "fne"           , [fp; fp], bool
    ; "ge"            , [int; int], bool
    ; "geu"           , [int; int], bool
    ; "gt"            , [int; int], bool
    ; "gtu"           , [int; int], bool
    ; "le"            , [int; int], bool
    ; "leu"           , [int; int], bool
    ; "lt"            , [int; int], bool
    ; "ltu"           , [int; int], bool
    ; "mul_overflows" , [int; int], bool
    ; "mulu_overflows", [int; int], bool
    ; "ne"            , [int; int], bool
    ; "not"           , [bool], bool
    ; "quot_overflows", [int; int], bool
    ; "sub_overflows" , [int; int], bool
    ]

let except base exns =
  let keep (o, _, _) = not (List.exists (fun (o', _, _) -> o =$= o') exns) in
  exns @ List.filter keep base

let nonbool ~int ~fp ~rm ~overrides = except (nonboolops ~int ~fp ~rm) overrides
let full ~int ~fp ~rm ~bool ~overrides =
  except (nonboolops ~int ~fp ~rm @ boolops ~int ~fp ~bool) overrides
@    
%$
<<context.ml>>=
type t = (Talloc.Multiple.t -> int -> Register.t) * (Register.t -> bool)
let spacename (s, _, _) = s
let of_space s =
  match s.Space.classification with
  | Space.Temp { Space.stands_for = ok } ->
      let name = spacename s.Space.space in
      let alloc = Talloc.Multiple.reg name in
      let ok ((s', _, _) as r) = spacename s' =<= name || ok r in
      alloc, ok
  | _ -> impossf "context from non-temporary space"

let rec of_spaces l = match l with
| [] -> impossf "context from empty list of spaces"
| [s] -> of_space s
| s :: ss ->
    let a,  o  = of_space  s  in
    let a', o' = of_spaces ss in
    let acellwidth =
      let (_, _, cell) = s.Space.space in Cell.to_width cell (Cell.C 1) in
    let alloc m =
      let a  = a  m in
      let a' = a' m in
      fun w -> if w = acellwidth then a w else a' w in
    alloc, (fun r -> o r || o' r)
@ 
<<context.ml>>=
module SM = Strutil.Map
let functions ops =
  let resmap = List.fold_left (fun m (n, a, r)-> SM.add n r m) SM.empty ops in
  let argmap = List.fold_left (fun m (n, a, r)-> SM.add n a m) SM.empty ops in
  let arg_contexts   (n, _) =
    try SM.find n argmap with Not_found -> impossf "no arg context for %s" n in
  let result_context (n, _) =
    try SM.find n resmap with Not_found -> impossf "no result context for %s" n in
  arg_contexts, result_context
@
\section{[[front_ir/contn.nw]]}
<<front_ir/contn.ml>>=
<<contn.ml>>
@

<<front_ir/contn.mli>>=
<<contn.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% ------------------------------------------------------------------ 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
\section{Continuations}
%%% ------------------------------------------------------------------ 
%%
%%A continuation is a pointer-sized {\PAL} \emph{value}. As such, it can
%%be passed around and stored in registers. However, not all data
%%necessary to represent a continuation fit into a pointer and therefore
%%the pointer points to a pair of two values: first, a pointer to the code
%%belonging to a continuation, and second, a stack pointer value. We call
%%this pair the continuation \emph{representation}. The representation is
%%stored in the activation record of a procedure and is initialized when
%%the procedure becomes active.
%%
%%To deal with the different aspects of a continuation, this module
%%provides an abstraction that is carefully balanced with the target and
%%calling convention.
%%Each is responsible for different types of information:
%%\begin{itemize}
%%\item contn: the continuation's layout in memory 
%%\item target: sizes
%%\item cc: which reg is the sp; how to set the pc and sp
%%\end{itemize}
%%
%%A continuation is a block of memory with two locations: one for a stack
%%pointer, and another for a code pointer.
%%[[with_overflow]] creates a stack block for a continuation; the
%%[[overflow]] input is a block for overflow parameters, and the base
%%address of the whole continuation will be relative to the base of
%%[[overflow]].
%%The observer function
%%[[rep]] can be used to get the stack block for the continuation.
%%
%%A continuation value is a pointer to the block. The block resides in
%%the stack frame of a procedure. It initializes the block by passing the
%%stack-pointer location and the address of the continuation code to
%%[[init_code]]. The call returns a list of instructions that perform the
%%initialization of the block.
<<contn.mli>>=
type t

val init_code     : t -> Mflow.cut_args -> Rtl.rtl
val rep           : t -> Block.t     (* entire cont in memory; rep is address *)
val with_overflow : ('a, 'b, 'c) Target.t -> overflow:Block.t -> t
@
%%
%%The [[cut_args]] function takes a pointer to the continuation ([[contn]])
%%on the stack and returns the argument record that can be used to make the cut.
%%The [[ovblock_exp]] function takes an expression that points to a continuation
%%value, the memsize and pointersize of the machine, and the alignment of the overflow
%%block. It returns the base address of the overflow block.
%%The [[get_contn]] function takes pointers to a pc * sp pair
%%from a continuation and returns a pointer to the continuation.
%%
<<contn.mli>>=
val cut_args    : ('a, 'b, 'c) Target.t -> contn:Rtl.exp -> Mflow.cut_args
val ovblock_exp : Rtl.exp -> int -> int -> int -> Rtl.exp
val get_contn   : Rtl.exp * Rtl.exp -> Rtl.exp
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<contn.ml>>=
module M = Mflow
module R = Rtl
module T = Target

type t =
    { block    : Block.t     (* memory block for pair + overflow incoming parms *)
    ; sp       : Rtl.loc     (* location inside block for sp *)
    ; pc       : Rtl.loc     (* location in block for code ptr *)
    }

let init_code t vals =
    Rtl.par [ Rtl.store t.pc vals.M.new_pc (Rtlutil.Width.loc t.pc)
            ; Rtl.store t.sp vals.M.new_sp (Rtlutil.Width.loc t.sp)
            ]

let rep t = t.block

let offset base n w  = Rtlutil.addk w base n

let pc_sp base t =
  let (_, _, cell)    = t.T.memspace in
  let (Rtl.C n) as ct = Cell.to_count cell t.T.pointersize in
  let mem addr        = Rtl.mem Rtl.none t.T.memspace ct addr in
  let pc              = mem (offset base 0 t.T.pointersize) in
  let sp              = mem (offset base n t.T.pointersize) in
  pc, sp

let ovblock_exp e memsize ptrsize alignment = 
  let ptrcells = ptrsize / memsize in
 offset e (Auxfuns.round_up_to alignment (2 * ptrcells)) ptrsize

let with_overflow t ~overflow =
  let size = t.T.pointersize / t.T.memsize in
  let my_pc_sp =
    Block.relative (Block.base overflow) "continuation block"
      Block.at ~size:(2 * size) ~alignment:t.T.alignment in
  let my_rep = Block.cathl overflow my_pc_sp in
  let pc, sp = pc_sp (Block.base my_rep) t in
  { block = my_rep; sp = sp; pc = pc }

let cut_args t ~contn =
  let w = t.T.pointersize in
  let pc, sp = pc_sp contn t in
  {Mflow.new_pc=R.fetch pc w; Mflow.new_sp=R.fetch sp w}

let get_contn (newpc, newsp) = newpc
@
\section{[[front_ir/expander.nw]]}
<<front_ir/expander.ml>>=
<<expander.ml>>
@

<<front_ir/expander.mli>>=
<<expander.mli>>
@

<<front_ir/postexpander.ml>>=
<<postexpander.ml>>
@

<<front_ir/postexpander.mli>>=
<<postexpander.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 et sw=4:
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%%%Grades: A Subsystem Later
%%
\section{A generic, parameterized code expander}
%%
%%\label{expander.sec}
%%
%%\emph{(See disclaimers in Section~\ref{expander.uncovered} on
%%  page~\pageref{expander.uncovered}.)}
%%
%%
%%A back end is obligated to expand code in such a way that each node in
%%the flow graph bears an RTL that can be represented as a single
%%instruction on the target machine (with a few exceptions noted below).
%%To make retargeting easier, we provide here a generic code expander
%%that reduces the machine-dependent obligation.
%%If the machine can move data, operate on temporary registers, and
%%provide a few simple control-flow operations, this module does the
%%rest.
%%In other words, this module expands a flow-graph node into a subgraph of
%%simpler nodes.
%%The target-dependent code is relegated to a \emph{postexpander}.
%%
%%
%%To explain what is happening, I use the following
%%conventions:\\
%%\begin{tabular}{@{\quad}cl}
%%$t$& any temporary or register-like space\\
%%$m$& any memory-like space\\
%%$k$& any compile-time constant\\
%%$L$& any label or link-time constant\\
%%$\oplus$& any RTL value operator\\
%%$r$& a hardware register\\
%%$\mathit{rm}$& a floating-point rounding mode\\
%%$w$& any wierd value, like a carry bit, in all or part of a register\\
%%$?$& any RTL comparison operator\\
%%\end{tabular}
%%
%%For a register machine, we reduce RTLs to the following forms:
%%{\def\gets{\mathrel{:=}}%
%%\def\rm{{\mathit{rm}}}%
%%$$\begin{array}{r@{}c@{}l@{\mskip10mu}ll}
%%\multicolumn4{l}{\mbox{\emph{Data movement}}}\\
%%m[t_l] & {}\gets{} & t     &\mbox{\texttt{store}}\\
%%t      & \gets & m[t_l]&\mbox{\texttt{load}} \\
%%t_1    & \gets & t_2   &\mbox{\texttt{move}} \\
%%t      & \gets & r   &\mbox{\texttt{hwget}} \\
%%r      & \gets & t   &\mbox{\texttt{hwset}} \\
%%t      & \gets & t@[\mathit{lo}..\mathit{hi}] & \mbox{\texttt{extract}} \\
%%t      & \gets & t_{\mathit{lo}},\ldots,t_{\mathit{hi}} & \mbox{\texttt{aggregate}} \\
%%m[t_l] & \gets & \mathtt{lobits}_n(t)     &\mbox{\texttt{lostore} (store byte/halfword)}\\
%%t      & \gets & \mathtt{sx}(m[t_l])       &\mbox{\texttt{sxload} (load signed b/h)} \\
%%t      & \gets & \mathtt{zx}(m[t_l])       &\mbox{\texttt{zxload} (load unsigned b/h)} \\
%%t      & \gets & k     &\mbox{\texttt{li} (load immediate constant)}\\
%%[3pt]\multicolumn4{l}{\mbox{\emph{Computation}}}\\
%%t      & \gets & t_1 \oplus t_2 &  
%%           \mbox{a binary ALU operation (\texttt{binop})}\\
%%t      & \gets & \mathit{op}(t_1) &  
%%           \mbox{a unary ALU operation (\texttt{unop})}\\
%%t      & \gets & t_1 \oplus_\rm t_2 &  
%%           \mbox{a binary floating-point operation (\texttt{binrm})}\\
%%t      & \gets & \mathit{op}(t_1, \rm) &  
%%           \mbox{a unary floating-point operation or conversion (\texttt{unrm})}\\
%%t      & \gets & \oplus(t_1, t_2, w) & 
%%           \mbox{a weird value operation, like add with carry (\texttt{wrdop})}\\
%%w      & \gets & \oplus(t_1, t_2, w) & 
%%           \mbox{a weird value/result operation, like carry (\texttt{wrdrop})}\\
%%t_{\mathit{hi}}, t_{\mathit{lo}}      & \gets & t_1 \otimes t_2 & 
%%            \mbox{an extended multiply operation (\texttt{dblop})}\\
%%%%t      & \gets & \oplus(t_1, \ldots, t_n) & 
%%%%  \mbox{ordinary ALU operations (\texttt{binop}, \texttt{unop}, etc)}\\
%%[3pt]\multicolumn4{l}{\mbox{\emph{Control flow}}}\\
%%\mathit{PC}& \gets & L &\mbox{\texttt{b} (branch)}\\
%%\mathit{PC}& \gets & t &\mbox{\texttt{br} (branch register)}\\
%%t \mathbin? t \rightarrow \mathit{PC}& \gets & L &\mbox{\texttt{bc} (branch conditional)}\\
%%\mathit{PC}& \gets & \rlap{t}\phantom{L/t} \mid t_l \gets t_r&\mbox{\texttt{cut\_to}}\\
%%\mathit{PC}& \gets & L/t \mid \cdots \mathit{PC} \cdots&\mbox{\texttt{call}/\texttt{callr}}\\
%%\end{array}
%%$$}%
%%The treatment of [[call]] and [[cut to]] needs some explanation.
%%Both instructions change the program counter while also assigning to a
%%register.
%%In the case of [[call]], the program counter appears on the right-hand
%%side of some additional effect.
%%The generic expander assumes that this RTL originated in a call to
%%[[t.Target.call]], and that its only obligation is to expand the
%%expression denoting the callee.
%%The other effects are assumed not to need expansion, and they aren't
%%touched.
%%It's up to the [[t.Target.call]] to know what it's doing, although the
%%postexpander can validate the RTL if it wants.
%%In any case, we maintain the call as an atomic RTL. 
%%
%%In the case of \mbox{[[cut to]]}, the program counter isn't mentioned
%%in an rvalue context, but some register (probably the stack
%%pointer) is modified along with the branch.
%%Here we don't need to know the details; all the expander needs to do is
%%preserve the atomicity of the assignment, but it can (and does) expand
%%out the right-hand sides.
%%In the case of \mbox{[[cut to]]}, the atomicity is not real; 
%%the illusion of atomicity is the result of
%%a conspiracy among the [[Target.t]], the expander, and the recognizer.
%%(The reason for the illusion is that between the time the stack
%%pointer is mutated and the time the branch is taken, the program's
%%internal invariants are no longer satisfied---in particular, it is not
%%safe to spill at that point.)
%%
%%Some machines, notably the Pentium floating-point unit, are not
%%register machines but stack machines.
%%The classification above is not useful because there are few
%%operations that can work with an arbitrary temporary~$t$.
%%
%%Driving the design is the following classification of operators:
%%\begin{itemize}
%%\item
%%A \emph{standard value operator} takes some bit vectors of reasonable
%%width and returns a result of that width.
%%\item
%%A \emph{weird value operator} takes some bit vectors of reasonable
%%width, but also may take an argument or return a result that is
%%unusually narrow.
%%
%%An important special case of weird value operator is a floating-point
%%operator, which takes ordinary floating-point operand(s) plus a
%%rounding mode.
%%%
%%The other weird value operators are extended multiplies (which double
%%with width of 
%%their operands) and multiprecision operators such as carry, borrow, add
%%with carry, and add with borrow.
%%\item
%%A \emph{size-changing operator} widens or narrows a bit vector.
%%The integer size-changing operators are [[sx]], [[zx]], and
%%[[lobits]].
%%The floating-point size-changing operators are [[i2f]], [[f2i]], and
%%[[f2f]].
%%\item
%%A \emph{comparison operator} takes one or more bit vectors and returns
%%a Boolean.
%%This category includes not only the usual integer and floating
%%comparisons but some machine-dependent condition-code testers and the
%%unnecessary [[bool]] operator.
%%\item
%%A \emph{Boolean operator} takes one or more Booleans and returns a
%%Boolean.
%%The Boolean operators are [[conjoin]], [[disjoin]], and [[not]].
%%The generic expander compiles them to control flow.
%%\item
%%The [[bit]] and [[bool]] operators convert between values and Booleans.
%%They are also compiled away in the generic expander.
%%N.B.~Machines such as MIPS support [[bit]] by instructions such as SLT
%%(set less than), so it probably should not be compiled away by the
%%front end (sadly).
%%\end{itemize}
%%This classification speaks to the properties of the operators
%%themselves.
%%As such, it
%% is orthogonal to the distinction between a
%%register machine and a stack machine, which speaks to how operators
%%are implemented on particular hardware.
%%
%%
\subsection{Support for expansion---the postexpander module}
%%
%%The [[Postexpander]] module does two jobs:
%%\begin{itemize}
%%\item
%%It exports a signature (module type)~[[S]], which defines the
%%interface that every target-dependent postexpander must implement.
%%\item
%%It defines some types and utility functions that can be used by
%%postexpanders. 
%%\end{itemize}
%%
%%Because it defines the postexpander interface, serves postexpanders,
%%and serves the generic expander, the [[Postexpander]] signature is
%%fairly rich.
<<postexpander.mli>>=
<<types for postexpanders>>
<<exported utility functions for postexpanders>>
<<exported utility functions for use by the generic expander>>
<<signature of a postexpander>>
@ 
%%To make the interfaces more readable, we use these type abbreviations:
<<types for postexpanders>>=
type temp      = Register.t
type rtl       = Rtl.rtl
type brtl      = Rtl.exp -> Rtl.rtl (* given expression, create branch rtl *)
type exp       = Rtl.exp
type address   = Rtl.exp
type width     = Rtl.width
type assertion = Rtl.assertion
type operator  = Rtl.Private.opr
@
%%We also have type definitions for weird (narrow) values.
%%If it is not a constant, a~weird value must be stored in an
%%ordinary temporary. 
%%The narrow value is in the low bits, and we record a fill type,
%%which is a demand that the postexpander must satisfy.
%%A~weird argument may also be a literal.
<<types for postexpanders>>=
type wtemp = fill * temp
and  fill  = HighS | HighZ | HighAny  
and  warg  = WBits of Bits.bits
           | WTemp of Register.x  (* high bits, if any, could contain anything *)
@ 
%%The [[warg_val]] utility function can help a postexpander create
%%RTLs that use a weird argument.
<<exported utility functions for postexpanders>>=
val warg_val : warg -> exp
@
%%\paragraph{Fragments of flow graphs}
%%
%%The fragments of a flow graph are defined in the [[Dag]] module.
<<types for postexpanders>>=
type 'a block   = 'a Dag.block
type 'a branch  = 'a Dag.branch
type 'a cbranch = 'a Dag.cbranch
type 'a cbinst  = 'a Dag.cbinst
@
%%
%%\paragraph{Postexpander utility functions}
%%
%%A postexpander may need to allocate a temporary or a slot in the stack
%%frame, or it may need to emit initialized data (e.g., for a
%%floating-point load). 
%%At present, only allocation of a temporary or a stack
%%slot is supported.
<<exported utility functions for postexpanders>>=
module Alloc : sig
  val temp : char -> width -> temp
  val slot : width:width -> aligned:int -> Automaton.loc
  val isValid : unit -> bool
end
@ 
%%The postexpander might also like to create a loop or conditional and
%%have the generic expander expand it further.
%%These functions achieve mutual recursion
%%between the generic expander and the postexpander;
%%it is up to the postexpander to be sure that this recursion
%%terminates. 
%%Only a postexpander may safely call these functions;
%%to call the functions while the generic expander is not active is an
%%\emph{unchecked} run-time error.
<<exported utility functions for postexpanders>>=
module Expand : sig
  val block    : exp block   -> brtl block
  val branch   : exp branch  -> brtl branch
  val cbranch  : exp cbranch -> brtl cbranch
  val cbranch' : exp -> ifso:(brtl cbranch) -> ifnot:(brtl cbranch) -> brtl cbranch
end
@ 
%%A~postexpander may want to execute a block with a hardware register in
%%a certain state.
%%This is easy to do with a pattern of ``save; set; block; restore.''
%%But in the case where we want to execute with the hardware register in
%%its current state, it is better just to emit ``block.'' 
%%The reason is that when code sets a part of a control register, the
%%RTLs can get pretty baroque, and at least as of October 2004, our optimizer
%%is unlikely to discover that the instructions are unnecessary.
%%
%%When [[hard = soft]], function [[with_hw hard soft temp block]] has the
%%effect of [[block]]. 
%%Otherwise it has the effect
%%\begin{verbatim}
%%  temp := zx hard;
%%  hard := soft;
%%  block;
%%  hard := lobits temp
%%\end{verbatim}
%%Only a postexpander may safely call [[with_hw]];
%%to call [[with_hw]] while the generic expander is not active is an
%%\emph{unchecked} run-time error.
<<exported utility functions for postexpanders>>=
val with_hw : hard:Register.x -> soft:warg -> temp:temp -> brtl block -> brtl block
@ 
%%Sequential composition of blocks is also useful for the generic expander.
%%It eliminates [[Nop]].
<<exported utility functions for postexpanders>>=
(*
val (<:>) : 'a block -> 'a block -> 'a block
*)
@ 
%%The [[shared]] function makes a node shared, so that it will not be
%%duplicated on conversion to a flow graph.
%%The [[shared]] function guarantees uniqueness of the identifier, and
%%it avoids wrapping [[Shared]] in [[Shared]].
<<exported utility functions for postexpanders>>=
(*
val shared : 'a cbranch -> 'a cbranch
*)
@
%%To convert a condition for use in [[If]] or [[While]], use [[cond]]. 
<<exported utility functions for postexpanders>>=
(*
val cond : exp -> exp cbranch  (* branch taken iff exp true *)
*)
@
%%To help deal with expansion of DAGs containing [[Shared]] nodes, 
%%we provide support for a set of nodes.
<<exported utility functions for postexpanders>>=
(*
type 'a nodeset
val empty : 'a nodeset
val lookup : uid -> 'a nodeset -> 'a   (* raises Not_found *)
val insert : uid -> 'a -> 'a nodeset -> 'a nodeset
*)
@
%%
\subsection  {The target-dependent postexpander interface}
%%\label{expander.sec:Postexpander.S}
%%
%%Here is a signature for a postexpander for an integer/float/address
%%machine.
%%These are the operations every target must implement.
%%The [[byte_order]] is used to check that access to memory uses the
%%target's byte order.
<<signature of a postexpander>>=
module type S = sig
  val byte_order : Rtl.aggregation (* used to check access to memory *)
  val exchange_alignment : int     (* alignment for an exchange slot *)
  <<generic expansion operations for register machines>>
  <<generic expansion operations for stack machines>>
end
@ 
%%\subsubsection{Postexpander operations for register machines}
%%
%%\paragraph{Data movement}
%%We provide basic load and store.
%%The [[assertion]] gives the alignment of the [[address]], which
%%tells the postexpander 
%%whether it can use a normal load or may (on some targets) need special
%%unaligned load and store instructions (e.g., ``load unaligned left''
%%or ``load unaligned right'').
<<generic expansion operations for register machines>>=
val load  : dst:temp  -> addr:address -> assertion -> brtl block
val store : addr:address -> src:temp  -> assertion -> brtl block
@
%%We also provide sign-extending and zero extending loads
%%as well as low-bit--extracting stores, all of which are used only
%%with integer registers.
%%This is the only place the back end is required to support
%%size-changing operators; other uses, such as compositions of widens
%%and narrows, should be compiled to suitable code (shifts or identity)
%%somewhere upstream.
%%In each case, the [[width]] is the width of the value loaded and
%%stored, and the [[assertion]] gives the alignment of the
%%[[address]].
<<generic expansion operations for register machines>>=
val sxload  : dst:temp  -> addr:address -> width -> assertion -> brtl block
val zxload  : dst:temp  -> addr:address -> width -> assertion -> brtl block
val lostore : addr:address  -> src:temp -> width -> assertion -> brtl block
@ 
%%For example, an [[sxload]] with width of~16 on a 32-bit machine
%%might correspond to a ``load signed halfword'' instruction.
%%A~[[lostore]] with width of~8 might correspond to ``store byte.''
%%
%%The [[move]] operation moves data between two registers of the same
%%width. 
%%It must handle not only moves within a single register space but
%%also moves from space to space (e.g., move a value from an integer
%%register into a floating-point register).
<<generic expansion operations for register machines>>=
val move : dst:temp -> src:temp -> brtl block
@ 
%%On some machines, we have to move data between registers of
%%different widths.
%%For example, it might be necessary to move a value from a 64-bit
%%floating-point register into two 32-bit integer registers (or vice
%%versa).
%%To move from a large temporary to a smaller one, we move one piece at
%%a time using [[extract]].
%%To fill a larger temporary using a list of smaller ones is more
%%complicated.
%%We pass the pieces of the large value, \emph{least significant piece
%%  first}, to [[aggregate]].
<<generic expansion operations for register machines>>=
val extract   : dst:temp -> lsb:int -> src:temp -> brtl block
val aggregate : dst:temp -> src:temp list       -> brtl block (* little-endian *)
@ 
%%Finally, we must handle a move into a hardware register that is
%%narrower than a single temporary.
%%Such a move can occur only as a result of a back end advertising a
%%narrow hardware register by name, but it is necessary to provide
%%access to the floating-point rounding mode.
<<generic expansion operations for register machines>>=
val hwset : dst:Register.x -> src:warg       -> brtl block
val hwget : dst:wtemp      -> src:Register.x -> brtl block
@ 
%%Load immediate can take any constant except a Boolean.
<<generic expansion operations for register machines>>=
val li  : dst:temp -> Rtl.Private.const -> brtl block
@ 
%%Usage note:
%%\begin{quote}\slshape
%%Depending on the capabilities of the target machine, there are three
%%common strategies for implementing load-immediate:
%%\begin{enumerate}
%%\item
%%The target machine can hold the entire constant in an immediate field
%%of an instruction (e.g., integer values on Pentium and other CISC
%%machines).
%%On this sort of machine, the postexpander can just issue a single
%%load-immediate instruction.
%%\item
%%The target machine can hold some constants in an immediate field, but
%%not a constant as large as the one being loaded.
%%On a machine like this, it typically requires a two-instruction
%%sequence to load an immediate constant.
%%Different machines use different sequences:
%%\begin{itemize}
%%\item
%%MIPS: ``load upper immediate; or immediate''
%%\item
%%SPARC: ``sethi; or immediate''
%%\item
%%PPC: some sort of load-upper instruction followed by ``add immediate''
%%\end{itemize}
%%Machines vary depending on where in word the split is made (e.g,
%%$16/16$ versus $22/10$) and whether the constant can simply be split
%%or whether something more complicated has to happen because low bits
%%are going to be sign-extended then added.
%%Ideally, we would have some generic support for such machines.
%%\end{enumerate}
%%\end{quote}
%%
%%An extended load-immediate can take sums and differences of
%%compile-time constants (including late compile-time constants). 
%%The [[lix]] may make optimistic assumptions about the size of
%%constants, as noted above on page~\pageref{sec:optimism}.
<<generic expansion operations for register machines>>=
val lix : dst:temp -> Rtl.exp           -> brtl block
@
%%Every machine should be able to do a block copy.
<<generic expansion operations for register machines>>=
val block_copy :
  dst:address -> assertion -> src:address -> assertion -> width -> brtl block
@ 
%%\paragraph{Computation} 
%%
%%Some operators are handled in the generic expander or the simplifier.
%%Others operators reach the postexpander.
%%Not all such operators have the same shape, so we provide an interface
%%function for each shape.
%%
%%Ordinary value operators are expected to be supported by these
%%operations, but only at their natural widths.
%%Weird value operators such as carry, borrow, or multiply-extended are
%%supported by special-purpose functions described further below.
<<generic expansion operations for register machines>>=
val unop  : dst:temp -> operator -> temp         -> brtl block
val binop : dst:temp -> operator -> temp -> temp -> brtl block
@ 
%%If a unary or binary operator takes rounding modes, it has a slightly
%%different shape:
<<generic expansion operations for register machines>>=
val unrm  : dst:temp -> operator -> temp         -> warg -> brtl block
val binrm : dst:temp -> operator -> temp -> temp -> warg -> brtl block
@ 
%%We support the width-doubling weird value operators with the
%%[[dblop]] function.
%%(Currently these are only the extended integer multiplies.
%%Perhaps one day we will understand the role of the extended
%%floating-point multiplies as well.)
<<generic expansion operations for register machines>>=
val dblop : dsthi:temp -> dstlo:temp -> operator -> temp -> temp -> brtl block
@ 
%%A weird value operator that has a 1-bit or 2-bit argument, but a
%%normal result, is
%%supported by  [[wrdop]].
%%These operators include [[addc]] and [[subb]] (as well as a host of
%%floating-point operators that are not actually supported in this
%%interface at this time).
<<generic expansion operations for register machines>>=
val wrdop  : dst:temp  -> operator -> temp -> temp -> warg -> brtl block
@ 
%%A~weird value operator that has a weird argument and also a weird
%%result is supported by [[wrdrop]].
%%These operators include only [[carry]] and [[borrow]].
<<generic expansion operations for register machines>>=
val wrdrop : dst:wtemp -> operator -> temp -> temp -> warg -> brtl block
@ 
%%Usage note:
%%\begin{quote}
%%\slshape
%%The interface contains multiple functions because different operators
%%take arguments of different types.
%%The types are discussed in detail in the documentation for the
%%[[Opshape]] module.
%%
%%It is almost certainly true that not every operator is implemented on
%%every machine.
%%The ability to expand blocks recursively is intended to make it easy
%%to use algebraic equivalents.
%%Our library of equivalents lives in the [[Rewrite]] module.
%%\end{quote}
%%
%%\paragraph{Machine contexts}
%%
%%The generic expander guarantees that
%%the arguments to functions above satisfy the precondition that the
%%temporaries are in the spaces the postexpander expects.
%%The postexpander must announce these spaces through argument and result contexts.
%%A~context has two parts.
%%The first part provides the ability to allocate temporaries, perhaps
%%of more than one width.\footnote
%%{For example, the SPARC floating-point context should support both 32-
%%  and 64-bit floats.}
%%The second part provides a predicate that says when a temporary
%%satisfies that context. 
%%\nextchunklabel{expander.Postexpander.context}%
<<generic expansion operations for register machines>>=
val icontext : Context.t (* for ints *)
val fcontext : Context.t (* for floats *)
val acontext : Context.t (* for addresses *)
val constant_context : width    -> Context.t
val arg_contexts     : operator -> Context.t list
val result_context   : operator -> Context.t
@ 
%%It probably would be a good idea if a context were extended to say
%%exactly what widths are supported by the target machine.
%%
%%THE REAL STORY HAS GOT TO BECOME MORE COMPLICATED.
%%HERE ARE THE CONTEXTS WE FIND ON THE X86:
%%\begin{itemize}
%%\item
%%A TEMPORARY THAT CAN BE ALLOCATED BY THE REGISTER ALLOCATOR
%%\item
%%A LOCATION ON THE FLOATING-POINT STACK
%%\item
%%A LOCATION IN MEMORY WITH KNOWN SIZE AND ALIGNMENT
%%\item 
%%A FIXED HARDWARE REGISTER SUCH AS ROUNDING MODES
%%\end{itemize}
%%THE EXPANDER SHOULD BE UPDATED TO PROVIDE THIS FULL INFORMATION AS THE
%%ARGUMENT AND RESULT CONTEXT FOR EVERY OPERATOR.
%%THEN IT CAN BE THE JOB OF THE EXPANDER TO DO SUCH THINGS AS ALLOCATE
%%MEMORY SLOTS, ETC.
%%
%% 
%%We have to know when a right-hand side is too big to try to cram into
%%a single temporary.
<<generic expansion operations for register machines>>=
val itempwidth : int  (* maximum width for one integer temporary *)
@ 
%%\paragraph{Control flow}
%%To recognize control flow, the expander must be able to identify the
%%program counter.
%%We could provide an abstract test of type [[Rtl.loc -> bool]],
%%but until we need the extra generality, we avoid it.
%%On the other hand, we \emph{do} need a different representation of the
%%program counter on the left and the right of an assignment, in order
%%to handle the SPARC \emph{PC}/\emph{nPC} duo.
<<generic expansion operations for register machines>>=
val pc_lhs : Rtl.loc                    (* program counter as assigned by branch *)
val pc_rhs : Rtl.loc                    (* program counter as captured by call *)
@ 
%%To create control flow, the postexpander must provide an RTL that
%%includes an assignment to [[pc_lhs]].
%%This RTL must be the last in the execution sequence (and therefore the
%%head of the list that is returned).
%%We can branch to a temporary drawn from [[acontext]] or to a constant. 
<<generic expansion operations for register machines>>=
val br : tgt:temp -> brtl branch               (* branch register *)
val b  : tgt:Rtl.Private.const -> brtl branch  (* branch *)
@ 
%%The implementation of [[b]] will normally assume, optimistically,
%%that the branch target is within range of a PC-relative branch
%%instruction. 
%%
%%For a conditional branch,  the target must be a static label, but the
%%postexpander provides any Boolean condition applied to temporaries.
%%Furthermore, it must be the case that the final, actual branch
%%instruction can have its sense reversed with [[bnegate]], and the
%%result is still representable by a single instruction on the target
%%machine.
%%
%%We split the conditional branch into two separate steps: the first step ([[bc_guard]])
%%  returns a block of code that checks the condition along with the expression
%%  representing the condition.
%%The second step takes the condition expression generated by [[bc_guard]] and
%%  produces the actual conditional branch code.
%%The final instruciton in the conditional branch must have as a guard the expression
%%  produced by [[bc_guard]].
%%The point of this division is that we can create a new branch instruction with
%%  a different target without having to understand the entire sequence of code that
%%  calculates the conditional expression and executes the branch.
<<generic expansion operations for register machines>>=
val bc_guard    : temp -> operator -> temp -> brtl block * Rtl.exp
val bc_of_guard : brtl block * Rtl.exp -> ifso:(brtl cbranch) -> ifnot:(brtl cbranch)
                    -> brtl cbranch
(* Formerly:
val bc : temp -> operator -> temp -> ifso:(brtl cbranch) -> ifnot:(brtl cbranch)
              -> brtl cbranch
*)
val bnegate : Rtl.rtl -> Rtl.rtl
@
%%
%%Usage notes:
%%\begin{quote}
%%\slshape
%%For machines with condition codes, the conditional branch instruction will
%%almost certainly involve the invention of new RTL operators that set
%%and query the condition codes.
%%Such invention is not absolutely required, but it enables two major
%%simplifications:
%%First, the postexpander and recognizer are much easier to write by
%%hand.
%%Second, many fewer RTL nodes are allocated at compile time.
%%
%%The typical game is to invent two classes of operators:
%%\begin{itemize}
%%\item
%%One class of operators \emph{sets} the condition codes.
%%On a clean, simple, regular machine, there might be only one way to
%%set condition codes, say by a compare instruction.
%%One might invent an RTL operator called [[vax_compare]], for example.
%%On a messy machine like the Pentium, there might be a half dozen
%%different ways to set condition codes. 
%%Each needs its own RTL operator.
%%\item
%%The other class of operators \emph{queries} the condition codes.
%%One might define operators such as [[vax_lt]] or [[vax_ovflw]].
%%\end{itemize}
%%Once the operators are invented, the expansion of [[bc]] uses one
%%instruction from each class.
%%For example, [[bc_guard x lt y]] might become
%%\begin{verbatim}
%%  P.Rtl (cc := x `vax_lt` y), vax_lt cc
%%\end{verbatim}
%%and [[bc_of_guard (bc_guard x lt y) ifso ifnot]] might become
%%\begin{verbatim}
%%  P.Test (cc := x `vax_lt` y, (vax_lt cc, ifso, ifnot))
%%\end{verbatim}
%%\end{quote}
%% 
%%The postexpander must be able to call direct and indirect.
%%A~call instruction may include multiple effects; the expander is responsible for
%%  passing the destination of the call, as well as any other effects.
<<generic expansion operations for register machines>>=
val callr : tgt:temp              -> brtl branch
val call  : tgt:Rtl.Private.const -> brtl branch
@ 
%%There's no need for a [[return]], as on most machine a [[return]] is
%%just a branch instruction anyway.
%%On a machine like the Pentium, a return changes both program counter and stack pointer.
%%But we don't need to expand it, so the instruction does not have to be protected
%%by using [[don't_touch_me]].
%%
%%The [[cut to]] is as created by the target-dependent code, except
%%right-hand sides have been expanded to temporaries.
%%We need a special function for [[cut to]] because this is the one
%%case, explained above, in which we produce a single RTL that normally
%%stands for a two-instruction sequence.
%%We do this because that sequence \emph{must not} be broken up.
<<generic expansion operations for register machines>>=
val cut_to : Mflow.cut_args -> brtl branch
@
%%The [[return]] instruction performs the conventional return, taking advantage of
%%  return-stack hardware.
%%The [[forbidden]] instruction produces a run-time error, which helps us generate
%%  efficient code with checked run-time errors.
<<generic expansion operations for register machines>>=
val return    : Rtl.rtl
val forbidden : Rtl.rtl   (* causes a run-time error *)
@
%%The postexpander may insist on having some instructions untouched.
%%This is possible only for an instruction with multiple effects and a
%%single guard.
%%It is useful for protecting target-specific, multi-effect instructions such as
%%returns. 
<<generic expansion operations for register machines>>=
val don't_touch_me : Rtl.Private.effect list -> bool
@
%%Several of the functions above return an abstract representation of machine
%%  instructions, in the form of values of the type [[CBranch]], which represent
%%  the essential [[RTL]] expressions and control-flow paths.
%%We can convert the abstract representations to concrete [[RTLs]] using the functions
%%  in the machine record:
%%\subsubsection{Postexpander operations for stack machines}
%%
%%Most postexpanders will not need this section and can simply placate
%%the gods by writing
%%\begin{verbatim}
%%  include Postexpander.Nostack(Address)
%%\end{verbatim}
%%to get implementations of the functions below.
%%But if you do have to deal with a machine without real registers (like
%%the x86 floating-point unit), read on.
%%
%%For simplicity, we assume the target machine has at most one stack.
%%If we need more generality, we can add it later.
%%
%%To begin, we have to know which operators use the stack.
%%If an operator uses the stack, we need to know whether to push its
%%left operand first or its right operand first, and we need to know how
%%much stack room it needs to execute successfully.
<<types for postexpanders>>=
type operator_class = Register | Stack of push * int
and  push = LeftFirst | RightFirst
@ 
%%For a particular machine, we need to know the class of each operator,
%%the depth of the stack, and the width of a value that can be pushed on
%%the stack.
<<generic expansion operations for stack machines>>=
val opclass : operator -> operator_class
val stack_depth : int
val stack_width : int
@ 
%%We also need to identify an operator that takes a value from the stack
%%and converts it for use in a temporary.  This sort of operator is
%%needed on machines in which the width of stack is different from the
%%width of a temporary (like the Pentium).
<<generic expansion operations for stack machines>>=
val converts_stack_to_temp : operator -> bool
@
%%We can push a value from memory or pop the stack into memory.
<<generic expansion operations for stack machines>>=
val push      : addr:address -> assertion -> brtl block
val store_pop : addr:address -> assertion -> brtl block
@ 
%%We also have versions of these operations that convert between data
%%formats while popping or pushing.
%%We have to give the width of the value in memory.
<<generic expansion operations for stack machines>>=
val push_cvt      : operator -> width -> addr:address -> assertion -> brtl block
val store_pop_cvt : operator -> width -> addr:address -> assertion -> brtl block
@ 
%%And there might be a rounding mode
<<generic expansion operations for stack machines>>=
val push_cvt_rm      : operator -> warg -> width -> addr:address -> assertion
                                -> brtl block
val store_pop_cvt_rm : operator -> warg -> width -> addr:address -> assertion
                                -> brtl block
@ 
%%For back ends that use stack-slot temporaries, these operations have
%%to be duplicated at different types.
%%A~stack-slot temporary, which is identified by [[SlotTemp.is]]
%%effectively carries with it an address and an 
%%assertion.
<<generic expansion operations for stack machines>>=
module SlotTemp : sig
  val is               : temp -> bool
  val push             : temp -> brtl block
  val store_pop        : temp -> brtl block
  val push_cvt         : operator -> width -> temp -> brtl block
  val store_pop_cvt    : operator -> width -> temp -> brtl block
  val push_cvt_rm      : operator -> warg -> width -> temp -> brtl block
  val store_pop_cvt_rm : operator -> warg -> width -> temp -> brtl block
end
@ 
%%We can also imagine a whole bunch of stack operations:
%%[[stack_copy]], [[dup]], [[exch]], [[pop]], and more.
%% Luckily we don't need any of them for code expansion.
%%
%%We may have to push a constant.
%%This, too, may happen with conversion.
<<generic expansion operations for stack machines>>=
val pushk     :                      Rtl.Private.const -> brtl block
val pushk_cvt : operator -> width -> Rtl.Private.const -> brtl block
@
%%We may operate on the stack.
%%Such on operation may need a rounding mode.
<<generic expansion operations for stack machines>>=
val stack_op    : operator         -> brtl block
val stack_op_rm : operator -> warg -> brtl block
@
%%We may branch conditionally based on the result of a stack operation.
<<generic expansion operations for stack machines>>=
val bc_stack : operator -> ifso:(brtl cbranch) -> ifnot:(brtl cbranch) -> brtl cbranch
@ 
%%To support a calling convention that passes arguments or results on
%%the stack, we have to support push and pop instructions.
%%But a calling-convention automaton knows nothing of push and pop---in
%%particular, an automaton expects to be able to fetch a value using
%%only an RTL expression, so it has no way to create the side effect on
%%the stack pointer.
%%We resolve this problem by introducing a \emph{proxy} for the location
%%on the top of the stack.
%%This proxy may be used before code expansion with the expectation that
%%the code expander will rewrite it away:
%%\begin{itemize}
%%\item
%%If the proxy appears in an rvalue context, the expander replaces it
%%with whatever is on top of the stack (which is popped off).
%%\item
%%If the proxy appears on the left of a store, the expander pushes the
%%right-hand side.
%%\item 
%%If the proxy is killed, the expander complains bitterly.
%%\end{itemize}
%%Because not every postexpander supports stack operations, we provide
%%[[is_stack_top_proxy]] so that it can always return [[false]].
<<generic expansion operations for stack machines>>=
val stack_top_proxy    : Rtl.loc
val is_stack_top_proxy : Rtl.Private.loc -> bool
@ 
%%\subsubsection{A placeholder for register-only machines}
%%A postexpander for a register-only machine can simply include a
%%[[Nostack]] module.
<<postexpander.mli>>=
module Nostack (Address : sig type t val reg : temp -> t end) : sig
 <<generic expansion operations for stack machines>>
end
@ 
%%\subsubsection{Relationship of postexpander and recognizer}
%%
%%It is often said that the recognizer must accept anything emitted by
%%the postexpander.
%%The truth is more subtle:
%%If an RTL is emitted by the postexpander, that RTL must be accepted by
%%the recognizer \emph{after} register allocation and simplification.
%%\begin{itemize}
%%\item
%%The postexpander must collude with the register allocator such that
%%after an acceptable substitution of hardware registers for
%%temporaries, the recognizer will accept the resulting RTL.
%%How does the register allocator know what substitutions are
%%acceptable?
%%By a combination of two elements: 
%%\begin{itemize}
%%\item
%%Given a calling convention [[cc]], the register allocator may use only
%%registers that appear in the union of the sets
%%[[cc.Call.volregs]] and [[cc.Call.pre_nvregs]].
%%Only these registers may be substituted for temporaries.
%%\item
%%Each temporary space~$S$ includes a [[Space.stands_for]] predicate, which says
%%whether a particular hardware register may acceptably be substituted
%%for a temporary drawn from space~$S$.
%%Help applying this predicate can be had from function [[Target.fits]].
%%\end{itemize}
%%\item
%%The simplifier evaluates many expressions at compile time.
%%For example, the expression $\mathtt{sx}_{16-32}(\mathtt{0xffff})$
%%is simplified to  $\mathtt{0xffffffff}$.
%%Even if the postexpander emits the former, the recognizer must be
%%prepared to accept the latter.
%%In fact, if what the machine instruction does is sign-extend a 16-bit
%%constant to 32~bits, the recognizer must accept \emph{exactly} those
%%32-bit constants that can be obtained by sign-extending 16-bit
%%constants.
%%(The postexpander, by contrast, can choose either representation.)
%%\item
%%The typical recognizer should be prepared to accept additional RTLs that are
%%not emitted by the postexpander but may be computed by peephole
%%optimization.
%%But unlike the previous two requirements, recognizing additional
%%instructions is optional.
%%This is because unlike the register allocator and simplifier, the
%%peephole optimizer is \emph{guarded} by a call to the recognizer.
%%\end{itemize}
%%
%%\clearpage
%%
\subsection{Implementation of the postexpander module}
%%
%%\subsubsection {Postexpander support}
%%
%%\paragraph{Allocation}
%%The generic expander can temporarily install and uninstall allocators.
<<exported utility functions for use by the generic expander>>=
val remember_allocators : Talloc.Multiple.t -> Automaton.t -> unit
val forget_allocators   : unit -> unit
@ 
%%The following are checked run-time errors:
%%\begin{itemize}
%%\item
%% To call [[remember_allocators]] twice
%%consecutively without an intervening call to [[forget_allocators]]
%%\end{itemize}
%%The following are \emph{unchecked} run-time errors:
%%\begin{itemize} 
%%\item
%%To call any function in [[Postexpander.S]] before any call to
%%[[remember_allocators]].
%%\item
%%To call any function in [[Postexpander.S]] if [[forget_allocators]]
%%has been called more recently than
%%[[remember_allocators]].
%%\end{itemize}
%%
<<postexpander.ml>>=
module DG  = Dag
module G   = Zipcfg
module R   = Rtl
module RU  = Rtlutil
type uid = int
<<types for postexpanders>>
<<signature of a postexpander>>
@ 
<<postexpander.ml>>=
module Alloc = struct
  let badslot : width -> int -> Automaton.loc =
    fun _ -> Impossible.impossible "slot allocator misconfigured"
  let badtemp : char -> width -> temp =
    fun _ _ -> Impossible.impossible "temporary allocator misconfigured"
  let valid = Reinit.ref false
  let theslot = Reinit.ref badslot
  let thetemp = Reinit.ref badtemp
  let slot ~width ~aligned = !theslot width aligned
  let temp c w = !thetemp c w
  let isValid () = !valid
end
let remember_allocators t s =
  if !Alloc.valid then
    Impossible.impossible "too many allocators";
  Alloc.valid := true;
  Alloc.thetemp := (fun c w -> Talloc.Multiple.reg c t w);
  Alloc.theslot := (fun w a -> Automaton.allocate s w "" a)
let forget_allocators () = 
  if not !Alloc.valid then
    Impossible.impossible "too few allocators";
  Alloc.valid := false;
  Alloc.theslot := Alloc.badslot;
  Alloc.thetemp := Alloc.badtemp
@
%%\paragraph{Expansion}
%%The generic expander can expand, recursively, for the postexpander.
<<exported utility functions for use by the generic expander>>=
val remember_expanders : 
  (exp block -> brtl block) -> (exp branch -> brtl branch) ->
  (exp cbranch -> brtl cbranch) -> unit
val forget_expanders : unit -> unit
@ 
%%The following are checked run-time errors:
%%\begin{itemize}
%%\item
%% To call [[remember_expanders]] twice
%%consecutively without an intervening call to [[forget_expanders]]
%%\end{itemize}
%%The following are \emph{unchecked} run-time errors:
%%\begin{itemize} 
%%\item
%%To call any function in [[Postexpander.S]] before any call to
%%[[remember_expanders]].
%%\item
%%To call any function in [[Postexpander.S]] if [[forget_expanders]]
%%has been called more recently than
%%[[remember_expanders]].
%%\end{itemize}
%%
<<postexpander.ml>>=
module Expand = struct
  let bad : exp block -> brtl block =
    fun _ -> Impossible.impossible "block expander misconfigured"
  let badb : exp branch -> brtl branch =
    fun _ -> Impossible.impossible "branch expander misconfigured"
  let badcb : exp cbranch -> brtl cbranch =
    fun _ -> Impossible.impossible "conditional branch expander misconfigured"
  let valid   = Reinit.ref false
  let theblock   = Reinit.ref bad
  let thebranch  = Reinit.ref badb
  let thecbranch = Reinit.ref badcb
  let block   b = !theblock   b
  let branch  b = !thebranch  b
  let cbranch b = !thecbranch b
  let cbranch' e ~ifso ~ifnot =
    let rec upd_cbr = function
      | DG.Exit true  -> ifso
      | DG.Exit false -> ifnot
      | DG.Test (b, c) -> DG.Test (upd_block b, upd_cbi c)
      | DG.Shared (u, cbr) -> DG.Shared (u, upd_cbr cbr)
    and upd_block b = match b with
      | DG.Rtl _ | DG.Nop -> b
      | DG.Seq (b1, b2) -> DG.Seq (upd_block b1, upd_block b2)
      | DG.If (e, b1, b2) -> DG.If (e, upd_block b1, upd_block b2)
      | DG.While (cb, b) -> DG.While (upd_cbr cb, upd_block b)
    and upd_cbi (i, cb1, cb2) = (i, upd_cbr cb1, upd_cbr cb2) in
    upd_cbr (cbranch (DG.Test (DG.Nop, (e, DG.Exit true, DG.Exit false))))
end
let remember_expanders b br cb =
  if !Expand.valid then
    Impossible.impossible "too many expanders";
  Expand.valid := true;
  Expand.theblock   := b;
  Expand.thebranch  := br;
  Expand.thecbranch := cb
let forget_expanders () = 
  if not !Expand.valid then
    Impossible.impossible "too few expanders";
  Expand.valid := false;
  Expand.theblock   := Expand.bad;
  Expand.thebranch  := Expand.badb;
  Expand.thecbranch := Expand.badcb
@ 
<<postexpander.ml>>=
let (<:>) = DG.(<:>)
@ 
%%To avoid circularity, these functions are copied from the [[Rewrite]] module.
<<postexpander.ml>>=
module RO = struct
  let lobits w w' x = Rtl.app (Rtl.opr "lobits" [w;w';]) [x; ]
  let zx w w' x = Rtl.app (Rtl.opr "zx" [w;w';]) [x; ]
end
@ 
<<postexpander.ml>>=
let warg_val = function
  | WTemp (Register.Reg t) -> R.fetch (R.reg t) (Register.width t)
  | WTemp (Register.Slice (w, lsb, t)) -> R.fetch (R.slice w ~lsb (R.reg t)) w
  | WBits b -> R.bits b (Bits.width b)

let with_hw ~hard ~soft ~temp block = 
  match soft with
  | WTemp r when Register.eqx r hard -> block
  | _ ->
      let n    = Register.widthx hard in
      let w    = Register.width temp in
      let t    = R.reg temp in
      let tval = R.fetch t w in
      let hardloc = match hard with
      | Register.Reg r -> R.reg r
      | Register.Slice (w, lsb, r) -> R.slice w ~lsb (R.reg r) in
      let hard = R.fetch hardloc n in
      let save    = DG.Rtl (R.store t (RO.zx n w hard) w) in
      let set     = DG.Rtl (R.store hardloc (warg_val soft) n) in
      let restore = DG.Rtl (R.store hardloc (RO.lobits w n tval) n) in
      Expand.block (save <:> set) <:> block <:> Expand.block restore
@
%%
%%\subsubsection{Placeholders for machines without stacks}
%%
<<postexpander.ml>>=
module Nostack (Address : sig type t val reg : temp -> t end) = struct
  let imposs = Impossible.impossible
  let opclass _ = Register
  let stack_depth = 0
  let stack_width = 0
  let converts_stack_to_temp _ = false
  let push ~addr _                   = imposs "stack op on register machine"
  let store_pop ~addr _              = imposs "stack op on register machine"
  let push_cvt _ _ ~addr _           = imposs "stack op on register machine"
  let push_cvt_rm _ _ _ ~addr _      = imposs "stack op on register machine"
  let store_pop_cvt _ _ ~addr _      = imposs "stack op on register machine"
  let store_pop_cvt_rm _ _ _ ~addr _ = imposs "stack op on register machine"
  let pushk _                        = imposs "stack op on register machine"
  let pushk_cvt _ _ _                = imposs "stack op on register machine"
  let stack_op _                     = imposs "stack op on register machine"
  let stack_op_rm _                  = imposs "stack op on register machine"
  let bc_stack _ ~ifso ~ifnot        = imposs "stack op on register machine"
  let stack_top_proxy = Rtl.reg (('\000', Rtl.Identity, Cell.of_size 0), 0, Rtl.C 0)
  let is_stack_top_proxy _ = false

  module SlotTemp = struct
    let is _ = false
    let push _                   = imposs "stack op on register machine"
    let store_pop _              = imposs "stack op on register machine"
    let push_cvt _ _ _           = imposs "stack op on register machine"
    let push_cvt_rm _ _ _ _      = imposs "stack op on register machine"
    let store_pop_cvt _ _ _      = imposs "stack op on register machine"
    let store_pop_cvt_rm _ _ _ _ = imposs "stack op on register machine"
  end
end
@
%%
%%\clearpage
%%% ----------------------------------------------------------------
\subsection{A generic expander}
%%% ----------------------------------------------------------------
%%
%%\subsubsection{Interface}
%%
%%The generic expander is functorized over a postexpander.
%%Here is the interface.
%%The expander needs a supply of temporaries, which is part of the
%%[[Ast2ir.proc]]. 
%%We provide multiple forms of the expander:
%%\begin{itemize}
%%  \item [[cfg]] expands an entire flow graph.
%%  \item [[branch]] expands a simple flow-graph branch segment.
%%\end{itemize}
%%
<<expander module type>>=
module type S = sig
  val cfg     : 'a -> Preast2ir.proc -> Preast2ir.proc * bool
  val machine : Preast2ir.basic_proc Target.machine
  val block :
    Preast2ir.basic_proc -> Rtl.exp Dag.block   -> (Rtl.exp -> Rtl.rtl) Dag.block
  val goto :
    Preast2ir.basic_proc -> Rtl.exp Dag.branch  -> (Rtl.exp -> Rtl.rtl) Dag.branch
  val cbranch :
    Preast2ir.basic_proc -> Rtl.exp Dag.cbranch -> (Rtl.exp -> Rtl.rtl) Dag.cbranch
  val call :
    Preast2ir.basic_proc -> Rtl.exp Dag.branch  -> (Rtl.exp -> Rtl.rtl) Dag.branch
  val jump :
    Preast2ir.basic_proc -> Rtl.exp Dag.branch  -> (Rtl.exp -> Rtl.rtl) Dag.branch
  val cut :
    Preast2ir.basic_proc -> Rtl.exp Dag.branch  -> (Rtl.exp -> Rtl.rtl) Dag.branch
end 
@
%%
<<expander.mli>>=
<<expander module type>>
module IntFloatAddr (Post : Postexpander.S) : S
@ 
%%\subsubsection{Abbreviations and utilities}
%%Here are some abbreviations and utilities.
%%
<<expander.ml>>=
open Nopoly
<<expander module type>>

module A   = Automaton
module BO  = Bits.Ops
module DG  = Dag
module G   = Zipcfg
module GR  = Zipcfg.Rep
module O   = Opshape 
module PA  = Preast2ir
module PX  = Postexpander
module R   = Rtl
module RP  = Rtl.Private
module RU  = Rtlutil
module Reg = Register
module Rg  = Register
module S   = Space
module T   = Target

module Up  = Rtl.Up
module Dn  = Rtl.Dn

let upassn = Rtl.Up.assertion
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let unimpf  fmt = Printf.kprintf Impossible.unimp fmt
@ 
<<expander.ml>>=
let fetch l = RP.Fetch (Dn.loc l, RU.Width.loc l)
let width e = RU.Width.exp (Up.exp e)
@ 
%%Sometimes, we may require that a node have an instruction.
<<expander.ml>>=
@ 
%%We provide three kinds of composition: blocks with blocks, blocks
%%with branches, and blocks with conditional branches.
<<block-manipulation utilities>>=
let (<:>) = DG.(<:>) in
let (<::>) is (is', branch) = (is <:> is', branch) in
let rec (<:::>) is cbranch = match cbranch with
| DG.Exit b -> DG.Exit b
| DG.Test (b, c) -> DG.Test (is <:> b, c)
| DG.Shared (u, c) -> DG.Shared (u, is <:::> c) in
@
%%\subsubsection{Printing code for debugging}
%%Some debugging code is most helpful.
%%The expander writes debugging information as it goes;
%%to activate it, try \texttt{QCDEBUG=expander~qc--}.
<<expander.ml>>=
module D = struct (* debugging *)
  let () = Debug.register "expander" "code expander"
  let eprintf = Printf.eprintf 
  let sprintf = Printf.sprintf 
  let strings =
    if Debug.on "expander" then
      (fun ss -> eprintf "%s" (String.concat "" ss))
    else
      (fun ss -> ()) 
  let int  n = string_of_int n
  let rtl  r = Rtlutil.ToString.rtl r
  let brtl b = "<function: exp -> rtl>"
  let temp ((s, _, ms), n, c) =
    sprintf "$%s[%d] : %d loc" (Char.escaped s) n (Cell.to_width ms c)
  let exp = Rtlutil.ToString.exp 
  let pr_rtls rs = List.iter (fun r -> strings ["  "; rtl r; "\n"]) (List.rev rs)
  <<more printing functions for the internal [[D]] module>>
  (* renaming *)
  let cbranch pa = if Debug.on "expander" then cbranch pa else fun _ -> "<cbranch>"
  let pr_block pa = if Debug.on "expander" then pr_block pa "  " else fun _ -> ()
  let exp  e = Rtlutil.ToString.exp (Up.exp e)
  let exp' e = Rtlutil.ToString.exp e
  let loc  l = Rtlutil.ToString.loc (Up.loc l)
end
@ 
%$
%%Printing conditional branches:
<<more printing functions for the internal [[D]] module>>=
let rec cbi pa c = match c with
| a, DG.Exit true,  DG.Exit false -> pa a
| a, DG.Exit false, DG.Exit true  -> sprintf "!(%s)" (pa a)
| a, DG.Exit true,  p -> sprintf "(%s || %s)" (pa a) (cbranch pa p)
| a, p, DG.Exit false -> sprintf "(%s && %s)" (pa a) (cbranch pa p)
| a, p, q -> sprintf "(%s ? %s : %s)" (pa a) (cbranch pa p) (cbranch pa q)
and cbranch pa c = match c with
| DG.Exit p           -> if p then "true" else "false"
| DG.Shared (_, c)    -> sprintf "[%s]" (cbranch pa c)
| DG.Test (DG.Nop, c) -> cbi pa c
| DG.Test (b, c)      -> sprintf "{%s; %s}" (compact_block pa b) (cbi pa c)
and compact_block pa b =
  let rec pr = function
    | DG.Rtl r        -> sprintf "%s" (rtl r)
    | DG.Seq (b, b')  -> sprintf "%s; %s" (pr b) (pr b')
    | DG.If (c, t, f) -> sprintf "if (%s) { %s; } else { %s; }"
                           (cbranch pa c) (pr t) (pr f)
    | DG.While (c, b) -> sprintf "while (%s) { %s; }" (cbranch pa c) (pr b)
    | DG.Nop          -> "skip" in
  pr b
@ 
%%Printing blocks:
<<more printing functions for the internal [[D]] module>>=
let rec pr_block pa ind b =
  let rec pr = function
    | DG.Rtl r          -> eprintf "%s%s;\n" ind (rtl r)
    | DG.Seq (b, b')    -> pr b; pr b'
    | DG.If (DG.Exit p, t, f) -> pr (if p then t else f)
          (* true to semantics, but maybe not informative enough *)
    | DG.If (DG.Shared (_, c), t, f) -> pr (DG.If(c, t, f))
    | DG.If (DG.Test (DG.Nop, c), t, f) -> 
        let ind' = ind ^ "  " in
        eprintf "%sif (%s) {\n" ind (cbi pa c);
        pr_block pa ind' t;
        eprintf "%s} else {\n" ind;
        pr_block pa ind' f;
        eprintf "%s}\n" ind
    | DG.If (DG.Test (b, cbi), t, f) ->
        assert (Pervasives.(<>) b DG.Nop);
        pr (DG.Seq (b, DG.If (DG.Test(DG.Nop, cbi), t, f)))
    | DG.While (c, b) ->  (* not implemented really *)
        let ind' = ind ^ "  " in
        eprintf "%swhile (%s) {\n" ind (cbranch pa c);
        pr_block pa ind' b;
        eprintf "%s}\n" ind
    | DG.Nop -> eprintf "%s<nop>\n" ind in
  pr b
@ 
%%This little hack
%%enables statement-count profiling to work even when the expander loops infinitely.
%%It was useful in debugging the expander.
<<expander.ml>>=
let _ = Sys.set_signal Sys.sigterm (Sys.Signal_handle (fun _ -> exit 0))
@ 
%%
%%\subsubsection {The generic-expander functor}
%%
%%This expander is intended for machines with integer, floating, and
%%address register spaces.
%%It will also work with integer/float machines, since we can make
%%address registers a synonym for integer registers.
<<expander.ml>>=
module IntFloatAddr (Post : Postexpander.S) = struct
  let pc_lhs = Dn.loc Post.pc_lhs
  let pc_rhs = Dn.loc Post.pc_rhs
  <<internal utilities for the generic expander>>
  <<generic expander>>
  <<generic flow-graph expander>>
end
@ 
%%\subsubsection{Contexts in which to evaluate expressions}
%%
%%The world is complicated by the existence of two kinds of machines:
%%stack machines and register machines.
%%For a stack machine, much of code expansion involves computing
%%subexpressions onto the stack.
%%For a register machine, much of code expansion involves computing
%%subexpressions into temporaries, which the register allocator will
%%later turn into registers.
%%
%%For simplicity, we assume that a stack machine has exactly one stack.
%%But registser machines have lots of kinds of registers.
%%To choose the right kind for an expression, we need to know the
%%\emph{context}.
%%The context tells us what sort of temporary is appropriate
%%(typically integer, float, or address).
%%Sadly, there are two representations of contexts.
%%\begin{itemize}
%%\item
%%A \emph{dynamic} context provides two items: an infinite
%%supply of temporaries, and a predicate that says whether an existing
%%temporary can be used in the context.
%%The supply of temporaries must be shared with the rest of the
%%compiler, including the variable placer and
%%register allocator.
%%Because the supply of temporaries is new for each procedure, we can't
%%provide one at compile-compile time.
%%This is why the context is \emph{dynamic}.
%%\item
%%A \emph{static} context provides, instead of a supply of temporaries,
%%the name of the space from which the temporaries should be drawn.
%%(The static context also includes the checking predicate.)
%%We can therefore create a static context at compile-compile time, and
%%in fact we require the postexpander to supply three of them (see
%%chunk~\subpageref{expander.Postexpander.context}). 
%%\end{itemize}
%%We use the allocator in the [[Proc.t]] to convert from a static
%%context to a dynamic context; see function [[contextmap]] in
%%chunk~\subpageref{expander.contextmap}. 
%%
%%Here we define the [[alloc]] and [[check]] functions, which use a
%%dynamic context.
%%(Actually [[check]] can use either kind.)
<<generic expander>>=
let alloc (allocate, check) w   = allocate w
let ok    (allocate, check) reg = check reg
@ 
%%Function [[temp_in_context]] takes an existing temporary and a
%%context, and returns a (possibly new) temporary that is OK for the
%%context (along with instructions that make it so). 
%%The temporary is \emph{preceded} by [[instructions]].
<<definition of [[temp_in_context]]>>=
let temp_in_context t context instructions =
  if ok context t then
    t, instructions
  else
    let t' = alloc context (Register.width t) in
    t', instructions <:> Post.move t' t in
@ 
%%Within the expander, we eagerly build some dynamic contexts:
%%[[icontext]], [[acontext]], and [[fcontext]].
%%We also keep function [[contextmap]] for those times when we get a
%%context that's not known at compile-compile time.
%%\nextchunklabel{expander.contextmap}%
<<generic expander>>=
let expand proc =
  let PA.T tgt = proc.Proc.target in
  <<stack-slot allocation>>
  <<block-manipulation utilities>>
  <<functions for dealing with trivial guards>>
  let contextmap (allocator, checker) = (allocator proc.Proc.temps, checker) in
  let icontext = contextmap Post.icontext in
  let acontext = contextmap Post.acontext in
  let fcontext = contextmap Post.fcontext in
  <<rounding-mode checking>>
  <<context guessing>>
  let alloc_direct (allocator, _) = allocator proc.Proc.temps in
  <<definition of [[temp_in_context]]>>
  <<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>
  (block, branch', expand_cbranch, call', jump', cut')
let number = 999
@ 
%%To find the context for the operands of a comparison, I use the
%%dreadful hack that every floating-point 
%%comparison begins with [[f]] and no other comparison does.
%%This code probably should be replaced with a call to
%%[[Post.arg_contexts]].
<<context guessing>>=
let cmp_context (oprname, ws) =
  if oprname.[0] =<= 'f' then fcontext else icontext in
@
%%In other situations, we may have to guess a context based on a
%%right-hand side. 
<<context guessing>>=
let guess_context = function
  | RP.Const (RP.Bits b) -> contextmap (Post.constant_context (Bits.width b))
  | RP.Const k -> icontext
  | RP.Fetch(RP.Reg ((('f'|'u'), _, _), _, _),_) -> fcontext
  | RP.Fetch _ -> icontext
  | RP.App (op, args) -> contextmap (Post.result_context op) in
@ 
%%We may also have to guess whether to develop a right-hand side into a
%%temporary or on the stack.
<<context guessing>>=
let looks_like_stack_rhs = function
  | RP.App (op, _) ->
      begin
        match Post.opclass op with
        | PX.Stack (_, _) -> true
        | PX.Register -> false
      end
  | RP.Fetch (l, _) -> Post.is_stack_top_proxy l
  | _ -> false in
@ 
%%\subsubsection{Expanding an expression into a temporary}
%%The core of the expander is a function [[to_temp]], which takes an
%%expression and returns a pair containing a list of instructions and a
%%temporary such that executing those instructions develops the
%%expression into that temporary.
%%
%%Unprimed versions of functions issue debugging screeds; primed
%%versions do the real work.
%%Here we define the primed and use the unprimed; the two are connected
%%with debugging code below.
%%
%%Most cases identify what postexpander function should be used and
%%create suitable temporaries.%
%%\footnote{We have a small problem with register targeting; the problem
%%effects the size of the expanded code and therefore the compile-time
%%efficiency.
%%We wish to avoid generating superfluous move
%%instructions.
%%There are two possible contexts: if a right-hand side is already a temporary, we avoid
%%allocating a second temporary.
%%But if a left-hand side is already a temporary, we fail to ``target''
%%the right-hand side into that temporary.
%%It is not obvious to NR how to write an expander that achieves both.}
<<definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>=
let rec to_temp' room context e =
  match e with
  <<cases for converting a compile-time constant to a temporary>>
  <<cases for converting a bare [[Fetch]] to a temporary>>
  <<cases for sign extending or zero extending a temporary>>
  <<cases for sign-extending and zero-extending loads>>
  <<cases for sign extending or zero extending a narrow hardware register>>
  <<cases for extracting from a wide temporary>>
  <<cases for narrow weird value operators>>
  <<cases for converting a Boolean to a value>>
  | RP.App ((_, [stackw; tempw]) as cvt, _) as e
    when Post.converts_stack_to_temp cvt ->
      let slot = exchange_slot tempw in
      let t, is = to_temp room context (fetch_slot slot tempw) in
      t, assign_slot room slot e tempw <:> is 
  | RP.App (("f2f_implicit_round", ws), [x]) ->
      to_temp room context (RP.App (("f2f", ws), [x; RP.Fetch(rounding_mode, 2)]))
  | RP.App (op, args) -> (
    <<action for expanding [[op(args)]] into a temporary>>
  )
<<other generic expander functions>>
in
@ 
%%Details depend on whether the operator is a stack operator or a
%%register operator.
<<action for expanding [[op(args)]] into a temporary>>=
match Post.opclass op with
| PX.Stack(dir, depth) ->
    let w = Post.stack_width in
    let slot = exchange_slot w in
    let t, is = to_temp room context (fetch_slot slot w) in
    t, assign_slot room slot e w <:> is
| PX.Register ->
    let w = width e in
    let t = alloc_direct (Post.result_context op) w in 
    let temp e c = to_temp room (contextmap c) e in
    let warg e c = to_warg room (contextmap c) e in
    let is = match O.capply temp warg op args (Post.arg_contexts op) with
    | O.Binop ((x, b1), (y, b2))          -> b1 <:> b2 <:>        Post.binop t op x y
    | O.Unop  ((x, b1))                   -> b1 <:>               Post.unop  t op x
    | O.Binrm ((x, b1), (y, b2), (r, b3)) -> b1 <:> b2 <:> b3 <:> Post.binrm t op x y r
    | O.Unrm  ((x, b1), (r, b2))          -> b1 <:> b2 <:>        Post.unrm  t op x r
    | O.Fpcvt ((x, b1), (r, b2))          -> b1 <:> b2 <:>        Post.unrm  t op x r
    | O.Dblop ((x, b1), (y, b2))          ->
        Impossible.unimp "double-width multiply into single temporary"
    | O.Wrdop ((x, b1), (y, b2), (z, b3)) -> b1 <:> b2 <:> b3 <:> Post.wrdop t op x y z
    | O.Wrdrop((x, b1), (y, b2), (z, b3)) ->
        impossf "single-bit result direct into temporary"
    | O.Cmp _ | O.Width | O.Bool | O.Nullary ->
        impossf "operator %%%s reached postexpander" (fst op) in
    temp_in_context t context is 
@
<<cases for converting a compile-time constant to a temporary>>=
| RP.Const k ->
    let w = width e in
    let t = alloc context w in
    t, Post.li t k
| RP.App (_, _) when is_compile_time_constant e ->
    let w = width e in
    let t = alloc context w in
    t, Post.lix t (Up.exp e)
@
<<cases for converting a bare [[Fetch]] to a temporary>>=
| RP.Fetch (l, w) when Post.is_stack_top_proxy l ->
    let slot = exchange_slot w in
    let t, is = to_temp room context (fetch_slot slot w) in
    t, assign_slot room slot e w <:> is
| RP.Fetch (RP.Mem (('m', agg, ms), c, addr, assn), w) ->
    let t = alloc context w in
    let a, is = address room addr in
    assert (agg =*= Post.byte_order);
    assert (w = Cell.to_width ms c);
    t, is <:> Post.load t a (upassn assn)
| RP.Fetch (RP.Reg r, w) ->
    assert (w = Register.width r);
    temp_in_context r context DG.Nop
| RP.Fetch _ ->
    impossf "memory-like access to non-memory space"
@ 
<<cases for extracting from a wide temporary>>=
| RP.App (("lobits", [w;n]), [RP.App (("shrl", [w']), [e; RP.Const (RP.Bits b)])]) ->
    let shamt = Bits.U.to_int b in
    assert (w = w' && shamt < w);
    let t = alloc context n in
    let src, is = to_temp room (guess_context e) e in
    t, is <:> Post.extract ~dst:t ~lsb:shamt ~src
| RP.App (("lobits", [w;n]), [e]) ->
    let t = alloc context n in
    let src, is = to_temp room (guess_context e) e in
    t, is <:> Post.extract ~dst:t ~lsb:0 ~src
@
%%Sign-extending and zero-extending loads are done into integer registers only.
%%This fact is documented in the postexpander interface.
<<cases for sign-extending and zero-extending loads>>=
| RP.App (("sx", [n;w]), [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n')]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    let t = alloc icontext w in
    let a, is = address room addr in
    assert (agg =*= Post.byte_order);
    temp_in_context t context (is <:> Post.sxload t a n (upassn assn))
| RP.App (("zx", [n;w]), [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n')]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    let t = alloc icontext w in
    let a, is = address room addr in
    assert (agg =*= Post.byte_order);
    temp_in_context t context (is <:> Post.zxload t a n (upassn assn))
@
<<cases for sign extending or zero extending a temporary>>=
| RP.App (("sx", [n; w]), [RP.App(("lobits", [w'; n']), [x])]) when w = w' ->
    if n <> n' then Impossible.impossible "ill-typed %sx(%lobits(...))";
    to_temp' room context (Dn.exp (Rewrite.sxlo n w (Up.exp x)))
| RP.App (("zx", [n; w]), [RP.App(("lobits", [w'; n']), [x])]) when w = w' ->
    if n <> n' then Impossible.impossible "ill-typed %zx(%lobits(...))";
    to_temp' room context (Dn.exp (Rewrite.zxlo n w (Up.exp x)))
@ 
%%
<<cases for sign extending or zero extending a narrow hardware register>>=
| RP.App ((("sx"|"zx" as o), [n; w]), [RP.Fetch(r, _)]) when RU.is_hardware r ->
    let r = RU.to_hardware r in
    let t = alloc icontext w in
    let fill = if o == "sx" then PX.HighS else PX.HighZ in
    t, Post.hwget ~dst:(fill,t) ~src:r 
@ 
%%To get a result of normal width, 
%%we can see a weird value operator in two contexts: a weird result is
%%extended or a normal result is used
<<cases for narrow weird value operators>>=
| RP.App ((("sx"|"zx") as xop, [n; w]),
          [RP.App((("carry"|"borrow"), [w']) as wrdop, args)]) ->
    if n <> 1 then Impossible.impossible "ill-typed %sx/%zx(...)";
    let signed = xop =$= "sx" in
    let x, y, z, is = compile_weird_args room wrdop args in
    let t = alloc_direct (Post.result_context wrdop) w in
    let fill = if signed then PX.HighS else PX.HighZ in
    t, is <:> Post.wrdrop ~dst:(fill,t) wrdop x y z 
@ 
%$
<<cases for narrow weird value operators>>=
| RP.App ((("addc"|"subb"), [w]) as wrdop, args) ->
    let x, y, z, is = compile_weird_args room wrdop args in
    let t = alloc_direct (Post.result_context wrdop) w in
    t, is <:> Post.wrdop ~dst:t wrdop x y z 
@ 
<<other generic expander functions>>=
and compile_weird_args room op args = match args, Post.arg_contexts op with
| [x; y; z], [xc; yc; zc] ->
    let x, xis = to_temp room (contextmap xc) x in
    let y, yis = to_temp room (contextmap yc) y in
    let z, zis = to_warg room (contextmap zc) z in
    x, y, z, xis <:> yis <:> zis
| _ -> impossf "wrong number of args or contexts to %%%s" (fst op)
@ 
%%To compute a weird argument, we have a literal, a temporary, or
%%a hardware register.
<<other generic expander functions>>=
and to_warg room context e = match e with
| RP.Const (RP.Bits b) ->
    PX.WBits b, DG.Nop
| RP.App (("lobits", [w; n]), [e]) ->
    let t, is = to_temp room context e in
    (PX.WTemp (Rg.Reg t)), is
| RP.App ((("carry"|"borrow"), [w]) as wrdop, args) ->
    let x, y, z, is = compile_weird_args room wrdop args in
    let t = alloc_direct (Post.result_context wrdop) w in
    let t, is = 
      temp_in_context t context (is <:> Post.wrdrop (PX.HighAny, t) wrdop x y z) in
    (PX.WTemp (Rg.Reg t)), is
| RP.Fetch (RP.Reg r, w) -> 
    (PX.WTemp (Rg.Reg r), DG.Nop)
| RP.Fetch (RP.Slice (w, lsb, (RP.Reg r)), w') ->
    assert (w = w');
    (PX.WTemp (Rg.Slice (w, lsb, r)), DG.Nop)
| RP.Fetch _ -> Impossible.unimp "narrow argument from memory"
| e -> impossf "trying to put %s into a weird temporary" (RU.ToString.exp (Up.exp e))
@ 
%%Eventually, [[with_rounding_mode rm f]] should
%%\begin{enumerate}
%%\item
%%Save the current hardware rounding mode if necessary
%%\item
%%Set the hardware rounding mode to [[rm]] (if necessary)
%%\item 
%%Execute the code represented by applying [[f]] to the hardware
%%rounding mode
%%\item
%%Restore  the hardware rounding mode if necessary.
%%\end{enumerate}
%%\emph{And} it should be a utility function, because some hardware
%%might have rounding-mode information in the instruction word itself.
%%So instead, operators that take rounding modes have to become weird
%%value operators.
%% 
%%For the bit operator, we generate two branches of control flow, create an rtl for a
%%conditional branch, and pass everything over to [[expand_cbranch]].
<<cases for converting a Boolean to a value>>=
| RP.App ((("sx"|"zx") as op, [n; w]), [RP.App (("bit", []), [e])]) ->
    assert (n = 1);
    let t       = alloc context w in
    let nonzero = if op =$= "sx" then -1 else 1 in
    let tbranch = Post.li t (RP.Bits (Bits.S.of_int nonzero w)) in
    let fbranch = Post.li t (RP.Bits (Bits.zero w)) in
    let e = Up.exp e in
    let cond    = expand_cbranch (DG.cond e) in
    t, DG.If (cond, tbranch, fbranch)
@
%$
%%We might one day support multiple addressing modes, but for now, just registers. 
<<other generic expander functions>>=
and address room exp =
  let t, is = to_temp room acontext exp in
  R.fetch (R.reg t) (Register.width t), is
@
%%A compile-time constant is a sum or difference of compile-time constants.
<<other generic expander functions>>=
and is_compile_time_constant = function
  | RP.Const (RP.Bits _ | RP.Late (_, _)) -> true
  | RP.App   ((("add"|"sub"), [w]), es)   -> List.for_all is_compile_time_constant es
  | _ -> false
@ 
%%
%%\subsubsection{Expanding using stack instructions}
<<other generic expander functions>>=
and to_stack' room e =
  if room < 1 then
    impossf "machine stack overflow in code generation";
  if Rtlutil.Width.exp' e <> Post.stack_width then
     (Printf.eprintf "failing expression: %s\n" (Rtlutil.ToString.exp
                                                  (Rtl.Up.exp e));
         Unsupported.stack_width ~have:(Rtlutil.Width.exp' e)
         ~want:Post.stack_width);
  Debug.eprintf "expander" "to_stack %s\n" (RU.ToString.exp (Up.exp e));
  match e with
  | RP.Const k -> Post.pushk k
  <<cases for getting a [[Fetch]] on the stack>>
  | RP.App (("f2f_implicit_round", ws), [x]) ->
      to_stack room (RP.App (("f2f", ws), [x; RP.Fetch(rounding_mode, 2)]))
  <<cases for converting pushes>>
  | RP.App (("i2f", [iw; fw] as i2f), [e; rm]) ->
      let slot = exchange_slot iw in
      assign_slot room slot e iw <:>
      to_stack room (RP.App (i2f, [fetch_slot slot iw; rm]))
  | RP.App (("f2f", [w; _] as f2f), [e; rm]) ->
      let slot = exchange_slot w in
      assign_slot room slot e w <:>
      to_stack room (RP.App (f2f, [fetch_slot slot w; rm]))
  | RP.App (op, args) -> (
   <<action for expanding [[op(args)]] onto the stack>>
)
@ 
<<cases for getting a [[Fetch]] on the stack>>=
| RP.Fetch (l, _) when Post.is_stack_top_proxy l ->
    DG.Nop
| RP.Fetch (RP.Mem (('m', agg, ms), c, addr, assn), w) ->
    let a, is = address room addr in
    assert (agg =*= Post.byte_order);
    assert (w = Cell.to_width ms c);
    is <:> Post.push a (upassn assn)
| RP.Fetch (RP.Reg src, w) when Post.SlotTemp.is src ->
    assert (w = Register.width src);
    Post.SlotTemp.push src
| RP.Fetch (RP.Reg _, w) ->
    let slot = exchange_slot w in
    assign_slot room slot e w <:> to_stack room (fetch_slot slot w)
| RP.Fetch _ ->
    impossf "memory-like access to non-memory space"
@ 
<<action for expanding [[op(args)]] onto the stack>>=
Debug.eprintf "expander" "to_stack generic case for %s\n" (D.exp e);
match Post.opclass op with
| PX.Stack(dir, depth) ->
    let push room args =
      let args = match dir with PX.LeftFirst -> args | PX.RightFirst -> List.rev args in
      let (is, _) = List.fold_left (fun (is,r) e -> (is <:> to_stack r e, r-1))
                    (DG.Nop,room) args in
      is in
    let temp e c = e in
    let warg e c = to_warg room (contextmap c) e in
    let compute room = match O.capply temp warg op args (Post.arg_contexts op) with
    | O.Binop (x, y)          -> push room [x; y] <:>       Post.stack_op op
    | O.Unop  (x)             -> push room [x]    <:>       Post.stack_op op
    | O.Binrm (x, y, (r, b))  -> push room [x; y] <:> b <:> Post.stack_op_rm op r
    | O.Unrm  (x, (r, b))     -> push room [x]    <:> b <:> Post.stack_op_rm op r
    | O.Fpcvt (x, (r, b))     -> impossf "general fpcvt on stack"
    | O.Dblop _ | O.Wrdop _ | O.Wrdrop _ ->
        Impossible.unimp "weird value operator on stack"
    | O.Cmp _ | O.Width | O.Bool | O.Nullary ->
        impossf "operator %%%s reached postexpander" (fst op) in
    if room >= depth then
      compute room
    else
      save_stack room <:> compute Post.stack_depth <:> restore_stack 1 room
| PX.Register ->
    let r, is = to_temp room (guess_context e) e in
    is <:> to_stack room (RP.Fetch (RP.Reg r, Register.width r))
@ 
<<rounding-mode checking>>=
let rounding_mode = Dn.loc tgt.Target.rounding_mode in
let is_not_rounding_mode arg = match arg with
| RP.Fetch (l, 2) -> not (RU.Eq.loc l rounding_mode)
| _ -> true in
@ 
%%
<<junk(expander.nw)>>=
let insist_rounding_mode arg =
  if is_not_rounding_mode arg then
    Unsupported.soft_rounding_mode()
@ 
%%
<<other generic expander functions>>=
and save_stack room =
  let _number_to_push = Post.stack_depth - room in
  Impossible.unimp "saving an overflowing machine stack"
and restore_stack number_to_keep number_to_restore =
  Impossible.unimp "restoring an overflowing machine stack"
@ 
<<cases for converting pushes>>=
| RP.App ((("sx"|"zx"), [n; w]) as op,
          [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n')]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    assert (agg =*= Post.byte_order);
    let a, is = address room addr in
    is <:> Post.push_cvt op n a (upassn assn)
| RP.App ((("f2f"|"f2i"|"i2f"), [n; w]) as op,
          [RP.Fetch (RP.Mem (('m',agg,ms), c, addr, assn), n'); rm]) ->
    assert (n = n' && n' = Cell.to_width ms c);
    assert (agg =*= Post.byte_order);
    let rcontext = match Post.arg_contexts op with [_; c] -> c
                                                 | _ -> impossf "rm context" in
    let r, is' = to_warg room (contextmap rcontext) rm in
    let a, is  = address room addr in
    is <:> is' <:> Post.push_cvt_rm op r n a (upassn assn)
| RP.App ((("sx"|"zx"), [n; w]) as op,
          [RP.Fetch (RP.Reg src, n')]) when Post.SlotTemp.is src ->
    assert (n = n' && n' = Register.width src);
    Post.SlotTemp.push_cvt op n src
| RP.App ((("f2f"|"f2i"|"i2f"), [n; w]) as op,
          [RP.Fetch (RP.Reg src, n'); rm]) when Post.SlotTemp.is src ->
    assert (n = n' && n' = Register.width src);
    let rcontext = match Post.arg_contexts op with [_; c] -> c
                                                 | _ -> impossf "rm context" in
    let r, is = to_warg room (contextmap rcontext) rm in
    is <:> Post.SlotTemp.push_cvt_rm op r n src
@ 
%%\subsubsection{Expanding RTLs}
%%
%%This part of the generic expander is currently simpler than it really
%%needs to be.
%%The main simplification is it doesn't deal with multiple effects.
%%In particular, it can't expand a call or a cut to node.
%%This flaw should be corrected soon.
%%
%%In the longer term,
%%it would be good to do something more general with multiple assignments and with
%%guards. {For example, if a guard uses a non-comparison, Boolean
%%operator, it would be a fine thing to compile it to control flow.}
%%
%%The expander is divided into three layers:
%%\begin{itemize}
%%\item
%%Function [[rtl]] expands a general RTL.
%%This function will need future work as noted above.
%%\item
%%Function [[guarded]] expands a single guarded effect.
%%Except for conditional branch, it currently handles only trivial
%%guards.
%%Because a nontrivial guard may appear only on a conditional branch,
%%this expander can't handle predicated instructions.
%%\item
%%Function [[assign]] expands an assignment with no guard.
%%\end{itemize}
%%
%%Because there's no support for multiple assignment yet, the [[rtl']]
%%function is trivial.
%%Note that if the source code asks for a bare kill, even conditional,
%%we're within our rights to implement it as a nop.
%%Conditional branches should never be called by the [[rtl']] or
%%[[branch']] functions; we handle conditional branches in
%%the [[???]] function.
%%
<<other generic expander functions>>=
and rtl' hr =
  let RP.Rtl gs = Dn.rtl hr in
  if trivially Post.don't_touch_me gs then
    DG.Rtl hr
  else
    match gs with
    | [(g, RP.Store (left, right, w))] -> guarded g left right w
    | [(g, RP.Kill _)] -> DG.Nop
    | [] -> DG.Nop (* a nop is a nop is a nop *)
    | ((_::_::_) as effs) -> (
     <<handle RTL with multiple effects [[effs]] (as RTL)>>
    )
and wrap_don't_touch f r =
  let RP.Rtl gs = Dn.rtl r in
  if trivially Post.don't_touch_me gs then
    DG.Nop, r
  else f r
and pre_rtl_to_call r =
  match Dn.exp (T.boxmach.T.call.T.project r) with
  | RP.Const c -> Post.call c
  | e          -> let r, is = to_temp Post.stack_depth acontext e in
                  is <::> Post.callr r
and rtl_to_call' r = wrap_don't_touch pre_rtl_to_call r
(* JUMP IS A PROBLEM -- WE DON'T DEAL WITH IT IN THE PX INTERFACE AT ALL *)
and pre_rtl_to_jump r =
  pre_rtl_to_branch r
and rtl_to_jump' r = wrap_don't_touch pre_rtl_to_jump r
and pre_rtl_to_cut r =
  let cut_args = T.boxmach.T.cutto.T.project r in
  let to_t e = 
    let e     = Dn.exp e in
    let t, is = to_temp Post.stack_depth (guess_context e) e in
    let t = R.reg t in 
    R.fetch t (RU.Width.loc t), is in
  let sp_t, is1 = to_t cut_args.Mflow.new_sp in
  let pc_t, is2 = to_t cut_args.Mflow.new_pc in
  is1 <:> is2 <::> Post.cut_to {Mflow.new_sp = sp_t; Mflow.new_pc = pc_t}
and rtl_to_cut' r = wrap_don't_touch pre_rtl_to_cut r
and pre_rtl_to_branch r =
  match Dn.exp (T.boxmach.T.goto.T.project r) with
  | RP.Const c -> Post.b c
  | e          -> let r, is = to_temp Post.stack_depth acontext e in
                  is <::> Post.br r
and rtl_to_branch' r = wrap_don't_touch pre_rtl_to_branch r
@ 
%%The type system tells us that anything in a guard must be a Boolean
%%operator or a comparison operator.\footnote
%%{Finally we get a payoff from NR's obsession with the distinction
%%between [[bool]] and \mbox{[[#1 bits]]}.}
<<other generic expander functions>>=
and guarded g left right w =
  match g with
  | RP.Const (RP.Bool b) -> if b then assign left right w else DG.Nop
  | RP.Const _ -> impossf "non-bool constant as guard"
  | RP.Fetch _ -> impossf "fetch as guard"
  | RP.App (cmp, [_; _]) ->
      Printf.eprintf "guarded: %s\n" (Rtlutil.ToString.exp (Up.exp g));
      Impossible.unimp "guard on other than conditional branch"
  | RP.App (cmp, _) ->
      Printf.kprintf Impossible.unimp "non-binary comparison in guard: %s" (D.exp g)
@ 
%%
%%POSSIBLY  REFERENCES TO [[pc_lhs]] SHOULD BE REPLACED BY USING
%%[[Target.goto.project]] AND FRIENDS.  IN GENERAL, WE NEED TO SEE
%%ABOUT MERGING SIMILAR INFORMATION IN THE [[Target]] AND
%%[[Postexpander.S]] INTERFACES.
%%
%%To compile a Boolean, we require that
%%a guarded effect with a nontrivial guard always be expanded into
%%a sequence that ends in a conditional branch.
%%To compile a comparison, we rely on the postexpander.
%%SOMEHOW WE HAVE TO FIGURE OUT WHAT TO DO WITH [[right]]!
<<other generic expander functions>>=
and expand_cbinst g ktrue kfalse =
  let room = Post.stack_depth in
  let rec expand g ktrue kfalse =
    match g with
    | RP.Const (RP.Bool b) -> if b then ktrue else kfalse
    | RP.Const _ -> impossf "non-bool constant as conditional guard"
    | RP.Fetch _ -> impossf "fetch as conditional guard"
    | RP.App (("not", []), [g]) -> expand g kfalse ktrue
    | RP.App (("conjoin", []), [x;y]) ->
        let kfalse = DG.shared kfalse in expand x (expand y ktrue kfalse) kfalse 
    | RP.App (("disjoin", []), [x;y]) ->
        let ktrue  = DG.shared ktrue  in expand x ktrue (expand y ktrue kfalse)
    | RP.App (cmp, ([x; y] as args)) ->
        begin
          match Post.opclass cmp with
          | PX.Register ->
              let context = cmp_context cmp in
              let xt, xis = to_temp room context x in
              let yt, yis = to_temp room context y in
              xis <:> yis <:::> Post.bc_of_guard (Post.bc_guard xt cmp yt) ktrue kfalse
          | PX.Stack(dir, depth) ->
              let args = List.filter is_not_rounding_mode args in (* cheat!!! *)
                  (* ROUNDING *)
              let args =
                match dir with PX.LeftFirst -> args | PX.RightFirst -> List.rev args in
              let push_args room =
                let is, _ =
                  List.fold_left (fun (is,r) e -> (is <:> to_stack r e, r-1))
                  (DG.Nop,room) args in
                is in
              let compute room ktrue kfalse =
                push_args room <:::> Post.bc_stack cmp ~ifso:ktrue ~ifnot:kfalse in
              if room >= depth then
                compute room ktrue kfalse
              else
                (* PLAUSIBLE BUT COMPLETELY UNTESTED. *)
                let t = restore_stack 0 room <:::> ktrue  in
                let f = restore_stack 0 room <:::> kfalse in
                save_stack room <:::> compute Post.stack_depth t f
        end
    | RP.App (cmp, _) ->
       Printf.eprintf "rtl exp: %s\n" (Rtlutil.ToString.exp (Up.exp g));
        Impossible.unimp "non-binary comparison in conditional guard" in
  expand g ktrue kfalse
@ 
%%
<<other generic expander functions>>=
and expand_cbranch' c = match c with
| DG.Exit x -> DG.Exit x
| DG.Shared (u, c) -> DG.Shared(u, expand_cbranch' c)
| DG.Test (b, (g, ktrue, kfalse)) ->
    let b = block b in
    let rec extend c = match c with
    | DG.Exit p -> DG.Exit p
    | DG.Test (b', c) -> DG.Test (b <:> b', c)
    | DG.Shared (u, c) -> DG.Shared(u, extend c) in
    extend (expand_cbinst (Dn.exp g) (expand_cbranch' ktrue) (expand_cbranch' kfalse))
@
%%An assignment is either a goto, a store, or a computation where we put
%%something in a temporary.
<<other generic expander functions>>=
and assign left right w = assign_room Post.stack_depth left right w
and assign_room room left right w = 
  match right with
  | RP.App (("f2f_implicit_round", ws), [x]) ->
      assign left (RP.App (("f2f", ws), [x; RP.Fetch(rounding_mode, 2)])) w
  | _ ->
      if RU.Eq.loc left pc_lhs then  (* unconditional branch *)
        impossf "assignment to pc is not a branch"
      else if Post.is_stack_top_proxy left then
        to_stack room right
      else
        match left with
        | RP.Mem (('m',agg,memsize) as mspace, c, addr, assn) ->  (* a store *)
            let w = Cell.to_width memsize c in
            assert (agg =*= Post.byte_order || agg =*= Rtl.Identity);
            <<definition of [[split_assignment]]>>
            let a, is' = address room addr in
            (match right with
            | 
             <<\emph{pattern [[->]] action} for low-bit store>>
            | 
            <<\emph{pattern [[->]] action} for splittable assignment>>
            | 
            <<\emph{pattern [[->]] action} for doubling weird value operator>>
            | _ ->
                if looks_like_stack_rhs right then
                  (match right with
                  | 
                  <<\emph{pattern [[->]] action} for push-convert, then store-pop>>
                  | 
                  <<\emph{pattern [[->]] action} for converting store-pop>>
                  | _ -> 
                      let is = to_stack room right in
                      is <:> is' <:> Post.store_pop a (upassn assn))
                else
                  match right with
                  | RP.Fetch (RP.Mem(('m', _, _), ct, addr', assn'), w) ->
                      let a', is = address room addr' in
                      is <:> is' <:>
                      Post.block_copy a (upassn assn) a' (upassn assn') w
                  | RP.Fetch (RP.Reg src, _) ->
                      is' <:> Post.store a src (upassn assn)
                  | _ ->
                      let r, is = to_temp room (guess_context right) right in
                      is <:> is' <:> Post.store a r (upassn assn))
        | RP.Mem (_, _, _, _) ->
            Impossible.unimp "memory space other than 'm'"
        | RP.Reg dst when Post.SlotTemp.is dst -> (* store to a stack slot *)
            (*<definition of [[split_assignment_slot]]>*)
            (match right with
            | 
             <<\emph{pattern [[->]] action} for low-bit store to reg>>
            | 
             <<\emph{pattern [[->]] action} for splittable assignment to reg>>
            | 
             <<\emph{pattern [[->]] action} for doubling weird value operator to reg>>
            | _ ->
                if looks_like_stack_rhs right then
                  match right with
                  | 
            <<\emph{pattern [[->]] action} for push-convert, then store-pop to reg>>
                  | 
            <<\emph{pattern [[->]] action} for converting store-pop to reg>>
                  | _ -> 
                      let is = to_stack room right in
                      is <:> Post.SlotTemp.store_pop dst
                else
                  match right with
                  | RP.Fetch (RP.Mem(('m', _, _), ct, addr, assn), w) ->
                      let a, is = address room addr in
                      is <:> Post.load dst a (upassn assn)
                  | RP.Fetch (RP.Reg src, _) -> Post.move ~dst ~src
                  | _ ->
                      let r, is = to_temp room (guess_context right) right in
                      is <:> Post.move dst r)
        | RP.Reg dst -> (* computation *)
              (match right with
              | RP.Fetch (RP.Reg src, _) -> Post.move ~dst ~src
              | _ -> let r, is = to_temp room (guess_context right) right in
                     is <:> Post.move ~dst ~src:r
              )
            (* ROUNDING --- narrow register *)
        | RP.Slice (w, lsb, RP.Reg r) ->
            let t, is = to_warg room icontext right in
            is <:> Post.hwset (Rg.Slice (w, lsb, r)) t
        | RP.Slice (w, lsb, _) ->
            impossf "back end advertises slice of non-HW in %s" (D.loc left)
        | RP.Var (_,_,_) | RP.Global(_,_,_) ->
            impossf "variable passed to code expander"
@ 
%%
%%DANGER WILL ROBINSON!  Tripped this case when trying to store least
%%significant 32~bits of a 64-bit floating-point value.
%%But the case should have been an \emph{ordinary} store 
%%where the right-hand side was picked up by 
%%[[<<cases for extracting from a wide temporary>>]].
%%So we'll have to have some way of distinguishing these cases, probably
%%by having a look at the width (and comparing with something from
%%postexpander). 
%%A~good first step might be for the postexpander to advertise at what
%%widths ordinary store and [[lostore]] are supported, 
%%or in other words, when to use [[lostore]] and when to use
%%[[extract]].
%%These issues are undoubtedly complicated by the machines on which the
%%answers depend on which set of registers you're talking about.
%%Like the Pentium.
<<\emph{pattern [[->]] action} for low-bit store>>=
RP.App (("lobits", [w; n]), [rhs]) ->
  let r, is = to_temp room icontext rhs in
  is <:> is' <:> Post.lostore a r n (upassn assn)
| RP.Const (RP.Bits b) when w < Post.itempwidth ->
  let rhs = RP.Const (RP.Bits (Bits.Ops.zx Post.itempwidth b)) in
  let r, is = to_temp room icontext rhs in
  is <:> is' <:> Post.lostore a r w (upassn assn)
@ 
%%
<<\emph{pattern [[->]] action} for low-bit store to reg>>=
RP.App (("lobits", [w; n]), [rhs]) ->
  impossf "slot-temp := %%lobits(e)   [extend postexpander?]"
| RP.Const (RP.Bits b) when w < Post.itempwidth ->
  impossf "slot-temp := %%lobits(k)   [extend postexpander?]"
@ 
<<\emph{pattern [[->]] action} for converting store-pop>>=
RP.App ((("sx" | "zx"), [wsrc; wdst]) as op, [rhs]) ->
  (* what goes wrong if wsrc is not the width of the stack? *)
  let is = to_stack room rhs in
  is <:> is' <:> Post.store_pop_cvt op wdst a (upassn assn)
| RP.App ((("f2f" | "f2i" | "i2f"), [wsrc; wdst]) as op, [rhs; rm]) ->
  (* what goes wrong if wsrc is not the width of the stack? *)
  let is = to_stack room rhs in
  let rcontext = match Post.arg_contexts op with [_; c] -> c
                                               | _ -> impossf "rm context" in
  let r, is'' = to_warg room (contextmap rcontext) rm in
  is <:> is' <:> is'' <:> Post.store_pop_cvt_rm op r wdst a (upassn assn)
@ 
<<\emph{pattern [[->]] action} for converting store-pop to reg>>=
RP.App ((("sx" | "zx"), [wsrc; wdst]) as op, [rhs]) ->
  (* what goes wrong if wsrc is not the width of the stack? *)
  let is = to_stack room rhs in
  is <:> Post.SlotTemp.store_pop_cvt op wdst dst
| RP.App ((("f2f" | "f2i" | "i2f"), [wsrc; wdst]) as op, [rhs; rm]) ->
  (* what goes wrong if wsrc is not the width of the stack? *)
  let is = to_stack room rhs in
  let rcontext = match Post.arg_contexts op with [_; c] -> c
                                               | _ -> impossf "rm context" in
  let r, is'' = to_warg room (contextmap rcontext) rm in
  is <:> is'' <:> Post.SlotTemp.store_pop_cvt_rm op r wdst dst
@ 
<<\emph{pattern [[->]] action} for push-convert, then store-pop>>=
RP.App ((("f2f"|"f2i"|"i2f"), [n; w]) as op,
        [RP.Fetch (RP.Mem ((_,agg,ms), c, srcaddr, srcassn), n'); rm]) ->
  assert (n = n' && n' = Cell.to_width ms c);
  assert (agg =*= Post.byte_order);
  let rcontext = match Post.arg_contexts op with [_; c] -> c
                                               | _ -> impossf "rm context" in
  let r, is' = to_warg room (contextmap rcontext) rm in
  let srca, is = address room srcaddr in
  is <:> is' <:> Post.push_cvt_rm op r n srca (upassn srcassn) <:>
  Post.store_pop a (upassn assn)
| RP.App ((("f2f"|"f2i"|"i2f"), [n; w]) as op,
        [RP.Fetch (RP.Reg src, n'); rm]) when Post.SlotTemp.is src ->
  assert (n = n' && n' = Register.width src);
  assert (agg =*= Post.byte_order);
  let rcontext = match Post.arg_contexts op with [_; c] -> c
                                               | _ -> impossf "rm context" in
  let r, is = to_warg room (contextmap rcontext) rm in
  is <:> Post.SlotTemp.push_cvt_rm op r n src <:> Post.store_pop a (upassn assn)
@ 
%%
<<\emph{pattern [[->]] action} for push-convert, then store-pop to reg>>=
RP.App ((("f2f"|"f2i"|"i2f"), [n; w]) as op,
        [RP.Fetch (RP.Mem ((_,agg,ms), c, srcaddr, srcassn), n'); rm]) ->
  assert (n = n' && n' = Cell.to_width ms c);
  assert (agg =*= Post.byte_order);
  let rcontext = match Post.arg_contexts op with [_; c] -> c
                                               | _ -> impossf "rm context" in
  let r, is' = to_warg room (contextmap rcontext) rm in
  let srca, is = address room srcaddr in
  is <:> is' <:> Post.push_cvt_rm op r n srca (upassn srcassn) <:>
  Post.SlotTemp.store_pop dst
| RP.App ((("f2f"|"f2i"|"i2f"), [n; w]) as op,
        [RP.Fetch (RP.Reg src, n'); rm]) when Post.SlotTemp.is src ->
  assert (n = n' && n' = Register.width src);
  let rcontext = match Post.arg_contexts op with [_; c] -> c
                                               | _ -> impossf "rm context" in
  let r, is = to_warg room (contextmap rcontext) rm in
  is <:> Post.SlotTemp.push_cvt_rm op r n src <:> Post.SlotTemp.store_pop dst
@ 
%%A~splittable right-hand side looks like this: 
%%\begin{quote}
%%[[%or[64](%zx[32,64]($r0), %shl[64](%zx[32,64]($r2), 32))]]
%%\end{quote}
%%I FEAR I MAY BE BOTCHING THE ASSERTION IN THE STORE, ESPECIALLY WHERE
%%ALIGNMENT IS CONCERNED.
%%
<<\emph{pattern [[->]] action} for splittable assignment>>=
( RP.App (("or", [ww]), [RP.App (("zx", [nn;ww']), [lsw]);
                          RP.App (("shl", [ww'']),
                                  [RP.App (("zx", [dd;ww''']), [msw]);
                                   RP.Const (RP.Bits nnb)])])
| RP.App (("or", [ww]), [RP.App (("shl", [ww'']),
                                  [RP.App (("zx", [dd;ww''']), [msw]);
                                   RP.Const (RP.Bits nnb)]);
                          RP.App (("zx", [nn;ww']), [lsw])])
) when w > Post.itempwidth && Pervasives.(<>) agg Rtl.Identity && ww = ww' && ww = ww''
    && ww = ww''' && dd = ww - nn && BO.eq nnb (Bits.U.of_int nn ww) ->
      split_assignment ~lsw ~lw:nn ~msw ~mw:dd
| RP.Const (RP.Bits b) when w > Post.itempwidth ->
  let lw = Post.itempwidth in
  let mw = w - lw in
  let lsw = RP.Const (RP.Bits (BO.lobits lw b)) in
  let msw = RP.Const (RP.Bits (BO.lobits mw (BO.shrl b (Bits.U.of_int lw w)))) in
  split_assignment ~lsw ~lw ~msw ~mw
@ 
%%
<<\emph{pattern [[->]] action} for splittable assignment to reg>>=
( RP.App (("or", [ww]), [RP.App (("zx", [nn;ww']), [lsw]);
                          RP.App (("shl", [ww'']),
                                  [RP.App (("zx", [dd;ww''']), [msw]);
                                   RP.Const (RP.Bits nnb)])])
| RP.App (("or", [ww]), [RP.App (("shl", [ww'']),
                                  [RP.App (("zx", [dd;ww''']), [msw]);
                                   RP.Const (RP.Bits nnb)]);
                          RP.App (("zx", [nn;ww']), [lsw])])
) when w > Post.itempwidth && ww = ww' && ww = ww''
    && ww = ww''' && dd = ww - nn && BO.eq nnb (Bits.U.of_int nn ww) ->
      impossf "splittable assignment to stack-slot temporary"
| RP.Const (RP.Bits b) when w > Post.itempwidth ->
      unimpf "assigned wide constant to stack-slot temporary"
@
%%
<<\emph{pattern [[->]] action} for doubling weird value operator>>=
RP.App ((("mulx"|"mulux"), [nw]) as opr, [x; y]) when w = 2 * nw ->
  let xcon, ycon = match Post.arg_contexts opr with
  | [x; y] -> contextmap x, contextmap y
  | _ -> impossf "arity of extended multiply (arg contexts)" in
  let rcon = contextmap (Post.result_context opr) in
  let tx, i1 = to_temp room xcon x in
  let ty, i2 = to_temp room ycon y in
  let thi, tlo = alloc rcon nw, alloc rcon nw in
  let i3 = Post.dblop ~dsthi:thi ~dstlo:tlo opr tx ty in
  let v tmp = RP.Fetch (RP.Reg tmp, nw) in
  i1 <:> i2 <:> i3 <:> split_assignment ~lsw:(v tlo) ~lw:nw ~msw:(v thi) ~mw:nw
| RP.App ((("mulx"|"mulux"), _), _) as e ->
    impossf "unsupported extended multiply %s at width %d"
      (RU.ToUnreadableString.exp (Up.exp e)) w
@ 
%%
<<\emph{pattern [[->]] action} for doubling weird value operator to reg>>=
RP.App ((("mulx"|"mulux"), [nw]), [x; y]) when w = 2 * nw ->
  impossf "extended multiply into stack-slot temporary"
| RP.App ((("mulx"|"mulux"), _), _) as e ->
    impossf "unsupported extended multiply %s at width %d"
      (RU.ToUnreadableString.exp (Up.exp e)) w
@ 
%%We split an assignment into a least significant word [[lsw]] of
%%width~[[lw]] and a most significant word [[msw]] of width~[[mw]].
<<definition of [[split_assignment]]>>=
let split_assignment ~lsw ~lw ~msw ~mw =
  if Debug.on "expander" then
    Printf.eprintf "Splitting msw %s; lsw = %s\n" (D.exp msw) (D.exp lsw);
  let lc, mc = Cell.to_count memsize lw, Cell.to_count memsize mw in
  assert (Cell.divides memsize lw && w = lw + mw);
  let addr = Up.exp addr in
  let assn = Up.assertion assn in
  let lsw, msw = Up.exp lsw, Up.exp msw in
  let offset (R.C n) = RU.addk tgt.T.pointersize addr n in
  match agg with
  | Rtl.LittleEndian ->
      rtl (R.par [R.store (R.mem assn mspace lc addr) lsw lw;
                  R.store (R.mem assn mspace mc (offset lc)) msw mw])
  | Rtl.BigEndian ->                           
      rtl (R.par [R.store (R.mem assn mspace mc addr) msw mw;
                  R.store (R.mem assn mspace lc (offset mc)) lsw lw])
  | Rtl.Identity ->
      impossf "bad aggregation in split assignment" in
@ 
<<other generic expander functions>>=
and fetch_slot slot w = Dn.exp (A.fetch slot w)
and assign_slot room slot right w =
  match Dn.rtl (A.store slot (Up.exp right) w) with
  | RP.Rtl [(RP.Const (RP.Bool true), RP.Store (left, right, w))] ->
      assign_room room left right w
  | _ -> impossf "stack slot is not a simple store"
@ 
%%Something with multiple effects is either a call, a [[cut to]], or a
%%shuffle.
%%In all three cases, the guard had better be trivial.
<<internal utilities for the generic expander>>=
let has_pc_on_left = function
  | RP.Store (pc, _, _) -> RU.Eq.loc pc pc_lhs
  | RP.Kill _ -> false 
let has_pc_on_right = function
  | RP.Store (_, e, _) -> RU.Exists.Loc.exp (RU.Eq.loc pc_rhs) e
  | RP.Kill _ -> false 
@ 
%%
<<handle RTL with multiple effects [[effs]] (as branch)>>=
<<support for call and [[cut to]]>>
let effs = strip_trivial_guards effs in
if Post.don't_touch_me effs then
  DG.Nop, R.par (List.map Up.effect effs)
else
  if List.exists has_pc_on_left effs then
    if List.exists has_pc_on_right effs then
      make_call effs
    else
      make_cut_to effs
  else
    impossf "call or cut to without reference to PC"
@ 
%%
<<handle RTL with multiple effects [[effs]] (as RTL)>>=
<<support for shuffle>>
let effs = strip_trivial_guards effs in
if Post.don't_touch_me effs then
  DG.Rtl (R.par (List.map Up.effect effs))
else
  let _ = if List.exists has_pc_on_left effs then
            impossf "straight-line code has PC on left" in
  make_shuffle effs
@ 
%%When we know guards should be trivial, we just strip them off.
%%When we don't know, we use the [[trivial]] function, which if guards
%%are trivial applies a predicate and if not returns [[false]].
%%\nwaddbox{trivially : (RP.effect list -> bool) -> RP.guarded list -> bool}
%%\deeperbox{16pt}
<<functions for dealing with trivial guards>>=
let strip_trivial_guards l =
  List.fold_right
    (fun (g, e) l ->
      match g with RP.Const (RP.Bool b) -> if b then e :: l else l
      | _ -> Impossible.unimp "multiple effects with a nontrivial guard") l [] in
let trivially p l =
  let rec t es' = function
    | [] -> p (List.rev es')
    | (g, e) :: ges ->
        match g with RP.Const (RP.Bool b) -> t (if b then e :: es' else es') ges
        | _ -> false in
  t [] l in
@ 
<<internal utilities for the generic expander>>=
let (<<) f g x = f (g x) 
@ 
%%
<<support for call and [[cut to]]>>=
let make_call effs = 
  let others = List.filter (not << has_pc_on_left) effs in
  match List.filter has_pc_on_left effs with
  | [RP.Store(pc, RP.Const c, _)] -> Post.call c others
  | [RP.Store(pc, e, _)] ->
      let t, is = to_temp Post.stack_depth acontext e in
      is <::> Post.callr t others
  | _ -> impossf "multiple pc := e in call" in
@ 
<<support for call and [[cut to]]>>=
let make_cut_to effs =
  let expand e (preds, effs) = match e with
    | RP.Store (l, r, w) ->
        let t, is = to_temp Post.stack_depth (guess_context r) r in
        (preds <:> is, RP.Store(l, RP.Fetch(RP.Reg t, w), w) :: effs)
    | RP.Kill l -> (preds, RP.Kill l :: effs) in
  let preds, effs = List.fold_right expand effs (DG.Nop, []) in
  preds <::> Post.cut_to effs in
@ 
%%Shuffle would be cooler if we carefully arranged to make things
%%push-like, but never mind.
%%As it is, we look for an effect that can go first (because its
%%left-hand side doesn't alias with any other right-hand-side or with an
%%addressing expression on the left-hand side), and if
%%we don't find one, we introduce a new temporary.
<<support for shuffle>>=
let make_shuffle effs =
  let strip_store = function
    | RP.Store (l, r, w) -> (l, r, w)
    | RP.Kill _ -> impossf "kill in shuffle" in
  let rec shuffle =
    let assign = noisy_assign in
    function
    | [(l, r, w)] -> assign l r w
    | [] -> DG.Nop
    | ((l, (r:RP.exp), w) :: rest) as effs ->
        <<definition of [[try_first_effect]]>>
        try_first_effect effs
          (fun (l, r, w) rest -> assign l r w <:> shuffle rest)
          (fun () ->
            let t = alloc (guess_context r) w in
            (assign (RP.Reg t) r w <:>
             shuffle rest <:>
             assign l (RP.Fetch (RP.Reg t, w)) w))
  in shuffle (List.map strip_store effs) in
@ 
<<definition of [[try_first_effect]]>>=
let try_first_effect effects succ fail =
  let rec maybe bad = function
    | [] -> fail()
    | (l, r, w) :: rest ->
        let alias = RU.MayAlias.store_uses' l in
        if not (List.exists alias bad || List.exists alias rest) then
          succ (l, r, w) (List.rev_append bad rest)
        else
          maybe ((l, r, w) :: bad) rest in
  maybe [] effects in
@ 
%%\subsubsection{Flow-graph fragments}
<<other generic expander functions>>=
and block b = match b with
| DG.Rtl r        -> rtl r
| DG.Seq (b, b')  -> block b <:> block b'
| DG.If (c, t, f) -> DG.If (expand_cbranch c, block t, block f)
| DG.While (e, b) -> Impossible.unimp "expand loop"
| DG.Nop          -> DG.Nop
and branch' (b, r) = let b', r = rtl_to_branch r in (block b <:> b', r)
and call'   (b, r) = let b', r = rtl_to_call   r in (block b <:> b', r)
and jump'   (b, r) = let b', r = rtl_to_jump   r in (block b <:> b', r)
and cut'    (b, r) = let b', r = rtl_to_cut    r in (block b <:> b', r)
@ 
%%
%%\subsubsection{Debugging the expander}
%%These wrapper functions show what the expander [[rtl]] and register
%%targeter [[to_temp]] are doing.
<<other generic expander functions>>=
and rtl r =
  let _ = D.strings ["Expanding "; D.rtl r; "\n"] in
  let is = rtl' r in
  let _ = D.strings ["Expanded "; D.rtl r; " into\n"]; D.pr_block D.brtl is in
  is
and rtl_to_jump r =
  let _ = D.strings ["Expanding "; D.rtl r; "\n"] in
  let is, b = rtl_to_jump' r in
  let _ = D.strings ["Expanded "; D.rtl r; " into\n"];
          D.pr_block D.brtl (is <:> DG.Rtl b) in
  is, b
and rtl_to_cut r =
  let _ = D.strings ["Expanding "; D.rtl r; "\n"] in
  let is, b = rtl_to_cut' r in
  let _ = D.strings ["Expanded "; D.rtl r; " into\n"];
          D.pr_block D.brtl (is <:> DG.Rtl b) in
  is, b
and rtl_to_call r =
  let _ = D.strings ["Expanding "; D.rtl r; "\n"] in
  let is, b = rtl_to_call' r in
  let _ = D.strings ["Expanded "; D.rtl r; " into\n"];
          D.pr_block D.brtl (is <:> DG.Rtl b) in
  is, b
and rtl_to_branch r =
  let _ = D.strings ["Expanding "; D.rtl r; "\n"] in
  let is, b = rtl_to_branch' r in
  let _ = D.strings ["Expanded "; D.rtl r; " into\n"];
          D.pr_block D.brtl (is <:> DG.Rtl b) in
  is, b
and expand_cbranch cb =
  let _ = D.strings ["Expanding conditional branch "; D.cbranch D.exp' cb; "\n"] in
  let is = expand_cbranch' cb in
  let _ =
    D.strings ["Expanded conditional branch "; " into "; D.cbranch D.brtl is; "\n"] in
  is
and noisy_assign l r w =
  let is = assign l r w in
  let r = R.store (Up.loc l) (Up.exp r) w in
  let _ = D.strings ["Shuffling "; D.rtl r; " into\n"];
          D.pr_block D.brtl is in
  is
and to_temp room context e =
  let _ = D.strings ["Targeting "; D.exp e; "...\n"] in
  let t, is = to_temp' room context e in
  let _ = D.strings ["Targeted "; D.exp e; " => "; D.temp t; " by \n"] in
  let _ = D.pr_block D.brtl is in
  t, is
and to_stack room e =
  let _ = D.strings ["Pushing "; D.exp e; "...\n"] in
  let is = to_stack' room e in
  let _ = D.strings ["Pushed "; D.exp e; " by \n"] in
  let _ = D.pr_block D.brtl is in
  is
@ 
%%\subsubsection{Stack-slot allocation}
%%To move from a temporary to the stack, we may need to allocate a stack slot.
<<stack-slot allocation>>=
let exchange_slot =
  let slots = ref [] in
  function w ->
    try List.assoc w (!slots)
    with Not_found ->
      let slot = Postexpander.Alloc.slot w Post.exchange_alignment in
      slots := (w, slot) :: !slots;
      slot in
@   
%%\subsubsection{Old code no longer relevant}
%%This is old stuff left over, which I might want to resurrect some day
%%when I try to expand general guards.
<<ZZZ definitions of [[to_temp]], [[rtl]] and all the other generic expander functions>>=
let rec old_general_guard g left right w =
  (* this case is bogus *)
  let r, is  = to_temp Post.stack_depth (guess_context right) right in
  let l, is' = old_loc left in
  is <:> is' <:> DG.Rtl (R.guard (Up.exp g) (R.store l (R.fetch (R.reg r) w) w))
and old_loc l =
  match l with
  | RP.Mem (('m',_,_) as mspace, w, addr, assn) ->
      let addr, is = to_temp Post.stack_depth (acontext) addr in
      Up.loc (RP.Mem (mspace, w, fetch (R.reg addr), assn)), is
  | _ -> Up.loc l, DG.Nop in
@
%%\subsubsection{The flow-graph expander}
%%
%%To expand the flow graph, we expand each node.
%%Expanding a node means converting its RTL to a block, a conditional
%%branch, or a branch; expanding the result; then
%%converting back to flow-graph nodes using  [[<<block-conversion functions>>]].
%%
%%Before and after expansion we must tie and untie the knot that
%%establishes the mutual recursion between the generic expander and the
%%machine-specific postexpander.
<<generic flow-graph expander>>=
let expand f proc =
  let modified = ref false in
  let PA.T tgt = proc.Proc.target in
  let machine  = proc, tgt.Target.machine, proc.Proc.exp_of_lbl in
  <<block-conversion functions>>
  let (expand_block, expand_branch, expand_cbranch,
       expand_call, expand_jump, expand_cut as expanders) = expand proc in
  let g =
    if Postexpander.Alloc.isValid () then
      f expanders (block_before, block2cfg, cbranch2cfg)
    else
      (Postexpander.remember_allocators proc.Proc.temps proc.Proc.priv;
       Postexpander.remember_expanders expand_block expand_branch expand_cbranch;
       let g = f expanders (block_before, block2cfg, cbranch2cfg) in
       Postexpander.forget_allocators();
       Postexpander.forget_expanders();
       g) in
  g, !modified

let cfg _ (cfg, proc) =
  let PA.T tgt = proc.Proc.target in
  let m = tgt.Target.machine in
  let expand_cfg (expand_block, expand_branch, expand_cbranch, expand_call,
                  expand_jump, expand_cut)
                 (block_before, block2cfg, cbranch2cfg) =
    let expand_middle n = match n with
      | GR.Instruction  i -> G.unfocus (block2cfg (expand_block (DG.Rtl i)))
      | GR.Stack_adjust _ -> G.single_middle n in
    let expand_last n =
      let to_block (b, i) n = 
        G.unfocus (block_before b (G.entry (G.single_last (G.new_rtll i n)))) in
      match n with
      | GR.Cbranch (i, ifso, ifnot) ->
          let be = (T.boxmach.T.branch.T.project i,
                    DG.Exit true, DG.Exit false) in
          let b  = expand_cbranch (DG.Test (DG.Nop, be)) in
          let g  = cbranch2cfg b ~ifso ~ifnot (G.entry G.empty) in
          G.of_block_list (G.postorder_dfs (G.unfocus g)) (* trim exit node *)
      | GR.Return    _ -> to_block (DG.Nop, m.Mflow.return) n
      | GR.Forbidden _ -> to_block (DG.Nop, m.T.forbidden) n
      | GR.Branch (r, _) | GR.Mbranch (r, _) -> to_block (expand_branch (DG.Nop, r)) n
      | GR.Jump (r, _, _) -> to_block (expand_jump (DG.Nop, r)) n
      | GR.Call {GR.cal_i = r} -> to_block (expand_call (DG.Nop, r)) n
      | GR.Cut (r, _, _) -> to_block (expand_cut (DG.Nop, r)) n
      | GR.Exit -> to_block (DG.Nop, GR.last_instr n) n in
    G.expand expand_middle expand_last cfg in
  let (g, modified) = expand expand_cfg proc in
  (g, proc), modified

let block   proc b = fst (expand (fun (exp, _, _, _, _, _) _ -> exp b) proc)
let goto    proc b = fst (expand (fun (_, exp, _, _, _, _) _ -> exp b) proc)
let cbranch proc b = fst (expand (fun (_, _, exp, _, _, _) _ -> exp b) proc)
let call    proc b = fst (expand (fun (_, _, _, exp, _, _) _ -> exp b) proc)
let jump    proc b = fst (expand (fun (_, _, _, _, exp, _) _ -> exp b) proc)
let cut     proc b = fst (expand (fun (_, _, _, _, _, exp) _ -> exp b) proc)

let machine = 
  let boxexp f = { T.embed = (fun p e -> f p (DG.Nop, Box.Exp.box e))
                 ; T.project = (fun _ -> assert false) } in
  let cutto =
    { T.embed =
        (fun p ca -> cut p (DG.Nop, Box.ExpList.box [ca.Mflow.new_sp; ca.Mflow.new_pc]))
    ; T.project = (fun box -> match Box.ExpList.unbox box with
                           | [sp; pc] -> {Mflow.new_sp = sp; Mflow.new_pc = pc}
                           | _ -> assert false)} in
  let move p ~src ~dst = Post.move ~dst ~src in
  let spill p r l = 
    let w = Reg.width r in
    match Dn.rtl (l.RU.store (R.fetch (R.reg r) w) w) with
    | RP.Rtl [(RP.Const (RP.Bool true),
               RP.Store (RP.Mem (_, _, addr, assn), _, _))] ->
        Post.store ~addr:(Up.exp addr) ~src:r (R.aligned assn)
    | _ -> Impossible.impossible "unexpected spill RTL" in
  let reload p l r = 
    let w = Reg.width r in
    match Dn.exp (l.RU.fetch w) with
    | RP.Fetch (RP.Mem (_, _, addr, assn), _) ->
        Post.load ~dst:r ~addr:(Up.exp addr) (R.aligned assn)
    | _ -> Impossible.impossible "unexpected reload exp" in
  { T.bnegate     = Post.bnegate
  ; T.goto        = boxexp goto
  ; T.jump        = boxexp jump
  ; T.call        = boxexp call
  ; T.branch      = { T.embed = (fun p g -> cbranch p (DG.cond g))
                    ; T.project = (fun _ -> assert false) }
  ; T.retgt_br =
      (fun r -> Post.bc_of_guard (DG.Nop, Up.exp (branch_condition r))
          ~ifso:(DG.Exit true) ~ifnot:(DG.Exit false))
  ; T.move   = move
  ; T.spill  = spill
  ; T.reload = reload 
  ; T.cutto       = cutto
  ; Mflow.return  = Post.return
  ; T.forbidden   = Post.forbidden
  }
@
<<internal utilities for the generic expander>>=
let branch_condition rtl = match Dn.rtl rtl with
| RP.Rtl [(g, RP.Store (left, right, w))] ->
    if not (RU.Eq.loc left pc_lhs) then
      impossf "conditional branch assigns to non-PC";
    g
| _ -> impossf "ill-formed conditional branch"
@
%%Free reference [[modified]] is set only if a new node is added to the graph.
<<block-conversion functions>>=
let update (g, m)    = (if m then modified := true; g) in
let block_before b g = update (G.block_before machine b g) in
let block2cfg    b   = update (G.block2cfg    machine b)   in
let cbranch2cfg c ~ifso ~ifnot g = update (G.cbranch2cfg machine c ifso ifnot g) in
@
%%N.B. the sharing works only for a DAG---the graph must be acyclic.
%%(Guaranteed by the rep.)
%%
%%\subsubsection{Compilation of Boolean expressions into control flow.}
%%
%%An if-statement is governed by a boolean expression that has no side
%%effects. A simple translation is to use this expression as a guard for a
%%conditional branch to implement the if-statement. The guard finally
%%becomes a guard in the {\rtl} that implements the conditional branch.
%%The problem is, that the guarding expression can be quite complex and
%%must be simplified before a machine instruction can be found that
%%implements it. We translate a boolean expression $e$ into a sequence of
%%nodes. If $e$ evaluates to true, the control flow reaches the end of the
%%sequence, otherwise it branches to a provided label. 
%%
%%
%%\begingroup % keeps definitions local
%%\def\C#1{{\cal C}[\![#1]\!]}
%%\let\i\textit
%%
%%The translation is summarized by the following function $\C{\cdot}~f$
%%that takes a boolean expression $e$ and a continuation $f$ to branch if
%%the expression evaluates to false. The result is a sequence of nodes,
%%that branches to $f$ if $e$ is false, and falls through otherwise.
%%
%%\begin{center}
%%\begin{eqnarray*}
%%    \C{\i{true}}~f              & \to & \i{nop}\\
%%    \C{\i{false}}~f             & \to & \i{goto}~f\\
%%    \C{x \vee y}~f              & \to & \C x~l; l: \C y~f\\
%%    \C{x \wedge y}~f            & \to & \C x~f; \C y~f\\
%%    \C{\lnot x}~f               & \to & \C x~l; \i{goto}~f; l:\\
%%    \C{\oplus(e_1, \dots, e_n)} & \to & 
%%        \i{if}(\lnot \oplus(e_1, \dots, e_n)\{\i{goto}~f\}
%%\end{eqnarray*}
%%\end{center}
%%
%%The last line covers the case of an application with a boolean result
%%but non-boolean arguments. Currently only the logical operators $\lnot$,
%%$\vee$, and $\wedge$ \emph{take} boolean arguments.
%%
%%The implementation first translates the governing expression into an
%%{\rtl} and then tranlate it into the sequence of nodes.
%%
%%\begin{quote}\it
%%    I think the code below shows a design weakness: we have decided to
%%    have explicit label nodes in the {\cfg}. In order to jump or branch
%%    to a node one needs the symbol associated with the label. This,
%%    however, cannot be observed. This means, labels can only be used
%%    where they are constructed. In the implementation of the {\cfg}
%%    labels could be made a sub-class of nodes. However, since we shield
%%    the object-oriented nature of nodes behind standard types, this is
%%    not easily possible. Nodes must be more abstract or labels must
%%    become special.  --CL
%%\end{quote}
%%
%%\endgroup
%%
<<old Make statements>>=
and guard state succ fail e = 
    let rec guard' succ fail = function

    | RP.Const(RP.Bool(true))         -> succ
    | RP.Const(RP.Bool(false))        -> fail
    | RP.Const(_)                     -> assert false
    | RP.Fetch(_)                     -> assert false
    <<special cases that match floating-point comparisons>>
    | RP.App(("conjoin",_), [x;y])    -> 
        let ll    = Idgen.label state.proc    in
        let ls    = F.symbol env ll     in
        let fail  = G.gm_label state.cfg ll ls fail in
            let tail = guard' succ fail y in
            let head = guard' tail fail x in
                head
    | RP.App(("not",_), [x])          -> guard' fail succ x
    | RP.App(("disjoin",_), [x;y])    ->
        let ll    = Idgen.label state.proc    in
        let ls    = F.symbol env ll     in
        let succ  = G.gm_label state.cfg ll ls succ in
        let y     = guard' succ fail y    in
        let lexp  = Rtl.codesym ls state.target.T.pointersize in
        let lrtl  = state.target.T.goto.T.embed lexp in
        let succ  = G.gm_goto state.cfg lrtl [G.lookup state.cfg ll] in
                guard' succ y x              
    | RP.App(opr, args) as e -> 
        let sl    = Idgen.label state.proc    in
        let ss    = F.symbol env sl     in
        let succ  = G.gm_label state.cfg sl ss succ in
        
        let fl    = Idgen.label state.proc    in
        let fs    = F.symbol env fl     in
        let fail  = G.gm_label state.cfg fl fs fail in
        
        let oexp  = Rtl.codesym fs state.target.T.pointersize in
        let ortl  = state.target.T.goto.T.embed oexp in
        let fail  = G.gm_goto state.cfg ortl [G.lookup state.cfg fl] in
        
        let e     = R.Revert.exp e in
        let link  = Rtl.codesym ss state.target.T.pointersize in
        let rtl   = state.target.T.branch.T.embed (e,link)  in
            G.gm_branch state.cfg rtl succ fail 
    in
        { state with node = guard' succ fail e }
        
@
<<special cases that match floating-point comparisons>>=
(* the evil empire *)
@
\section{Things yet to be covered in this document}
%%\label{expander.uncovered}
%%\begin{enumerate}
%%\item
%%Kill effects
%%\item
%%The problem of instructions with multiple effects:
%%The generic expander can't expand while maintaining multiple effects
%%\item
%%Contexts really aren't general enough---need to say something about
%%widths, and hardware registers would be nice
%%\item
%%Not covered to sufficient detail: mutual recursion between generic
%%expander and postexpander 
%%(e.g., tying of recursive knot places restrictions on use)
%%\end{enumerate}
%%
%%
%%Aside:
%%I'm contemplating how we might create a hand-written expander that can
%%easily be specialized to establish ``most of'' the machine invariant
%%for many different targets, without relying so heavily on peephole
%%optimization \emph{post facto}.
%%For example, it's legitimate to think of $\mathtt{\$m}[\cdot]$ as an
%%``address context.''
%%Any machine should be able to deal with $t$~in an address context, but
%%many machines will also be able to deal with $t_1+t_2$ and $t+k$ (though
%%on some machines $k$~may not be too large).
%%Some machines can even deal with $t_1+4\times t_2$!
%%One possibility, then, would be to make an ``address context''
%%function dynamic through Lua.
%%Care would have to be taken to avoid paying for an expensive identity
%%function (embedding/projection) at every application of such a function.
\section{[[front_ir/opshape.nw]]}
<<front_ir/opshape.ml>>=
<<opshape.ml>>
@

<<front_ir/opshape.mli>>=
<<opshape.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%%%Grades: B Peripheral Soon
%%
\section{Operator-shape analysis}
%%
%%In order to know how to do code expansion, we haev to analyze what
%%kinds of arguments and 
%%results operators have.
%%Here's where it happens.
%%We call a pattern of arguments and results a ``shape,'' and we have to
%%ensure that each shape is handled either in the generic expander or by
%%each postexpander.
%%To see a complete list of operators with their type schemes,
%%try
%%\begin{verbatim}
%%  qc-- -e 'Rtlop.print_shapes()'
%%\end{verbatim}
%%
%%We export an analysis function that the generic expander can use to
%%pass the buck to the postexpander.
<<opshape.mli>>=
<<exported type definitions(opshape.nw)>>
@ 
%%
<<exported type definitions(opshape.nw)>>=
type opr = Rtl.Private.opr
type exp = Rtl.Private.exp
type 'a hi = Hi of 'a
type 'a lo = Lo of 'a
type ('temp, 'warg) t =
  | Binop  of 'temp * 'temp
  | Unop   of 'temp
  | Binrm  of 'temp * 'temp * 'warg
  | Unrm   of 'temp * 'warg
  | Cmp    of 'temp * 'temp
  | Dblop  of 'temp * 'temp
  | Wrdop  of 'temp * 'temp * 'warg
  | Wrdrop of 'temp * 'temp * 'warg
  | Width
  | Fpcvt  of 'temp * 'warg
  | Bool
  | Nullary
@ 
<<opshape.mli>>=
val of_opr : opr -> (unit, unit) t
val capply :
    ('exp -> 'c -> 'temp) ->
    ('exp -> 'c -> 'warg) -> opr -> 'exp list -> 'c list -> ('temp, 'warg) t
@ 
%%\begingroup
%%\def\bits#1{\mathtt{bits}\##1}
%%\def\cross{\times}
%%\def\arrow{\rightarrow}
%%\def\bool{\mathtt{bool}}
%%
%%\def\optype#1{\par\noindent\hspace*{2em}$#1$\\}
%%\def\oplist#1{\noindent\hangindent=4em\hangafter=1\texttt{#1}\par}
%%
\subsection{Shapes}
%%
%%All the shapes we know about are grouped below.
%%The postexpander sees arguments and results as follows:
%%\begin{itemize}
%%\item
%%An argument or result of type $\bits n$ gets passed in a temporary.
%%\item
%%An argument of type $\bits1$ or $\bits2$ is a ``weird argument'' and
%%gets passed in a~[[warg]]. 
%%\item
%%A~result of type $\bits1$ gets returned in a [[wtemp]], which is a
%%temporary plus a fill type.
%%\item
%%The postexpander never sees an argument of type [[bool]].
%%A~result of type [[bool]] gets turned into a conditional branch.
%%\item
%%A~result of type $\bits{2n}$ gets returned in a pair of temporaries
%%[[dsthi]] and [[dstlo]].
%%\end{itemize}
%%
%%
%%\subsubsection{Ordinary value operators}
%%
%%These value operators correspond to postexpander functions [[binop]]
%%and [[unop]].
%%\optype{\forall  n . \bits n \cross \bits n \arrow \bits n}
%%  \oplist{add, and, div, mod, \ldots}
%%\optype{\forall  n . \bits n \arrow \bits n}
%%  \oplist{com, neg, fabs, fneg, popcnt}
%%
%%\subsubsection{Ordinary value operators with rounding mode}
%%
%%These value operators correspond to postexpander functions [[binrm]]
%%and [[unrm]].
%%\optype{\forall  n . \bits n \cross \bits n \cross \bits 2 \arrow \bits n}
%%  \oplist{fadd, fdiv, fmul, fsub}
%%\optype{\forall  n . \bits n \cross \bits 2 \arrow \bits n}
%%  \oplist{fsqrt}
%%
%%\subsubsection{Comparisons}
%%
%%Comparisons correspond to the postexpander function~[[bc]].
%%\optype{\forall  n . \bits n \cross \bits n \arrow \bool}
%%  \oplist{eq, ge, gt, le, lt, ne, \ldots}
%%
%%
%%\subsubsection{Weird value operators}
%%
%%These operators correspond to postexpander functions
%%[[dblop]],
%%[[wrdop]],
%%and
%% [[wrdrop]].
%%\optype{\forall  n . \bits n \cross \bits n \arrow 2\cross\bits n}
%%  \oplist{mulx, fmulx, mulux}
%%\optype{\forall  n . \bits n \cross \bits n \cross \bits 1 \arrow \bits n}
%%  \oplist{addc, subb}
%%\optype{\forall  n . \bits n \cross \bits n \cross \bits 1 \arrow \bits 1}
%%  \oplist{carry, borrow}
%%
%%
%%\subsubsection{Width-changers}
%%
%%
%%Unclear how these work; mostly the generic expander composes them with
%%things.  (E.g., see [[sxload]], [[zxload]], [[lostore]].)
%%
%%\optype{\forall  n, m . \bits n \arrow \bits m}
%%  \oplist{sx, zx, lobits, NaN}
%%\optype{\forall  n, m . \bits n \cross \bits 2 \arrow \bits m}
%%  \oplist{f2f, f2i, i2f}
%%
%%
%%\subsubsection {Boolean operators}
%%
%%These operators are all dealt with directly by the generic expander.
%%\optype{\bool \arrow \bool}
%%  \oplist{not}
%%\optype{bool \arrow \bits 1}
%%  \oplist{bit}
%%\optype{\bits 1 \arrow \bool}
%%  \oplist{bool}
%%\optype{bool \cross \bool \arrow \bool}
%%  \oplist{conjoin, disjoin}
%%\optype{bool}
%%  \oplist{false, true}
%%
%%\subsubsection{Nullary operators}
%%
%%These operators are turned into constants in the simplifier.
%%\optype{\bits 2}
%%  \oplist{round\_up, round\_down, round\_zero, round\_nearest}
%%\optype{\forall  n . \bits n}
%%  \oplist{minf, pinf, mzero, pzero}
%%
\subsection{Obsolete, unsupported operators}
%%
%%\optype{\forall  n . \bits n \cross \bits n \arrow \bits 2}
%%  \oplist{fcmp}
%%\optype{\forall  n, m . \bits n \cross \bits n \cross \bits m \arrow \bits n}
%%  \oplist{bitInsert}
%%\optype{\forall  n . \bits n \cross \bits n \cross \bits n \cross \bits n \cross \bits n \arrow \bits n}
%%  \oplist{bitTransfer}
%%
%%\endgroup
%%
<<opshape.ml>>=
module SM = Strutil.Map
module T  = Types

let impossf fmt = Printf.kprintf Impossible.impossible fmt
 

<<exported type definitions(opshape.nw)>>
@ 
%%Here are the type variables:
<<'a>>=
T.Bits (T.Var 1)
@ 
<<'b>>=
T.Bits (T.Var 2)
@ 
<<bits1>>=
T.Bits (T.Const 1)
@ 
<<bits2>>=
T.Bits (T.Const 2)
@ 
<<rm>>=
<<bits2>>
@ 
<<opshape.ml>>=
let shape scheme = match scheme with
| [
   <<'a>>
   ; 
   <<'a>>
    ], 
    <<'a>>
    -> Binop ((), ())
| [
   <<'a>>
    ], 
    <<'a>>
   -> Unop ()
| [
   <<'a>>
   ; 
   <<'a>>
   ; 
   <<rm>>
   ], 
  <<'a>>
               -> Binrm ((), (), ())
| [
  <<'a>>
  ; 
  <<rm>>
            ], 
  <<'a>>
               -> Unrm ((), ())
| [
  <<'a>>
  ; 
  <<'a>>
            ], T.Bool               -> Cmp ((), ())
| [
  <<'a>>
  ; 
  <<'a>>
             ], T.Bits (T.Double 1)  -> Dblop ((), ())
| [
  <<'a>>
  ; 
  <<'a>>
  ; 
  <<bits1>>
  ], 
  <<'a>>
                 -> Wrdop ((), (), ())
| [
   <<'a>>
   ; 
   <<'a>>
   ; 
   <<bits1>>
   ], 
   <<bits1>>
              -> Wrdrop ((), (), ())
| [
  <<'a>>
                    ], 
  <<'b>>
                -> Width
| [
  <<'a>>
  ; 
  <<rm>>
            ], 
   <<'b>>
                -> Fpcvt ((), ())
| [T.Bool|
     <<bits1>>
           ], (T.Bool | 
               <<bits1>>
       ) -> Bool
| [T.Bool; T.Bool           ], T.Bool               -> Bool
| [                         ], T.Bool               -> Bool
| [                         ], 
    (
    <<'a>>
    |
    <<bits2>>
    )   -> Nullary
| _ -> impossf "unrecognized operator type %s" (Types.scheme_string scheme)

let shapetab = Rtlop.fold (fun o t z -> SM.add o (shape t) z) SM.empty

let of_opr (o, _) =
  try SM.find o shapetab with _ -> impossf "operator %%%s has no shape" o
@ 
%%Here's the general idea of what we're trying to accomplish.
%%It's readable, but it's wrong in two ways:
%%\begin{itemize}
%%\item
%%There are no contexts
%%\item
%%The order of evaluation is not determined
%%\end{itemize}
<<opshape.ml>>=
let args () = impossf "wrong number of arguments to operator"
let appfun t w = function
  | Binop  _ -> (function [x; y]    -> Binop  (t x, t y)      | _ -> args())
  | Unop   _ -> (function [x]       -> Unop   (t x)           | _ -> args())
  | Binrm  _ -> (function [x; y; r] -> Binrm  (t x, t y, w r) | _ -> args())
  | Unrm   _ -> (function [x;r ]    -> Unrm   (t x, w r)      | _ -> args())
  | Cmp    _ -> (function [x; y]    -> Cmp    (t x, t y)      | _ -> args())
  | Dblop  _ -> (function [x; y]    -> Dblop  (t x, t y)      | _ -> args())
  | Wrdop  _ -> (function [x; y; c] -> Wrdop  (t x, t y, w c) | _ -> args())
  | Wrdrop _ -> (function [x; y; c] -> Wrdrop (t x, t y, w c) | _ -> args())
  | Width    -> (function [x]       -> Width                  | _ -> args())
  | Fpcvt  _ -> (function [x;r ]    -> Fpcvt  (t x, w r)      | _ -> args())
  | Bool     -> (function _         -> Bool)
  | Nullary  -> (function []        -> Nullary                | _ -> args())
@ 
%%Now for the truth, with contexts.
%%This code is absolute hell to write (and read?) because we must use
%%explicit [[let]] bindings to control the order of evaluation.
%%We would have to do the same above except the [[apply]] function is
%%not exposed.
<<opshape.ml>>=
let cappfun t w = 
  let binop cs es =
    match es, cs with
    | [x; y], [xc; yc] ->
        let x = t xc x in
        let y = t yc y in
        Binop  (x, y)
    | _ -> args() in
  let unop cs es =
    match es, cs with [x], [xc] -> Unop (t xc x) | _ -> args() in
  let binrm cs es =
    match es, cs with
    | [x; y; r], [xc; yc; rc] ->
        let x = t xc x in
        let y = t yc y in
        let r = w rc r in
        Binrm (x, y, r)
    | _ -> args() in
  let unrm cs es =
    match es, cs with
    | [x; r], [xc; rc] ->
        let x = t xc x in
        let r = w rc r in
        Unrm (x, r)
    | _ -> args() in
  let cmp cs es =
    match es, cs with
    | [x; y], [xc; yc] ->
        let x = t xc x in
        let y = t yc y in
        Cmp (x, y)
    | _ -> args() in
  let dblop cs es =
    match es, cs with
    | [x; y], [xc; yc] ->
        let x = t xc x in
        let y = t yc y in
        Dblop (x, y)
    | _ -> args() in
  let wrdop cs es =
    match es, cs with
    | [x; y; z], [xc; yc; zc] ->
        let x = t xc x in
        let y = t yc y in
        let z = w zc z in
        Wrdop(x, y, z)
    | _ -> args() in
  let wrdrop cs es =
    match es, cs with
    | [x; y; z], [xc; yc; zc] ->
        let x = t xc x in
        let y = t yc y in
        let z = w zc z in
        Wrdrop(x, y, z)
    | _ -> args() in
  let width cs es = 
    match es, cs with [x], [xc] -> Width | _ -> args() in
  let fpcvt cs es =
    match es, cs with
    | [x; r], [xc; rc] ->
        let x = t xc x in
        let r = w rc r in
        Fpcvt (x, r)
    | _ -> args() in
  let nullary cs es = 
    match es, cs with [], [] -> Width | _ -> args() in
  function
  | Binop  _ -> binop
  | Unop   _ -> unop
  | Binrm  _ -> binrm
  | Unrm   _ -> unrm
  | Cmp    _ -> cmp
  | Dblop  _ -> dblop
  | Wrdop  _ -> wrdop
  | Wrdrop _ -> wrdrop
  | Width    -> width
  | Fpcvt  _ -> fpcvt
  | Bool     -> (fun _ _ -> Bool)
  | Nullary  -> nullary

let capply to_temp to_warg opr = cappfun to_temp to_warg (of_opr opr)
@ 
\section{[[front_ir/preast2ir.nw]]}
<<front_ir/preast2ir.ml>>=
<<preast2ir.ml>>
@

<<front_ir/preast2ir.mli>>=
<<preast2ir.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et sts=4
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
\section{Target and proc definitions}
%%
%%This code is in a separate module to make it easier to avoid circular dependencies.
<<type defs>>=
type tgt  = T of (basic_proc, (Rtl.exp -> Automaton.t), Call.t) Target.t
and basic_proc = (Automaton.t, unit, Call.t, tgt) Proc.t
type proc = Zipcfg.graph * basic_proc
type old_proc = (Automaton.t, Rtl.rtl Cfgx.M.cfg, Call.t, tgt) Proc.t
@
<<preast2ir.mli>>=
<<type defs>>
val tgt : basic_proc -> (basic_proc, (Rtl.exp -> Automaton.t), Call.t) Target.t
@
%%
<<preast2ir.ml>>=
<<type defs>>
let tgt {Proc.target = T t} = t
@ 
\section{[[front_ir/proc.nw]]}
<<front_ir/proc.ml>>=
<<proc.ml>>
@

<<front_ir/proc.mli>>=
<<proc.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{Procedure Intermediate Representation}
%%% ------------------------------------------------------------------ 
%%
%%The \module{ast3ir} module translates {\PAL} {\AST} to abstract assembly
%%code, where each instruction represents an entire procedure. A procedure
%%is represented by a control-flow graph and some accompanied
%%informations. This module provides a data type for this intermediate
%%representation of a procedures.
%%
%%The data type provided here is in-complete and there will change. The
%%main purpose of this module is to provide a centralized defintion and
%%documentation for it.
%%
%%THERE'S A BIT OF A PROBLEM HERE: ALL SORTS OF DATA LEAK INTO
%%[[Proc.t]] WHEN IN A JUST WORLD THOSE DATA WOULD BE THE PRIVATE
%%PROPERTIES OF THEIR INDIVIDUAL PASSES.  FOR EXAMPLE, [[global_map]]
%%SHOULD BE THE PRIVATE PROPERTY OF THE VARIABLE PLACER.
<<type t(proc.nw)>>=
type overflow = (Block.t list, Block.t list) Call.split_blocks
type ('automaton, 'cfg, 'cc, 'tgt) t = 
    { symbol:         Symbol.t           (* of procedure *)
    ; cc:             'cc                (* calling convention                   *)
    ; target:         'tgt               (* target of this procedure             *)
    ; formals:        (int * Ast.bare_formal) list (* formal args w/ indices)    *)
    ; temps:          Talloc.Multiple.t  (* allocator for temporaries            *)
    ; mk_symbol:      string -> Symbol.t (* allocator for symbols                *)
    ; cfg:            'cfg               (* control-flow graph                   *)
    ; oldblocks:      overflow           (* stack - incoming parms, outgoing results *)
    ; youngblocks:    overflow           (* stack - outgoing parms, incoming results *)
    ; stackd:         Block.t            (* stack - user stack data              *)
    ; conts:          Block.t            (* pairs of pointers for conts *)
    ; sp:             Block.t            (* the `standard' location of sp in body *)
    ; priv:           'automaton         (* stack - spill slots etc - still open *)
    ; eqns:           Rtleqn.t list      (* eqns for compile time consts *)
    ; vars:           int                (* number of local vars + parameters *)
    ; nvregs:         int                (* number of non-volatile registers *)
    ; var_map:        Automaton.loc option array (* where variables are stored *)
    ; global_map:     Automaton.loc array (* where global variables are stored *)
    ; bodylbl:        Zipcfg.uid * string (* beginning of procedure body *)
    ; headroom:       int                 (* size of the headroom *)
    ; exp_of_lbl:     (Unique.uid * string) -> Rtl.exp (* exp of code label *)
    }
@
%%
%%\begin{itemize}
%%\item [[symbol]]:              the name of the procedure represented by this.
%%\item [[cc]]:                  calling convention for this procedure.
%%\item [[target]]:              the target we are compiling for.    
%%\item [[formals]]:             the formal arguments to this procedure (with the index
%%                               for each variable)
%%\item [[temps]]:               an allocator for temporaries
%%\item [[mk_symbol]]:           an allocator for symbols
%%\item [[cfg]]:                 the control-flow graph of the procedure.
%%\item [[oldblocks]]:    stack area for incoming overflow parameters or
%%outgoing overflow results, some allocated by the
%%                               caller and some by the callee
%%\item [[youngblocks]]:  stack area for outgoing overflow parameters or
%%incoming overflow results, some deallocated by the
%%                               caller and some by the callee.
%%\item [[incoming]]:            stack area for incoming parameters.
%%\item [[outgoing]]:            stack area for outgoing parameters.
%%\item [[stackd]]:              User stack data, from the [[stack data]] construct.
%%\item [[conts]]:               Area on the stack where continuations are stored.
%%\item [[sp]]:                  The block where the sp is stored during the procedure
%%                               body.
%%\item [[priv]]:                Automaton that provides register-like \emph{memory}
%%                               locations for spill slots, continuations, etc. The 
%%                               memory will be allocated on the stack.
%%\item [[eqns]]:                Constraints for symbolic compile-time constants.
%%                               They are introduced by [[Area.t]] values that are
%%                               concatenated and overlayed to form a procedure's
%%                               stack frame.
%%\item [[vars]]:                Parameters and local variables in a procdure are
%%                               numbered starting from zero for the runtime system. 
%%                               [[vars]] is the number of parameters plus the number
%%                               of local variables.
%%\item [[nvregs]]:              The number of non-volatile registers in this procedure.
%%\item [[var_map]]:             A map from variables to the temps they are placed in.
%%\item [[global_map]]:          A map from the index of a global
%%                               variable to the machine location it is placed in.
%%\item [[spans]]:               At each call site and continuation, we keep track of
%%                               information for the runtime system, including
%%                               the locations of stackdata, spans, etc.; the second
%%                               element is the span information.
%%\item [[bodylbl]]:             Name of the label marking the beginning of the procedure
%%                               body after standard prolog code. It is safe to insert
%%                               arbitrary code into the procedure at this label.
%%\item [[exp_of_lbl]]:          A function that converts a label to an expression.
%%                               This function is in the [[Proc.t]] record because it
%%                               may require access to a procedure-specific environment.
%%\end{itemize}
%%
<<proc.mli>>=
<<type t(proc.nw)>>
@ 
%%
<<proc.ml>>=
<<type t(proc.nw)>>
@
\section{[[front_ir/rewrite.nw]]}
<<front_ir/rewrite.ml>>=
<<rewrite.ml>>
@

<<front_ir/rewrite.mli>>=
<<rewrite.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
\section{Rewriting RTL operators (and related utilities)}
%%
%%This module has rewrite rules that help postexpanders implement
%%unsupported operators in terms of supported operators.
%%Arguments may be copied, so for maximum efficiency, it may be best if
%%they are temporaries---but we don't require this.
<<exported type abbreviations>>=
type width = Rtl.width
type exp   = Rtl.exp
type loc   = Rtl.loc
type block = exp Postexpander.block
type temp  = Register.t
@ 
%%
<<rewrite.mli>>=
<<exported type abbreviations>>
@ 
\subsection{Basic operator interface}
<<rewrite.mli>>=
module Ops : sig
  <<type signatures for applying standard operators>>
  val signed   : width -> int -> exp
  val unsigned : width -> int -> exp
end
@ 
\subsection{Rewriting functions}
%%There are too many options for rewriting division.
%%We assume the common case is that arguments have the same sign (i.e.,
%%both positive).
%%\begin{itemize}
%%\item 
%%If the machine's divide instruction provides both \texttt{quot} and
%%\texttt{rem} for free, it is probably best to use [[div']].
%%It uses at most two conditional branches and will use one in the common case.
%%\item 
%%If the divide instruction gives only \texttt{quot}, it's probably
%%better to use one of the other instructions.
%%The first uses two conditional branches always.
%%The second uses only one in the common case, but may use up to three
%%in uncommon cases.
%%\end{itemize}
<<rewrite.mli>>=
val div' : width -> dst:loc -> exp -> exp -> quot:exp -> rem:exp -> block
  (* uses: comparisons, add, sub *)

val div2 : width -> dst:loc -> exp -> exp -> block
  (* always 2 conditional branches *)

val div1_3 : width -> dst:loc -> exp -> exp -> block
  (* 1--3 conditional branches *)
@ 
<<rewrite.mli>>=
val div_overflows : width -> exp -> exp -> exp
  (* uses: conjoin, eq *)

val (mod) : width -> exp -> exp -> exp
  (* uses : div, mul, sub *)

val modu : width -> exp -> exp -> exp
  (* uses : divu, mul, sub *)

val rem  : width -> exp -> exp -> exp
  (* uses : quot, mul, sub *)
@ 
<<rewrite.mli>>=
val popcnt : width -> dst:loc -> exp -> block (* for 32 bits only *)
@ 
<<rewrite.mli>>=
val sxlo : width -> width -> exp -> exp
  (* uses : shl, shra *)
val zxlo : width -> width -> exp -> exp
  (* uses : shl, shrl *)
@
\subsection{Other related utilities}
%%
%%Get the value of an expression composed of high and low parts.
%%This is just [[zx hi << w | zx lo]] where [[w = width lo]].
<<rewrite.mli>>=
val regpair : hi:exp -> lo:exp -> exp
@ 
%%A~slice of a value, implementing using the standard [[lobits]] and
%%[[shrl]] operators.
%%The first width is the width of the expression; the second is the
%%width of the slice (as in [[lobits]]).
<<rewrite.mli>>=
val slice : width -> width -> lsb:int -> exp -> exp
@ 
%%Here are two ways to split a value for RISC load-immediate
%%implementations.
<<rewrite.mli>>=
type 'a pair = { hi : 'a; lo : 'a }
val splits : width -> lsb:int -> exp -> exp pair
val splitu : width -> lsb:int -> exp -> exp pair
@ 
%%It's a checked run-time error unless $0 < \mathtt{lsb} <
%%\mathtt{w}$.
%%The 
%%postconditions are as follows:
%%\begin{quote}
%%\let\t\mathtt
%%\def\lo#1#2{\t{lobits}_{#1 \rightarrow #2}}
%%\def\sx#1#2{\t{sx}_{#1 \rightarrow #2}}
%%\def\zx#1#2{\t{zx}_{#1 \rightarrow #2}}
%%[[splits w n e = {hi, lo}]] where
%%\begin{eqnarray*}
%%\t e &=& \t{hi} + \t{lo}\\
%%\lo w n \t{hi} &=& 0\\
%%\sx n w (\lo w n \t{lo}) &=& \t{lo}\\
%%\end{eqnarray*}
%%
%%[[splitu w n e = {hi, lo}]] where
%%\begin{eqnarray*}
%%\t e &=& \t{hi} + \t{lo} = \t{hi} \mathbin{|} \t{lo}\\
%%\lo w n \t{hi} &=& 0\\
%%\zx n w (\lo w n \t{lo}) &=& \t{lo}\\
%%\end{eqnarray*}
%%\end{quote}
%%The idea is that given a constant expression, one can implement load
%%immediate by
%%$t \gets \mathtt{hi}; t \gets t + \mathtt{\sigma x}\;\mathtt{lo}$ 
%%where $\sigma$~stands for [[s]]~or~[[z]].
%%The recognizer should use the [[Bits.[SU].fits]] predicates.
%%
\subsection{Implementation}
<<rewrite.ml>>=
module B  = Bits
module BO = Bits.Ops
module DG = Dag
module R  = Rtl
module RU = Rtlutil

let (<:>) = DG.(<:>)

<<exported type abbreviations>>

module Ops = struct
  <<automatically generated implementations of operators>>
  let signed   w n = R.bits (B.S.of_int n w) w
  let unsigned w n = R.bits (B.U.of_int n w) w
end
module O = Ops


let div_overflows w x y =
  let minint = R.bits (BO.shl (B.U.of_int 1 w) (B.U.of_int (w-1) w)) w in
  O.conjoin (O.eq w x minint) (O.eq w y (O.signed w (-1)))

let (mod) w x y = O.sub w x (O.mul w y (O.div  w x y))
let modu  w x y = O.sub w x (O.mul w y (O.divu w x y))
let rem   w x y = O.sub w x (O.mul w y (O.quot w x y))
@ 
<<rewrite.ml>>=
let sxlo n w x =
  let shamt = O.unsigned w (w-n) in
  O.shra w (O.shl w x shamt) shamt

let zxlo n w x =
  let shamt = O.unsigned w (w-n) in
  O.shrl w (O.shl w x shamt) shamt
@ 
%%Population count discussed in \emph{Hacker's Delight} and also in AMD
%%Athlon Optimization manual
%%(\url{http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/22007.pdf}). 
%%
<<rewrite.ml>>=
let popcnt w ~dst x =
  if w <> 32 then
    Unsupported.popcnt ~notok:w ~ok:32;
  let u      = O.unsigned 32 in
  let (@:=) l r = DG.Rtl (R.store l r 32) in
  let (&)   l r = O._and 32 l r in
  let (>>)  l r = O.shrl 32 l (u r) in
  let (-)   l r = O.sub 32 l r in
  let (+)   l r = O.add 32 l r in
  let ( * ) l r = O.mul 32 l r in
  let tmploc = dst in
  let tmpval = R.fetch tmploc 32 in
  let mask3  = u 0x33333333 in
  let mask5  = R.bits (Bits.U.of_int64 0x55555555L 32) 32 in   (* Caml sign bit set *)
  let maskF  = u 0x0F0F0F0F in 
  let mask01 = u 0x01010101 in 
  tmploc @:= x - ((x >> 1) & mask5) <:>
  tmploc @:= (tmpval & mask3) + ((tmpval >> 2) & mask3)  <:>
  tmploc @:= ((tmpval + (tmpval >> 4)) & maskF)  <:>
  tmploc @:= ((tmpval * mask01) >> 24)   (* AMD guide *)
@ 
%% From \emph{Hacker's Delight}, an alternative to the last line is
%%\begin{verbatim}
%%  tmploc @:= tmploc + (tmploc >> 8) <:>
%%  tmploc @:= tmploc + (tmploc >> 16) <:>
%%  tmploc @:= (tmploc & u 0x3F)
%%\end{verbatim}
%%
<<rewrite.ml>>=
let regpair ~hi ~lo =
  let hw = RU.Width.exp hi in
  let lw = RU.Width.exp lo in
  let w = hw + lw in
  O.(or) w (O.shl w (O.zx hw w hi) (O.unsigned w lw)) (O.zx lw w lo)
@ 
%%
<<rewrite.ml>>=
let slice w n ~lsb e =
  if lsb = 0 then
    O.lobits w n e
  else
    O.lobits w n (O.shrl w e (O.unsigned w lsb))
@ 
%%Unsigned splitting is simple; we just grab the bits.
<<rewrite.ml>>=
type 'a pair = { hi : 'a; lo : 'a }

let splitu w ~lsb:n e =
  assert (0 < n && n < w);
  let lo = O.zx n w (O.lobits w n e) in
  let n  = O.unsigned w n in
  let hi = O.shl w (O.shrl w e n) n in
  { hi = hi; lo = lo }
@ 
%%Signed splitting is a bit tricky.
%%If the sign bit of the low part (bit $\mathtt{lsb}-1$) is set,
%%eventually $1$~will be subtracted from the high part, so we have to
%%add it ([[adjust]]) here.  The arithmetic achieves this effect without
%%any conditionals. 
<<rewrite.ml>>=
let splits w ~lsb:n e =
  assert (0 < n && n < w);
  let lo     = O.sx n w (O.lobits w n e) in
  let adjust = O.zx 1 w (slice w 1 ~lsb:(n-1) e) in
  let n      = O.unsigned w n in
  let hi     = O.shl w (O.add w (O.shrl w e n) adjust) n in
  { hi = hi; lo = lo }
@
%%
\section{Things not to be looked at}
%%
\subsection{Automatically generated helper functions}
%%This code is generated automatically by [[Rtlop.Emit.creators]].
<<automatically generated implementations of operators>>=
(* This code generated automatically by Rtlop.Emit.creators *)
let _NaN w w' x = Rtl.app (Rtl.opr "NaN" [w;w';]) [x; ]
let add w x y = Rtl.app (Rtl.opr "add" [w;]) [x; y; ]
let addc w x y z = Rtl.app (Rtl.opr "addc" [w;]) [x; y; z; ]
let add_overflows w x y = Rtl.app (Rtl.opr "add_overflows" [w;]) [x; y; ]
let _and w x y = Rtl.app (Rtl.opr "and" [w;]) [x; y; ]
let bit x = Rtl.app (Rtl.opr "bit" []) [x; ]
let bool x = Rtl.app (Rtl.opr "bool" []) [x; ]
let borrow w x y z = Rtl.app (Rtl.opr "borrow" [w;]) [x; y; z; ]
let carry w x y z = Rtl.app (Rtl.opr "carry" [w;]) [x; y; z; ]
let com w x = Rtl.app (Rtl.opr "com" [w;]) [x; ]
let conjoin x y = Rtl.app (Rtl.opr "conjoin" []) [x; y; ]
let disjoin x y = Rtl.app (Rtl.opr "disjoin" []) [x; y; ]
let div w x y = Rtl.app (Rtl.opr "div" [w;]) [x; y; ]
let div_overflows w x y = Rtl.app (Rtl.opr "div_overflows" [w;]) [x; y; ]
let divu w x y = Rtl.app (Rtl.opr "divu" [w;]) [x; y; ]
let eq w x y = Rtl.app (Rtl.opr "eq" [w;]) [x; y; ]
let f2f w w' x y = Rtl.app (Rtl.opr "f2f" [w;w';]) [x; y; ]
let f2f_implicit_round w w' x = Rtl.app (Rtl.opr "f2f_implicit_round" [w;w';]) [x; ]
let f2i w w' x y = Rtl.app (Rtl.opr "f2i" [w;w';]) [x; y; ]
let fabs w x = Rtl.app (Rtl.opr "fabs" [w;]) [x; ]
let fadd w x y z = Rtl.app (Rtl.opr "fadd" [w;]) [x; y; z; ]
let fcmp w x y = Rtl.app (Rtl.opr "fcmp" [w;]) [x; y; ]
let fdiv w x y z = Rtl.app (Rtl.opr "fdiv" [w;]) [x; y; z; ]
let feq w x y = Rtl.app (Rtl.opr "feq" [w;]) [x; y; ]
let fge w x y = Rtl.app (Rtl.opr "fge" [w;]) [x; y; ]
let fgt w x y = Rtl.app (Rtl.opr "fgt" [w;]) [x; y; ]
let fle w x y = Rtl.app (Rtl.opr "fle" [w;]) [x; y; ]
let float_eq = Rtl.app (Rtl.opr "float_eq" []) []
let float_gt = Rtl.app (Rtl.opr "float_gt" []) []
let float_lt = Rtl.app (Rtl.opr "float_lt" []) []
let flt w x y = Rtl.app (Rtl.opr "flt" [w;]) [x; y; ]
let fmul w x y z = Rtl.app (Rtl.opr "fmul" [w;]) [x; y; z; ]
let fmulx w x y = Rtl.app (Rtl.opr "fmulx" [w;]) [x; y; ]
let fne w x y = Rtl.app (Rtl.opr "fne" [w;]) [x; y; ]
let fneg w x = Rtl.app (Rtl.opr "fneg" [w;]) [x; ]
let fordered w x y = Rtl.app (Rtl.opr "fordered" [w;]) [x; y; ]
let fsqrt w x y = Rtl.app (Rtl.opr "fsqrt" [w;]) [x; y; ]
let fsub w x y z = Rtl.app (Rtl.opr "fsub" [w;]) [x; y; z; ]
let funordered w x y = Rtl.app (Rtl.opr "funordered" [w;]) [x; y; ]
let ge w x y = Rtl.app (Rtl.opr "ge" [w;]) [x; y; ]
let geu w x y = Rtl.app (Rtl.opr "geu" [w;]) [x; y; ]
let gt w x y = Rtl.app (Rtl.opr "gt" [w;]) [x; y; ]
let gtu w x y = Rtl.app (Rtl.opr "gtu" [w;]) [x; y; ]
let i2f w w' x y = Rtl.app (Rtl.opr "i2f" [w;w';]) [x; y; ]
let le w x y = Rtl.app (Rtl.opr "le" [w;]) [x; y; ]
let leu w x y = Rtl.app (Rtl.opr "leu" [w;]) [x; y; ]
let lobits w w' x = Rtl.app (Rtl.opr "lobits" [w;w';]) [x; ]
let lt w x y = Rtl.app (Rtl.opr "lt" [w;]) [x; y; ]
let ltu w x y = Rtl.app (Rtl.opr "ltu" [w;]) [x; y; ]
let minf w = Rtl.app (Rtl.opr "minf" [w;]) []
let (mod) w x y = Rtl.app (Rtl.opr "mod" [w;]) [x; y; ]
let modu w x y = Rtl.app (Rtl.opr "modu" [w;]) [x; y; ]
let mul w x y = Rtl.app (Rtl.opr "mul" [w;]) [x; y; ]
let mulux w x y = Rtl.app (Rtl.opr "mulux" [w;]) [x; y; ]
let mulx w x y = Rtl.app (Rtl.opr "mulx" [w;]) [x; y; ]
let mul_overflows w x y = Rtl.app (Rtl.opr "mul_overflows" [w;]) [x; y; ]
let mulu_overflows w x y = Rtl.app (Rtl.opr "mulu_overflows" [w;]) [x; y; ]
let mzero w = Rtl.app (Rtl.opr "mzero" [w;]) []
let ne w x y = Rtl.app (Rtl.opr "ne" [w;]) [x; y; ]
let neg w x = Rtl.app (Rtl.opr "neg" [w;]) [x; ]
let not x = Rtl.app (Rtl.opr "not" []) [x; ]
let (or) w x y = Rtl.app (Rtl.opr "or" [w;]) [x; y; ]
let pinf w = Rtl.app (Rtl.opr "pinf" [w;]) []
let popcnt w x = Rtl.app (Rtl.opr "popcnt" [w;]) [x; ]
let pzero w = Rtl.app (Rtl.opr "pzero" [w;]) []
let quot w x y = Rtl.app (Rtl.opr "quot" [w;]) [x; y; ]
let quot_overflows w x y = Rtl.app (Rtl.opr "quot_overflows" [w;]) [x; y; ]
let rem w x y = Rtl.app (Rtl.opr "rem" [w;]) [x; y; ]
let rotl w x y = Rtl.app (Rtl.opr "rotl" [w;]) [x; y; ]
let rotr w x y = Rtl.app (Rtl.opr "rotr" [w;]) [x; y; ]
let round_down = Rtl.app (Rtl.opr "round_down" []) []
let round_nearest = Rtl.app (Rtl.opr "round_nearest" []) []
let round_up = Rtl.app (Rtl.opr "round_up" []) []
let round_zero = Rtl.app (Rtl.opr "round_zero" []) []
let shl w x y = Rtl.app (Rtl.opr "shl" [w;]) [x; y; ]
let shra w x y = Rtl.app (Rtl.opr "shra" [w;]) [x; y; ]
let shrl w x y = Rtl.app (Rtl.opr "shrl" [w;]) [x; y; ]
let sub w x y = Rtl.app (Rtl.opr "sub" [w;]) [x; y; ]
let subb w x y z = Rtl.app (Rtl.opr "subb" [w;]) [x; y; z; ]
let sub_overflows w x y = Rtl.app (Rtl.opr "sub_overflows" [w;]) [x; y; ]
let sx w w' x = Rtl.app (Rtl.opr "sx" [w;w';]) [x; ]
let unordered = Rtl.app (Rtl.opr "unordered" []) []
let xor w x y = Rtl.app (Rtl.opr "xor" [w;]) [x; y; ]
let zx w w' x = Rtl.app (Rtl.opr "zx" [w;w';]) [x; ]
let bitExtract w w' x y = Rtl.app (Rtl.opr "bitExtract" [w;w';]) [x; y; ]
let bitInsert w w' x y z = Rtl.app (Rtl.opr "bitInsert" [w;w';]) [x; y; z; ]
let bitTransfer w x y z u v = Rtl.app (Rtl.opr "bitTransfer" [w;]) [x; y; z; u; v; ]
@ 
<<type signatures for applying standard operators>>=
val _NaN : width -> width -> exp -> exp
val add : width -> exp -> exp -> exp
val addc : width -> exp -> exp -> exp -> exp
val add_overflows : width -> exp -> exp -> exp
val _and : width -> exp -> exp -> exp
val bit : exp -> exp
val bool : exp -> exp
val borrow : width -> exp -> exp -> exp -> exp
val carry : width -> exp -> exp -> exp -> exp
val com : width -> exp -> exp
val conjoin : exp -> exp -> exp
val disjoin : exp -> exp -> exp
val div : width -> exp -> exp -> exp
val div_overflows : width -> exp -> exp -> exp
val divu : width -> exp -> exp -> exp
val eq : width -> exp -> exp -> exp
val f2f : width -> width -> exp -> exp -> exp
val f2f_implicit_round : width -> width -> exp -> exp
val f2i : width -> width -> exp -> exp -> exp
val fabs : width -> exp -> exp
val fadd : width -> exp -> exp -> exp -> exp
val fcmp : width -> exp -> exp -> exp
val fdiv : width -> exp -> exp -> exp -> exp
val feq : width -> exp -> exp -> exp
val fge : width -> exp -> exp -> exp
val fgt : width -> exp -> exp -> exp
val fle : width -> exp -> exp -> exp
val float_eq : exp
val float_gt : exp
val float_lt : exp
val flt : width -> exp -> exp -> exp
val fmul : width -> exp -> exp -> exp -> exp
val fmulx : width -> exp -> exp -> exp
val fne : width -> exp -> exp -> exp
val fneg : width -> exp -> exp
val fordered : width -> exp -> exp -> exp
val fsqrt : width -> exp -> exp -> exp
val fsub : width -> exp -> exp -> exp -> exp
val funordered : width -> exp -> exp -> exp
val ge : width -> exp -> exp -> exp
val geu : width -> exp -> exp -> exp
val gt : width -> exp -> exp -> exp
val gtu : width -> exp -> exp -> exp
val i2f : width -> width -> exp -> exp -> exp
val le : width -> exp -> exp -> exp
val leu : width -> exp -> exp -> exp
val lobits : width -> width -> exp -> exp
val lt : width -> exp -> exp -> exp
val ltu : width -> exp -> exp -> exp
val minf : width -> exp
val ( mod ) : width -> exp -> exp -> exp
val modu : width -> exp -> exp -> exp
val mul : width -> exp -> exp -> exp
val mulux : width -> exp -> exp -> exp
val mulx : width -> exp -> exp -> exp
val mul_overflows : width -> exp -> exp -> exp
val mulu_overflows : width -> exp -> exp -> exp
val mzero : width -> exp
val ne : width -> exp -> exp -> exp
val neg : width -> exp -> exp
val not : exp -> exp
val ( or ) : width -> exp -> exp -> exp
val pinf : width -> exp
val popcnt : width -> exp -> exp
val pzero : width -> exp
val quot : width -> exp -> exp -> exp
val quot_overflows : width -> exp -> exp -> exp
val rem : width -> exp -> exp -> exp
val rotl : width -> exp -> exp -> exp
val rotr : width -> exp -> exp -> exp
val round_down : exp
val round_nearest : exp
val round_up : exp
val round_zero : exp
val shl : width -> exp -> exp -> exp
val shra : width -> exp -> exp -> exp
val shrl : width -> exp -> exp -> exp
val sub : width -> exp -> exp -> exp
val subb : width -> exp -> exp -> exp -> exp
val sub_overflows : width -> exp -> exp -> exp
val sx : width -> width -> exp -> exp
val unordered : exp
val xor : width -> exp -> exp -> exp
val zx : width -> width -> exp -> exp
@ 
\subsection{C~code to test division rules}
%%
%%There seem to be lots of ways to implement division.
%%Some of them don't work, especially if we are careless about overflow.
%%Here's a useful test program.
<<divtest.c>>=
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

int mosml_div(int x, int y) {
  assert(y != 0);
  if( y < 0 ) { x = - x; y = -y; }
  if( x >= 0 ) { return x / y; }
  else
        { x = - x;
          if( x % y == 0 )
            return - (x /y);
          else
            return - (x / y) - 1;
        }
}

// incorrect 
int simplediv(int x, int y) {
      if( y < 0 ) { x = - x; y = -y; }
      if( x >= 0 )
        { return x / y; }
      else
        { return - (- x + (y - 1)) / y; // can fail because of overflow
        }
}

@ 
%%
<<divtest.c>>=
int njdiv(int x, int y) {
   if (y >= 0) {
     if (x >= 0) {
       return x / y;
     } else {
       return (x+1) / y - 1;
     }
   } else {
     if (x > 0) {
       return (x-1) / y - 1;
     } else {
       return x / y;
     }
   }
}
@ 
%%
<<rewrite.ml>>=
let div2 w ~dst x y =
  let return e = DG.Rtl (R.store dst e w) in
  let one  = O.signed w 1 in
  let zero = O.signed w 0 in
  DG.If (DG.cond (O.ge w y zero),
         DG.If (DG.cond (O.ge w x zero),
                return (O.quot w x y),
                return (O.sub w (O.quot w (O.add w x one) y) one)),
         DG.If (DG.cond (O.gt w x zero),
                return (O.sub w (O.quot w (O.sub w x one) y) one),
                return (O.quot w x y)))
@ 
%%
<<divtest.c>>=
int njfast (int x, int y) {
   if ((x ^ y) >= 0) {
     return x / y;
   } else if (y >= 0) {
     return (x+1) / y - 1;
   } else if (x == 0) {
     return 0;
   } else {
     return (x-1) / y - 1;
   }
}
@
<<rewrite.ml>>=
let div1_3 w ~dst x y =
  let return e = DG.Rtl (R.store dst e w) in
  let one  = O.signed w 1 in
  let zero = O.signed w 0 in
  DG.If (DG.cond (O.ge w (O.xor w x y) zero),
         return (O.quot w x y),
  DG.If (DG.cond (O.ge w y zero),
         return (O.sub w (O.quot w (O.add w x one) y) one),
  DG.If (DG.cond (O.eq w x zero),
         return zero,
         return (O.sub w (O.quot w (O.sub w x one) y) one))))
@ 
%%
<<divtest.c>>=
int m3div (int x, int y) {
  int rem = x % y;
  int quot = x / y;
  if ((x ^ y) < 0 && rem != 0) {
    return quot - 1;
  } else {
    return quot;
  }
}
@
%%
<<rewrite.ml>>=
let div' w ~dst x y ~quot ~rem =
  let return e = DG.Rtl (R.store dst e w) in
  DG.If (DG.cond (O.conjoin (O.lt w (O.xor w x y) (O.signed w 0))
                            (O.ne w rem (O.signed w 0))),
         return (O.sub w quot (O.signed w 1)),
         return quot)
@ 
%%
<<divtest.c>>=
#define nzsign(Y) ((Y) > 0 ? 1 : -1)

// incorrect
int signdiv(int x, int y) {
  if ((x ^ y) >= 0) {
    return x / y;
  } else {
    return (x - (y - nzsign(y))) / y;   // can fail --- overflow
  }
}

// incorrect
int rounddiv(int x, int y) {
  if ((x ^ y) >= 0) {
    return x / y;
  } else if (y < 0) {
    return (x - y - 1) / y; // can fail --- overflow
  } else {
    return (x - y + 1) / y; // can fail --- overflow
  }
}


struct test { int ( * fun)(int, int); const char *name; };

struct test tests[] = {
  { mosml_div, "mosml_div" },
    // { simplediv, "simplediv" },
  { njdiv, "njdiv" },
  { njfast, "njfast" },
  { m3div, "m3div" },
    //  { signdiv, "signdiv" },
    //  { rounddiv, "rounddiv" },
};

int divtest(int x, int y) {
  int i, q;
  int failcount = 0;
  assert(y != 0);

  q = mosml_div(x, y);
  for (i = 0; i < sizeof(tests) / sizeof(tests[0]); i++) {
    int tq = tests[i].fun(x, y);
    printf("%12s(%3d, %3d) == %3d %s\n", tests[i].name, x, y, tq,
           tq == q ? "" : "<====== ERROR");
    if (tq != q) failcount++;
  }
  return failcount;
}

int randtest(unsigned n) {
  int *xs, *ys, i, rc;
  FILE *rand;
  int fails = 0;
  xs = malloc(n * sizeof(*xs));
  ys = malloc(n * sizeof(*ys));
  assert (xs != NULL && ys != NULL);
  rand = fopen("/dev/urandom", "r");
  if (!rand) {
    perror("Cannot open /dev/urandom --- need a Linux box?");
    exit(1);
  }
  rc = fread(xs, sizeof(*xs), n, rand);
  assert(n == rc);
  rc = fread(ys, sizeof(*ys), n, rand);
  assert(n == rc);
  fclose(rand);
  for (i = 0; i < n; i++)
    if (ys[i])
      fails += divtest(xs[i], ys[i]);
  return fails;
}

  

main() {
  int x, y;
  int fails = 0;
  printf("%d\n", njdiv(1606571677, -684103929));
  for (x = -10; x <= 10; x++)
    for (y = -10; y <= 10; y++)
      if (y != 0)
        fails += divtest(x, y);
  fails += randtest(500000);
  if (fails)
    printf("%d failures <====\n", fails);
  else
    printf("All tests passed.\n");
}
@ 
\section{[[front_ir/runtimedata.nw]]}
<<front_ir/runtimedata.ml>>=
<<runtimedata.ml>>
@

<<front_ir/runtimedata.mli>>=
<<runtimedata.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et sts=4
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% inc: \usepackage{alltt}
%%
%%
%%% ------------------------------------------------------------------ 
\section{Collecting and emitting data for the run-time system}
%%% ------------------------------------------------------------------ 
%%The run-time system needs to examine stack frames that are suspended at call
%%sites or at continuations.
%%We refer to these locations collectively as {\em stopping points}.
%%For each stopping point, we emit information to tell the run-time system about
%%the stack frame.
%%
%%The run-time system walks the stack by tracking the boundaries between
%%frames. 
%%Each boundary is set at the \emph{callee's deallocation point}.
%%We set the boundary here because it is resilient to tail calls.
%%Although we work with deallocation points, for ease of writing and
%%naming variables, we call them allocation points.
%%
%%The run-time system needs to know:
%%\begin{itemize}
%%\item the difference between the incoming allocation point and the
%%  frame's virtual frame pointer
%%\item the difference between the outgoing allocation point and the
%%  frame's virtual frame pointer, which is more or less the size of the
%%  frame at the call site
%%  (for a continuation, the continuation's stack pointer plays the role
%%  of the outgoing allocation point),
%%\item the location of the return address,
%%\item the locations of stackdata,
%%\item the locations of values stored in callee-save registers on entry to the procedure,
%%\item the locations of local variables,
%%\item the locations of span data declared in the \pal~source, and
%%\item the locations of unwind continuations (currently unimplemented).
%%\end{itemize}
%%For ease in writing the run-time system, each of the two differences
%%above is represented by the location of the corresponding allocation
%%point. 
%%To pass 
%%such a location to the run-time system, we code it as an offset, which
%%is the difference we require.
%%
%%In order to avoid complications in threading this data through the compiler, 
%%we convert each type of data to spans.
%%Later, when we are ready to emit assembly code (compile-time constants have been
%%computed, etc.), we emit the spans as assembly code.
%%
%%This module hides the representation of data as spans, as well as the encoding
%%of the spans as assembly.
%%The interface of the module provides functions to convert the different types of
%%data to spans and a single function to emit all the spans as assembly.
%%
%%% ------------------------------------------------------------------ 
\subsection{The interface}
%%% ------------------------------------------------------------------ 
%%We expose two types of functions:
%%\begin{itemize}
%%\item Functions that convert data to a span.
%%\item A function that emits the spans as assembly.
%%\end{itemize}
%%The first conversion function takes a user's key and value and produces a span.
%%
%%We need to be able to update spans; sometimes it is easy to update all the spans
%%in the control-flow graph.
<<runtimedata.mli>>=
type spans = Spans.t
exception DeadValue
val upd_spans     : (Rtl.loc -> Rtl.loc) -> spans -> unit   (* may raise DeadValue *)
val upd_all_spans :
    (Rtl.loc -> Rtl.loc) -> Zipcfg.graph -> unit   (* may raise DeadValue *)
@ 
%%The run-time system needs to know how the registers are mapped to constants.
<<runtimedata.mli>>=
type tgt  = Preast2ir.tgt
val print_reg_map : tgt -> unit
@
%%After we have placed all the data in spans, we emit
%%the data as assembly by calling [[emit_as_asm]].
%%The function should be partially applied to an assembler, then added
%%to the optimization pipeline.
<<runtimedata.mli>>=
val emit_as_asm : tgt -> 'a Asm.assembler -> procsym:Symbol.t -> Zipcfg.graph -> unit
@
%%It appears that the interpreter needs to know about user-defined spans and
%%stackdata.
<<runtimedata.mli>>=
val user_spans : spans -> (Bits.bits * Reloc.t) list
val stackdata  : spans -> Rtl.loc list
@ 
%%The compiler can emit data for the run-time system, such as the
%%direction of stack growth.
<<runtimedata.mli>>=
val emit_global_properties : ('a, 'b, Call.t) Target.t -> 'c Asm.assembler -> unit
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Imports, type definitions, and utilities}
%%% ------------------------------------------------------------------ 
%%A number of shorthands are used throughout the implementation.
<<runtimedata.ml>>=
module B  = Bits
module G  = Zipcfg
module GR = Zipcfg.Rep
module CT = Ctypes
module PA = Preast2ir
module RM = Register.Map
module RS = Register.Set
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module W  = Rtlutil.Width
module Dn = Rtl.Dn
module Up = Rtl.Up
module S  = Spans
module T  = Target
module IM = Map.Make (struct type t = int let compare = compare end)

type tgt   = Preast2ir.tgt
type spans = S.t
exception DeadValue

let imposs = Impossible.impossible
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let unimp  = Impossible.unimp

(* Don't touch the user-defined spans -- not necessary *)
let upd_spans upd spans =
  let spans = S.expose spans in
  let maybe_upd l = match l with
    | Some l -> (try Some (upd l) with DeadValue -> None)
    | None   -> None in
  spans.S.inalloc  <- upd spans.S.inalloc;
  spans.S.outalloc <- upd spans.S.outalloc;
  spans.S.ra       <- upd spans.S.ra;
  spans.S.csregs   <- List.map (fun (r,l) -> (r, maybe_upd l)) spans.S.csregs;
  spans.S.conts    <- List.map (fun (pc,sp,vars) -> (pc, upd sp, vars)) spans.S.conts;
  spans.S.sds      <- List.map upd spans.S.sds;
  Array.iteri (fun i l -> spans.S.vars.(i) <- maybe_upd l) spans.S.vars

let upd_all_spans upd g = Zipcfg.iter_spans (upd_spans upd) g
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Mapping data to expressions and emitting emitting spans as assembly}
%%% ------------------------------------------------------------------ 
%%At each stopping point, we emit information to tell the run-time system about
%%the stack frame.
%%We first separate out the spans that are visible throughout a procedure (stackdata).
%%The stackdata spans ([[sd_spans]]) are emitted in a separate table.
%%Then, for each stopping point, we emit the associated spans by calling
%%[[emit_site_spans]].
<<runtimedata.ml>>=
let emit_as_asm (PA.T target) asm ~procsym cfg =
  <<gather the [[spans]] in order>>
  let wordsize   = target.T.wordsize in
  let to_bits  i = Bits.S.of_int i wordsize  in 
  let zero       = Bits.zero wordsize in
  let one        = to_bits 1 in
  <<define functions for emitting data>>
  <<define [[emit_sd_spans]] and [[emit_site_spans]]>>
  let prev_section = asm#current in
  emit_sd_spans ();
  List.iter emit_site_spans spans;
  asm#section prev_section
@
%%Along with each of the spans, we collect the label to which we attach the run-time data.
<<gather the [[spans]] in order>>=
let add_spans (first, _ as b) _ spans =
  let (_, last) = GR.goto_end (GR.unzip b) in
  let add spans (_, lbl) = function Some ss -> (lbl, ss) :: spans | None -> spans in
  let spans = match first with
              | GR.Label (lbl, _, ss) -> add spans lbl (!ss)
              | GR.Entry              -> spans in
  match last with
  | GR.Call { GR.cal_spans = ss; GR.cal_contedges = {G.node = n} :: _ } ->
      add spans n ss
  | _ -> spans in
let spans = List.rev (G.fold_layout add_spans [] cfg) in
@
%%\paragraph{Emitting Stackdata Spans}
%%Stackdata spans have been attached to all the span collections.
%%They should all be identical, so we just pick one.
%%
%%A stackdata map for $n$ stackdata labels is of size $n + 1$ words.
%%The first word gives the number of stackdata labels.
%%The next $n$ words give the stackdata labels in order.
<<define [[emit_sd_spans]] and [[emit_site_spans]]>>=
let sd_label = asm#local (Idgen.label "stackdata") in

let emit_sd_spans () =
  match spans with
  | (_, spans)::_ ->
      let spans = S.expose spans in
      asm#section "pcmap_data";
      asm#label   sd_label;
      asm#value   (Bits.U.of_int (List.length spans.S.sds) target.T.wordsize);
      List.iter   emit_loc spans.S.sds
 | [] -> () in
@
%%\paragraph{Emitting Stopping-Point Spans}
%%For each stopping point, we must emit the information stored in
%%the [[spans]].
%%The information is organized in two distinct areas.
%%The first area is a map from stopping points in the procedure to run-time
%%data associated with the stopping points.
%%The run-time data for each stopping point begins at the label [[frame_label]].
%%This map is placed in the [[pcmap]] section of the assembly code.
%%
%%The second area is the collection of run-time data for each stopping point.
%%This data is placed in the [[pcmap_data]] section of the assembly code.
%%
%%If a stopping point is a call node, its successor is the label we are suspended at;
%%otherwise, we expect the argument node to have a label.
<<define [[emit_sd_spans]] and [[emit_site_spans]]>>=
let emit_site_spans (stop_l, spans) =
  let spans = S.expose spans in
  let frame_label = asm#local (Idgen.label "frame") in
  <<emit proc to run-time data map>>
  <<emit frame data>>
  in
@
%%The first area consist of two consecutive pointers, one to the stopping point
%%and the other to the data associated with the stopping point:
%%\begin{verbatim}
%%.section pcmap
%%+--------------------+
%%| stopping_point_lbl |
%%+--------------------+
%%| frame_data_lbl     |
%%+--------------------+
%%\end{verbatim}
<<emit proc to run-time data map>>=
  asm#section "pcmap";
  asm#addr (Reloc.of_sym (asm#local stop_l, Rtl.codesym) wordsize);
  asm#addr (Reloc.of_sym (frame_label, Rtl.datasym)      wordsize);
@
%%The second area keeps track of the per-PC information.
%%A~picture of
%%the layout appears below;
%%[[L]]~stands for a coded machine location,
%%[[I]]~stands for an integer, 
%%and
%%[[P]]~stands for a pointer (address).
%%\begin{verbatim}
%%.section pcmap_data
%%frame_data_lbl:
%%+--------------------------+
%%| L : incoming dealloc pt  |
%%+--------------------------+
%%| L : outgoing dealloc pt  |
%%+--------------------------+
%%| L : return address       |
%%+--------------------------+
%%| P : stackdata_table      |
%%+--------------------------+
%%| I : num registers        |
%%+--------------------------+
%%| I : num locals           |
%%+--------------------------+
%%| I : num spans            |
%%+--------------------------+
%%| I : cont block size      |
%%+--------------------------+
%%| registers (I : index, L : location) * |
%%+--------------------------+
%%| locals (L : location) *  |
%%+--------------------------+  <--- cont offsets are from here
%%| num continuations        |
%%| cont 1 offset            |
%%|     ...                  |
%%| cont n offset            |
%%| --------------           |
%%| cont 1 block             |
%%|     ...                  |
%%| cont n block             |
%%+--------------------------+
%%| spans                    |
%%+--------------------------+
%%\end{verbatim}
%%
%%We emit each of these blocks in order, beginning with the \PAL\ internal spans.
<<emit frame data>>=
asm#section "pcmap_data";
asm#label frame_label;
emit_loc spans.S.inalloc;
emit_loc spans.S.outalloc;
emit_loc spans.S.ra;
asm#addr (Reloc.of_sym (sd_label, Rtl.datasym) wordsize);
emit_int (List.length (List.filter nonredundant spans.S.csregs));
emit_int (Array.length spans.S.vars);
@
%%The source spans are laid out by index.
%%We start with index~0 and go up to [[max_span_\index]].
%%Because the indices may be sparse, we fill in any gaps with zeroes.
%%Inner spans, which take priority, are placed first by the front end,
%%so we use a stable sort to order the indices.
<<emit frame data>>=
let users =
  let unsorted = List.map (fun (n,e) -> (Bits.S.to_int n,e)) spans.S.users in
  let compare ((n : int), _) ((n' : int), _) = compare n n' in
  List.stable_sort compare unsorted in
let max_span_ix = match users with [] -> -1 | _ :: _ -> fst (Auxfuns.last users) in
let rec emit_spans_from n spans =
  if n <= max_span_ix then
    match spans with
    | (n', e) :: tail when n > n' -> emit_spans_from n tail (* skip duplicate span *)
    | (n', e) :: tail when n = n' -> asm#addr e; emit_spans_from (n+1) tail
    | _                           -> emit_int 0; emit_spans_from (n+1) spans in
@
%%And now, we fill in the rest of the data.
<<emit frame data>>=
emit_int (max_span_ix + 1);
emit_int (size_cont_block spans.S.conts);
List.iter emit_csreg spans.S.csregs;
Array.iter emit_maybe_loc spans.S.vars;
emit_conts spans.S.conts;
emit_spans_from 0 users;
@
%%We cover each section of the frame data in detail.
%%In addition to emitting spans as assembly data, we provide functions
%%to convert each type of data (frame size, register contents, locals, etc.)
%%to spans.
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Conversion to/from spans}
%%% ------------------------------------------------------------------ 
%%We provide conversion functions to store a value in a span,
%%and we provide the functions to emit the expressions in these spans as 
%%assembly.
%%
%%We define functions for emitting two possible types of data in a single word:
%%link-time constants and value locations.
%%A link-time constant can be emitted directly.
%%As a special case, we may encounter a constant false value when we expect a link-time
%%constant.
%%This case indicates that there the value is never used, so we emit 0.
%%
%%A value location, on the other hand, is one of three types: dead, register, or
%%stack offset.
%%We distinguish between the three cases by using the two high bits as tags and using the
%%rest of the word to indicate the value's location.
%%\begin{enumerate}
%%\item Dead --- The value is dead at this point in the procedure.
%%The two high bits are 0b00. Since a dead value has no location, we just emit 0x0.
%%\item Register --- The value is stored in a register.
%%The two high bits are 0b01. Of the remaining $n$ bits, the low $n/2$
%%bits hold an index indicating the register, and the high $n/2$ bits hold an offset into
%%the register (in case the value is not stored in the low bits of the register).
%%\item Offset --- The value is stored on the stack, at a fixed offset from the virtual
%%frame pointer.
%%The high bit is 0b1.
%%The remaining bits store the offset from the virtual frame pointer (in
%%the usual two's-complement representation).
%%\end{enumerate}
%%
%%First, we define a slew of helpers to emit the different types of values.
<<define functions for emitting data>>=
<<define [[simplify_exp]] to simplify rtl expressions>>
let reg_ix (((s,_,_), i, _) as r) =
  try  RM.find r (snd target.T.reg_ix_map)
  with Not_found -> imposs "Register not found in map" in
let emit_dead_loc      () = asm#value zero in
let emit_link_const sym   = asm#addr (Reloc.of_sym sym wordsize) in
let offset_w = wordsize - 1 in
let emit_offset bits = (* possibly an offset *)
  let value    = Bits.S.to_int bits in
  (try ignore (Bits.S.of_int value offset_w)
   with Bits.Overflow -> imposs "Offset from vfp is too large for run-time encoding");
  asm#value (B.Ops.or' (B.Ops.shl  one (to_bits offset_w))
                       (B.Ops.shrl (B.Ops.shl (to_bits value) one) one)) in
let emit_int i = asm#value (Bits.U.of_int i wordsize) in
let emit_reg ix offset =
  let offset_w = wordsize - 2 in
  let w'       = offset_w / 2 in
  (try ignore (Bits.S.of_int ix w'); ignore(Bits.S.of_int offset w')
   with Bits.Overflow -> imposs "Reg ix or offset is too large for run-time encoding");
  asm#value (B.Ops.or' (B.Ops.shl one (to_bits offset_w))
                         (B.Ops.or' (B.Ops.shl (to_bits offset) (to_bits w'))
                                      (to_bits ix))) in
@  
%%Then, we check the type of value (as encoded in the [[Rtl.exp]] type) and emit the
%%value in the proper format.
<<define functions for emitting data>>=
let emit_loc l =
  let mklink kind s w = Up.exp (RP.Const (RP.Link(s, kind, w))) in
  match Dn.loc (simplify_loc l) with
  | RP.Mem (_,_, RP.Const (RP.Link (sym,kind,_)),_)  ->
     emit_link_const (sym, mklink kind)
  | RP.Mem (_,_, RP.Const (RP.Bits bs),_)            -> emit_offset   bs
  | RP.Reg r                                         -> emit_reg  (reg_ix r) 0
  | RP.Slice (_, i, RP.Reg r)                        -> emit_reg  (reg_ix r) i
  | _ -> impossf "unexpected location for span data: %s" (RU.ToString.loc l)  in
let emit_maybe_loc l = match l with
  | Some l -> emit_loc l
  | None   -> emit_dead_loc () in

let nonredundant (reg, l) = match l with
| Some r -> not (RU.Eq.loc (Dn.loc r) (RP.Reg reg))
| None   -> true in

let emit_csreg (reg, l) =
  if nonredundant (reg, l) then
    (emit_int (reg_ix reg); emit_maybe_loc l) in
@
%%To check that the continuation index is within bounds, we first emit the number
%%of unwind continuations.
%%For each continuation, we have:
%%\begin{enumerate}
%%\item A 1-word offset to locate the block.
%%\item 2 words for each variable argument to the continuation.
%%\item A 1-word ``end of variable'' marker.
%%\item A 1-word stack-pointer offset.
%%\item A 1-word return address.
%%\end{enumerate}
<<define functions for emitting data>>=
let size_cont_block conts =
  let n = List.length conts in
  let nvars = List.fold_left (fun rst (_,_,vars) -> List.length vars + rst) 0 conts in
  1 + 2 * nvars + 4 * n in
@
%%We emit the following data in the continuation block:
%%\begin{enumerate}
%%\item The number of continuations.
%%\item The offsets of the continuations.
%%\item The blocks for the continuations.
%%\end{enumerate}
%%The sizes of these blocks are as described above.
<<define functions for emitting data>>=
let emit_conts conts =
  let n = List.length conts in
  emit_int n;
  ignore (List.fold_left (fun offset (_,_,vs) -> emit_int offset;
                                                 offset + 2 * List.length vs + 3)
                         (n+1) conts);
  let emit_cont_block (pc, sp, vars) =
    emit_int (List.length vars);
    asm#addr (Reloc.of_sym (asm#local pc, Rtl.datasym) wordsize);
    emit_loc sp;
    List.iter (fun (h,i,a) -> emit_int i; emit_int (Ctypes.enum_int h)) vars in
  List.iter emit_cont_block conts in
@
%%We provide a function to simplify an expression first by flattening slices such that
%%they consist of a single offset from a location (if applicable), then by calling
%%[[Simplify.exp]] on any expressions.
<<define [[simplify_exp]] to simplify rtl expressions>>=
let simplify_loc loc =
  let vfp     = target.T.vfp in
  let check w = if w mod wordsize <> 0 || w < 0 then
                   unimp (Printf.sprintf "unsupported size or alignment %d" w) in
  let is_vfp_offset e =
    let rec exp e = match e with
      | RP.Fetch (l,_)  -> loc l
      | RP.App (_,exps) -> List.fold_left (fun v e -> v || exp e) false exps
      | RP.Const _      -> false
    and loc l = 
      print_string "TODO: pad: reput Vfp.is_vfp\n";
      if false (* Vfp.is_vfp l  *)
     then true 
     else match l with
      | RP.Mem   (_,_,e,_) -> exp e
      | RP.Slice (_,_,l)   -> loc l
      | _                  -> false in
    exp e in
  let rec flatten offset l = match l with
    | RP.Mem ((_,_,mcell as ms),_,e,ass) when is_vfp_offset e ->
        let w = Rtlutil.Width.exp (Up.exp e) in
        check offset; check w;
        (*V.eprintf verb "Adding an offset %d of width %d\n" offset w;*)
        let e' = Rtlutil.add w (R.app (R.opr "sub" [w]) [Up.exp e; vfp])
                               (R.bits (Bits.S.of_int offset w) w) in
        R.mem (Up.assertion ass) ms (Cell.to_count mcell w) (Simplify.exp e')
    | RP.Mem (ms,w,e,ass) -> (* not a VFP offset *)
        R.mem (Up.assertion ass) ms w (Simplify.exp (Up.exp e))
    | RP.Reg r ->
        let w = Register.width r in
        check w; check offset;
        let l_up = Up.loc l in
        if offset <> 0 then
          R.slice w offset l_up
        else l_up
    | RP.Slice (_,i,l)       -> flatten (offset + i) l
    | RP.Var _ | RP.Global _ -> Up.loc l in
  flatten 0 (Dn.loc loc) in
@
%%It appears that the interpreter needs to know about user-defined spans and
%%stackdata.
<<runtimedata.ml>>=
let user_spans spans = (S.expose spans).S.users
let stackdata  spans = (S.expose spans).S.sds
@
%%The run-time system needs to know how the register are mapped to constants.
<<runtimedata.ml>>=
let print_reg_map (PA.T tgt) =
  let (n, map) = tgt.T.reg_ix_map in
  Printf.printf "Target has %d registers:\n" n;
  RM.iter (fun ((s,_,_),i,_) n -> Printf.printf "  %c[%d] -> %d\n" s i n) map
@
<<runtimedata.ml>>=
let emit_global_properties target (asm:'c Asm.assembler) =
  let cc = Call.get_cc target "C--" in
  let growth = match cc.Call.stack_growth with Memalloc.Up -> 1 | Memalloc.Down -> -1 in
  let wordsize = target.Target.wordsize in
  let memsize  = target.Target.memsize in
  let sym = asm#export "Cmm_stack_growth" in
  asm#section "data";
  asm#align (wordsize / memsize);
  asm#label sym;
  asm#value (Bits.S.of_int growth wordsize)
  

@ 
\section{[[front_ir/talloc.nw]]}
<<front_ir/talloc.ml>>=
<<talloc.ml>>
@

<<front_ir/talloc.mli>>=
<<talloc.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%\begin{quote}\it
%%    Observations and ideas: the [[Single]] module currently has no
%%    clients. Does the implementation of [[Multiple]] be that
%%    complicated? The functions to allocate a temporary take both the
%%    space and the desired width as arguments. It seems, that simple
%%    counter should be enough to create new temporaries. The source for
%%    temporaries could be made part of a target description. This would
%%    simplify the interface because a certain space would imply the width
%%    of that space. --CL (Mon Apr 29 17:36:53 EDT 2002)
%%\end{quote}
%%
%%% ---------------------------------------------------------------- %
\section{Allocator for temporaries}
%%% ---------------------------------------------------------------- %
%%
%%Multiple parts of the compiler may need to allocate temporaries.
%%Here we provide simple allocators for temporaries.
%%The primary variation is in the interfaces.
%%
%%One policy question is whether the client of the allocator should name
%%the temporary space directly or should name the hardware space into
%%which the temporary will eventually be mapped.  We have decided that
%%clients must ask for a specific temporary space, not for a temporary
%%mapping into some hardware space.  Our reasoning is twofold: first, that
%%asking for a hardware space does not specify a location set, and second,
%%that the client is supposed to know all about the temporaries anyway.
%%
%%Type~[[Single.t]] represents an allocator for a single space.  It is a
%%mutable type; its state represents the temporaries that have already
%%been allocated.  [[Single.for_space]] creates a fresh allocator.  The
%%space passed to [[Single.for_space]] must be a temporary space.
%%Functions [[reg]] and [[loc]] provide different interfaces to the
%%allocator.  It may be useful to partially apply [[reg]] to [[t]].
<<talloc.mli>>=
module Single : sig
  type t       (* an allocator for one space -- a mutable type *)

  val for_space : Space.t -> t            (* a fresh allocator *)
  val reg : t -> (*width*) int -> Register.t
  val loc : t -> (*width*) int -> Rtl.loc
end
@ 
%%
%%Type~[[Multiple.t]] represents a group of allocators, one for each
%%temporary space on a machine.  It is a mutable type; its state
%%represents the temporaries that have already been allocated.
%%[[Single.for_spaces]] creates a fresh allocator for each temporary space
%%on the list passed to it.  Non-temporary spaces are ignored, so it is
%%possible to pass a list of \emph{all} spaces.  Functions [[reg]],
%%[[loc]], and [[reg_like]] provide different interfaces to the allocator.
%%It may be useful to partially apply [[reg]] and [[loc]] to~[[t]] and a
%%space.  More interfaces could be added.  It is a checked run-time error
%%to ask for a space that is not a temporary space on the original list.
<<talloc.mli>>=
module Multiple : sig
  type t       (* an allocator for multiple spaces -- a mutable type *)

  val for_spaces : Space.t list -> t            (* a fresh allocator *)
  val reg : char -> t -> (*width*) int -> Register.t
  val loc : t -> char -> (*width*) int -> Rtl.loc
  val reg_like : t -> Register.t -> Register.t
end
@ 
%%
%%% ---------------------------------------------------------------- %
\subsection{Implementation}
%%% ---------------------------------------------------------------- %
%%
<<talloc.ml>>=
open Nopoly

module S = Space
<<auxiliaries(talloc.nw)>>
module Single = struct
  type t = ((*width*)int -> Register.t) * ((*width*)int -> Rtl.loc)
        
  let for_space space =
    let next = ref 1 in
    let (_, _, cell) = space.S.space in
    let to_count = Cell.to_count cell in
    (fun width ->
      <<use [[width]] to make [[k]] be the next index, updating [[next]]>>
      (space.S.space, k, to_count width)),
    (fun width ->
      <<use [[width]] to make [[k]] be the next index, updating [[next]]>>
      Rtl.reg (space.S.space, k, to_count width))

  let _ = (for_space : Space.t -> t)

  let reg (reg, _) = reg
  let loc (_, loc) = loc
end
@ 
%%
<<use [[width]] to make [[k]] be the next index, updating [[next]]>>=
let () = if not (existsEq width space.S.widths) then
           Impossible.impossible ("Asked for temporary in space `" ^
                                  space.S.doc ^ "' with unsupported width " ^
                                  string_of_int width) in
let Cell.C n = to_count width in
let k = !next in
let _ = next := k + n in
@ 
%%
<<auxiliaries(talloc.nw)>>=
let existsEq v =
  let rec exists = function
  | [] -> false
  | h :: t -> h = v || exists t
  in exists
@ 
<<talloc.ml>>=
module Multiple = struct
  let fail c =
    prerr_string ("Space '" ^ Char.escaped c ^ "' is not a temporary space\n");
    flush stderr;
    assert false

  let is_temp s = match s.S.classification with
  | S.Temp _ -> true
  | _ -> false

  type t = char -> Single.t

  let for_spaces spaces =
    List.fold_right
      (fun s rest ->
         if is_temp s then
           let a = Single.for_space s in
           let named_by (c', _, _) c = c =<= c' in
           fun c -> if named_by s.S.space c then a else rest c
         else
           rest)
      spaces fail

  let _ = (for_spaces : Space.t list -> t)

  let reg c t = Single.reg (t c)
  let loc t c = Single.loc (t c)

  let reg_like (t:t) ((c, _, ms) as _space, _, ct) =
    Single.reg (t c) (Cell.to_width ms ct)
end
@ 
%%This bit of cleverness may get the compiler to optimize division using
%%right shifts.  If not, we could write the right shifts ourselves.
%%I have absolutely no business pulling stunts like this!
<<auxiliaries(talloc.nw)>>=
let divideby = function
  | 32 -> fun n -> n / 32
  | 8  -> fun n -> n / 8
  | 64 -> fun n -> n / 64
  | m  -> fun n -> n / m
@ 
%%  
\section{[[front_ir/typecheck.nw]]}
%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et:
%%
%%% ------------------------------------------------------------------ 
\section{Type Checker for the Control-Flow Graph}
%%% ------------------------------------------------------------------ 
%%
%%The control-flow graph (\cfg) of a procedure contains {\rtl}s. This
%%module provides a stage for the compiler's backplane that allows to
%%check the types of all {\rtls}.
%%
%%To embed the function into the back plane it takes a procedure as
%%argument. The embedding into Lua is handled by the \module{lualink}
%%module.
<<typecheck.mli>>=
val proc: Ast2ir.proc -> unit
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation simply pieces together functionality: module
%%\module{rtldebug.nw} provides type checking, and module \module{zipcfg.nw}
%%traversal of a {\cfg}.
<<typecheck.ml>>=
let rtl =
  fun rtl ->
    try
      Rtldebug.typecheck rtl
    with
      Rtldebug.TypeCheck r ->
        Printf.eprintf "Ill-typed RTL %s\n" (Rtlutil.ToUnreadableString.rtl rtl)

let proc (cfg, p) = Zipcfg.iter_rtls rtl cfg
@

\chapter{[[assembler]]}

\section{[[assembler/astasm.nw]]}
<<assembler/astasm.ml>>=
<<astasm.ml>>
@

<<assembler/astasm.mli>>=
<<astasm.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 et sw=4 sts=4
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{{\PAL} Assembler}
%%% ------------------------------------------------------------------ 
%%
%%This is an assembler that emits {\PAL}. It implements the
%%[[Asm.assembler]] interface for assemblers in the {\qcc} compiler.
%%
%%Since {\PAL} has no natural \emph{native pointer size} like assemblers
%%for real machines it receices a functor argument of type [[PERSONALITY]]
%%that defines the size of pointers and words. 
%%THIS SEEMS BOGUS, AS NOW IT IS POSSIBLE TO CONVERT TO AST ONLY IF THE
%%INPUT PROGRAM MATCHES THE COMPILED-IN TARGET.  THE TARGET SHOULD BE A
%%DYNAMIC PARAMETER.
<<PERSONALITY>>=
module type PERSONALITY = sig
    val wordsize:       int
    val pointersize:    int
    val memsize:        int
    val byteorder:      Rtl.aggregation
    val float:          string
    val charset:        string
    type proc
    val cfg2ast : proc -> Ast.proc
end
@
%%The assembler constructor receices the output channel for the assembler. 
<<S(astasm.nw)>>=
module type S = sig
    type proc
    val asm: out_channel -> proc Asm.assembler
end    
@ 
%%
<<astasm.mli>>=
<<PERSONALITY>>
<<S(astasm.nw)>>
module Make(P: PERSONALITY): S with type proc = P.proc
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation provides no surprises. It builds up an {\AST} and
%%emits it to [[stdout]] when the [[emit]] method is called.
<<astasm.ml>>=
module T        = Target
module A        = Ast
module Asm      = Asm

<<PERSONALITY>>
<<S(astasm.nw)>>
module Make (P: PERSONALITY): S with type proc = P.proc = struct
    type proc = P.proc
    <<Make(astasm.nw)>>
end
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Auxilliaries}
%%% ------------------------------------------------------------------ 
%%
<<Make(astasm.nw)>>=
let pointer     = A.BitsTy(P.pointersize)
let bits n      = A.BitsTy n
let int n       = A.Sint( string_of_int n, Some (bits P.wordsize))
let one         = int 1 (* wordsize *)
let zero        = A.Sint( "0" , Some (bits P.memsize)) (* memsize *)

exception Unsupported of string
let unsupported msg = raise (Unsupported msg)
type reloc = Reloc.t
@
%%% ------------------------------------------------------------------ 
%%\subsubsection{Name Mangling}
%%% ------------------------------------------------------------------ 
%%
%%Since we emit {\PAL} code we have to make sure that symbols respect the
%%{\PAL} naming conventions. The \module{mangle} module provides name
%%mangling support. To highlight the destinction between names and symbols
%%we prefix every symbol with [[sym]].
<<Make(astasm.nw)>>=
let spec =
    let reserved =
        [ "aborts"; "align"; "aligned"; "also"; "as"; "big"; "byteorder";
        "case"; "const"; "continuation"; "cut"; "cuts"; "else"; "equal";
        "export"; "foreign"; "goto"; "if"; "import"; "invariant"; "jump";
        "little"; "memsize"; "pragma"; "register"; "return"; "returns";
        "section"; "semi"; "span"; "stackdata"; "switch"; "target"; "targets";
        "to"; "typedef"; "unicode"; "unwinds"; "float"; "charset";
        "pointersize"; "wordsize"]
    in
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '.' 
        | '_' 
        | '$' 
        | '@'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '@' 
        in    
            { Mangle.preprocess = (fun x -> "sym:"^x)  
            ; Mangle.replace    = replace
            ; Mangle.reserved   = reserved
            ; Mangle.avoid      = (fun x -> x ^ "$")
            }
@
%%% ------------------------------------------------------------------ 
%%\subsubsection{Relocatable Addresses}
%%% ------------------------------------------------------------------ 
%%
%%Relocatable addresses come in a generic format. We have to provide a
%%translation into the {\PAL} abstract syntax. A relocatable address has
%%the same width as a pointer.
<<Make(astasm.nw)>>=
let reladdr (a:reloc) =
  let const b = Rtlutil.ToAST.expr (Rtl.bits b (Bits.width b)) in
  let sym (s,_) = A.Fetch (A.Name(None,s#mangled_text,None)) in
  let binop op l r = A.BinOp(l, op, r) in
  Reloc.fold ~const ~sym ~add:(binop "+") ~sub:(binop "-") a
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{The assembler class}
%%% ------------------------------------------------------------------ 
%%
%%The assembler maintains mutable state for:
%%
%%\begin{itemize}
%%\item the actual section the assembler is in,
%%\item exported symbols,
%%\item imported symbols,
%%\item completed sections in reverse order,
%%\item declarations in the current section in reverse order.
%%\end{itemize}
%%
%%Most methods append a declaration to the current section---[[append]]
%%provides a private method for this.
%%
%%The [[init]] argument for the constructor provides a chance to open a
%%file or similar. We don't use it at the momement.
%%
<<Make(astasm.nw)>>=
type init  = unit

class asm (fd:out_channel): [proc] Asm.assembler = 
object (this)
    val         _fd       = fd
    val mutable _section  = "this can't happen"
    val mutable _exported = Strutil.Set.empty
    val mutable _imported = Strutil.Set.empty
    val mutable _toplevel = ([]: (string * A.section list) list) (* rev'ed *)
    val mutable _actions  = ([]: A.section list) (* reversed *)                
    val         _mangle   = Mangle.mk spec

    method globals n = ()  (* probably could do better here... *)

    (* We put every top-level thingie into its own section. This helps
       the pretty printer. For John Dias *)
    method private append (a:A.section) =
        _toplevel <- (_section, [a]) :: _toplevel

    (* declare symbols *)
    method import s =
        ( _imported <- Strutil.Set.add s _imported
        ; Symbol.with_mangler _mangle s
        )
        
    method export s =
        ( _exported <- Strutil.Set.add s _exported
        ; Symbol.with_mangler _mangle s
        )
        
    method local  s = 
        Symbol.with_mangler _mangle s

    (* sections *)
    (* section closes the current section and adds it to toplevel. It is
       dropped in case it is empty. *)
    method section s = 
        ( match _actions with [] -> ()
        | _ :: _ -> _toplevel <- (_section, List.rev _actions) :: _toplevel 
        )    
        ; _section <- s
        ; _actions <- []

    method current = 
        _section
            
    (* define symbols *)        
    method label (s: Symbol.t) = 
        this#append (A.Datum(A.Label s#mangled_text))
    
    method const (s: Symbol.t) (b:Bits.bits) =
        let i = Printf.sprintf "0x%Lx" (Bits.U.to_int64 b) in 
        let bits = A.Uint(i,Some (bits (Bits.width b))) in
        this#append (A.Decl(A.Const(None,s#mangled_text,bits)))

    (* set location counter *)
    method org n =
        unsupported "no location counter in this implementation"

    method align n =
        this#append (A.Datum(A.Align n))

    method  addloc n = 
        let memsize = P.memsize in
        let ty      = bits memsize            in
        let size    = int n                   in
            this#append (A.Datum(A.MemDecl(ty,A.FixSize(size),None)))

    method longjmp_size () =
      Impossible.unimp "longjmp size not set for AST -- needed for alternate returns"

    (* instructions *)
    method cfg_instr (proc:proc) = 
            this#append (A.Procedure(P.cfg2ast proc))

    

    (* emit data *)
    method zeroes (n:int) =
        let ty      = bits P.memsize in
        let size    = int n                   in
        let rec z   = function
            | 0 -> []
            | n -> zero :: z (n-1)            in
        let _init n  = Some(A.InitExprs(z n))  in
        let init n  = None in (* fix for John's problem with SPEC benchmarks *)
            if n > 0 then
                this#append (A.Datum(A.MemDecl(ty,A.FixSize(size),init n)))
            else
                ()
    
    method value (v:Bits.bits) = 
        let ty   = bits (Bits.width v)              in
        let i    = Printf.sprintf "0x%Lx" (Bits.U.to_int64 v) in
        let init = A.InitExprs([A.Uint(i, Some ty)]) in
            this#append (A.Datum(A.MemDecl(ty, A.FixSize one, Some init)))
            
    method addr (a: reloc) = 
        let ty   = bits (Reloc.width a) in
        let init = A.InitExprs([reladdr a]) in
            this#append (A.Datum(A.MemDecl(ty, A.FixSize one, Some init)))

    (* the AST has comments only at the statement level. However, we are 
    outside procedures here and thus cannot issue a comment. Should this
    method call unsupported()? *)

    method comment s = ()

    method private imports =
        match Strutil.Set.elements _imported with
        | []    -> None
        | names -> Some (A.Import( Some (A.BitsTy P.pointersize)
                                 , List.map (fun n -> None, n) names
                                 ))

    method private exports =
        match Strutil.Set.elements _exported with
        | []    -> None
        | names -> Some (A.Export( Some pointer
                                 , List.map (fun n -> n, None) names
                                 )) 
    
    (* Advertise pointer sizes and such for this assembler *)

    method private personality =
        [ A.Memsize P.memsize
        ; ( match P.byteorder with
          | Rtl.BigEndian    -> A.ByteorderBig
          | Rtl.LittleEndian -> A.ByteorderLittle
          | _                -> assert false
          )
        ; A.PointerSize P.pointersize
        ; A.WordSize    P.wordsize
        ; A.Charset     P.charset
        ; A.FloatRepr   P.float
        ]
    
    (* emit takes the declarations in toplevel and completes them to a
       C-- program. Imports and exports are announced according to the
       names registered in _imported, _exported *)

    method emit = 
        let target   = A.TopDecl(A.Target this#personality)  in 
        let section  = (_section, List.rev _actions)    in
        let toplevel = List.rev (section :: _toplevel) in
        let sections = List.map (fun (name,sect) -> A.Section(name,sect))
                                toplevel                in
        let ast      = match this#imports, this#exports with
            | None  , None   -> target :: sections
            | Some i, None   -> target :: A.TopDecl(i) :: sections
            | None  , Some e -> target :: A.TopDecl(e) :: sections
            | Some i, Some e -> target :: A.TopDecl(i) :: A.TopDecl(e) 
                             :: sections in
        Astpp.emit _fd 72 ast
end    
@
%%
%%% ------------------------------------------------------------------ 
\section{Assember Constructor Function}
%%% ------------------------------------------------------------------ 
%%
<<Make(astasm.nw)>>=
let asm fd = new asm fd
@
\section{[[assembler/cfgutil.nw]]}
<<assembler/cfgutil.ml>>=
<<cfgutil.ml>>
@

<<assembler/cfgutil.mli>>=
<<cfgutil.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{Control-Flow Graph Utilities}
%%% ------------------------------------------------------------------ 
%%
%%The \module{zipcfg} module provides the essential functionality for
%%control-flow graphs ({\cfg}s). In order to separate essential
%%functionality from nice-to-have functionality this module provides
%%additional functions on {\cfg}s whose implementation do not require
%%knowledge of the internal details of \module{zipcfg}.
<<cfgutil.mli>>=
val cfg2dot : compress:bool -> live:bool -> name:string -> Zipcfg.graph -> string
val cfg2ast : (Rtl.rtl -> Ast.stmt) -> Zipcfg.graph -> name:string -> Ast.proc
val emit    : Ast2ir.basic_proc -> Zipcfg.graph ->
                (Zipcfg.Rep.call -> unit) -> (Rtl.rtl -> unit) ->
                (string -> unit) -> unit
val block_name : Zipcfg.graph -> Zipcfg.uid -> string
val print_cfg: Zipcfg.graph -> unit
val pr_first : Zipcfg.Rep.first  -> unit
val pr_mid   : Zipcfg.Rep.middle -> unit
val pr_last  : Zipcfg.graph -> Zipcfg.Rep.last -> unit
val pr_last' : Zipcfg.Rep.last -> unit

type node = F of Zipcfg.Rep.first | M of Zipcfg.Rep.middle | L of Zipcfg.Rep.last
val numbered_layout_nodes : Zipcfg.graph -> (int * node) list
(* val delete : Zipcfg.zgraph -> Zipcfg.graph --- delete focus *)
@
%%WHAT DO [[cfg2ast]] AND [[emit]] DO? PLEASE EXPLAIN THE PARAMETERS. --CL
%%\begin{itemize}
%%\item [[limit]], [[first]]: node numbers for {\cfg} traversing functions 
%%      in \module{cfg3}.
%%      
%%\item [[fold_fwd]], [[fold_bwd]]: work as their counterparts in [[Cfg]]
%%      except that they cover the entire {\cfg}. Note, that the [[cfg]]'s
%%      nodes must be enumerated.
%%
%%\item [[subst]] substitutes {\rtl}s in all nodes of a [[cfg]].       
%%
%%\item [[cfg2dot]]: returns a {\cfg} in the \textsc{dot} input language.
%%       The parameter [[compress]] tells \texttt{dot} to compress the
%%      output graph to fit on one sheet of paper (\texttt{ratio=compress}).
%%
%%\item [[emit]]: Fold over {\cfg} in enumeration order and pass {\rtl}s
%%      and symbols to the provided functions. Enumerates the {\cfg} if it is
%%      not already enumerated.
%%
%%\item [[find_join_node]]: Find the join node with the given label, or return
%%      the illegal node if no such node can be found.
%%\end{itemize}
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<cfgutil.ml>>=
module A  = Ast 
module DG = Dag
module G  = Zipcfg
module GR = Zipcfg.Rep
module OG = Cfgx.M 
module P  = Proc
module PA = Preast2ir
module T  = Target
module UM = Unique.Map 
@
<<cfgutil.ml>>=
let block_name g uid =
  try
    (match UM.find uid (G.to_blocks g) with
    | GR.Entry, _ -> "<entry>"
    | GR.Label ((_, l), _, _), _ -> l)
  with Not_found -> "<unknown-uid>"
@
<<cfgutil.ml>>=
let pr = Printf.eprintf
let pr_first = function
  | GR.Entry -> pr "<entry>\n"
  | GR.Label ((_, l), _, _) -> pr "%s:\n" l
let pr_mid m = match m with
  | GR.Instruction  r
  | GR.Stack_adjust r -> pr "%s\n" (Rtlutil.ToString.rtl r)
let lasttype = function
  | GR.Exit        -> "exit"
  | GR.Branch    _ -> "branch"
  | GR.Cbranch   _ -> "cbranch"
  | GR.Mbranch   _ -> "mbranch"
  | GR.Call      _ -> "call"
  | GR.Cut       _ -> "cut"
  | GR.Return    _ -> "return"
  | GR.Jump      _ -> "jump"
  | GR.Forbidden  _ -> "forbidden"
let pr_last g l =
  let succ_names l = String.concat " " (List.map (block_name g) (GR.succs l)) in
  pr "<%s> %s [%s]\n" (lasttype l) (Rtlutil.ToString.rtl (GR.last_instr l))
                      (succ_names l)
let pr_last' l =
  pr "<%s> %s\n" (lasttype l) (Rtlutil.ToString.rtl (GR.last_instr l))
let print_block g (first, tail) =
  pr_first first;
  let rec pr_tail = function
    | GR.Tail (m, tail) ->
        pr_mid m; pr_tail tail
    | GR.Last GR.Exit -> pr "<exit>\n"
    | GR.Last l -> pr_last g l in
  pr_tail tail

let print_cfg g =
  let () = Printf.eprintf "\nBEGIN CFG\n" in
  let () =
    try List.iter (print_block g) (G.postorder_dfs g)
    with Not_found -> Unique.Map.iter (print_block g) (G.to_blocks g) in
  let () = Printf.eprintf "END CFG\n" in
  flush stderr
@
%%
<<cfgutil.ml>>=
let matches next = match next with
| None -> (fun _ -> false)
| Some (u, l) -> (fun (u', l') -> Unique.eq u u')

let emit proc cfg call_emit rtl_emit sym_emit =
  let PA.T tgt = proc.P.target in
  let rec seq_emit = function  (* emit sequence of RTLs only *)
    | DG.Rtl r -> rtl_emit r
    | DG.Seq (a, b) -> seq_emit a; seq_emit b
    | DG.Nop -> ()
    | DG.If _ | DG.While _ -> Impossible.impossible "expected linear code sequence" in
  let block b next () =
    let first f () = match f with
    | GR.Entry -> ()
    | GR.Label ((_, l), _, _) -> sym_emit l in
    let middle m () =
      if GR.is_executable m then
        rtl_emit (GR.mid_instr m) in
    let last l () = match l with
    | GR.Branch (_, tgt) when matches next tgt -> ()
    | GR.Cbranch (_, ttgt, ftgt) when not (matches next ftgt) ->
        rtl_emit (GR.last_instr l);
        let (b, r) = tgt.T.machine.T.goto.T.embed proc (proc.P.exp_of_lbl ftgt) in
        seq_emit b;
        rtl_emit r
    | GR.Call c -> call_emit c
    | _ -> rtl_emit (GR.last_instr l) in
    GR.fold_fwd_block first middle last b () in
  G.fold_layout block () cfg
@ 
%%
<<cfgutil.ml>>=
let extend_with preds nodes =
  let rec add_predecessors visited candidates = match candidates with
  | [] -> visited
  | node :: candidates ->
      if List.exists (OG.eq node) visited then
        add_predecessors visited candidates
      else
        add_predecessors (node :: visited) (preds node @ candidates) in
  add_predecessors nodes (List.flatten (List.map preds nodes))

type node = F of GR.first | M of GR.middle | L of GR.last

let numbered_layout_nodes g =
  let add_block (f, t) next (i, nodes') =
    let (i, nodes') = (i+1, (i, F f) :: nodes') in
    let is_next (u', _) = match next with
    | Some (u, _) -> Unique.eq u u'
    | None -> false in
    let rec tail t (i, nodes') = match t with
    | GR.Tail (m, t) -> tail t (i+1, (i, M m) :: nodes')
    | GR.Last (GR.Branch (_, lbl)) when is_next lbl -> (i, nodes') 
    | GR.Last l      -> (i+1, (i, L l) :: nodes') in
    tail t (i, nodes') in
  let _, nodes' = G.fold_layout add_block (0, []) g in
  List.rev nodes'

let id_matches u = function
  | F GR.Entry -> Unique.eq u GR.entry_uid
  | F (GR.Label ((u', _), _, _)) -> Unique.eq u u'
  | L _ | M _ -> false

let cfg2dot ~compress ~live ~name g =
  let () = if live then assert false in
  let nodes = numbered_layout_nodes g in
  let number u = fst (List.find (fun (i, n) -> id_matches u n) nodes) in
  let spr = Printf.sprintf in
  let number_and_rtl (n, node) =
    let instr rtl = spr "N%d: %s" n (Rtlutil.ToString.rtl rtl) in
    match node with
    | F GR.Entry -> "Entry"
    | F (GR.Label ((_, l), _, _)) -> spr "N%d: %s" n l
    | M m -> instr (GR.mid_instr m)
    | L GR.Exit -> "Exit" 
    | L l -> instr (GR.last_instr l) in
  let dotnode node = spr "N%d [label=%S]" (fst node) (number_and_rtl node) in
  let edge_fwd from to' =
    let edge = spr "N%d -> N%d" from to' in
    if live then
      (* edge ^ "[label=\"" ^ Register.SetX.to_string (L.live_in to') ^ "\"]\n" *)
      assert false
    else
      edge ^ "\n" in
  let _edge_bwd from to' = spr "N%d -> N%d [dir=back,style=dotted]\n" to' from in
  let edges_leaving node tail = match snd node with
  | F _ | M _ -> edge_fwd (fst node) (fst node + 1) :: tail
  | L last ->
    let add_edge dir edges u = dir (fst node) (number u) :: edges in
    let tail = List.fold_left (add_edge edge_fwd) tail (GR.succs last) in
    tail in
  let oldv = Rtlutil.ToAST.verbosity Rtlutil.ToAST.Low in
  let openg  = "digraph " ^ name ^ " {\n" in
  let closeg = "}\n" in
  let pagesize = "  page=\"8,10.5\"\n" in
  let compress = if compress then "  ratio=compress\n" else "" in
  let body = List.fold_right (fun n t -> edges_leaving n t)      nodes [closeg] in
  let body = List.fold_right (fun n t -> dotnode n :: "\n" :: t) nodes body     in
  let _ = Rtlutil.ToAST.verbosity oldv in
  String.concat "" (openg :: pagesize :: compress :: body)
@
<<cfgutil.ml>>=
let cfg2ast instr g ~name =
  let block b next prev' =
    let mid n prev' = instr (GR.mid_instr n) :: prev' in
    let first n prev' = match n with
    | GR.Label (l,_,_) -> A.LabelStmt (snd l) :: prev'
    | GR.Entry -> prev' in
    let last n prev' = match n with
    | GR.Exit -> A.CommentStmt "exit node!" :: prev'
    | GR.Branch (_, lbl) when matches next lbl -> prev'
    | GR.Forbidden _ -> A.CommentStmt "forbidden to reach this point" :: prev'
    | _ -> instr (GR.last_instr n) :: prev' in
    let rec tail t prev' = match t with
    | GR.Last l -> last l prev'
    | GR.Tail (m, t) -> tail t (mid m prev') in
    let (f, t) = b in
    tail t (first f prev') in
  let oldv = Rtlutil.ToAST.verbosity Rtlutil.ToAST.Low in
  let stmts' = G.fold_layout block [] g in
  let _ = Rtlutil.ToAST.verbosity oldv in
    ( None
    , name
    , []
    , List.rev_map (fun s -> Ast.StmtBody s) stmts'
    , Srcmap.null
    )
@ 
<<old cfgutil.ml>>=
let delete g n =
  <<replace focus with empty subgraph>>
@
\section{[[assembler/dotasm.nw]]}
<<assembler/dotasm.ml>>=
<<dotasm.ml>>
@

<<assembler/dotasm.mli>>=
<<dotasm.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% ------------------------------------------------------------------ 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
\section{Assembler Interface to DOT}
%%% ------------------------------------------------------------------ 
%%
%%This module implements an assembler that emits every procedure as a
%%graph in \textsc{dot} format. The assember constructor receives the
%%output channel for the assembler.
<<dotasm.mli>>=
val asm : compress:bool -> live:bool -> out_channel -> Ast2ir.proc Asm.assembler
@                      
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%Most assembler directives do nothing. We are only interested in the
%%control-flow-graphs that are part of an instruction. 
<<dotasm.ml>>=
module Asm = Asm

exception Unsupported of string
let unsupported msg = raise (Unsupported msg)

<<Make(dotasm.nw)>>
let asm ~compress ~live fd = new asm (Cfgutil.cfg2dot ~compress ~live) fd
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Name Mangling}
%%% ------------------------------------------------------------------ 
%%
%%We have to make sure that emitted names conform to {\small DOT}'s
%%syntax. The [[spec]] below allows to create a name mangler that ensures
%%this.
%%
<<Make(dotasm.nw)>>=
let spec =
    let reserved = [] in
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '_'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '_' 
        in    
            { Mangle.preprocess = (fun x -> x)  
            ; Mangle.replace    = replace
            ; Mangle.reserved   = reserved
            ; Mangle.avoid      = (fun x -> x ^ "_")
            }
@
%%
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{The assembler class}
%%% ------------------------------------------------------------------ 
%%
<<Make(dotasm.nw)>>=
class ['proc] asm cfg2dot (fd:out_channel) : ['proc] Asm.assembler =
object (this)
    val mutable _section = "this can't happen"

    (* declarations *)
    method import s = Symbol.unmangled s
    method export s = Symbol.unmangled s
    method local  s = Symbol.unmangled s

    method globals n = ()

    (* sections *)
    method section s = 
      print_string "pad: Dotasm.section\n";
      _section <- s
    method current   = 
      print_string "pad: Dotasm.current\n";
      _section

    (* definitions *)
    method label s   = ()
    method const s b = ()

    (* locations *)

    method org n    = ()
    method align n  = ()
    method addloc n = ()

    method longjmp_size () =
      print_string "pad: Dotasm.XXX\n";
      Impossible.unimp "longjmp size not set for dot -- needed for alternate returns"

    (* instructions *)
    method cfg_instr (proc : 'proc) =
      print_string "pad: Dotasm.cfg_instr\n";
      let (cfg, proc) = proc in
      let s   = proc.Proc.symbol in
      let mangle  = Mangle.mk spec in
      output_string fd (cfg2dot ~name:(mangle s#mangled_text) cfg)

    method zeroes n = ()
    method value v = ()
    method addr  a = ()
    method comment s = ()
    method emit = ()
end


@ 
\section{[[assembler/dummyasm.nw]]}
<<assembler/dummyasm.ml>>=
<<dummyasm.ml>>
@

<<assembler/dummyasm.mli>>=
<<dummyasm.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% ------------------------------------------------------------------ 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: E Peripheral Label
\section{Dummy Assembler}
%%% ------------------------------------------------------------------ 
%%
<<dummyasm.mli>>=
val asm : unit Asm.assembler
@                      
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<dummyasm.ml>>=
module Asm = Asm

let debug s = prerr_string ("Dummyasm." ^ s ^ "\n")

<<Make(dummyasm.nw)>>
let asm = new asm ()
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{The assembler class}
%%% ------------------------------------------------------------------ 
%%
<<Make(dummyasm.nw)>>=
class ['proc] asm () : ['proc] Asm.assembler =
object (this)

    (* declarations *)
    method import s = 
      debug "import";
      Symbol.unmangled s
    method export s = 
      debug "export";
      Symbol.unmangled s
    method local  s = 
      debug "local";
      Symbol.unmangled s

    method globals n = 
      debug "globals";
      ()

    (* sections *)
    method section s = 
      debug "section";
      ()
      
    method current   = 
      debug "current";
      "TODO"

    (* definitions *)
    method label s   = 
      debug "label";
      ()
    method const s b = 
      debug "const";
      ()

    (* locations *)

    method org n    = 
      debug "org";
      ()
    method align n  = 
      debug "align";
      ()
    method addloc n = 
      debug "addloc";
      ()

    method longjmp_size () =
      debug "longjmp_size";
      failwith "longjmp_size"

    (* instructions *)
    method cfg_instr (proc : 'proc) =
      debug "cfg_instr"

    method zeroes n = 
      debug "zeroes";
      ()
    method value v = 
      debug "value";
      ()
    method addr  a = 
      debug "addr";
      ()
    method comment s = 
      debug "comment";
      ()
    method emit = 
      debug "emit";
      ()
end


@ 
\section{[[assembler/mangle.nw]]}
<<assembler/mangle.ml>>=
<<mangle.ml>>
@

<<assembler/mangle.mli>>=
<<mangle.mli>>
@

%%
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% l2h substitution dots ...
%%% l2h substitution ast AST
%%% l2h substitution rtl RTL
%%% l2h substitution ir IR
%%% l2h substitution noweb NOWEB
%%% l2h substitution qcc QC--
%%% l2h substitution C C--
%%% l2h substitution PAL C--
%%% l2h substitution pal C--
%%% l2h substitution asdl ASDL
%%% l2h substitution ocaml OCaml
%%% l2h substitution forall forall
%%% l2h macro module 1 <a href="#$1.html"><tt>#1.nw</tt></a>
%%
%%% l2h substitution mapsto ->
%%% l2h substitution cup +
%%% l2h substitution not not
%%% l2h substitution gets <-
%%% l2h substitution dom dom
%%
%%
%%
%%% ------------------------------------------------------------------ 
\section{Name Mangling}
%%% ------------------------------------------------------------------ 
%%
%%An assembler of signature [[Asm.S]] accepts any name to register a
%%symbol for. If the name does not comply with the syntax the assembler is
%%interfacing to it must transform a given name to make it comply. This
%%module offers a framework for such name mangling.
%%
%%From the outside, a [[mangler]] is simple:  is takes a name and returns
%%a name.  Because a [[mangler]] remembers the mapping for past names, the
%%same name is always mapped to the same symbol.  Otherwise it takes care
%%of the specific needs of the assembler at hand.
%%
<<mangle.mli>>=
type t = string -> string
@
%%
%%The characteristics of symbols of an assembler are captured by a
%%[[spec]] value.  In implements a number of tactics to create new names
%%from names:
%%
<<mangle.mli>>=
type spec   = { preprocess:  string -> string
              ; replace:     char -> char
              ; reserved:    string list
              ; avoid:       string -> string
              }
@
%%
%%\begin{enumerate}
%%\item A name is first [[preprocess]]'ed in some unspecified way. This might
%%      include limiting its length, or removing some prefix.
%%
%%\item In the resulting name illegal characters are [[replaced]] by
%%      legal characters. 
%%
%%\item If the resulting name is a [[reserved]] name this collision is
%%      resolved by passing it repeatedly to [[avoid]]. 
%%\end{enumerate}
%%
%%We create a new mangler by supplying a specification [[spec]] to [[mk]]:
%%
<<mangle.mli>>=
val mk:         spec -> t     (* create a mangler *)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation is fairly imperative, although this is mostly
%%hidden to clients (except for the memory of used mappings).  But first
%%things first:  here are the types and modules declared in the
%%interface, which provide no surprises.
%%
<<mangle.ml>>=
type strset         = Strutil.Set.t
type strmap         = (string,string) Hashtbl.t

type t              = string -> string
type spec           = { preprocess:  string -> string
                      ; replace:     char -> char
                      ; reserved:    string list
                      ; avoid:       string -> string
                      }
@
%%
%%A [[mangler]] must maintain some state: the set of used names, and the
%%map of names to new names.                       
%%
<<mangle.ml>>=
type state          = { mutable used: strset
                      ; map:          strmap (* is also mutable *)
                      }
@
%%
%%                      
%%All reseved names are simply added to the set of used names to make sure
%%they are never used for a name. If a name can not be found in
%%[[state.map]] it must be mangled and the new mapping together with the
%%new name are recorded in the mutable state.
%%
<<mangle.ml>>=
let mk spec =
    let state    = { used = Strutil.Set.empty
                   ; map  = Hashtbl.create 997 (* initial size *)
                   } 
    in
    
    let rec avoid s  =
            if   Strutil.Set.mem s state.used 
            then avoid (spec.avoid s)
            else s 
    in

    let newMangle s =
        let s'   = String.copy (spec.preprocess s) in
        let _    = for i = 0 to (String.length s') - 1 do
                     String.set s' i (spec.replace (String.get s' i))
                   done in
        let s'   = avoid s' in
            ( state.used <- Strutil.Set.add s'   state.used
            ; Hashtbl.add state.map s s' 
            ; s'
            )
    in         
    let mangle s = 
        try  Hashtbl.find state.map s
        with Not_found -> newMangle s
    in
        mangle
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Example}
%%% ------------------------------------------------------------------ 
%%
%%Here is a simple [[symbol]] for testing a mangler.
%%        
<<mangle.ml unused>>=
let simple =
    let reserved =
        [ "aborts"; "align"; "aligned"; "also"; "as"; "big"; "byteorder";
        "case"; "const"; "continuation"; "cut"; "cuts"; "else"; "equal";
        "export"; "foreign"; "goto"; "if"; "import"; "invariant"; "jump";
        "little"; "memsize"; "pragma"; "register"; "return"; "returns";
        "section"; "semi"; "span"; "stackdata"; "switch"; "target"; "targets";
        "to"; "typedef"; "unicode"; "unwinds"; "float"; "charset";
        "pointersize"; "wordsize"]
    in
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '.' 
        | '_' 
        | '$' 
        | '@'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '@' in    
        { preprocess = (fun x -> x)
        ; replace    = replace
        ; reserved   = reserved
        ; avoid      = (fun x -> x ^ "$")
        }
@
%%    
%%                      

\chapter{[[front_last]]}

\section{[[front_last/automatonutil.nw]]}
<<front_last/automatonutil.ml>>=
<<automatonutil.ml>>
@

<<front_last/automatonutil.mli>>=
<<automatonutil.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% vim: ts=8 sw=4 et:
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%%%Grades: B Peripheral Later
%%
%%
\section{Automaton utilities}
%%
%%This code is in a separate module so we can avoid charging
%%[[Automaton]] for it in papers.
%%
%%An [[Automaton.loc]] can be converted to the list of locations that
%%would be written, provided we know its width.  
%%Function [[aloc]] expects that list to have exactly length~1,
%%otherwise it halts with a compiler error.
<<automatonutil.mli>>=
val alocs : Automaton.loc -> Rtl.width -> Rtl.loc list
val aloc  : Automaton.loc -> Rtl.width -> Rtl.loc 
@ 
\subsection{Implementation}
%%
<<automatonutil.ml>>=
module R   = Rtl
module RP  = Rtl.Private
module Up  = Rtl.Up
module Dn  = Rtl.Dn
@ 
%%
<<automatonutil.ml>>=
let alocs aloc w =
  let RP.Rtl gs = Dn.rtl (Automaton.store aloc (Rtl.late "dummy" w) w) in
  let getloc = function _, RP.Store (l, _, _) -> Up.loc l | _, RP.Kill l -> Up.loc l in
  List.map getloc gs
let aloc a w = match alocs a w with
| [l] -> l
| _ -> Impossible.impossible "automaton split value across multiple locations"
@ 
\section{[[front_last/callspec.nw]]}
<<front_last/callspec.ml>>=
<<callspec.ml>>
@

<<front_last/callspec.mli>>=
<<callspec.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim:ts=8 sw=4 et:
%%
%%% ------------------------------------------------------------------ 
\section{Constructing a Calling Convention}
%%% ------------------------------------------------------------------ 
%%
%%A calling convention is represented by a [[Call.t]] value. Since this is
%%a quite complicated type, this module provides a client-oriented
%%interface to build such a value.
%%
%%We provide a convenience function and two default values that represent whether the
%%caller or callee allocate/deallocate overflow blocks.
<<callspec.mli>>=
val overflow      : dealloc:Call.party -> alloc:Call.party -> Call.overflow
val c_overflow    : Call.overflow
val tail_overflow : Call.overflow
@ 
%%When a (general) register is spilled, a stack slot must be allocated. A
%%[[nvr_saver]] provides a slot for a non-volatile register.
<<callspec.mli>>=
type nvr_saver = Talloc.Multiple.t -> Register.t -> Rtl.loc
(* suggested by NR, but not used 
 * val save_nvrs: Space.t list -> nvr_saver
 *)
@
%%\paragraph{Return Address} The return address is the address a procedure
%%returns to. It needs to be saved accross calls if it is in a register.
%%We have two basic policies:
%%
%%\begin{itemize}
%%\item [[KeepInPlace]] leaves the return address where it is, which is
%%      probably on the stack.
%%\item [[SaveToTemp c]] save the return address to a temporary of the
%%     space named~[[c]].
%%      Upon return, the return address is loaded into a fresh,
%%      short-lived temporary in the space with that name.
%%\end{itemize}
%%
%%The basic policy cannot express to use coventional location for the
%%return address.
<<callspec.mli>>=
module ReturnAddress: sig
    type style  =
        | KeepInPlace           (* leave RA where it is     *)
        | SaveToTemp  of char   (* save RA in a temporary of this space  *)
    (* <<suggested functions>> *)
end     
@
%%
%%NR suggested to provide the following functions. The problem is that an
%%implementation needs to know about which spaces to use for temporaries,
%%conventional return addresses and other informations not available.
%%They are currently unimplemented.
%%
<<suggested functions>>=
val enter_in_loc    : Rtl.loc -> Block.t -> Rtl.exp 
val save_in_temp    : Rtl.exp -> Talloc.Multiple.t -> Rtl.loc
val save_as_is      : Rtl.exp -> Talloc.Multiple.t -> Rtl.loc
val exit_in_temp    : Rtl.exp -> Block.t -> Talloc.Multiple.t -> Rtl.loc
val exit_as_is      : Rtl.exp -> Block.t -> Talloc.Multiple.t -> Rtl.loc
@
%%
%%\paragraph{The Specification} The following specification decribes a
%%calling convention. Passing it to [[to_call]], creates a [[Call.t]]
%%value.
%%
<<callspec.mli>>=
<<type t(callspec.nw)>>

@ 
%%
<<type t(callspec.nw)>>=
type t =
    { name              : string            (* name this CC *)
    ; stack_growth      : Memalloc.growth   (* up or down *)
    ; overflow          : Call.overflow     (* overflow handling *)
    ; memspace          : Register.space
    ; sp                : Register.t        (* stack pointer register *)
    ; sp_align          : int               (* alignment of sp *)
    ; all_regs          : Register.Set.t    (* regs visible to allocator *)
    ; nv_regs           : Register.Set.t    (* preserved registers *)
    ; save_nvr          : nvr_saver         (* how to save registers *)
    ; ra                : Rtl.loc           (* where is RA, how to treat it *)
                          * ReturnAddress.style
    }
@
%%
%%A client has to supply the {\rtl}s for the [[cutto]] and alternate
%%return instructions.
%%
<<callspec.mli>>=
val to_call: cutto:(unit, Mflow.cut_args) Target.map -> 
             return:(int -> int -> ra:Rtl.exp -> Rtl.rtl) -> 
             Automaton.cc_spec ->
             t -> Call.t   
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<callspec.ml>>=
module R  = Rtl
module RU = Rtlutil
module W  = Rtlutil.Width
module T  = Talloc.Multiple
module C  = Call
module A  = Automaton

let overflow ~dealloc ~alloc = 
    { C.parameter_deallocator = dealloc
    ; C.result_allocator      = alloc
    }


let tail_overflow = 
    { C.parameter_deallocator = C.Callee
    ; C.result_allocator      = C.Caller
    }

let c_overflow =
    { C.parameter_deallocator = C.Caller
    ; C.result_allocator      = C.Caller
    } 

type nvr_saver = Talloc.Multiple.t -> Register.t -> Rtl.loc


module ReturnAddress = struct
    type style  =
        | KeepInPlace                   (* leave RA where it is     *)
        | SaveToTemp of char            (* save RA in a temporary   *)
end    

<<type t(callspec.nw)>>
@
%%We want to abstract from the direction of stack growth. Therefore, we
%%rather talking about the high and low end of a block we want to talk
%%about its young or old end.
<<callspec.ml>>=
let old_end wordsize growth block = match growth with
| Memalloc.Down -> RU.addk wordsize (Block.base block) (Block.size block)
| Memalloc.Up   -> Block.base block

let young_end wordsize growth block = match growth with
| Memalloc.Down -> Block.base block
| Memalloc.Up   -> RU.addk wordsize (Block.base block) (Block.size block) 


let wordsize t = match t.sp with ((_,_,ms),_,c) -> Cell.to_width ms c
let memspace t = t.memspace
let byteorder t = let (_, b, _) = t.memspace in b
let vfp wordsize             = Vfp.mk wordsize
let std_sp_location wordsize = 
    RU.add wordsize (vfp wordsize) (R.late "minus frame size" wordsize)

let mk_automaton wordsize memspace block_name automaton = fun () ->
    Block.srelative (vfp wordsize) block_name (A.at memspace)
      automaton
@
%%
%%Small utilities to observe the return address location and its policy
%%independently.
%%
<<callspec.ml>>=
let ra t    = fst t.ra
let style t = snd t.ra
@
%%
%%The prolog is independent of the overflow policy. The first step is
%%always to allocate the frame for the procedure and to copy the incoming
%%parameters. Incoming overflow parameters always are held in a block
%%allocated by the caller.
%%
<<callspec.ml>>=
let prolog t auto = 
  let autosp = (fun a -> young_end (wordsize t) t.stack_growth a.A.overflow) in
  C.incoming ~growth:t.stack_growth ~sp:(R.reg t.sp)
    ~mkauto:(mk_automaton (wordsize t) (memspace t) "in call parms" auto.A.call)
                        
    (* ~autosp:(fun _ -> vfp (wordsize t)) *)
    ~autosp:autosp
    ~postsp:(fun _ _ -> std_sp_location (wordsize t)) 
    ~insp:(fun a _ _ -> autosp a)
@
%%
%%Before the epliog, [[sp]] points at the standard location, independent
%%of the overflow policy. Whereever the result is placed, it must be
%%deallocated by the caller and thus we cannot dealloate it. 
%%
%%There is one problematic case: when the callee deallocates the
%%pamarameter block and the caller allocates the result block, is the
%%caller allowed to overlap the result with the parameter block?
%%Currently the compiler overlaps and thus we deallocate only up
%%to the young end of the result block. But in principle the result block
%%could be allocated outside the parameter block and thus we could
%%deallocate the parameter block completely. 
%%
<<callspec.ml>>=
let epilog t auto =
    C.outgoing ~growth:t.stack_growth ~sp:(R.reg t.sp)
        ~mkauto:(mk_automaton (wordsize t) (memspace t) 
                   "out ovfl results" auto.A.results)
        ~autosp:(fun r -> std_sp_location (wordsize t))
        ~postsp:(match t.overflow with
                | {C.parameter_deallocator=C.Caller; C.result_allocator=C.Caller} ->
                    (fun _ _ -> vfp (wordsize t)) 
                | {C.parameter_deallocator=C.Callee; C.result_allocator=C.Caller} 
                | {C.parameter_deallocator=C.Caller; C.result_allocator=C.Callee} 
                | {C.parameter_deallocator=C.Callee; C.result_allocator=C.Callee} -> 
                    (fun a _ -> 
                        young_end (wordsize t) t.stack_growth a.A.overflow)
                )
@
%%
%%A call always allocates space for outgoing parameters, independent of
%%who deallocates it.  Currently the space for results that the caller
%%allocates is overlapped with the block for outgoing parameters, so no
%%extra action is required. The young end of the outgoing block might or
%%might not be the standard location, depending on the stack layout
%%specified in Lua. Therefore, the move to the young end might be
%%redundant but we cannot test for it here.
%%
<<callspec.ml>>=
let call_actuals t auto =
    C.outgoing ~growth:t.stack_growth ~sp:(R.reg t.sp)
        ~mkauto:(mk_automaton (wordsize t) (memspace t) "out call parms" auto.A.call)
        ~autosp:(fun r  -> std_sp_location (wordsize t))
        ~postsp:(fun a sp -> young_end (wordsize t) t.stack_growth a.A.overflow)
@
%%
%%After a call the stack pointer points at the young end of the result
%%overflow block. We have to move it back to the standard location. This
%%might or might not be redundant. If it is not, this will deallocate any
%%callee-allocated result block.
%%
<<callspec.ml>>=
let call_results t auto =
    let autosp = (fun a   -> young_end (wordsize t) t.stack_growth a.A.overflow) in
    C.incoming ~growth:t.stack_growth ~sp:(R.reg t.sp)
      ~mkauto:(mk_automaton (wordsize t) (memspace t) "in ovfl results" auto.A.results)
      ~autosp
      ~postsp:(fun _ _ -> std_sp_location (wordsize t)) 
      ~insp:(fun a _ _ -> autosp a)
@
%%
%%Parameter passing for cuts is independent of parameter passing for
%%procedures.
%%
<<callspec.ml>>=
let also_cuts_to t auto =
    let autosp = (fun r   -> std_sp_location (wordsize t)) in
    C.incoming ~growth:t.stack_growth ~sp:(R.reg t.sp)
      ~mkauto:(mk_automaton (wordsize t) (memspace t) "in cont parms" auto.A.cutto)
      ~autosp
      ~postsp:(fun _ _ -> std_sp_location (wordsize t)) 
      ~insp:(fun a _ _ -> autosp a)

let cut_actuals t auto base =
    C.outgoing ~growth:t.stack_growth ~sp:(R.reg t.sp) 
        ~mkauto:(fun ()  -> A.at (memspace t) ~start:base auto.A.cutto)
        ~autosp:(fun r   -> R.fetch (R.reg t.sp) (wordsize t))
        ~postsp:(fun _ _ -> R.fetch (R.reg t.sp) (wordsize t))

@
%%
%%On entry, the return address is in the location specified by [[t]]. We
%%simply fetch it from there.
%%
<<callspec.ml>>=
let ra_on_entry t block = R.fetch (ra t) (wordsize t)
@
%%
%%Under the [[SaveToTemp]] policy we put the return address into a
%%\emph{fresh} temporary on exit. The hope is, that this temporary will be
%%short lived and not be spilled. Under the [[KeepInPlace]] policy, we
%%just keep the current location. The policy cannot express to put the
%%return address into a conventional location on exit, as required by the
%%Alpha for example.
%%
%%\textbf{Alert:} The register allocator shows a bug when we put the
%%return address into a temporary on exit. 
%%
<<callspec.ml>>=
let ra_on_exit t saved_ra block temp = match style t with
    | ReturnAddress.KeepInPlace  -> saved_ra 
    | ReturnAddress.SaveToTemp s -> Talloc.Multiple.loc temp s (wordsize t) 

let where_to_save_ra t = fun ra_on_entry temp -> match style t with
    | ReturnAddress.KeepInPlace  -> ra t
    | ReturnAddress.SaveToTemp s -> Talloc.Multiple.loc temp s (wordsize t) 

let to_call ~cutto ~return auto t =
    <<it's impossible for the stack pointer to be a useful register too>>
    ;
    let volregs = Register.Set.diff t.all_regs t.nv_regs in
    { C.name           = t.name
    ; C.overflow_alloc = t.overflow
    ; C.call_parms     = {C.in'=prolog       t auto; C.out=call_actuals t auto}
    ; C.cut_parms      = {C.in'=also_cuts_to t auto; C.out=cut_actuals  t auto}
    ; C.results        = {C.in'=call_results t auto; C.out=epilog       t auto}
    
    ; C.stack_growth     = t.stack_growth
    ; C.stable_sp_loc    = std_sp_location (wordsize t)
    ; C.jump_tgt_reg     = Rtl.reg (Register.Set.choose volregs)
    ; C.replace_vfp      = Vfp.replace_with ~sp:(R.reg t.sp)
    ; C.sp_align         = t.sp_align
    ; C.ra_on_entry      = ra_on_entry t
    ; C.where_to_save_ra = where_to_save_ra t
    ; C.ra_on_exit       = ra_on_exit t
    ; C.sp_on_unwind     = (fun _   -> Rtl.null)
    ; C.sp_on_jump       = (fun _ _ -> Rtl.null)
    ; C.pre_nvregs       = t.nv_regs
    ; C.volregs          = volregs
    ; C.saved_nvr        = t.save_nvr
    ; C.return           = return
    }
@ 
%%
<<it's impossible for the stack pointer to be a useful register too>>=
if Register.Set.mem t.sp t.all_regs then
  Impossible.impossible
    (Printf.sprintf "In convention \"%s\", stack pointer is also an ordinary register"
       t.name)
else
  ()
@
%%
%%
\section{[[front_last/dataflow.nw]]}
<<front_last/dataflow.ml>>=
<<dataflow.ml>>
@

<<front_last/dataflow.mli>>=
<<dataflow.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
\section{A polymorphic infrastructure for dataflow problems}
%%
%%This module presents a framework for solving iterative dataflow
%%problems. 
%%There are two major submodules: one for forward problems and another
%%for backward problems.
%%Both modules incorporate the composition framework developed by
%%Lerner, Grove, and Chambers.
%%They also support a \emph{transaction limit}, which enables the
%%binary-search debugging technique developed by Whalley and Davidson
%%under the name \emph{vpoiso}.
%%Transactions may either be known to the individual dataflow solvers or
%%may be managed by the framework.
%%
%%In the composition framework, a pass either produces a dataflow fact
%%or proposes to rewrite the graph.  
%%Rewrites are not coordinated, so every rewrite is a Whalley/Davidson
%%transaction. 
%%The number of such transactions is limited by a value of type
%%[[txlimit]]. 
<<exported types(dataflow.nw)>>=
type 'a answer = Dataflow of 'a | Rewrite of Zipcfg.graph
type txlimit = int
@
%%A dataflow pass is based on a single dataflow fact of type~[['a]].
%%Values of type~[['a]] should form a lattice.
%%The dataflow engine uses the lattice structure to compute a 
%%solution to a set of dataflow equations.
%%The engine is indifferent to direction:
%%it can start at the bottom and climb to a least solution, or it can
%%start at the top and drop to a greatest solution.
%%We abstract the direction and initial value by the functions
%%[[add_info]] and [[init_info]], but for concreteness, we describe the
%%framework in terms of
%%least solutions.
%%You flipping the lattice over to describe a greatest solution. 
%%
%%The engine works by starting at the bottom and iterating to a fixed
%%point, so we require the
%%bottom element, a join (least upper bound) operation, and a comparison
%%to find out if a value has changed (grown).
%%
%%Finally, we require a way to store dataflow facts in global mutable
%%state, associated with unique IDs.
%%In the [[fact]] type, this capability is provided by the [[prop]] field.
<<exported types(dataflow.nw)>>=
type 'a fact = {
  fact_name : string;                     (* documentation *)
  init_info : 'a;                         (* lattice bottom element *)
  add_info  : 'a -> 'a -> 'a;             (* lattice join (least upper bound) *)
  changed   : old:'a -> new':'a -> bool;  (* is new one bigger? *)
  prop      : 'a Unique.Prop.t;           (* access to mutable state by uid *)
}
@
%%The [[fact]] type is the most common usage, but sometimes we might need access
%%  to the block id to fetch dataflow facts.
%%For example, we might want a forward pass to use information generated by a backward
%%  pass.
<<exported types(dataflow.nw)>>=
type 'a fact' = {
  fact_name' : string;                     (* documentation *)
  init_info' : 'a;                         (* lattice bottom element *)
  add_info'  : 'a -> 'a -> 'a;             (* lattice join (least upper bound) *)
  changed'   : old:'a -> new':'a -> bool;  (* is new one bigger? *)
  get'       : Zipcfg.uid -> 'a;
  set'       : Zipcfg.uid -> 'a -> unit;
}
@
%%The [[fact]] type is more convenient, but the [[fact']] is more general.
%%Therefore, we write our code to manipulate the [[fact']] type, and we use
%%  an embedding function to construct a [[fact']] from a [[fact]].
<<utilities(dataflow.nw)>>=
let to_fact' f =
  { fact_name' = f.fact_name
  ; init_info' = f.init_info
  ; add_info' = f.add_info
  ; changed' = f.changed
  ; get' = P.get f.prop
  ; set' = P.set f.prop
  }
let to_fact f f' =
  {fact_name = f'.fact_name'; init_info = f'.init_info'; add_info = f'.add_info';
   changed = f'.changed'; prop = f.prop}
@
%%Here is the overall structure of the module:
<<dataflow.mli>>=
<<exported types(dataflow.nw)>>
module B : sig
  <<exported types for backward analyses>>
  <<declarations of exported values for analyses>>
  <<declarations of exported values for backward analyses>>
end
module F : sig
  <<exported types for forward analyses>>
  <<declarations of exported values for analyses>>
  <<declarations of exported values for forward analyses>>
end
<<declarations of shared exported values>>
@ 
%%
\subsection {Descriptions of dataflow passes}
%%
%%\paragraph{Passes for backward dataflow problems}
%%
%%The computation of a fact is the basis of a dataflow pass.
%%A~computation takes not one but two type parameters:
%%\begin{itemize}
%%\item
%%Type parameter [['i]] is an input, from which it should be possible to
%%derived a dataflow fact of interest.
%%For example, [['i]] might be equal to a fact, or it might be a tuple
%%of which one element is a fact.
%%\item
%%Type parameter [['o]] is an output, or possibly a function from
%%[[txlimit]] to an output
%%\end{itemize}
%%Backward analyses compute [[in]] facts (facts on inedges). 
<<exported types for backward analyses>>=
type ('i, 'o) computation =
 { name      : string;
   last_in   : Zipcfg.Rep.last -> 'o;
   middle_in : 'i -> Zipcfg.Rep.middle -> 'o;
   first_in  : 'i -> Zipcfg.Rep.first -> 'o;
 } 
@ 
%%From these elements we build several kinds of passes:
%%\begin{itemize}
%%\item
%%A pure analysis computes a fact, using that fact as input and
%%output.
%%\item
%%A~pure transformation computes no facts but only changes the graph.
%%\item
%%A fully general pass both computes a fact and rewrites the graph,
%%respecting the current transaction limit.
%%\end{itemize}
<<exported types for backward analyses>>=
type 'a analysis       = 'a fact  * ('a, 'a)                   computation
type 'a analysis'      = 'a fact' * ('a, 'a)                   computation
type 'a transformation =           ('a, Zipcfg.graph option)   computation
type 'a pass           = 'a fact  * ('a, txlimit -> 'a answer) computation
type 'a pass'          = 'a fact' * ('a, txlimit -> 'a answer) computation
@ 
%%And some more embedding functions:
<<backward utilities>>=
let to_analysis' (f, c) = (to_fact' f, c)
let y = (to_analysis' : 'a analysis -> 'a analysis')
let to_pass'     (f, c) = (to_fact' f, c)
@
%%
%%\paragraph{Passes for forward dataflow problems}
%%
%%A forward dataflow pass has a similar structure, but the details are
%%different. 
%%In particular, the output fact from a [[last]] node has a higher-order
%%representation: it takes a function that mutates a [[uid]] to account
%%for the new fact, then performs the necessary mutation on every
%%successor of the last node.
%%We therefore have two kinds of type parameter for outputs: 
%%output from a [[middle]] node is~[['om]], and output from a [[last]]
%%node is~[['ol]].  
<<exported types for forward analyses>>=
type 'a edge_fact_setter = (Zipcfg.uid -> 'a -> unit) -> unit

type ('i, 'om, 'ol) computation =
 { name       : string;
   middle_out : 'i -> Zipcfg.Rep.middle -> 'om;
   last_outs  : 'i -> Zipcfg.Rep.last   -> 'ol;
 } 
@ 
%%The notions of analysis, pass, and transformation are analogous to the
%%backward case.
<<exported types for forward analyses>>=
type 'a analysis  = 'a fact  * ('a, 'a,                'a edge_fact_setter) computation
type 'a analysis' = 'a fact' * ('a, 'a,                'a edge_fact_setter) computation
type 'a transformation =     ('a, Zipcfg.graph option, Zipcfg.graph option) computation
type 'a pass =
  'a fact *
 ('a, txlimit -> 'a answer, txlimit -> 'a edge_fact_setter answer) computation
type 'a pass' =
  'a fact' *
 ('a, txlimit -> 'a answer, txlimit -> 'a edge_fact_setter answer) computation
@ 
%%And some more embedding functions:
<<forward utilities>>=
let to_analysis' (f, c) = (to_fact' f, c)
let to_pass'     (f, c) = (to_fact' f, c)
@
%%
%%\paragraph{Composing passes}
%%
%%
%%Both forward and backward engines share a handful of functions for
%%composing analyses, transformations, and passes.
%%
%%We can make an analysis pass, or we can 
%%combine a related analysis and transformation into a full pass.
<<declarations of exported values for analyses>>=
val anal  : 'a analysis  -> 'a pass
val anal' : 'a analysis' -> 'a pass'
val a_t   : 'a analysis  -> 'a transformation -> 'a pass
val a_t'  : 'a analysis' -> 'a transformation -> 'a pass'
@ 
%%Diagnostic help:
<<declarations of exported values for analyses>>=
val debug' : ('a -> string) -> 'a pass' -> 'a pass'
val debug  : ('a -> string) -> 'a pass  -> 'a pass
@ 
%%\paragraph {Running the dataflow engine}
%%
%%Every function for running analyses has two forms, because for a
%%forward analysis, we supply an entry fact, whereas for a backward
%%analysis, we don't need to supply an exit fact (because a graph for a
%%procedure doesn't have an exit node).
%%It's possible we could make these things more regular.
%%
%%The analysis function sets properties on unique IDs.
<<declarations of exported values for backward analyses>>=
val run_anal  : 'a analysis  -> Zipcfg.graph -> unit
val run_anal' : 'a analysis' -> Zipcfg.graph -> unit
@ 
<<declarations of exported values for forward analyses>>=
val run_anal  : 'a analysis  -> entry_fact:'a -> Zipcfg.graph -> unit
val run_anal' : 'a analysis' -> entry_fact:'a -> Zipcfg.graph -> unit
@ 
%%The rewrite pass sets properties and also rewrites the graph.
%%The Boolean result tells if the graph changed.
<<declarations of exported values for backward analyses>>=
val rewrite  : 'a pass  -> Zipcfg.graph -> Zipcfg.graph * bool
val rewrite' : 'a pass' -> Zipcfg.graph -> Zipcfg.graph * bool
@ 
<<declarations of exported values for forward analyses>>=
val rewrite  : 'a pass  -> entry_fact:'a -> Zipcfg.graph -> Zipcfg.graph * bool
val rewrite' : 'a pass' -> entry_fact:'a -> Zipcfg.graph -> Zipcfg.graph * bool
@
%%If a graph is already solved, we can take a short cut and just rewrite
%%it in one pass.
%%We haven't needed a backward version yet.
<<declarations of exported values for forward analyses>>=
val rewrite_solved  : 'a pass  -> entry_fact:'a -> Zipcfg.graph -> Zipcfg.graph * bool
val rewrite_solved' : 'a pass' -> entry_fact:'a -> Zipcfg.graph -> Zipcfg.graph * bool
val modify_solved'  : 'a pass' -> entry_fact:'a -> Zipcfg.graph -> Zipcfg.graph * bool
@
%%In some cases, we want to use the dataflow framework for an analysis and
%%transformation, but what if the transformation doesn't preserve the results of the
%%analysis?
%%For example, a register allocator replaces each temp in an \rtl\ with a register;
%%if we re-run the analysis on the transformed \rtl, we won't get the same result.
%%For these cases, we have the [[modify_solved']] graph, which forwards the
%%dataflow analysis from the unchanged graph, even when an \rtl\ is transformed.
%%\paragraph{Respecting the transaction limit}
<<declarations of shared exported values>>=
val limit_fun  : ('a -> 'b -> 'c option) -> ('a -> 'b -> txlimit -> 'c option)
@
\section{Implementation}
%%
<<dataflow.ml>>=
module G  = Zipcfg
module GR = Zipcfg.Rep
module P  = Unique.Prop
module RS = Rtlutil.ToString
module UM = Unique.Map
let impossf fmt = Printf.kprintf Impossible.impossible fmt
let unimpf  fmt = Printf.kprintf Impossible.unimp      fmt
let dprintf fmt = Debug.eprintf "dataflow" fmt
let _ = Debug.register "dataflow" "execution of generic dataflow engine"

<<exported types(dataflow.nw)>>
<<utilities(dataflow.nw)>>
<<definitions of exported functions>>
module B = struct
  <<exported types for backward analyses>>
  <<backward utilities>>
  <<backward stuff>>


  module XXX = struct 
   <<backward, no txlim>>
  end

end
module F = struct
  <<exported types for forward analyses>>
  <<forward utilities>>
  <<forward stuff>>
end
@ 
\subsection{Utilities}
%%
%%Here's a function to run an action on blocks until we reach a fixed point.
<<utilities(dataflow.nw)>>=
let run dir name fact changed entry_fact do_block txlim blocks =
  let init () = 
    List.iter (fun b -> fact.set' (GR.id b) fact.init_info') blocks;
    fact.set' GR.entry_uid entry_fact in
  let rec iterate n =
    let () = changed := false in
    let txlim = List.fold_left do_block txlim blocks in
    if !changed then
      if n < 1000 then iterate (n + 1)  (* starts from original txlim *)
      else impossf "%s didn't converge in %n %s iterations" name n dir
    else
      (Debug.eprintf name "%s converged in %d %s iterations\n" name n dir; txlim) in
  Debug.eprintf name "starting %s dataflow pass %s\n" dir name;
  init();
  Debug.eprintf name "post-init %s dataflow pass %s\n" dir name;
  iterate 1
@ 
%%And here's where we update with a new fact.
%%If we want better diagnostics, we can pass the graph in as well, then
%%use the graph to look up the uid and print a label.
<<utilities(dataflow.nw)>>=
let update fact changed =
  fun u a ->
    let old_a = fact.get' u in
    let new_a = fact.add_info' a old_a in
      if fact.changed' ~old:old_a ~new':new_a then
        begin
          dprintf "Dataflow fact changed at unknown uid\n";
          fact.set' u new_a;
          if not (Unique.eq u GR.entry_uid) then (* no need to re-run on new entry *)
            changed := true
        end

let _ = (update : 'a fact' -> bool ref -> G.uid -> 'a -> unit)
@ 
<<utilities(dataflow.nw)>>=
let without_changing_entry fact go =
  let restore =
    try
      let entry = fact.get' GR.entry_uid in
      fun () -> fact.set' GR.entry_uid entry
    with Not_found ->
      fun () -> () in
  let output = go () in
  let answer = fact.get' GR.entry_uid in
  restore();
  output, answer
@ 
%%
\subsection{Backward problems}
%%
%%In a backward problem, we compute \emph{in} facts from \emph{out}
%%facts.
%%The analysis gives us [[last_in]], [[middle_in]], and [[first_in]],
%%each of which computes an \emph{in} fact for one kind of node.
%%We provide [[head_in]], which computes the \emph{in} fact for a first
%%node followed by zero or more middle nodes.
%%
%%We don't compute and return the \emph{in} fact for block; instead, we
%%use [[set']] to attach that fact to the block's unique~ID.
%%We iterate until no more facts have changed.
<<backward stuff>>=
let run_anal' (fact, comp) graph =
  let changed = ref false in
  let update = update fact changed in
  let set_block_fact () b =
    let h, l = GR.goto_end (GR.unzip b) in
    let block_in = (* 'in' fact for the block *)
      let rec head_in h out = match h with
        | GR.Head (h, m) -> head_in h (comp.middle_in out m)
        | GR.First f -> comp.first_in out f in
      head_in h (comp.last_in l) in
    update (GR.id b) block_in in
  let blocks = List.rev (G.postorder_dfs graph) in
  run "backward" comp.name fact changed fact.init_info' set_block_fact () blocks
let run_anal anal graph = run_anal' (to_analysis' anal) graph
@ 
%%In the general case we solve a graph in the context of a larger subgraph.
%%To do this, we need a locally modified computation that allows an
%%``exit fact'' to flow into the exit node.
<<backward utilities>>=
let comp_with_exit comp exit_fact =
  let last_in l txlimit = match l with
  | GR.Exit -> Dataflow exit_fact
  | _ -> comp.last_in l txlimit in
  { comp with last_in = last_in } 
@ 
%%Given this function, we can now solve a graph simply by doing a
%%backward analysis on the modified computation.
%%The tricky work is in the [[answer[lmf]]] functions.
%%(HOW DO WE PROVE THAT IT IS SAFE TO USE THE SHARED MUTABLE STATE
%%ASSOCIATED WITH THE ENTRY NODE?)
%%\enlargethispage{2\baselineskip}
<<backward stuff>>=
let rec solve_graph fact comp txlim graph exit_fact =
  without_changing_entry fact (fun () ->
    general_backward fact (comp_with_exit comp exit_fact) txlim graph)
and general_backward fact comp txlim graph =
  let changed = ref false in
  let update = update fact changed in
  let set_block_fact txlim b =
    let txlim, block_in = 
      let rec head_in txlim h out = match h with
        | GR.Head (h, m) ->
            (dprintf "Solving middle node %s\n" (RS.rtl (GR.mid_instr m));
             match comp.middle_in out m txlim with
             | Dataflow a -> head_in txlim h a
             | Rewrite g ->
                 let txlim, a = solve_graph fact comp (txlim-1) g out in
                 head_in txlim h a)
        | GR.First f -> 
            match comp.first_in out f txlim with
            | Dataflow a -> txlim, a
            | Rewrite g -> solve_graph fact comp (txlim-1) g out in
      let h, l = GR.goto_end (GR.unzip b) in
      match comp.last_in l txlim with
      | Dataflow a -> head_in txlim h a
      | Rewrite g ->
          let txlim, a = solve_graph fact comp (txlim-1) g fact.init_info' in
          head_in txlim h a in
    update (GR.id b) block_in;
    txlim in
  let blocks = List.rev (G.postorder_dfs graph) in
  run "backward" comp.name fact changed fact.init_info' set_block_fact txlim blocks
@
%%We solve and rewrite in two passes: the first pass iterates to a fixed
%%point to reach a dataflow solution, and the second pass uses that
%%solution to rewrite the graph.
%%
%%The key job is done by [[propagate]], which propagates a fact of type~[['a]]
%%between a head and tail.
%%The tail is in final form; the head is still to be rewritten.
<<backward stuff>>=
let rec solve_and_rewrite fact comp txlim graph exit_fact changed =
  let _, a = solve_graph fact comp txlim graph exit_fact in          (* pass 1 *)
  let txlim, g, c =                                                  (* pass 2 *)
    backward_rewrite fact (comp_with_exit comp exit_fact) txlim graph changed  in
  txlim, a, (g, c) 
and backward_rewrite (fact : 'a fact') comp txlim graph changed =
  let rec rewrite_blocks txlim rewritten fresh changed : txlimit * G.graph * bool =
    match fresh with
    | [] -> txlim, G.of_block_list rewritten, changed
    | b :: bs ->
        let rec rewrite_next_block txlim =
          let h, l = GR.goto_end (GR.unzip b) in
          match comp.last_in l txlim with
          | Dataflow a -> propagate txlim h a (GR.Last l) rewritten changed
          | Rewrite g ->
              let txlim, a, (g, _) =
                solve_and_rewrite fact comp (txlim-1) g fact.init_info' changed in
              let t, g = G.remove_entry g in
              let rewritten = add_blocks (G.to_blocks g) rewritten in
              (* continue at entry of g *)
              propagate txlim h a t rewritten true
        and propagate : txlimit -> GR.head -> 'a -> GR.tail -> GR.block list -> bool ->
                          txlimit * G.graph * bool =
          fun txlim h out tail rewritten changed -> match h with
          | GR.Head (h, m) -> (
              dprintf "Rewriting middle node %s\n" (RS.rtl (GR.mid_instr m));
              match comp.middle_in out m txlim with
              | Dataflow a -> propagate txlim h a (GR.Tail (m, tail)) rewritten changed
              | Rewrite g ->
                  dprintf "Rewriting middle node...\n";
                  let txlim, a, (g, _) =
                    solve_and_rewrite fact comp (txlim-1) g out changed in
                  dprintf "Rewrite of middle node completed\n";
                  let t, g = G.splice_tail g tail in
                  let rewritten = add_blocks (G.to_blocks g) rewritten in
                  propagate txlim h a t rewritten true)
          | GR.First f ->
              match comp.first_in out f txlim with
              | Dataflow a ->
                  let b = (f, tail) in
                  check_property_match fact a b;
                  rewrite_blocks txlim (b :: rewritten) bs changed
              | Rewrite g -> impossf "rewriting a label in backward dataflow" in
        rewrite_next_block txlim in
    rewrite_blocks txlim [] (List.rev (G.postorder_dfs graph)) changed

let rewrite' (fact, comp) g =
  let txlim = Tx.remaining () in
  let txlim', _, gc = solve_and_rewrite fact comp txlim g fact.init_info' false in
  Tx.decrement ~name:comp.name ~from:txlim ~to':txlim';
  gc
let rewrite pass g = rewrite' (to_pass' pass) g
@ 
<<backward utilities>>=
let check_property_match fact a block =
  match (fst block) with
  | GR.Entry -> () (* needn't match *)
  | GR.Label ((_, l), _, _) -> 
      let old_a = fact.get' (GR.id block) in
      let new_a = fact.add_info' a old_a in
      if not (eqfact fact old_a new_a) then
        impossf "property at label '%s' changed after supposedly reaching fixed point" l
@
<<utilities(dataflow.nw)>>=
let add_blocks map list =
  let add _ b bs = b :: bs in
  UM.fold add map list
@ 
<<utilities(dataflow.nw)>>=
let ( << ) f g = fun x -> f (g x)
@ 
<<backward stuff>>=
let debug' s (f, comp) =
  let pr = Printf.eprintf in
  let fact dir node a = pr "%s %s for %s = %s\n" f.fact_name' dir node (s a) in
  let rewr node g = pr "%s rewrites %s to <not-shown>\n" comp.name node in
  let wrap f nodestring node txlim =
    let answer = f node txlim in
    let () = match answer with
    | Dataflow a -> fact "in " (nodestring node) a
    | Rewrite g  -> rewr (nodestring node) g in
    answer in
  let wrapout f nodestring out node txlim =
    fact "out" (nodestring node) out;
    wrap (f out) nodestring node txlim in
  let last_in = wrap comp.last_in (RS.rtl << GR.last_instr) in
  let middle_in = wrapout comp.middle_in (RS.rtl << GR.mid_instr) in
  let first_in  =
    let first = function GR.Entry -> "<entry>" | GR.Label ((u, l), _, _) -> l in
    wrapout comp.first_in first in
  f, { comp with last_in = last_in; middle_in = middle_in; first_in = first_in; }
let debug s ((f, comp) as pass) =
  let (f', comp') = debug' s (to_pass' pass) in
  (to_fact f f', comp')
@ 
<<backward stuff>>=
let anal (fact, comp) =
  let wrap  f node txlim = Dataflow (f node) in
  let wrap2 f out node txlim = Dataflow (f out node) in
  fact,
  { name = comp.name; last_in = wrap comp.last_in;
    middle_in = wrap2 comp.middle_in; first_in = wrap2 comp.first_in; }
let anal' = anal
@ 
<<backward stuff>>=
let a_t' (fact, comp) tx =
 let last_in l txlim =
   if txlim > 0 then
     match tx.last_in l with
     | Some g -> Rewrite g
     | None   -> Dataflow (comp.last_in l)
   else
     Dataflow (comp.last_in l) in
 let middle_in out m txlim =
   if txlim > 0 then
     match tx.middle_in out m with
     | Some g -> Rewrite g
     | None   -> Dataflow (comp.middle_in out m)
   else
     Dataflow (comp.middle_in out m) in
 let first_in out f txlim =
   if txlim > 0 then
     match tx.first_in out f with
     | Some g -> Rewrite g
     | None   -> Dataflow (comp.first_in out f)
   else
     Dataflow (comp.first_in out f) in
 fact, 
 { name    = Printf.sprintf "%s and %s" comp.name tx.name;
   last_in = last_in; middle_in = middle_in; first_in  = first_in;
 }
let a_t x tx = a_t' x tx
@ 
<<definitions of exported functions>>=
let limit_fun f i n txlim = if txlim > 0 then f i n else None
let limit_last f n txlim  = if txlim > 0 then f n else None
@ 
<<backward stuff>>=
let limit_anal (fact, comp) =
  fact,
  { name = comp.name;
    first_in  = (fun i n _ -> comp.first_in i n);
    middle_in = (fun i n _ -> comp.middle_in i n);
    last_in   = (fun l _   -> comp.last_in l);
  }
let limit_tx tx =
  { name = tx.name;
    first_in = limit_fun tx.first_in;
    middle_in = limit_fun tx.middle_in;
    last_in = limit_last tx.last_in;
  }
@
\subsection{Forward}
%%
%%We don't compute and return the \emph{in} fact for block; instead, we
%%use [[set']] to attach that fact to the block's unique~ID.
%%We iterate until no more facts have changed.
<<forward stuff>>=
let run_anal' (fact, comp) ~entry_fact graph =
  let changed = ref false in
  let update = update fact changed in
  let set_successor_facts () b =
    let rec forward in' t = match t with
    | GR.Tail (m, t) -> forward (comp.middle_out in' m) t
    | GR.Last l -> comp.last_outs in' l update in
    let f, t = b in
    let blockname =
      match f with GR.Entry -> "<entry>" | GR.Label ((_, l), _, _) -> l in
    dprintf "Setting successor fact of block %s\n" blockname;
    forward (fact.get' (GR.fid f)) t in
  let blocks = G.postorder_dfs graph in
  run "forward" comp.name fact changed entry_fact set_successor_facts () blocks
let run_anal anal ~entry_fact graph = run_anal' (to_analysis' anal) entry_fact graph
@ 
%%In the general case we solve a graph in the context of a larger subgraph.
%%To do this, we need a locally modified computation that allows an
%%``exit fact'' to flow out of the exit node.
<<forward utilities>>=
let comp_with_exit comp exit_fact_ref =
  let last_outs in' l txlimit = match l with
  | GR.Exit -> Dataflow (fun set -> exit_fact_ref := in')
  | _ -> comp.last_outs in' l txlimit in
  { comp with last_outs = last_outs } 
@ 
%%Given this function, we can now solve a graph simply by doing a
%%backward analysis on the modified computation.
<<forward stuff>>=
let rec solve_graph fact comp txlim graph in_fact =
  let exit_fact_ref = ref fact.init_info' in
  let txlim =
    general_forward fact (comp_with_exit comp exit_fact_ref) txlim in_fact graph in
  txlim, !exit_fact_ref
and general_forward fact comp txlim entry_fact graph =
  let changed = ref false in
  let update = update fact changed in
  let set_successor_facts txlim b =
    let rec set_tail_facts txlim in' t = match t with
      | GR.Tail (m, t) ->
          (dprintf "Solving middle node %s\n" (RS.rtl (GR.mid_instr m));
           match comp.middle_out in' m txlim with
           | Dataflow a -> set_tail_facts txlim a t
           | Rewrite g -> 
               let txlim, g = solve_graph fact comp (txlim-1) g in' in
               set_tail_facts txlim g t)
      | GR.Last l -> 
          match comp.last_outs in' l txlim with
          | Dataflow setter -> (setter update; txlim)
          | Rewrite g -> fst (solve_graph fact comp (txlim-1) g in') in
    let f, t = b in
    let in' = match f with  (* CHANGE TO USE GR.id ? *)
    | GR.Entry -> entry_fact
    | GR.Label ((u, _), _, _) -> fact.get' u in
    set_tail_facts txlim in' t in
  let blocks = G.postorder_dfs graph in
  run "forward" comp.name fact changed entry_fact set_successor_facts txlim blocks
@
%%We solve and rewrite in two passes: the first pass iterates to a fixed
%%point to reach a dataflow solution, and the second pass uses that
%%solution to rewrite the graph.
%%
%%The key job is done by [[propagate]], which propagates a fact of type~[['a]]
%%between a head and tail.
%%The tail is in final form; the head is still to be rewritten.
<<forward stuff>>=
let expectD = function
  | Dataflow d -> d
  | Rewrite _  -> impossf "expected dataflow result"
let rec solve_and_rewrite modify fact comp txlim graph in_fact changed =
  let _ = solve_graph fact comp txlim graph in_fact in                   (* pass 1 *)
  let exit_ref = ref fact.init_info' in
  let txlim, g, c = forward_rewrite modify fact
                      (comp_with_exit comp exit_ref) txlim graph in_fact changed in
  txlim, !exit_ref, (g,c)
and forward_rewrite modify (fact : 'a fact') comp txlim graph entry_fact changed =
  let rec rewrite_blocks txlim rewritten fresh changed : txlimit * G.graph * bool =
    match fresh with
    | [] -> txlim, G.of_block_list rewritten, changed
    | b :: bs ->
        let rec rewrite_next_block txlim =
          let f, t = b in
          let in' = match f with
          | GR.Entry -> entry_fact
          | GR.Label ((u, _), _, _) -> fact.get' u in
          propagate txlim (GR.First f) in' t rewritten changed
        and propagate :
             txlimit -> GR.head -> 'a -> GR.tail -> GR.block list -> bool ->
               txlimit * G.graph * bool =
          fun txlim h in' t rewritten changed -> match t with
          | GR.Tail (m, t) -> (
              dprintf "Rewriting middle node %s\n" (RS.rtl (GR.mid_instr m));
              match comp.middle_out in' m txlim with
              | Dataflow a -> propagate txlim (GR.Head (h, m)) a t rewritten changed
              | Rewrite g ->
                  dprintf "Rewriting middle node...\n";
                  let txlim, a, (g, _) =
                    if modify then
                      (txlim-1, expectD (comp.middle_out in' m 0), (g, false))
                    else solve_and_rewrite modify fact comp (txlim-1) g in' changed in
                  dprintf "Rewrite of middle node completed\n";
                  let g, h = G.splice_head h g in
                  propagate txlim h a t (add_blocks (G.to_blocks g) rewritten) true)
          | GR.Last l ->
              dprintf "Rewriting last node %s\n" (RS.rtl (GR.last_instr l));
              match comp.last_outs in' l txlim with
              | Dataflow set ->
                  if not modify then set (check_property_match fact);
                  let b = GR.zip (h, GR.Last l) in
                  rewrite_blocks txlim (b :: rewritten) bs changed
              | Rewrite g ->
                  (* could test here that [[exits g = exits (GR.Entry, GR.Last l)]] *)
                  if Debug.on "rewrite-last" then 
                    dprintf "Last node %s rewritten to:\n" (RS.rtl (GR.last_instr l));
                    let k (txlim, _, (g, changed)) =
                      let g = G.to_blocks (G.splice_head_only h g) in
                      rewrite_blocks txlim (add_blocks g rewritten) bs changed in
                    if modify then
                     k (txlim-1, expectD (comp.last_outs in' l 0), (g, true))
                    else
                     k (solve_and_rewrite modify fact comp (txlim-1) g in' true) in
        rewrite_next_block txlim in
  rewrite_blocks txlim [] (G.postorder_dfs graph) changed

let _ =
  Debug.register "rewrite-last" "show what happens when last node is rewritten forward"

let rewrite_solved'' modify (fact, comp) ~entry_fact g =
  let txlim = Tx.remaining () in
  let txlim', g, changed = forward_rewrite modify fact comp txlim g entry_fact false in
  Tx.decrement ~name:comp.name ~from:txlim ~to':txlim';
  g, changed
let rewrite_solved  pass ~entry_fact g =
  rewrite_solved'' false (to_pass' pass) entry_fact g
let rewrite_solved' pass ~entry_fact g = rewrite_solved'' false pass entry_fact g
let modify_solved'  pass ~entry_fact g = rewrite_solved'' true  pass entry_fact g

let rewrite' (fact, comp) ~entry_fact g =
  let txlim = Tx.remaining () in
  let txlim', _, gc = solve_and_rewrite false fact comp txlim g entry_fact false in
  Tx.decrement ~name:comp.name ~from:txlim ~to':txlim';
  gc
let rewrite pass ~entry_fact g = rewrite' (to_pass' pass) entry_fact g
@ 
<<utilities(dataflow.nw)>>=
let eqfact fact a a' = (* poor man's approximation of equality *)
  not (fact.changed' a a' or fact.changed' a' a)
@ 
<<forward utilities>>=
let check_property_match fact u a =
  let old_a = fact.get' u in
  let new_a = fact.add_info' a old_a in
  if not (eqfact fact old_a new_a) then
    impossf "property '%s' changed after supposedly reaching fixed point"
            fact.fact_name'
@ 
<<forward stuff>>=
let debug' s (f, comp) =
  let pr = Printf.eprintf in
  let fact dir node a = pr "%s %s for %s = %s\n" f.fact_name' dir node (s a) in
  let setter dir node run_sets set =
    run_sets (fun u a -> pr "%s %s for %s = %s\n" f.fact_name' dir node (s a); set u a) in
  let rewr node g = pr "%s rewrites %s to <not-shown>\n" comp.name node in
  let wrap f nodestring wrap_answer in' node txlim =
    fact "in " (nodestring node) in';
    wrap_answer (nodestring node) (f in' node txlim)
  and wrap_fact n answer =
    let () = match answer with
    | Dataflow a -> fact "out" n a
    | Rewrite g  -> rewr n g in
    answer
  and wrap_setter n answer =
    match answer with
    | Dataflow set -> Dataflow (setter "out" n set)
    | Rewrite g  -> (rewr n g; Rewrite g) in
  let middle_out = wrap comp.middle_out (RS.rtl << GR.mid_instr) wrap_fact in
  let last_outs = wrap comp.last_outs (RS.rtl << GR.last_instr) wrap_setter in
  f, { comp with last_outs = last_outs; middle_out = middle_out; }
let debug s ((f, comp) as pass) =
  let (f', comp') = debug' s (to_pass' pass) in
  ({fact_name = f'.fact_name'; init_info = f'.init_info'; add_info = f'.add_info';
    changed = f'.changed'; prop = f.prop}, comp')
@ 
<<forward stuff>>=
let limit_anal (fact, comp) =
  fact,
  { name = comp.name;
    middle_out = (fun i n _ -> comp.middle_out i n);
    last_outs  = (fun i n _ -> comp.last_outs i n);
  }
let limit_tx tx =
  { name = tx.name;
    middle_out = limit_fun tx.middle_out;
    last_outs  = limit_fun tx.last_outs;
  }
@ 
<<forward stuff>>=
let anal (fact, comp) =
  let wrap f in' node txlim = Dataflow (f in' node) in
  fact,
  { name = comp.name;
    last_outs = wrap comp.last_outs; middle_out = wrap comp.middle_out; }
let anal' = anal
@ 
<<forward stuff>>=
let a_t' (fact, comp) tx =
 let last_outs in' l txlim =
   if txlim > 0 then
     match tx.last_outs in' l with
     | Some g -> Rewrite g
     | None   -> Dataflow (comp.last_outs in' l)
   else
     Dataflow (comp.last_outs in' l) in  
 let middle_out in' m txlim =
   if txlim > 0 then
     match tx.middle_out in' m with
     | Some g -> Rewrite g
     | None   -> Dataflow (comp.middle_out in' m)
   else
     Dataflow (comp.middle_out in' m) in
 fact, 
 { name = Printf.sprintf "%s and %s" comp.name tx.name;
   last_outs = last_outs; middle_out = middle_out;
 }
let a_t x tx = a_t' x tx
@ 
%%
%%
<<backward, no txlim>>=
let comp_with_exit comp exit_fact =
  let last_in l = match l with
  | GR.Exit -> Dataflow exit_fact
  | _ -> comp.last_in l in
  { comp with last_in = last_in } 

let run f c e d blocks = run "backward" "comp.name" f c e (fun () b -> d b) () blocks

let rec solve_graph fact comp graph exit_fact =
  general_backward fact (comp_with_exit comp exit_fact) graph;
  fact.get' GR.entry_uid 
and general_backward fact comp graph =
  let changed = ref false in
  let update = update fact changed in
  let set_block_fact b =
    let block_in = 
      let rec head_in h out = match h with
        | GR.Head (h, m) ->
            let a = match comp.middle_in out m with
              | Dataflow a -> a
              | Rewrite g -> solve_graph fact comp g out in
            head_in h a
        | GR.First f -> 
            match comp.first_in out f with
            | Dataflow a -> a
            | Rewrite g -> solve_graph fact comp g out in
      let h, l = GR.goto_end (GR.unzip b) in
      let a = match comp.last_in l with
        | Dataflow a -> a
        | Rewrite g -> solve_graph fact comp g fact.init_info' in
      head_in h a in
    update (GR.id b) block_in in
  let blocks = List.rev (G.postorder_dfs graph) in
  run fact changed fact.init_info' set_block_fact blocks
@ 
<<backward, no txlim>>=
let rec solve_and_rewrite fact comp graph exit_fact changed =
  let a = solve_graph fact comp graph exit_fact in          (* pass 1 *)
  let g, c =                                                (* pass 2 *)
    backward_rewrite fact (comp_with_exit comp exit_fact) graph changed  in
  a, (g, c) 
and backward_rewrite fact comp graph changed =
  let rec rewrite_blocks rewritten fresh changed : G.graph * bool =
    match fresh with
    | [] -> G.of_block_list rewritten, changed
    | b :: bs ->
        let rec rewrite_next_block () =
          let h, l = GR.goto_end (GR.unzip b) in
          match comp.last_in l with
          | Dataflow a -> propagate h a (GR.Last l) rewritten changed
          | Rewrite g ->
              let a, (g, _) =
                solve_and_rewrite fact comp g fact.init_info' changed in
              let t, g = G.remove_entry g in
              let rewritten = add_blocks (G.to_blocks g) rewritten in
              (* continue at entry of g *)
              propagate h a t rewritten true
        and propagate : GR.head -> 'a -> GR.tail -> GR.block list -> bool ->
                          G.graph * bool =
          fun h out tail rewritten changed -> match h with
          | GR.Head (h, m) -> (
              match comp.middle_in out m with
              | Dataflow a -> propagate h a (GR.Tail (m, tail)) rewritten changed
              | Rewrite g ->
                  let a, (g, _) =
                    solve_and_rewrite fact comp g out changed in
                  let t, g = G.splice_tail g tail in
                  let rewritten = add_blocks (G.to_blocks g) rewritten in
                  propagate h a t rewritten true)
          | GR.First f ->
              match comp.first_in out f with
              | Dataflow a ->
                  let b = (f, tail) in
                  rewrite_blocks (b :: rewritten) bs changed
              | Rewrite g -> impossf "rewriting a label in backward dataflow" in
        rewrite_next_block () in
    rewrite_blocks [] (List.rev (G.postorder_dfs graph)) changed
@ 
%%
<<backward, no txlim>>=
module Unique = struct
  module Map = struct
    let empty = G.of_blocks Unique.Map.empty
    let union g1 g2 = G.of_blocks (Unique.Map.union (G.to_blocks g1) (G.to_blocks g2))
    let add k v g = G.of_blocks (Unique.Map.add k v (G.to_blocks g))
  end
end

let rec solve_and_rewrite fact comp graph exit_fact =
  let a = solve_graph fact comp graph exit_fact in          (* pass 1 *)
  let g =                                                (* pass 2 *)
    backward_rewrite fact (comp_with_exit comp exit_fact) graph in
  a, g 
and backward_rewrite fact comp graph =
  let rec rewrite_blocks rewritten fresh =
    match fresh with
    | [] -> rewritten
    | b :: bs ->
        let rec rewrite_next_block () =
          let h, l = GR.goto_end (GR.unzip b) in
          match comp.last_in l with
          | Dataflow a -> propagate h a (GR.Last l) rewritten
          | Rewrite g ->
              let a, g = solve_and_rewrite fact comp g fact.init_info' in
              let t, g = G.remove_entry g in
              let rewritten = Unique.Map.union g rewritten in
              (* continue at entry of g *)
              propagate h a t rewritten 
        and propagate : GR.head -> 'a -> GR.tail -> G.graph -> G.graph =
          fun h out tail rewritten -> match h with
          | GR.Head (h, m) -> (
              match comp.middle_in out m with
              | Dataflow a -> propagate h a (GR.Tail (m, tail)) rewritten 
              | Rewrite g ->
                  let a, g = solve_and_rewrite fact comp g out in
                  let t, g = G.splice_tail g tail in
                  let rewritten = Unique.Map.union g rewritten in
                  propagate h a t rewritten)
          | GR.First f ->
              match comp.first_in out f with
              | Dataflow a ->
                  let b = (f, tail) in
                  rewrite_blocks (Unique.Map.add (GR.id b) b rewritten) bs 
              | Rewrite g -> impossf "rewriting a label in backward dataflow" in
        rewrite_next_block () in
    rewrite_blocks Unique.Map.empty (List.rev (G.postorder_dfs graph)) 


@ 
\section{[[front_last/mvalidate.nw]]}
<<front_last/mvalidate.ml>>=
<<mvalidate.ml>>
@

<<front_last/mvalidate.mli>>=
<<mvalidate.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
\section{RTL Validation}
%%
%%[[Mvalidate.rtl]] checks that operators are used in ways consistent
%%with the target-machine capability record.
%%If we detect that an RTL cannot be
%%compiled then the value returned from [[rtl]] is [[Some s]] where
%%[[s]] is a string explaining why the RTL is invalid.  Otherwise the
%%result is [[None]].
<<mvalidate.mli>>=
val rtl : ('a, 'b, 'c) Target.t -> Rtl.rtl -> string option
@ 
<<mvalidate.ml>>=
open Nopoly

module RP   = Rtl.Private
module Down = Rtl.Dn
module Up   = Rtl.Up
@ 
%%The exception [[RTLInvalid]] is used internally in this module to
%%signal that a RTL cannot be compiled---users never see this.
<<mvalidate.ml>>=
exception RTLInvalid of string
@ 
<<mvalidate.ml>>=
let () = Debug.register "mvalidate" "debug machine-environment validator"
let rtl t r =
  let remove_bits = function
    | Types.Bits n -> n
    | Types.Bool   -> 1
  in
  let impossf fmt = Printf.kprintf Impossible.impossible fmt in
  let imposs = Impossible.impossible in
  let m    = List.map Rtl.Dn.opr t.Target.capabilities.Target.operators in
  let lops = List.map Rtl.Dn.opr t.Target.capabilities.Target.litops in
  let w    = t.Target.wordsize in
  let ns   = t.Target.capabilities.Target.literals in
  Debug.eprintf "mvalidate" "ns is %d length\n" (List.length ns);
  let spaces = Vfp.mk_space w :: t.Target.spaces in
  let name   = t.Target.name in
  let widths ops opname =
    let all = List.find_all (fun (opname',_) -> opname =$= opname') ops in
    List.map (fun (opname, ws) -> ws) all in
  let machine_widths = widths m in
  let literal_widths = widths lops in
  let xy_or_z tostr xyz =
    match List.rev xyz with
    | []    -> impossf "No literal sizes specified for target '%s'" name
    | [z]   -> tostr z
    | z::yx ->
        let xy  = List.rev (List.map tostr yx) in
        let xy' = String.concat ", " xy in
          xy'^" or "^tostr z in
  let sprintf = Printf.sprintf in
  let reject fmt = Printf.kprintf (fun s -> raise (RTLInvalid s)) fmt in
  let spacename (s, _, _) = s in
  let reg s n p1 p2 =
    let space =
      try List.find (fun x -> spacename x.Space.space =<= s) spaces
      with Not_found -> reject "%s" (p1 s name) in
    List.mem n space.Space.widths
    || reject "%s" (p2 s (xy_or_z string_of_int space.Space.widths) n) in
  let rec loc = function
    | RP.Mem(_,n,e,_) -> exp e (* not clear what else to do *)
    | RP.Reg((s,_,cell),_,c) ->
        reg s (Cell.to_width cell c)
          (sprintf "Space '%c' not found in target '%s'")
          (sprintf "Space '%c' only supports width %s; asked for %d")
    | RP.Var(x,_,n) -> n <= w || n mod t.Target.memsize == 0 
      || reject 
          "variable %s of type bits%d should either be at most %d bits wide or else have a width a multiple of %d bits" x n w t.Target.memsize
    | RP.Global(s,_,n) ->
        if s =$= "System.rounding_mode" || s =$= "rm" then
          n = 2 || reject "System.rounding_mode must be 2 bits, not %d" n
        else
          reg 'r' n (fun c s -> imposs "Space 'r' must be available")
            (fun c -> sprintf "Globals only available at %s bits; asked for %d bits")
    | RP.Slice(n,_,l)  -> loc l (* what to check here? *)
  and exp e = exp' None e
  and exp' litcontext e =
    let nonliteral = match litcontext with
    | None -> (fun s -> s)
    | Some op -> (fun s -> reject "operator %%%s may be applied only to \
                                   compile-time constant expressions" op) in
    let rec exp = function
    | RP.Fetch(l, n) -> nonliteral (loc l)
    | RP.App(("or", [resw]), [RP.App(("zx", _), [e]);
                              RP.App(("shl", _), [RP.App(("zx",_), [e']); k])])
        when resw mod w = 0 && exp e && exp e' && exp k -> true
    | RP.App(("lobits", [argw; resw]), [RP.App(("shrl",_), [e; k])]) 
        when resw mod w = 0 && exp e && exp k -> true
        (* should also check that k is a constant multiple of wordsize *)
    | RP.App(("lobits", [argw; resw]), [e]) when resw mod w = 0 && exp e -> true
    | RP.App((opname, ws), es) ->
        let str_of_opty (opname, ws) =
          let (argw, resw) = Rtlop.mono (Rtl.opr opname ws) in
          let argw = List.map remove_bits argw in
          let resw = remove_bits resw in
          String.concat "->" (List.map string_of_int (argw @ [resw])) in
        (* like the widener, we give up on operations not in M *)
        let wss' = machine_widths opname in
        let op_possible wss =
          (* An op is possible if some form exists where each argument is narrower than required.
           * and if we have the right number of arguments. *)
          try List.exists (List.for_all2 (fun w w' -> w <= w') ws) wss
          with Invalid_argument _ -> false in
        if Debug.on "mvalidate" then
          (Printf.eprintf "Validating %%%s::%s..." opname (str_of_opty (opname, ws));
           if op_possible wss' then
             Debug.eprintf "mvalidate" "matches at %s\n"
               (xy_or_z str_of_opty (List.map (fun x -> (opname, x)) wss'))
           else Debug.eprintf "mvalidate" "impossible\n");
        if op_possible wss' then
           List.for_all exp es
        else
          let lit_wss = literal_widths opname in
          if op_possible lit_wss then
            List.for_all (exp' (Some opname)) es
          else
            reject "No acceptable widths for %%%s on target '%s'; \
                    asked for %s, target accepts %s" opname name 
              (str_of_opty (opname, ws))
              (match wss' with [] -> "nothing!"
                   | _ -> xy_or_z str_of_opty (List.map (fun x -> (opname, x)) wss'))
    | RP.Const c -> const c
  and const c =
    let string c = Rtlutil.ToString.exp (Up.exp (RP.Const c)) in
    match c with
    | (RP.Link(_,_,n)) as c -> nonliteral (List.exists (fun w -> n <= w) ns)
      || reject "Constant %s is %d bits but was expected at <= %s bits"
          (string c) n (xy_or_z string_of_int ns)
    | RP.Diff(x,y) -> nonliteral (const x && const y)
    | (RP.Late(_,n)) as c -> nonliteral (List.exists (fun w -> n <= w) ns)
      || reject "Constant %s is %d bits but was expected at <= %s bits"
          (string c) n (xy_or_z string_of_int ns)
    | (RP.Bits b) as c -> List.exists (fun w -> Bits.width b <= w) ns
      || reject "Constant %s is %d bits but was expected at <= %s bits"
          (string c) (Bits.width b) (xy_or_z string_of_int ns)
    | RP.Bool _  -> true in
    exp e in
  let check (g, eff) =
    let eff' =
      match eff with
      | RP.Store(l, r, w) -> loc l && exp r
      | RP.Kill l -> loc l
    in
    eff' && exp g
  in
  let RP.Rtl es = Down.rtl r in
  try
    if List.for_all check es then None
    else Some "No explanation"
  with RTLInvalid s -> Some s
@ 
%$
\section{[[front_last/placevar.nw]]}
<<front_last/placevar.ml>>=
<<placevar.ml>>
@

<<front_last/placevar.mli>>=
<<placevar.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%%%Grades: D Peripheral Later
%%
\section{Placing variables into suitable temporary locations}
%%The [[mk_automaton]] function generates an automaton for placing variables,
%%given a warning function and a function that returns temporaries.
%%The [[context]] variable placer gives an automaton stage the opportunity to put
%%a variable into a temporary; if the opportunity is not used (i.e. the stage
%%passes the buck to its successor), the variable goes into the private block on
%%the stack.
<<placevar.mli>>=
val mk_automaton : warn:(width:int -> alignment:int -> kind:string -> unit) ->
                   vfp:Rtl.exp ->
                   memspace:Rtl.space ->
                   (temps:(char -> Automaton.stage) -> Automaton.stage) ->
                   (Ast2ir.proc -> Automaton.t)
val context : (Ast2ir.proc -> Automaton.t) -> 'e -> Ast2ir.proc -> Ast2ir.proc * bool
@ 
%%The [[replace_globals]] placer replaces global variables with the
%%locations in the procedure's [[global_map]], and otherwise it does
%%nothing. 
<<placevar.mli>>=
val replace_globals : 'a -> Ast2ir.proc -> Ast2ir.proc * bool
@
%%Boilerplate for linking to Lua.
<<placevar.ml>>=
open Nopoly

module A  = Automaton
module G  = Zipcfg
module GR = Zipcfg.Rep
module P  = Proc
module PA = Preast2ir
module R  = Rtl
module RT = Runtimedata
module RU = Rtlutil
module RP = Rtl.Private

<<replace var>>
@ 
<<fetch and store globals>>=
let store_global exp (s, i, w) = proc.P.global_map.(i).A.store (R.Up.exp exp) w in
let fetch_global     (s, i, w) = proc.P.global_map.(i).A.fetch                w in
@    
%%We use a higer-order function to allow different variable placers to replace a variable
%%and take advantage of the rtl-walk.
<<replace var>>=
let replace_var store_var fetch_var store_global fetch_global r =
  <<walk RTL>>
  walkRtl r
@
%%A standard recursive tree walk.
%%The interesting case is [[RP.Fetch]] in [[walkExp]]; we apply the function.
<<walk RTL>>=
let rec walkLoc loc =
  match loc with
  | RP.Mem   (sp, w, e, ass) -> RP.Mem (sp, w, walkExp e, ass)
  | RP.Reg   (sp, i, w) as r -> r
  | RP.Var   (s, i, w)       -> Impossible.unimp "slice of variable"
  | RP.Global(s, i, w)       -> Impossible.unimp "slice of global variable"
  | RP.Slice (w, i, l)       -> RP.Slice (w, i, walkLoc l)

and walkExp exp = match exp with
  | RP.Const _                      -> exp
  | RP.Fetch (RP.Var    (s,i,w), _) -> R.Dn.exp (fetch_var    (s,i,w))
  | RP.Fetch (RP.Global (s,i,w), _) -> R.Dn.exp (fetch_global (s,i,w))
  | RP.Fetch (l, w)                 -> RP.Fetch (walkLoc l, w)
  | RP.App   (op, exps)             -> RP.App(op, List.map walkExp exps)
and upExp e = R.Up.exp (walkExp e)
and upLoc l = R.Up.loc (walkLoc l)
  
and walkEffect effect = match effect with
  | RP.Store (RP.Var    (s,i,w), e, _) -> store_var    (walkExp e) (s,i,w)
  | RP.Store (RP.Global (s,i,w), e, _) -> store_global (walkExp e) (s,i,w)
  | RP.Store (l, e, w)        -> R.store (upLoc l) (upExp e) w
  | RP.Kill  (RP.Var _ | RP.Global _) -> Impossible.unimp "killing variables"
  | RP.Kill  l -> R.kill (upLoc l) in

let walkGuard (exp, effect) = R.guard (upExp exp) (walkEffect effect) in

let walkRtl r = match Rtl.Dn.rtl r with
  | RP.Rtl gs -> R.par (List.map walkGuard gs) in
@
\subsection{Variable Placement by Execution Estimate}
%%This variable placer bases its decisions on how often a variable is used in each
%%context.
%%We use a table of operator contexts to find the context in which a variable is used
%%in each instruction.
%%We weight each context of a variable by the number of times the instruction is
%%executed.
%%We place the variable in the context in which it is used most often in the procedure.
<<placevar.ml>>=
module IntMod  = struct type t = int            let compare = compare end
module IM = Map.Make (IntMod)
module NM = Unique.Map
module SM = Strutil.Map
@
%%The first argument to the variable placer is a function that takes a [[proc.t]] and
%%returns an automaton.
%%The automaton provides locations for variables.
%%The automaton must return unsplit locations.
%%In the variable placer, we rely on this guarantee; for an automaton used in calling
%%conventions, we have no such guarantees.
<<placevar.ml>>=
<<define context count structures>>
let context autmtn _ (g, ({ Proc.target = PA.T tgt; Proc.formals = formals;
                            Proc.var_map = tMap} as proc)) =
  let changed = ref false in
  let autmtn  = autmtn (g, proc) in
  <<initialize context count structures>>
  <<get operator contexts>>
  <<estimate [[exec_counts]] for graph nodes>>
  <<count uses in each context>>
  <<choose a context for each variable>>
  <<replace variables with temps>>
  <<freeze [[autmtn]] and make sure its overflow block is empty>>
  <<add variable placements to spans>>
  (g, proc), !changed
@
%%For each variable, we keep track of how many times it is used in each context.
%%We use mutable state to store the counts for each variable, and we keep the records
%%in an array indexed by the variable number.
<<define context count structures>>=
type counts = { mutable intc   : float
              ; mutable floatc : float
              ; mutable addrc  : float
              ; mutable boolc  : float
              }
@
<<initialize context count structures>>=
let new_count _ = { intc = 0.0; floatc = 0.0; addrc = 0.0; boolc = 0.0}        in
let var_counts = Array.init proc.Proc.vars new_count                           in
let inc_int   i f = let record = var_counts.(i)                                in
                    record.intc <- record.intc +. f                            in
let inc_float i f = let record = var_counts.(i)                                in
                    record.floatc <- record.floatc +. f                        in
let inc_addr  i f = let record = var_counts.(i)                                in
                    record.addrc <- record.addrc +. f                          in
let inc_bool  i f = Error.warningPrt "variable found in boolean context"       in
let inc_rm    i f = Error.warningPrt "variable found in rounding mode context" in
@
%%A call to [[Context.standard]] returns a list of (operator, parameter list, result)
%%triples, where the argument list and result tell us in what context the arguments and 
%%results are expected by the operator.
%%To speed lookup, we use a map to hold this information.
%%THERE IS A LATENT BUG HERE.  WE SHOULD BE USING A TARGET-DEPENDENT CONTEXT.
<<get operator contexts>>=
let ops =
  let context = Context.full inc_int inc_float inc_rm inc_bool [] in
  let add map (op, parms, res) = SM.add op (parms, res) map in
  List.fold_left add SM.empty context in
let ctxt_parms  op = try Some (fst (SM.find op ops)) with Not_found -> None in
let ctxt_result op = try Some (snd (SM.find op ops)) with Not_found -> None in
@
%%For now, we don't estimate execution counts; we assume each node is executed once.
<<estimate [[exec_counts]] for graph nodes>>=
let exec_counts = G.fold_blocks (fun b map -> NM.add (GR.id b) 1.0 map) NM.empty g  in
let get_exec_count b = try NM.find (GR.id b) exec_counts
                       with Not_found -> Impossible.impossible "node not counted" in 
@
%%We use the execution counts and the table of operator contexts to estimate how many
%%times each variable is used in each context.
%%The function [[count]] calls [[count_rtl]] to walk the rtl's and count uses.
<<count uses in each context>>=
let count (block : GR.block) =
  <<define counting functions>>
  let rec count = function
    | GR.Tail (m, t) -> begin count_rtl (GR.mid_instr m); count t end
    | GR.Last l -> count_rtl (GR.last_instr l) in
  let (first, tail) = block in
  count tail in
let () = G.iter_blocks count g in
@
%%The function [[count_rtl]] walks an rtl in a top-down fashion, looking for the use of
%%an operator.
%%If an operator is found and its argument or result is a variable, we increment the
%%number of times the variable has been used in its current context (as determined by the
%%operator).
%%Counting arguments to an operator is easy (see [[count_exp]]), but counting the result
%%of the operator requires a special case in [[count_effect]].
<<define counting functions>>=
let rec count_loc loc ctxt = match loc with
  | RP.Mem   (_, _, e, _) -> count_exp e (Some inc_addr)
  | RP.Slice (_, _, l)    -> count_loc l ctxt
  | RP.Reg    _           -> ()
  | RP.Global _           -> ()  (* cannot be placed based on context *)
  | RP.Var   (_, i, _)    ->
    (match ctxt with
     | None   -> ()
     | Some c -> c i (get_exec_count block))

and count_exp exp ctxt = match exp with
  | RP.Const _        -> ()
  | RP.Fetch (l, _)   -> count_loc l ctxt
  | RP.App ((op, _), exps) ->
    let ctxts = match ctxt_parms op with
                | None    -> List.map (fun s -> None)   exps
                | Some cs -> List.map (fun c -> Some c) cs   in
    try List.iter2 count_exp exps ctxts
    with Invalid_argument _ -> Impossible.impossible "bad context in placevar" in

let count_effect effect = match effect with
  | RP.Store (l, (RP.App ((op, _), _) as e), _) ->
      (count_exp e None ; count_loc l (ctxt_result op))
  | RP.Store (l, e, _) -> (count_exp e None ; count_loc l None)
  | RP.Kill   l        -> count_loc l None in

let count_guard (exp, effect) = (count_effect effect ; count_exp exp None) in

let rec count_rtl r = match Rtl.Dn.rtl r with
  | RP.Rtl gs -> List.iter count_guard gs in
@
%%For each variable, we choose the context with the most votes.
%%The default context is "int".
<<choose a context for each variable>>=
let default_kind = "int" in
let ctxt_map =
  let elect i =
    let cnts = var_counts.(i) in
    let icnt = cnts.intc      in
    let fcnt = cnts.floatc    in
    let acnt = cnts.addrc     in
    let (cnt,ctxt) = if icnt >=. fcnt then (icnt,"int") else (fcnt, "float") in
    if cnt >=. acnt then ctxt else "address" in
  Array.init proc.Proc.vars elect in
@
%%To replace a variable, we use the automaton to allocate a new fetch of the variable,
%%and we extract the location.
%%The automaton relies on a kind to return an appropriate location.
%%If the variable is a formal argument with a kind, we use that kind and issue a warning
%%if it is different from the elected kind.
%%The function [[choose_kind]] is responsible for detecting and handling formal
%%arguments.
%%We do not issue a warning if the elected kind is the default, with zero votes.
%%
%%WE DON'T INFER ANY ALIGNMENT.  SHOULD WE WORRY?
<<context replace var>>=
let formal_arr = Array.make proc.Proc.vars None in
let () = List.iter (fun (i,v) -> formal_arr.(i) <- Some v) formals in
let choose_ty i elected_kind = 
  let space_name = function "signed" | "unsigned" | "" -> "int"
                          | n                          -> n     in
  match formal_arr.(i) with
  | Some (Some ("address" as h), _, _, n, a) when elected_kind =$= "int" ->
    if tgt.Target.distinct_addr_sp then
      Impossible.unimp "Var placer does not distinguish addr and int spaces"
    else h, a
  | Some (Some h, _, _, n, a) when Pervasives.(<>) (space_name h) elected_kind ->
    let votes = var_counts.(i) in
    begin
      (if not (elected_kind =$= default_kind) || votes.intc <>. 0.0 then
        let error_str =
          ( Printf.sprintf
              "Kind \"%s\" on formal parameter %s differs from inferred kind \"%s\":\n"
              h n elected_kind
          ^ Printf.sprintf "  {int: %f, float: %f, addr: %f}"
                           votes.intc votes.floatc votes.addrc) in
        Debug.eprintf "placevar" "%s" error_str);
      h, a
    end
  | _ -> elected_kind, None in
  
let get_placer i w =
  match tMap.(i) with
  | Some a -> a
  | None   -> let kind, aligned = choose_ty i ctxt_map.(i) in
              let alloc = A.allocate autmtn w kind (Auxfuns.Option.get 1 aligned) in
              (changed := true;
               tMap.(i) <- Some alloc;
               alloc) in
let store_var exp (s, i, w) = (get_placer i w).A.store (R.Up.exp exp) w in
let fetch_var     (s, i, w) = (get_placer i w).A.fetch                w in
@
%%We fold over the nodes, replacing variables with each variable with a temp for the
%%proper context.
<<replace variables with temps>>=
<<context replace var>>
<<fetch and store globals>>
let update rtl = replace_var store_var fetch_var store_global fetch_global rtl in
let g = G.map_rtls update g in
<<verbosely dump [[tMap]]>>
@ 
%%
<<verbosely dump [[tMap]]>>=
let () =
  if Debug.on "placevar" then
    let loc = function
      | None -> "<??none??>"
      | Some l -> RU.ToString.exp (l.A.fetch 99) in
    Printf.eprintf "Varmap: Var i -> Loc\n";
    Array.iteri (fun i l -> Printf.eprintf "  %d -> %s\n" i (loc l)) tMap in
@
<<placevar.ml>>=
let () = Debug.register "placevar" "variable placer"
@
<<freeze [[autmtn]] and make sure its overflow block is empty>>=
let aresult = A.freeze autmtn in
let _ = if Block.size aresult.A.overflow <> 0 then
          Impossible.impossible "nonempty overflow from placing variables" in
@
<<placevar.ml>>=
let ( *> ) = A.( *> )

let from_temps proc space = (* stage to allocate a temporary location *)
  let allocator = Talloc.Multiple.loc proc.Proc.temps space in
  let alloc ~width:w ~alignment:a ~kind:h = A.of_loc (allocator w) in
  A.wrap (fun methods -> {A.allocate = alloc; A.freeze = methods.A.freeze})

let debug lbl w h a ctr =
  Printf.eprintf "Placevar %s w=%d h=%s a=%d ctr=%d\n" lbl w h a ctr

let mk_automaton ~warn ~vfp ~memspace mk_stage (g, proc) =
  let warn methods =
    let alloc ~width:w ~alignment:a ~kind:h =
      warn ~width:w ~alignment:a ~kind:h;
      methods.A.allocate w a h in
    {A.allocate = alloc; A.freeze = methods.A.freeze} in
  Block.srelative vfp "variables placed in memory" (A.at memspace)
  ( A.wrap warn *> mk_stage ~temps:(from_temps proc) *> A.as_stage proc.Proc.priv )
@
%%After we have placed the variables, we record their locations in the spans.
<<add variable placements to spans>>=
let upd_var e = match R.Dn.loc e with
  | RP.Var (_,i,_) -> (match tMap.(i) with
                       | None   -> raise RT.DeadValue
                       | Some l -> (Automatonutil.aloc l tgt.Target.wordsize))
  | _              -> e in
RT.upd_all_spans upd_var g;
@
<<placevar.ml>>=
let replace_globals _ (g, ({ Proc.target = tgt; Proc.global_map = gmap} as proc)) =
  let subst = RU.Subst.aloc ~guard:(function RP.Global _ -> true | _ -> false)
                ~map:(function RP.Global (_, i, _) -> gmap.(i)
                             | l -> Impossible.impossible "global replacement") in
  let subst =
    if Debug.on "placevar" then
      (fun rtl ->
        let rtl' = subst rtl in
        Printf.eprintf "Placing vars maps\n  %s\nto\n  %s\n"
          (RU.ToString.rtl rtl) (RU.ToString.rtl rtl');
        rtl')
    else
      subst in
  (G.map_rtls subst g, proc), true (* probably changed :-) *)
@
\section{[[front_last/vfp.nw]]}
<<front_last/vfp.ml>>=
<<vfp.ml>>
@

<<front_last/vfp.mli>>=
<<vfp.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vi users, do your worst on this line!
%%
\section{Virtual frame pointer}
%%
%%This file contains some notes about a virtual frame pointer.
%%One day it may contain a substitution algorithm.
%%
%%The problem we're trying to solve is how to deal with a stack pointer
%%that moves around.
%%\begin{itemize}
%%\item
%%In the presence of tail calls, a stack pointer may have at least three
%%values: the value on entry, the value on exit, and the value between
%%prolog and epilog.
%%\item
%%Depending on calling convention, the stack pointer may be moved by a
%%callee.
%%\item
%%On some targets, it may be pleasant to use push or pop instructions to
%%save or restore nonvolatile registers.
%%\end{itemize}
%%If the stack pointer moves, it is difficult to use it to address the
%%activation record.  This note suggests a solution by means of a
%%\emph{virtual frame pointer}.
%%
%%A virtual frame pointer is an immutable run-time value used to address
%%locations on the stack.
%%For simplicity, we say that the value of the virtual frame pointer is
%%the value the stack pointer had at procedure entry.
%%
%%To use a virtual frame pointer effectively, we require certain
%%conventions:
%%\begin{itemize}
%%\item
%%All addressing expressions referring to data on the stack are written
%%in the form $\mathtt{Fetch}(\vfp)+k$, where $k$~is a (possibly late) compile-time
%%constant.\footnote
%%{From here on, we omit the \texttt{Fetch}.}
%%In particular, an addressing expression returned by the block
%%abstraction is of
%%the form \mbox{$\vfp+k$}.
%%The stack pointer is never used in an addressing expression.
%%\item
%%The \vfp\ is immutable, so it never appears in an lvalue context.
%%\item
%%We normally set $\sp$ by an assignment of the form
%%\mbox{$\sp \gets \vfp + k$}, but we might also adjust the stack pointer by an
%%assignment of the form 
%%\mbox{$\sp \gets \sp + k$}.
%%\end{itemize}
%%
%%At procedure entry, the calling convention dictates where the stack
%%pointer is relative to the overflow incoming parameters (and possibly
%%return address).
%%This is probably at the extreme young end of the stack (high or low
%%depending on the direction of stack growth).
%%In any case, the calling convention should provide not only the block
%%and the locations of parameters but the location of the stack pointer.
%%This location is, of course, where the virtual frame pointer points.
%%
%%To enter the procedure, we need to allocate its activation record and
%%to move all the parameters, the return 
%%address, and the callee-saves registers into their ``private''
%%locations, where they reside for the duration of the procedure.
%%\begin{enumerate}
%%\item
%%Find the extreme young end of the stack frame and call that
%%location~$y$.
%%Invent a fresh, late compile-time constant $n$~to stand for the frame
%%size, and write the equation $y=\vfp-n$.
%%\item
%%Emit the instruction $\sp \gets \vfp-n$.
%%\item
%%Emit a big shuffle as a single RTL.
%%This shuffle does all the moves noted above.
%%It's the code expander's job to eliminate redundant moves and do the
%%remaining moves in the right order.
%%It's the job of 
%%the code that chooses stack slots for variables and callee-saves
%%registers to maximize the number of redundant moves.
%%\end{enumerate}
%%This prolog is very simple, but it may be hard to discover push
%%instructions.
%%On a machine that favors push instructions (such as the $x$86), 
%%we might want a somewhat different prolog.
%%
%%The epilog works similarly, by issuing a big shuffle for the
%%nonvolatile registers and the return value.
%%
%%After the stack is frozen, we can compute for each node~$n$ the equation
%%\mbox{$\vfp = \sp+k_n$}, where  $k_n$~may be different at each node.
%%This equation holds on any edge flowing into~$n$:
%%consistency is required at each join point.
%%We compute $k_n$ as a forward dataflow problem.
%%We know that $\vfp$~is immutable, and that on entry $\vfp=\sp$.
%%We can therefore start at the entry node and propagate information
%%forward.
%%\begin{itemize}
%%\item
%%If we encounter a node that doesn't touch \sp, nothing happens.
%%\item
%%If we know $\vfp=\sp+k$ and we
%% encounter a node with \mbox{$\sp \gets \sp+k'$}, 
%%then after that node \mbox{$\vfp=\sp+(k-k')$}.
%%\item
%%If we know $\vfp=\sp+k$ and we
%% encounter a node with \mbox{$\sp \gets \vfp+k'$}, 
%%then after that node $\vfp=\sp-k'$.
%%\item
%%If we encounter any other sort of node, the compiler is broken, and we
%%halt with an assertion failure.
%%\end{itemize}
%%We also need to check the equations for consistency at each join point
%%in the control-flow graph.
%%
%%After we have $\vfp=\sp+k_n$ on entry to each node, we can substitute
%%appropriately for $\vfp$ and simplify.
%%One hopes this step creates no additional work in the code expander.
%%(In real life, we can probably combine the substitution and the
%%computation. The code will appear in this file.) 
%%
%%
%%Other notes:
%%\begin{itemize} 
%%\item 
%%It is OK to add a possibly redundant assignment to \sp\ on an edge
%%flowing out of a call site.
%%If the call does change the stack pointer, it will be reset as needed.
%%If the call does not change the stack pointer, the redundant
%%assignment can be optimized away.
%%\end{itemize}
<<vfp.mli>>=
val mk_space : Rtl.width       -> Space.t
val mk       : Rtl.width       -> Rtl.exp
val is_vfp   : Rtl.Private.loc -> bool
val replace_with : sp:Rtl.loc -> Zipcfg.graph -> Zipcfg.graph * bool
@ 
<<vfp.ml>>=
module D  = Dataflow
module G  = Zipcfg
module GR = Zipcfg.Rep
module P  = Property
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module Dn = Rtl.Dn
module Up = Rtl.Up

let impossf fmt = Printf.kprintf Impossible.impossible fmt

let mk w = Rtl.fetch (Rtl.reg (('V', Rtl.Identity, Cell.of_size w), 0, Rtl.C 1)) w
let is_vfp = function
  | RP.Reg (('V', _, _), 0, _) -> true
  | _ -> false
@ 
%%We replace $\vfp$ by $\sp+k$ using the identity
%%$\vfp = \sp + (\vfp - \sp)$.
<<vfp.ml>>=
let unknown = max_int
let matcher = { P.embed = (fun a -> P.Vfp a);
                P.project = (function P.Vfp a -> Some a | _ -> None);
                P.is = (function P.Vfp a -> true | _ -> false);
              }

let prop = Unique.Prop.prop matcher

let fact sp = {
  D.fact_name = "vfp location";
  D.init_info = (sp, unknown);
  D.add_info =
    (fun (vfp, k as a) (vfp', k' as a') ->
      let () = Debug.eprintf "vfp" "updating vfp dataflow fact\n" in
      if k = k' then a
      else if k = unknown then a'
      else if k' = unknown then a
      else (* accept inconsistency at exit and entry points to cut and unwind contn's *)
        if false (* G.kind node =*= G.Exit || G.is_non_local_join node *) then a
        else impossf "inconsistent stack-pointer location: %d and %d" k k');
  D.changed = (fun ~old:(_, k) ~new':(_, k') -> k <> k');
  D.prop = prop;
}
@ 
<<vfp.ml>>=
let replace_with ~sp =
  let w = RU.Width.loc sp in
  let spval = R.fetch sp w in
  let sp = Dn.loc sp in
  let sp_plus = RU.addk w spval in
  let sp_plus k = Dn.exp (sp_plus k) in
  <<supporting functions>>
  let fact = fact (Dn.exp spval) in
  let middle_out (vfp, k) m txlim =
    <<definition of [[simp]], which is verbose>>
    let i = GR.mid_instr m in
    let down = Dn.rtl i in
    if RU.Exists.Loc.rtl is_vfp down then
      let simp = match m with GR.Stack_adjust _ -> simp | _ -> Simplify.rtl in
      let rtl = simp (replace_vfp vfp i) in
      D.Rewrite (G.single_middle (G.new_rtlm rtl m))
    else
      D.Dataflow (note_sp_changes down vfp k) in

  let last_outs (vfp, k) l txlim =
    let upd vfp rtl = Simplify.rtl (replace_vfp vfp rtl) in
    let set_succs (vfp, k as a) =
      let upd_cedges ces =
        let upd ce = note_sp_changes (Dn.rtl ce.G.assertion) vfp k in
        D.Dataflow (fun set -> List.iter (fun ce -> set (fst ce.G.node) (upd ce))
                                         ces) in
      match l with
      | GR.Cut  (_, ces, _) -> upd_cedges ces
      | GR.Call c           -> upd_cedges c.GR.cal_contedges
      | _ -> D.Dataflow (fun set -> GR.iter_succs (fun u -> set u a) l) in
    let rewrite_assertions l fail =
      let upd_cedges vfp k cedges succ =
        if List.exists (fun ce -> RU.Exists.Loc.rtl is_vfp (Dn.rtl ce.G.assertion))
                       cedges then
          succ (List.map (fun ce -> {ce with G.assertion = upd vfp ce.G.assertion})
                         cedges)
        else fail () in
      match l with
      | GR.Cut (i, ces, r) ->
          let upd ces = D.Rewrite (G.single_last (GR.Cut (i, ces, r))) in
          upd_cedges vfp k ces upd
      | GR.Call c ->
          let upd ces =
            D.Rewrite (G.single_last (GR.Call { c with GR.cal_contedges = ces })) in
          let vfp, k = note_sp_changes (Dn.rtl (GR.last_instr l)) vfp k in
          upd_cedges vfp k c.GR.cal_contedges upd
      | _ -> fail () in
    let i = GR.last_instr l in
    let down = Dn.rtl (GR.last_instr l) in
    let propagate () = match l with
      | GR.Cut _ ->  set_succs (vfp, k)
      | _        ->  set_succs (note_sp_changes down vfp k) in
    if RU.Exists.Loc.rtl is_vfp down then
      let l = G.new_rtll (upd vfp i) l in
      rewrite_assertions l (fun () -> D.Rewrite (G.single_last l))
    else rewrite_assertions l propagate in
  let repl =
    { D.F.name = "replace vfp";
      D.F.middle_out = middle_out; D.F.last_outs = last_outs; } in
  D.F.rewrite (fact, repl) ~entry_fact:(Dn.exp spval, 0)
@ 
<<definition of [[simp]], which is verbose>>=
let simp rtl =
  let str = Rtlutil.ToString.rtl in
  let rtl' = Simplify.Unsafe.rtl rtl in
  Debug.eprintf "vfp"
    "Simplified stack adjustment from %s to %s\n" (str rtl) (str rtl');
  rtl' in
@
%%
<<vfp.ml>>=
let () = Debug.register "vfp" "stack adjustments for virtual frame pointer"
@ 
<<supporting functions>>=
let replace_vfp value =
  let is_vfp = function
    | RP.Fetch (v, _) -> is_vfp v
    | _ -> false in
  RU.Subst.exp ~guard:is_vfp ~map:(fun _ -> value) in
@ 
%%All we ever have to cope with is $\sp \gets \sp \pm k'$.
%%We have
%%{\newcommand\post[1]{\bar{#1}}%
%%\begin{eqnarray}
%%\vfp &=& \sp + k\\
%%\post\sp &=& \sp + k'\\
%%\vfp &=& \post\sp + \post k\\
%%\end{eqnarray}
%%We solve for $\post k = k - k'$.}
<<supporting functions>>=
let rec note_sp_changes rtl vfp k =
  if RU.Exists.Loc.rtl (RU.Eq.loc sp) rtl then
    let k' = find_k'_added_to_sp rtl in
    let post_k = k - k' in
    sp_plus post_k, post_k
  else
    vfp, k
and find_k'_added_to_sp (RP.Rtl ges) =
  let rec find found k' = function
    | [] -> k' (* could be zero if only assignment is guarded *)
    | (RP.Const (RP.Bool b), RP.Store (sp', e, w)) :: ges when RU.Eq.loc sp sp' ->
        if not b then
          find found k' ges
        else if found then
          Impossible.impossible "multiple assignments to stack pointer"
        else
          (match e with
          | RP.App (("add", [_]), [RP.Fetch(sp', _); RP.Const (RP.Bits k')])
            when RU.Eq.loc sp' sp -> find true (Bits.S.to_int k') ges
          | RP.App (("add", [_]), [RP.Const (RP.Bits k'); RP.Fetch(sp', _)])
            when RU.Eq.loc sp' sp -> find true (Bits.S.to_int k') ges
          | RP.App (("sub", [_]), [RP.Fetch(sp', _); RP.Const (RP.Bits k')])
            when RU.Eq.loc sp' sp -> find true (- (Bits.S.to_int k')) ges
          | RP.Fetch (sp', _)
            when RU.Eq.loc sp' sp -> find true 0 ges
    |	_ -> Printf.printf "illegal sp assignment: sp := %s\n" (RU.ToString.exp (Up.exp e)) ; 0)
(* RRO temp
          | _ -> Impossible.impossible ("sp assigned other than sp + k: " ^
                                        RU.ToString.exp (Up.exp e)))
*)
    | (g, RP.Store (sp', e, w)) :: ges when RU.Eq.loc sp sp' ->
        Impossible.impossible ("assigned sp with nontrivial guard " ^
                               Rtlutil.ToString.exp (Rtl.Up.exp g))
    | (g, RP.Kill sp') :: ges when RU.Eq.loc sp sp' -> 
        Impossible.impossible "killed sp"
    | _ :: ges -> find found k' ges in
  find false 0 ges in
@ 
<<vfp.ml>>=
let mk_space w = 
    { Space.space = ('V', Rtl.Identity, Cell.of_size w)
    ; Space.doc = "holds the virtual frame pointer"
    ; Space.indexwidth = w
    ; Space.indexlimit = None
    ; Space.widths = [w]
    ; Space.classification = Space.Fixed
    }
@ 

\chapter{[[arch/dummy]]}

\section{[[arch/dummy/dummy.nw]]}
<<arch/dummy/dummy.ml>>=
<<dummy.ml>>
@

<<arch/dummy/dummy.mli>>=
<<dummy.mli>>
@

%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et:
%%
%%% ------------------------------------------------------------------ 
\section{The Dummy Target}
%%% ------------------------------------------------------------------ 
%%
%%This target describes a purely fictional target. We use it for
%%debugging. The target is functorized, such that we can invent new
%%targets easily. 
%%
%%\emph{The Implementation uses the [[Space.Standard32]] module to define
%%control-flow {\rtl}s. We therefore assume therefore pointer and words
%%are 32 bit wide. Is it safe to pass in other values? --CL}
<<dummy.mli>>=
module type ARCH = sig
    val arch:           string (* name of this architecture *)
    val byte_order:     Rtl.aggregation
    val wordsize:       int
    val pointersize:    int
    val memsize:        int
end

module Make(A: ARCH): sig
    val target' :       Ast2ir.tgt
end    
@
%%We provide ready-made 32 bit targets.
<<dummy.mli>>=
val dummy32l':  Ast2ir.tgt
val dummy32b':  Ast2ir.tgt
@
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
<<dummy.ml>>=
module AN       = Automaton
module C        = Call
module PA       = Preast2ir
module R        = Rtl
module RP       = Rtl.Private
module RU       = Rtlutil
module Up       = Rtl.Up
module Dn       = Rtl.Dn
module SS32     = Space.Standard32
module T        = Target
module RS       = Register.Set

module type ARCH = sig
    val arch:           string (* name of this architecture *)
    val byte_order:     Rtl.aggregation
    val wordsize:       int
    val pointersize:    int
    val memsize:        int
end

let ( *> ) = AN.( *> ) 

(* to simplify the machine environment definition *)
let b i = Types.Bits i

module Make(A: ARCH) = struct
    let id          = Rtl.Identity
    let pointersize = A.pointersize
    let memsize     = A.memsize

    <<module Spaces>>

    (* important registers *)
    let {SS32.cc = eflags} = SS32.locations Spaces.c
    let locations   = SS32.locations Spaces.c
    let pc          = locations.SS32.pc
    let cc          = locations.SS32.cc
    let npc         = locations.SS32.npc
    let fp_mode     = locations.SS32.fp_mode
    let fp_fcmp     = locations.SS32.fp_fcmp

    let rspace = ('r', Rtl.Identity, Cell.of_size A.wordsize)
    let fspace = ('f', Rtl.Identity, Cell.of_size A.wordsize)
    let mspace = ('m', A.byte_order, Cell.of_size 8)
    let reg n       = R.reg (rspace,n,R.C 1)
    let sp          = reg 31                    (* stack pointer  *)
    let ra          = reg 30                    (* return address *)

    let fetch l     = R.fetch l   A.wordsize
    let store l e   = R.store l e A.wordsize
    let assign      = store
    let return      = store pc (fetch ra)

    <<global register allocation>>
    <<module Flow>>
    <<module Spill>>
    <<module CC for calling conventions>>

    let ccspecs = {AN.call=CC.simple; AN.results=CC.simple; AN.cutto=CC.simple}
        (* the new-style target *)
    let fmach = Flow.machine sp
    let target' = 
      let PA.T x86_tgt = X86.target in
      let spaces  = [ Spaces.m 
                    ; Spaces.c 
                    ; Spaces.r 
                    ; Spaces.f
                    ; Spaces.t
                    ; Spaces.u
                    ] in
        { T.name         = A.arch
        ; T.cc_specs     = [ "C--", ccspecs
                           ; "C"  , ccspecs
                           ] 
        ; T.cc_spec_to_auto = (fun ccname spec -> CC.conv "C--" false spec)
        ; T.is_instruction  = (fun _ -> true)
        ; T.tx_ast = (fun secs -> secs)
(* Using the same M as x86 so that tests don't fail.
   Not sure what the right M is for dummy. KR *)
        ; T.capabilities = x86_tgt.T.capabilities
        ; T.byteorder    = A.byte_order
        ; T.wordsize     = A.wordsize
        ; T.pointersize  = A.pointersize
        ; T.vfp          = SS32.vfp
        ; T.memspace     = mspace
        ; T.max_unaligned_load  = R.C 1
        ; T.alignment    = 1
        ; T.memsize      = 8
        ; T.float        = Float.ieee754
        ; T.globals      = globals
        ; T.rounding_mode = fp_mode
        ; T.named_locs   = Strutil.assoc2map 
                           ["IEEE 754 rounding mode", fp_mode
                           ;"IEEE 754 rounding results", fp_fcmp
                           ]
        ; T.spaces       = spaces
        ; T.reg_ix_map   = T.mk_reg_ix_map spaces
        ; T.distinct_addr_sp = false
        ; T.machine = { T.bnegate     = fmach.T.bnegate
                      ; T.goto        = fmach.T.goto
                      ; T.jump        = fmach.T.jump
                      ; T.call        = fmach.T.call 
                      ; T.cutto       = cutto
                      ; Mflow.return  = fmach.Mflow.return
                      ; T.branch      = fmach.T.branch
                      ; T.move        = (fun _ -> assert false)
                      ; T.spill       = (fun _ -> assert false)
                      ; T.reload      = (fun _ -> assert false)
                      ; T.retgt_br    = fmach.T.retgt_br
                      ; T.forbidden   =
                          Rtl.store (Rtl.mem Rtl.none mspace (Rtl.C 1)
                                            (Rtl.bits (Bits.zero 32) 32))
                                    (Rtl.bits (Bits.zero 8) 8) 8
                      }
        (* bogus *)
        ; T.charset      = "latin1" 
        ; T.data_section = "data"
        }
    let target' = PA.T target'
end

module Dummy32l = Make(struct
    let arch        = "dummy32l"
    let byte_order  = Rtl.LittleEndian
    let wordsize    = 32
    let pointersize = 32
    let memsize     = 8
end)

module Dummy32b = Make(struct
    let arch        = "dummy32b"
    let byte_order  = Rtl.BigEndian
    let wordsize    = 32
    let pointersize = 32
    let memsize     = 8
end)

let dummy32l' = Dummy32l.target'
let dummy32b' = Dummy32b.target'
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Global Register Allocation}
%%% ------------------------------------------------------------------ 
%%
%%\emph{Note: after introducing the new Automaton model we discovered 
%%that the mechanism for dealing with named hardware registers has to
%%change. Therefore, the automaton for global registers no longer deals
%%with them.}
%%
<<global register allocation>>=
let globals base = 
    let width w     = if w <= 8 then 8 else if w <= 16 then 16 else
                      Auxfuns.round_up_to 32 w in
        AN.at ~start:base mspace
              (AN.widen width 
               *> AN.align_to (function 8 -> 1 | 16 -> 2 | _ -> 4)
               *> AN.overflow ~growth:Memalloc.Down ~max_alignment:4)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Spaces}
%%% ------------------------------------------------------------------ 
%%
<<module Spaces>>=
module Spaces = struct
    let m   = SS32.m A.byte_order [8; 16; 32]
    let c   = SS32.c 2  id [32]
    let r   = SS32.r 32 id [32]
    let f   = SS32.f 32 id [32]
    let t   = SS32.t    id  32
    let u   = SS32.u    id  32
end                 
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Control Flow}
%%% ------------------------------------------------------------------ 
%%
<<module Flow>>=
module Flow = Mflow.MakeStandard
    (struct
        let pc_lhs      = pc
        let pc_rhs      = pc
        let ra_reg      = R.reg (rspace, 30, R.C 1)
        let ra_offset   = 4 (* just guessing *)
    end)

let cutto =                 
    { T.embed   = (fun _ { Mflow.new_pc=newpc
                         ; Mflow.new_sp=newsp
                         } ->
                         (Dag.Nop, Rtl.par [assign (reg 31) newsp; assign pc newpc]))
    ; T.project = (fun r -> match Dn.rtl r with
                    | RP.Rtl [ (_, RP.Store(_, nsp, _)) 
                             ; (_, RP.Store(_, npc, _))] -> 
                                { Mflow.new_sp =Up.exp nsp
                                ; Mflow.new_pc= Up.exp npc
                                }  
                    | _ -> Impossible.impossible "projected non-cutto")
    }
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Spills and Reloads}
%%% ------------------------------------------------------------------ 
%%
%%\emph{What is the [[lookup]] parameter for? We should expunge it.}
%%
<<module Spill>>=
module Spill = struct
  let assign lookup ~src ~dst =
    if Register.width src <> Register.width dst then
      Impossible.impossible "Dummy.assign source and destination width don't match"
    else
      let src_loc = Rtl.reg src  in
      let dst_loc = Rtl.reg dst  in
      Rtl.store dst_loc (Rtl.fetch src_loc (Register.width src)) (Register.width dst)

  let spill lookup reg loc =
    let w = Register.width reg in
    [Automaton.store loc (Rtl.fetch (Rtl.reg reg) w) w]

  let reload lookup reg loc =
    let w = Register.width reg in
    [Rtl.store (Rtl.reg reg) (Automaton.fetch loc w) w]
end
@        
%%
%%% ------------------------------------------------------------------ 
\subsection{Calling Conventions}
%%% ------------------------------------------------------------------ 
%%
<<module CC for calling conventions>>=
module CC = struct
    <<calling convention>>
end
@
%%
%%% ------------------------------------------------------------------ 
\subsection{New-Style Calling Convention}
%%% ------------------------------------------------------------------ 
%%
%%
%%\paragraph{Important registers}
%%
<<calling convention>>=
let reg  n   = (rspace, n, R.C 1)
let freg n   = (fspace, n, R.C 1)
let vfp      = Vfp.mk A.wordsize
let regs     = List.map reg  [0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15]
let fregs    = List.map freg [0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15] 
@
%%Volatile and non-volatile registers. For simplicity, all registers are
%%volatile.
<<calling convention>>=
let volregs  = RS.union (RS.of_list regs) (RS.of_list fregs)
let nvolregs = RS.empty     
@
%%
%%\paragraph{Conventions}
%%
%%The documentation for the $x$86 warns to use [[minus frame size]]. I
%%hope we are allowed to use it once per target, rather than once per
%%compiler.
%%
<<calling convention>>=
let spval           = fetch sp         
let sp_align        = 4
let growth          = Memalloc.Down
let std_sp_location = RU.add pointersize 
                        vfp (R.late "minus frame size" pointersize)
@
%%
%%\paragraph{Automata for passing values}
%%
%%We pass everything in registers, until we run out of them and pass
%%remaining parameters in memory. We use 16 floating point and 16 integer
%%registers. 
%%
<<calling convention>>=
let simple =
    AN.choice
        [ AN.is_kind "float",  AN.widen (Auxfuns.round_up_to ~multiple_of:32) 
                            *> AN.widths  [32]
                            *> AN.useregs fregs false
        ; AN.is_any,         AN.widen (Auxfuns.round_up_to ~multiple_of:32)
                          *> AN.widths  [32]
                          *> AN.useregs regs false
        ] *> 
    AN.overflow ~growth:Memalloc.Down ~max_alignment:sp_align
@
%%
%%
%%The [[return]] instruction for a possibly alternate return.
%%
<<calling convention>>=
let return k n ~ra =
    if k = 0 && n = 0 
    then store pc ra
    else Impossible.impossible "alternate return is unsupported"
@
%%
%%How to save callee-saved registers. 
%%
<<calling convention>>=
let saved_nvr temps =
    let t = Talloc.Multiple.loc temps 't' in
    let u = Talloc.Multiple.loc temps 'u' in
        function
        | (('r', _, _),_,_) as reg -> t (Register.width reg)
        | (('f', _, _),_,_) as reg -> u (Register.width reg)
        | ((s,_,_),i,_) ->
            Impossible.impossible (Printf.sprintf "cannot save $%c%d" s i)
@
%$
%%
%%I have to admit, that I don't know what I am doing here.
%%
<<transformations(dummy.nw)>>=
let autoAt = AN.at mspace in
let call_actuals  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out call parms" autoAt specs.AN.call)
    ~autosp:(fun r  -> Block.base r.AN.overflow)
    ~postsp:(fun _ sp -> sp) in  

let prolog  =
  let autosp = (fun _ -> vfp) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in call parms" autoAt specs.AN.call)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a) in

let call_results  =
  let autosp = (fun r -> Block.base r.AN.overflow) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in ovfl results" autoAt specs.AN.results)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location) (* irrelevant? *)
    ~insp:(fun a _ _ -> autosp a) in

let epilog  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out ovfl results" autoAt specs.AN.results)
    ~autosp:(fun r -> Block.base r.AN.overflow)
    ~postsp:(fun _ _ -> vfp)  (* irrelevant *) in

let also_cuts_to =
  let autosp = (fun r -> std_sp_location) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in cont parms" autoAt specs.AN.cutto)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a) in

let cut_actuals base  =
   C.outgoing ~growth ~sp ~mkauto:(fun () -> autoAt base specs.AN.cutto)
     ~autosp:(fun r -> spval)
     ~postsp:(fun _ _ -> spval) in
@ 
%%
<<calling convention>>=
let conv name jump specs =
  <<transformations(dummy.nw)>>
  { C.name             = name
  ; C.overflow_alloc  = { C.parameter_deallocator = if jump then C.Callee else C.Caller
                        ; C.result_allocator      = C.Caller
                        }
  ; C.call_parms       = { C.in' = prolog;       C.out = call_actuals}
  ; C.cut_parms        = { C.in' = also_cuts_to; C.out = cut_actuals}
  ; C.results          = { C.in' = call_results; C.out = epilog}
 
  ; C.stack_growth     = Memalloc.Down
  ; C.stable_sp_loc    = std_sp_location
  ; C.replace_vfp      = Vfp.replace_with ~sp
  ; C.jump_tgt_reg     = R.reg (reg 7)
  ; C.sp_align         = sp_align    (* alignment of stack pointer at call/cut *)
  ; C.pre_nvregs       = nvolregs    (* registers preserved across calls *)
  ; C.volregs          = volregs     (* registers not preserved across calls *)
  ; C.saved_nvr        = saved_nvr
  ; C.return           = return
  ; C.ra_on_entry      = (fun _     -> R.fetch ra A.wordsize)
  ; C.where_to_save_ra = (fun _ t   -> Talloc.Multiple.loc t 't' A.wordsize)
  ; C.ra_on_exit       = (fun t b _ -> t)
  ; C.sp_on_unwind     = (fun e -> RU.store sp e)
  ; C.sp_on_jump       = (fun _ _ -> Rtl.null)
  } 
@ 
%%
%%Finally, we can define a calling convention.
<<calling convention>>=
let cmm = conv "C--" false
            { AN.call = simple ; AN.results = simple ; AN.cutto = simple }
@
\section{[[arch/dummy/dummyexpander.nw]]}
%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et: 
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% ------------------------------------------------------------------ 
\section{Code-Expander for the Dummy Target}
%%% ------------------------------------------------------------------ 
%%
%%The {\rtl}s generated by the \module{Ast3ir} module violate the machine
%%invariant that every {\rtl} must be representable as a machine
%%instruction. A code-expander establishes this invariant by simplifying
%%{\rtl}s. This module provides a toy code expander for the [[Dummy]]
%%target. Although it would be possible to write a generic code expander
%%that works for all targets, we keep things simple and write a
%%specialized one. The expander is specified as a set of {\burg} rules.
%%
%%The idea of code expansion is to store intermediate results into
%%registers.  Registers come in different flavors (c.f.~module
%%\module{Targets}); we use the following notion: 
%%
%%\begin{center}
%%\begin{tabular}{@{\quad}ll}
%%$r$& an integer hardware register, or an integer temporary\\
%%$f$& a floating-point hardware register or a floating-point temporary\\
%%$m$& memory space\\
%%$k$& non-bool constant\\
%%$\oplus$& {\rtl} integer {\rtl} operator \\
%%$\otimes$& {\rtl} floating-point {\rtl} operator \\
%%\end{tabular}
%%\end{center}
%%
%%Or goal is, to re-write all {\rtl}s to the following form:
%%
%%\begingroup
%%\def\gets{$\mathrel{:=}$}%
%%\let\mc\multicolumn
%%
%%\begin{center}
%%\begin{tabular}{rcl@{\quad}l}
%%$r$     & \gets & $k$ & all constants are considered integers\\
%%$r$     & \gets & $r$ \\
%%$r$     & \gets & $\oplus(r, \ldots, r)$ \\
%%$r$     & \gets & $m[t]$ \\
%%$r$     & \gets & $f$ & conversion \\
%%\\ 
%%$f$     & \gets & $f$ \\
%%$f$     & \gets & $\otimes(f, \ldots, f)$ \\
%%$f$     & \gets & $m[t]$ \\
%%$f$     & \gets & $r$ & conversion\\
%%\\ 
%%$m[t]$  & \gets & $r$ & an address in an integer\\
%%$m[t]$  & \gets & $f$ \\
%%\end{tabular}
%%\end{center}
%%\endgroup
%%
%%\begin{quote}\it
%%    What to do with boolean expressions? What to do with guarded
%%    effects? The code generator emits target-specific {\rtl}s for
%%    branches, jumps, and so on. There is a danger that we try to
%%    expand those, how do we avoid that?
%%\end{quote}
%%
%%Locations are divided into memory, and registers. Registers are further
%%divided into floating-point and integer registers where a register is
%%either a hardware register or a temporary. Memory is addressed by
%%integer registers, {\rtl} operators take either integer or floating
%%point arguments and return integer or floating point results
%%respectively. 
%%
%%The main point of code expansion is to eliminate complex expressions by
%%keeping their values in registers. The code passed to the expander
%%already includes some registers from calling conventions that we in
%%general do not want to replace. For this reason we only distinguish
%%between integer and floating point registers, but mostly do not enforce
%%that values are kept in temporaries. In particular, operands can be a
%%mix of temporaries and hardware registers holding either integers or
%%floating point values.
%%
%%% ------------------------------------------------------------------ 
\subsection{Code Expansion with {\burg}}
%%% ------------------------------------------------------------------ 
%%
%%A {\burg} specification consists of non-deterministic rules to cover a
%%tree. Code generated from that specification finds with dynamic
%%programming at run-time the rules that cover a given tree with minimal
%%cost. For code expansion the tree to be covered is an {\rtl}. For the
%%details of how {\burg} works, see the manual of {\small MLBURG} and
%%Fraser and Hanson: \textit{Engineering a Simple, Efficient Code
%%Generator Generator}, {\small ACM} Letters on Programming Languages and
%%Systems 1, 3 (Sep 1992), 213-226.
%%
<<dummyexpander.mlb>>=
%head {: 
 <<utilities(dummyexpander.nw)>>
 :}    
<<terminal types(dummyexpander.nw)>>
%tail {: 
 <<tail(dummyexpander.nw)>>
:}
%%
<<rules(dummyexpander.nw)>>
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Utilities for {\burg} actions}
%%% ------------------------------------------------------------------ 
%%
%%To keep the semantic actions of {\burg} rules as simple as possible, we
%%provide some basic functions in the head of the specification and
%%abbreviate commonly used modules.
%%
<<utilities(dummyexpander.nw)>>=
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module T  = Target
module C  = Camlburg
module D  = Rtl.Dn      (* Convert Down to private repr. *)
module U  = Rtl.Up       (* Convert Up    to abstract repr. *)
module W  = Rtlutil.Width 
module G  = Cfg             (* for expanding all RTLs in a CFG *)
module GU = Cfgutil
@
%%
%%Instead of the always useful [[assert false]] we raise a more
%%descriptive error. These errors are still considered to be fatal.
%%
<<utilities(dummyexpander.nw)>>=
exception Error of string
let error msg = raise (Error msg)
@
%%
%%Most semantic actions transform an expression into a sequence of {\rtl}s
%%that evaluates the expression into a register and return that register.
%%Thus, two things are returned: the register where the expression's value
%%can be found, and the sequence of {\rtl}s. To avoid decomposing returned
%%pairs, these semantic actions are implemented as a state monad: the
%%state is the list of accumulated {\rtl}s and a source for temporaries. A
%%monadic action takes the state, and produces a pair of a new result and
%%a new state:
%%
<<utilities(dummyexpander.nw)>>=
type state = R.rtl list * Talloc.Multiple.t
type 'a m  = state -> ('a * state)
@
%%
%%In particular, we save an {\rtl} in the state with [[exec]]. {\rtl}s are
%%saved in \emph{reverse exceution order}.
%%
<<utilities(dummyexpander.nw)>>=
let exec  rtl  = fun (rtls,tmp) -> ((), (rtl :: rtls,tmp)) 
@
%%
%%The power of monads come from higher-order functions to deal with them.
%%Here are the standard functions, often called \emph{unit} and
%%\emph{bind}:
%%
<<utilities(dummyexpander.nw)>>=
let return a  = fun s -> (a, s)
let (>>=) (m: 'a m) (f: 'a -> 'b m) = fun s -> let (a,s) = m s in f a s 
@
%%
%%We need a source for new temporaries; the functions [[itmp]] and
%%[[ftmp]] return a new temporary when applied to the desired width of the
%%new temporary.
%%
<<utilities(dummyexpander.nw)>>=
let dtmp = function
    | 2 -> fun(rtls, tmp as state) -> (R.reg ('d', 1, 2), state)
    | w  -> Impossible.impossible 
                (Printf.sprintf "unsupported width for d-space register: %d" w)

let itmp = function
    | 32 -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 't' 32, state)
    (*
    | 8  -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'v'  8, state)
    *)
    | 8  -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 't'  32, state)
    | w  -> Impossible.impossible 
                (Printf.sprintf "unsupported width for int register: %d" w)
let ftmp = function
    | 64 -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'u' 32, state)
    | 32 -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'u' 32, state)
    | 8  -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'u' 32, state)
    | w  -> Impossible.impossible 
                (Printf.sprintf "unsupported width for float register: %d" w)
@
%%
%%{\rtl} operators do not distinguish between floating point and integer
%%values, but we assume the [[Dummy]] machine does. As an oversimplified
%%experiment, we declare the following operators to be floating point
%%operators, taking and yielding floating point values.
%%
<<utilities(dummyexpander.nw)>>=
module StringSet = Set.Make(struct type t = string let compare = compare end)
@
%%
%%To simplify guarded effects we have to know which operators return
%%boolean values. All operators that take \emph{and} return boolean values
%%have been re-written into control-flow structures and do not show up
%%here. The operators listed here all take non-boolean arguments.
%%
<<utilities(dummyexpander.nw)>>=
let bool_ops2 = (* boolean valued primitive with non-boolean args *)
    List.fold_right StringSet.add
        ["eq"; "ge"; "geu"; "gt"; "gtu"; "le"; "leu"; "lt"; "ltu"; "ne"]
         StringSet.empty

let is_bool_op2  op     = StringSet.mem op bool_ops2
let is_bool_op1  op     = op = "bool"
@
%%
%%To create a fetch from a location we have to know the size of the
%%location. The [[fetch]] function makes this easy.
%%
<<utilities(dummyexpander.nw)>>=
let fetch t = R.fetch t (W.loc t)
@
%%
%%% ------------------------------------------------------------------ 
\section{Code Expansion Rules}
%%% ------------------------------------------------------------------ 
%%
%%A Variable in a rule pattern matches either an Objective Caml value, or
%%polymorphic {\burg} value. The Objective Caml values are called terminal
%%values and recognized by their terminal type. The following types are
%%terminal:
%%
<<terminal types(dummyexpander.nw)>>=
%term k width opr exps agg ass index bool bits link late x
@
%%
%%Note, that in a {\burg} pattern a variable $v$ is an abbreviation for
%%$v:v$, i.e.~variable $v$ of type $v$. A variable [[width]] is thus
%%of type [[width]] and thus represents a terminal value.
%%
%%{\rtl}s are mainly composed of expressions, locations and effects. The
%%code expander keeps the latter two and replaces an expression by a location
%%that hold the expression's value. 
%%
%%The following table summarizes the nonterminals in the rules and their
%%purpose. 
%%
%%\begin{tabular}{ll}
%%    Nonterminal & Meaning \\ 
%%    \hline
%%    [[ireg]]        & integer value (in register)\\
%%    [[freg]]        & floating-point value (in register)\\
%%    [[creg]]        & value of control register\\
%%    [[dreg]]        & value of 2 bit control register for FP comparison \\
%%    [[mem]]         & memory location\\
%%    [[icell]]       & integer register location\\
%%    [[fcell]]       & floating-point register location\\
%%    [[ccell]]       & control register location\\
%%    [[dcell]]       & 2 bit register for FP comparison result\\
%%    [[const]]       & constant value\\
%%    [[addr]]        & memory address\\
%%    [[stmt]]        & side effect (like assignment)\\
%%\end{tabular}
%%
%%The costs associated with burg rules usually reflect the number of
%%generated {\rtl}s. In addition, we want to penalize the conversion
%%between integer and floating point registers. A missing cost annotation
%%defaults to zero.
%%
<<rules(dummyexpander.nw)>>=
const:      Const(k)
            {: return (U.exp (RP.Const(k))) :}

-- r := k   
ireg:       const [1]
            {:  const                                >>= fun k ->
                itmp (W.exp k)                       >>= fun t  ->
                exec (R.store t k (W.exp k))         >>= fun () ->
                return t
            :}

-- r := $m[addr]            
ireg:       Fetch(mem,width) [1]
            {:  mem           >>= fun m ->
                itmp width    >>= fun t -> 
                exec (R.store t (R.fetch m width) width) >>= fun () ->
                return t
            :}  
            
-- f := $m[addr]
freg:       Fetch(mem,width) [1]
            {:  mem           >>= fun m ->
                ftmp width    >>= fun u -> 
                exec (R.store u (R.fetch m width) width) >>= fun () ->
                return u
            :}
@
%%
%%Fetches from registers must not to be rewritten, but the fetch
%%instruction disappears. It is inserted when the value is used in
%%a right-hand-side context.
%%
<<rules(dummyexpander.nw)>>=
ireg:       Fetch(icell,width) {: icell :}
freg:       Fetch(fcell,width) {: fcell :}    
dreg:       Fetch(dcell,width) {: dcell :} 
@
%%
%%Each primitive is matched by one rule. The rule expresses the number of
%%argument registers and their ``types''. The code below allows to keep
%%the semantic action for each rule essential. The first argument is a
%%generator for a temporary for the result. Passing [[itmp]] means, that
%%the result will be stored in an integer temporary.
%%
<<utilities(dummyexpander.nw)>>=
let bits2 n = R.bits (Bits.U.of_int n 2) 2

let app0 tmp s x =
    let opr   = R.opr s x in
    let exp   = R.app opr [] in
    let width = W.exp exp in
    tmp width >>= fun t -> 
    (*
    exec (R.store t exp width) >>= fun () ->
    *)
    return t

let app1 tmp s x arg1 =
    arg1 >>= fun a1 ->
    let opr   = R.opr s x in
    let exp   = R.app opr [fetch a1] in
    let width = W.exp exp in
    tmp width >>= fun t ->
    exec (R.store t exp width) >>= fun () ->
    return t

let app2 tmp s x arg1 arg2 =
    arg1 >>= fun a1 -> arg2 >>= fun a2 ->
    let opr   = R.opr s x in
    let exp   = R.app opr [fetch a1; fetch a2] in
    let width = W.exp exp in
    tmp width >>= fun t ->
    exec (R.store t exp width) >>= fun () ->
    return t

let app3 tmp s x arg1 arg2 arg3 =
    arg1 >>= fun a1 -> arg2 >>= fun a2 -> arg3 >>= fun a3 ->
    let opr   = R.opr s x in
    let exp   = R.app opr [fetch a1; fetch a2; fetch a3] in
    let width = W.exp exp in
    tmp width >>= fun t ->
    exec (R.store t exp width) >>= fun () ->
    return t
@
%%
%%
<<rules(dummyexpander.nw)>>=
dreg:   App0("float_eq", x)               {: app0 dtmp "float_eq" x :}
dreg:   App0("float_gt", x)               {: app0 dtmp "float_gt" x :}
dreg:   App0("float_lt", x)               {: app0 dtmp "float_lt" x :}
dreg:   App0("unordered", x)              {: app0 dtmp "unordered" x :}

const:  App0("round_down", x)             {: return (bits2 3) :}  
const:  App0("round_nearest", x)          {: return (bits2 1) :}
const:  App0("round_up", x)               {: return (bits2 2) :}
const:  App0("round_zero", x)             {: return (bits2 0) :}


ireg:   App1("com",  x, r1:ireg)          {: app1 itmp "com"  x r1 :}
ireg:   App1("lobits",x,r1:ireg)          {: app1 itmp "lobits" x r1 :}
ireg:   App1("neg",  x, r1:ireg)          {: app1 itmp "neg"  x r1 :}
ireg:   App1("sx",   x, r1:ireg)          {: app1 itmp "sx"   x r1 :}
ireg:   App1("zx",   x, r1:ireg)          {: app1 itmp "zx"   x r1 :}
@ 
%%
<<rules(dummyexpander.nw)>>=
ireg:   App2("add",  x, r1:ireg, r2:ireg) {: app2 itmp "add"  x r1 r2 :}
ireg:   App2("and",  x, r1:ireg, r2:ireg) {: app2 itmp "and"  x r1 r2 :}
ireg:   App2("div",  x, r1:ireg, r2:ireg) {: app2 itmp "div"  x r1 r2 :}
ireg:   App2("divu", x, r1:ireg, r2:ireg) {: app2 itmp "divu" x r1 r2 :}
ireg:   App2("mod",  x, r1:ireg, r2:ireg) {: app2 itmp "mod"  x r1 r2 :}
ireg:   App2("modu", x, r1:ireg, r2:ireg) {: app2 itmp "modu" x r1 r2 :}
ireg:   App2("mul",  x, r1:ireg, r2:ireg) {: app2 itmp "mul"  x r1 r2 :}
ireg:   App2("or",   x, r1:ireg, r2:ireg) {: app2 itmp "or"   x r1 r2 :}
ireg:   App2("quot", x, r1:ireg, r2:ireg) {: app2 itmp "quot" x r1 r2 :}
ireg:   App2("rem",  x, r1:ireg, r2:ireg) {: app2 itmp "rem"  x r1 r2 :}
ireg:   App2("rotl", x, r1:ireg, r2:ireg) {: app2 itmp "rotl" x r1 r2 :}
ireg:   App2("rotr", x, r1:ireg, r2:ireg) {: app2 itmp "rotr" x r1 r2 :}
ireg:   App2("shl",  x, r1:ireg, r2:ireg) {: app2 itmp "shl"  x r1 r2 :}
ireg:   App2("shra", x, r1:ireg, r2:ireg) {: app2 itmp "shra" x r1 r2 :}
ireg:   App2("shrl", x, r1:ireg, r2:ireg) {: app2 itmp "shrl" x r1 r2 :}
ireg:   App2("sub",  x, r1:ireg, r2:ireg) {: app2 itmp "sub"  x r1 r2 :}
ireg:   App2("xor",  x, r1:ireg, r2:ireg) {: app2 itmp "xor"  x r1 r2 :}

freg:   App1("fneg", x, r1:freg)          {: app1 ftmp "fneg" x r1 :}

freg:   App2("f2i",  x, r1:freg, r2:dreg) {: app2 itmp "f2i"  x r1 r2 :}
freg:   App2("i2f",  x, r1:ireg, r2:dreg) {: app2 ftmp "i2f"  x r1 r2 :}
freg:   App2("f2f",  x, r1:freg, r2:dreg) {: app2 ftmp "f2f"  x r1 r2 :}

-- FP operations use a rounding mode
freg:   App3("fadd", x, r1:freg, r2:freg, c:dreg) {:app3 ftmp "fsub" x r1 r2 c:}
freg:   App3("fsub", x, r1:freg, r2:freg, c:dreg) {:app3 ftmp "fadd" x r1 r2 c:}
freg:   App3("fdiv", x, r1:freg, r2:freg, c:dreg) {:app3 ftmp "fdiv" x r1 r2 c:}
freg:   App3("fmul", x, r1:freg, r2:freg, c:dreg) {:app3 ftmp "fmul" x r1 r2 c:}
@ 
%%
<<rules(dummyexpander.nw)>>=
--
-- Floating point comparison results are ALWAYS stored in a hardware
-- register. This is a hack.
--

dreg:      App2("fcmp", x, f1:freg, f2:freg) [1]
            {:
                f1 >>= fun f1 -> f2 >>= fun f2 ->
                let o        = R.opr "fcmp" x in
                let exp      = R.app o [fetch f1; fetch f2] in
                let fpcond n = R.reg ('d', n, 2) in
                let r        = fpcond 1 in
                exec (R.store r exp 2) >>= fun () ->
                return r
            :}    
@
%%
%%
%%A cell is either a register or a memory cell. A register has a constant
%%address and needs no further re-writing. We just categorize it as
%%integer, floating-point, or control register. Memory cells include
%%address expressions which must be rewritten. This is enforced by the
%%[[addr]] nonterminal, which stands for a register value. Hence, memory
%%can only be addresses by registers in this model.
%%
<<utilities(dummyexpander.nw)>>=
let mem sp agg width addr ass=
    addr >>= fun a -> return (R.mem (U.assertion ass) sp agg width a)

let reg sp i width = return (R.reg (sp, i, width))
@     
%%
<<rules(dummyexpander.nw)>>=
addr:       ireg  {: ireg >>= fun r -> return (fetch r) :}

@ 
<<rules(dummyexpander.nw)>>=
mem:        Mem('m', agg, width, addr, ass)  {: mem 'm' agg width addr ass :}
@
%%
%%The name [[icell]] is poorly chosen. We originally had no syntax for
%%registers in {\rtl}s, only for cells. 
%%
<<rules(dummyexpander.nw)>>=
icell:      Reg('r', index, width) {: reg 'r' index width :} 
icell:      Reg('t', index, width) {: reg 't' index width :} 
icell:      Reg('g', index, width) {: reg 'g' index width :} 
icell:      Reg('v', index, width) {: reg 'v' index width :} 
fcell:      Reg('f', index, width) {: reg 'f' index width :} 
fcell:      Reg('u', index, width) {: reg 'u' index width :} 
dcell:      Reg('d', index, width) {: reg 'd' index width :} 
ccell:      Reg('c', index, width) {: reg 'c' index width :} 

error:      Reg(x:char, index, width)
            {: error (Printf.sprintf "register in space '%c'" x) :}

error:      Mem(x:char, agg, width, addr, ass) [10]
            {: error (Printf.sprintf "cell in space '%c'" x) :}    
@
%%
%%To make sure we can cover every {\rtl}, we allow to move integer
%%registers into floating-point temporaries, and floating-point registers
%%into integer temporaries.  We do not like these conversions so we
%%penalize them with high costs. 
%%
<<rules(dummyexpander.nw)>>=
-- t := f
ireg:       freg [10]    
            {:  
                freg                                >>= fun u  ->
                let w = W.loc u in 
                itmp w                              >>= fun t  ->
                exec (R.store t (R.fetch u w) w)    >>= fun () ->
                return t
            :} 

-- f := t            
freg:       ireg [10]    
            {:  
                ireg                                >>= fun t ->
                let w = W.loc t in
                ftmp w                              >>= fun u  ->
                exec (R.store u (R.fetch t w) w)    >>= fun () ->
                return u
            :} 
@
%%
%%{\rtl} effects are covered by the [[stmt]] nonterminal. We allow only
%%very simple assignments between registers of the same class and
%%registers and memory. In particular, constants cannot be written to
%%memory, and no memory-memory transfer is allowed. 
%%
<<utilities(dummyexpander.nw)>>=
let store left right width =
    left >>= fun l -> right >>= fun r -> 
    return (R.store l (R.fetch r width) width)

let store' left right width =   (* right is a value, not a location *)
    left >>= fun l -> right >>= fun r -> 
    return (R.store l r width)
@ 
%%
<<rules(dummyexpander.nw)>>=
stmt:       Store(mem,   ireg, width)       {: store mem   ireg  width :}
stmt:       Store(mem,   freg, width)       {: store mem   freg  width :}
stmt:       Store(icell, ireg, width)       {: store icell ireg  width :}
stmt:       Store(fcell, freg, width)       {: store fcell freg  width :}
stmt:       Store(ccell, ireg, width) [1]   {: store ccell ireg  width :}
stmt:       Store(dcell, dreg, width)       {: store dcell dreg  width :}
stmt:       Store(dcell, const, width)      {: store' dcell const width :}
stmt:       Store(ccell, const,width)       {: store' ccell const width :}
@
%%
%%Currently the front end generates guarded expression only for
%%if-statements. The expression is already simplified such that it is
%%either [[true]], [[false]], or an application with a boolean result that
%%takes \emph{non-boolean} arguments. 
%%
%%I don't know how to handle guarded statements. The guard expression is a
%%boolean expression. For the moment I treat the guard as a literal and do
%%not expand it.
%%
<<rules(dummyexpander.nw)>>=
guard:      True()  {: return (R.bool true)  :}
guard:      False() {: return (R.bool false) :}

guard:      App2(o:string, x, r1:ireg, r2:ireg) 
            [{: if is_bool_op2 o then 0 else C.inf_cost  :}]
            {:  
                r1 >>= fun r1 -> r2 >>= fun r2 ->
                let opr = R.opr o x in
                return (R.app opr [fetch r1; fetch r2])
            :}    

-- we need an extra rule for floating point results that always
-- stay in 'd' space.

guard:      App2(o:string, x, r1:dreg, r2:dreg) 
            [{: if is_bool_op2 o then 0 else C.inf_cost  :}]
            {:  
                r1 >>= fun r1 -> r2 >>= fun r2 ->
                let opr = R.opr o x in
                return (R.app opr [fetch r1; fetch r2])
            :}    

guard:      App1(o:string, x, r1:ireg)
            [{: if is_bool_op1 o then 0 else C.inf_cost  :}]
            {:  
                r1 >>= fun r1 -> 
                let opr = R.opr o x in
                return (R.app opr [fetch r1])
            :}    
           
gstmt:      GStmt(guard,stmt)
            {: 
                guard >>= fun g ->
                stmt  >>= fun s -> 
                return (R.guard g s) 
            :}

gstmts:     Nil() {:  return [] :}
gstmts:     Cons(gstmt,gstmts)
            {: gstmt  >>= fun s  -> gstmts >>= fun ss -> return (s::ss) :}
@
%%
%%An {\rtl} is a list of guarded statements. 
%%
<<rules(dummyexpander.nw)>>=
rtl:        Rtl(gstmts) [1]
            {:
                gstmts            >>= fun rtls ->
                exec (R.par rtls) >>= fun ()  ->
                return ()
            :}
@
%%
%%Here are the cases we cannot handle (yet). 
%%
<<rules(dummyexpander.nw)>>=
error:      Kill()  {: error "cannot handle Kill" :}
error:      Var()   {: error "Var constructor" :}
error:      Slice() {: error "Slice constrictor" :}
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
%%% ------------------------------------------------------------------ 
%%
%%The code generated from {\burg} rules knows nothing about {\rtl}s. In
%%order to expand an {\rtl}, we have to traverse it and pass the different
%%parts to the generated functions whose names we know from the {\small
%%MLBURG} manual. This code follows here. 
%%
<<tail(dummyexpander.nw)>>=
let rec map f = function
    | []                        -> conNil ()
    | x::xs                     -> conCons (f x) (map f xs)
@    
%%  
%%Make sure that the above function [[map]] is \emph{not} in the same
%%[[letrec]] as the functions below. In that case it becomes monomorphic
%%and the code below will not type check! This mistake has taken me some
%%time to spot.
%%
<<tail(dummyexpander.nw)>>=
let rec exp = function
    | RP.Const(RP.Bool(true))   -> conTrue()
    | RP.Const(RP.Bool(false))  -> conFalse()
    | RP.Const(k)               -> conConst(k)
    | RP.Fetch(l,w)             -> conFetch (loc l) w
    | RP.App((o,x),[])          -> conApp0 o x
    | RP.App((o,x),[e1])        -> conApp1 o x (exp e1)
    | RP.App((o,x),[e1;e2])     -> conApp2 o x (exp e1) (exp e2)
    | RP.App((o,x),[e1;e2;e3])  -> conApp3 o x (exp e1) (exp e2) (exp e3)
    | _                         -> error "application with too many args"

and loc = function
    | RP.Mem(char, aff, w, e, ass) -> conMem char aff w (exp e) ass 
    | RP.Reg(sp, i, w)          -> conReg sp i w
    | RP.Var(s, i, w)           -> conVar ()
    | RP.Slice(w,i,loc)         -> conSlice ()
    
and stmt = function
    | RP.Store(l,e,w)           -> conStore (loc l) (exp e) w
    | RP.Kill(loc)              -> conKill ()

and guarded (e,eff)             =  conGStmt (exp e) (stmt eff)

and rtl = function
    | RP.Rtl(gs)                -> conRtl (map guarded gs)
@
%%
%%The [[rtl]] function returns (the best) plan to rewrite a given {\rtl}.
%%When this plan is executed, it returns a monadic value that includes the
%%desired expanded {\rtl}s.
%%
<<tail(dummyexpander.nw)>>=
let expand tmps (r: R.rtl) = 
    let plan = rtl (D.rtl r) in
    try
        match plan.rtl.Camlburg.action () ([],tmps) with
            | (), (rtls,_) -> rtls
    with 
        Camlburg.Uncovered -> 
            ( List.iter prerr_endline
                [ "cannot expand this RTL:"
                ; RU.ToUnreadableString.rtl r
                ]
            ; assert false
            )
@                        
%%
%%% ------------------------------------------------------------------ 
\subsection{Expanding an entire {\cfg}}
%%% ------------------------------------------------------------------ 
%%
%%{\rtl}s do not live in isolation but belong to a procedure's {\cfg}.
%%Since procedures are the basic units of compilation we want to expand
%%all the {\rtl}s of a procedure. This requires to re-write the {\cfg}.
%%
%%Re-writing the {\cfg} mutates its structure and therefore we have to
%%obtain first all the nodes whose {\rtl}s we want to expand. We cannot
%%use the iterator provided by the {\cfg} module because it does not work
%%under mutation.
%%
%%[[Cfg]] expands all {\rtl}s of a procedure and returns [[true]], if the 
%%structure of the procedure's {\cfg} had to be modified.
%%
<<tail(dummyexpander.nw)>>=
let cfg proc =
    let nodes       = GU.fold_bwd proc.Proc.cfg (fun n ns -> n::ns) []
    and tmps        = proc.Proc.temps   (* source for temporaries *)
    and insert n i  = G.gm_insert_assign_before i n
    and modified    = ref false in
    let expnd node =
        match expand tmps (G.instr node) with
        | last :: preds ->
            ( ignore (List.fold_left insert node preds)
            ; G.upd_instr node (fun _ -> last)
            ; modified := (preds <> [])
            )
        | [] -> assert false 
    in    
        ( List.iter expnd nodes
        ; !modified
        )
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Exporting the Expander to Lua}
%%% ------------------------------------------------------------------ 
%%
%%Code expansion is part of {\qcc}'s backend that is controlled by a Lua
%%interpreter. To make the expander accessible for Lua code, it is
%%exported as a Lua primitive [[Expander.dummy]].
<<tail(dummyexpander.nw)>>=
module Make (ProcT: Lua.Lib.TYPEVIEW with type 'a t = Proc.t): 
    Lua.Lib.USERCODE with type 'a userdata' = 'a ProcT.combined =
struct
    type 'a userdata' = 'a ProcT.combined
    module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a userdata') =
    struct
      module V  = C.V

      let ( **-> ) = V.( **-> )
      let proc     = ProcT.makemap V.userdata V.projection
      let init =
        C.register_module "Expander" 
        [ "dummy", V.efunc (V.value **-> proc **-> V.result V.bool) (fun _ -> cfg)
        ] 
 (* FIX -- want proper stage *)
    end (*M*)    
end (*Make*)            
@
%%

\chapter{[[arch/arm]]}

\section{[[arch/arm/arm.nw]]}
<<arch/arm/arm.ml>>=
<<arm.ml>>
@

<<arch/arm/arm.mli>>=
<<arm.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% ------------------------------------------------------------------ 
\section{Back end for the ARM}
%%% ------------------------------------------------------------------ 
%%
%%This module defines a 32 bit little-endian {\arm} architecture.
<<arm.mli>>=
module Post : Postexpander.S
module X    : Expander.S

val target: Ast2ir.tgt
val placevars : Ast2ir.proc -> Automaton.t
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Abbreviations and utility functions}
%%% ------------------------------------------------------------------ 
%%
<<arm.ml>>=
module SS   = Space.Standard32
module S    = Space
module A    = Automaton
let ( *> )  = A.( *> ) 
module PX   = Postexpander
module R    = Rtl
module RP   = Rtl.Private
module RU   = Rtlutil
module Up   = Rtl.Up
module Dn   = Rtl.Dn
module SM   = Strutil.Map
module T    = Target

let unimp               = Impossible.unimp
let impossible          = Impossible.impossible
let rtl r = PX.Rtl r
let (<:>) = PX.(<:>)
@ 
<<utilities that depend on [[byteorder]] or [[wordsize]]>>=
let fetch_word l        = R.fetch l   wordsize
let store_word l e      = R.store l e wordsize
let mcell = Cell.of_size 8
let mspace = ('m', byteorder, mcell)
let mcount = Cell.to_count mcell
let mem w addr          = R.mem R.none mspace (mcount w) addr
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Name and storage spaces}
%%% ------------------------------------------------------------------ 
%%
%%A {\arm} architecture can be either little or big endian. For now, we
%%assume little endianness but expect to functorize the implementation
%%later.
<<arm.ml>>=
let arch        = "arm"                    (* architecture *)
let byteorder   = Rtl.LittleEndian 
let wordsize    = 32
<<utilities that depend on [[byteorder]] or [[wordsize]]>>
@
%%We use the standard storage spaces, including the spaces for PC and
%%condition codes.
%%There is no float-point hardware.
<<arm.ml>>=
module Spaces = struct
    let id = Rtl.Identity
    let m  = SS.m byteorder [8; 16; 32]
    let r  = SS.r 16 id [32]
    let t  = SS.t    id  32
    let c  = SS.c  3 id [32]    (* pc, _, cc *)
end
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Registers}
%%% ------------------------------------------------------------------ 
%%
<<arm.ml>>=
let locations   = SS.locations Spaces.c
let pc          = locations.SS.pc
let cc          = locations.SS.cc
let vfp         = Vfp.mk wordsize

let rspace = ('r', Rtl.Identity, Cell.of_size 32)
let reg n       = (rspace,n,Rtl.C 1)
let sp          = reg 13        (* stack pointer    *)
let ra          = reg 14        (* return address   *)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Variable Placer}
%%% ------------------------------------------------------------------ 
%%
%%This variable placer puts small variables in registers and others in memory.
<<arm.ml>>=
let placevars = 
  let warn ~width:w ~alignment:a ~kind:k =
    if w > 32 then unimp (Printf.sprintf "%d-bit values not supported" w) in
  let mk_stage ~temps =
    A.choice
      [ (fun w h _ -> w <= 32),   A.widen (fun _ -> 32) *> temps 't';
        A.is_any,                 A.widen (Auxfuns.round_up_to ~multiple_of: 8);
      ] in
  Placevar.mk_automaton ~warn ~vfp ~memspace:mspace mk_stage
@ 
%%% ------------------------------------------------------------------ 
\subsection{Control-flow {\rtl}s}
%%% ------------------------------------------------------------------ 
%%
%%We generate standard control-flow {\rtl}s. The \module{ast2ir.nw} module
%%inserts these into the {\cfg} it builds. 
<<arm.ml>>=
module F = Mflow.MakeStandard
    (struct
        let pc_lhs    = pc
        let pc_rhs    = pc
        let ra_reg    = R.reg ra
        let ra_offset = 4               (* size of call instruction *)
     end)   
@
%%Module [[F]] does not provide a return instruction. A return is simply a
%%jump.
<<arm.ml>>=
let return = R.store pc (fetch_word (R.reg ra))
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Postexpander}
%%% ------------------------------------------------------------------ 
%%
<<arm.ml>>=
module Post = struct
    <<ARM postexpander>>
end
@ 
%%
<<ARM postexpander>>=
let byte_order  = byteorder
let wordsize    = wordsize
let exchange_alignment = 4

type temp       = Register.t
type rtl        = Rtl.rtl
type width      = Rtl.width
type assertion  = Rtl.assertion
type operator   = Rtl.Private.opr
@
%%The postexpander may need to allocate temporaries.
<<ARM postexpander>>=
let talloc = Postexpander.Alloc.temp
@
%%\paragraph{Contexts}
%%There is no distinction between an integer and an address.
<<ARM postexpander>>=
let icontext = Context.of_space Spaces.t
let acontext = icontext
let itempwidth = 32
let fcontext = (fun x y -> unimp "no floating point on ARM"), fun _ -> false
let rcontext = (fun x y -> unimp "no rounding mode on ARM"),  fun _ -> false
let constant_context w = icontext

let operators = Context.nonbool icontext fcontext rcontext []
let arg_contexts, result_context = Context.functions operators
@
%%\paragraph{Addressing modes}
<<ARM postexpander>>=
module Address = struct
    type t    = Rtl.exp
    let reg r = R.fetch (R.reg r) (Register.width r)
end
include Postexpander.Nostack(Address)
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Load and Store}
%%% ------------------------------------------------------------------ 
%%
%%All temporaries are 32~bit wide.
<<ARM postexpander>>=
let tloc t = Rtl.reg t
let tval t = R.fetch (tloc t) (Register.width t)
let twidth = Register.width

let load ~dst ~addr assn =
    let w = twidth dst in
        assert (w = wordsize);
        rtl (R.store (tloc dst) (R.fetch (mem w addr) w) w)

let store ~addr ~src assn =
    let w = twidth src in
        assert (w = wordsize);
        rtl (R.store (mem w addr) (tval src) w)

let block_copy ~dst dassn ~src sassn w =
  match w with
  | 32 -> let t = talloc 't' w in load t src sassn <:> store dst t dassn
  | _  -> Impossible.unimp "general block copies on Arm"
@
%%The {\arm} provides sign- and zero-extending load operations for
%%loading values smaller than [[wordsize]]. We only support operations on
%%[[wordsize]].
<<ARM postexpander>>=
let extend  op n e = R.app (R.opr op       [n; wordsize]) [e]
let lobits     n e = R.app (R.opr "lobits" [wordsize; n]) [e]

let xload op ~dst ~addr n assn =
  let w = twidth dst in
  assert (w = wordsize); 
  rtl (R.store (tloc dst)
         (extend op n (R.fetch (R.mem assn mspace (mcount n) addr) n)) w)

let sxload = xload "sx"
let zxload = xload "zx"

let lostore ~addr ~src n assn =
  assert (Register.width src = wordsize);
  rtl (R.store (R.mem assn mspace (mcount n) addr) (lobits n (tval src)) n)
@
%%The general move operation only works between temporaries of the same
%%width. Load immediate loads a constant into a temorary.
<<ARM postexpander>>=
let move ~dst ~src =
  assert (Register.width src = Register.width dst);
  if Register.eq src dst then PX.Nop
  else rtl (R.store (tloc dst) (tval src) (twidth src))
@ 
<<ARM postexpander>>=
let extract ~dst ~lsb ~src = Impossible.unimp "extract"
let aggregate ~dst ~src = Impossible.unimp "aggregate"
@ 
<<ARM postexpander>>=
let hwset ~dst ~src = Impossible.unimp "setting hardware register"
let hwget ~dst ~src = Impossible.unimp "getting hardware register"
@
%%Immediate load, and extended immediate load. An extended load-immediate
%%can take sums and differences of compile-time constants (including late
%%compile-time constants). 
<<ARM postexpander>>=
let li  ~dst const = rtl (R.store (tloc dst) (Up.const const) (twidth dst))
let lix ~dst e     = rtl (R.store (tloc dst) e                (twidth dst))  
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Binary and unary operators}
%%% ------------------------------------------------------------------ 
%%
%%This stuff is wrong because condition codes are not set.
%%At present, we keep only conditions for subtraction, which we need to
%%implement a conditional branch.
<<ARM postexpander>>=
let subflags x y w = R.store cc (R.app (R.opr "arm_subcc" [w]) [x; y]) 32

let unop ~dst op x =
  rtl (R.store (tloc dst) (R.app (Up.opr op) [tval x]) (twidth dst))

let binop ~dst op x y =
  rtl (R.store (tloc dst) (R.app (Up.opr op) [tval x; tval y]) (twidth dst))

let unrm  ~dst op x rm   = Impossible.unimp "floating point with rounding mode"
let binrm ~dst op x y rm = Impossible.unimp "floating point with rounding mode"

let dblop ~dsthi ~dstlo op x y = Unsupported.mulx_and_mulux()
let wrdop  ~dst op x y z = Unsupported.singlebit ~op:(fst op)
let wrdrop ~dst op x y z = Unsupported.singlebit ~op:(fst op)
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Control Flow}
%%% ------------------------------------------------------------------ 
%%
%%On the {\arm}, the PC can be read and written.
<<ARM postexpander>>=
let pc_lhs = pc         (* PC as assigned by branch *)
let pc_rhs = pc         (* PC as captured by call   *)
@
%%
%%\paragraph{Unconditional Branches}
<<ARM postexpander>>=
let br ~tgt = PX.Nop, R.store pc_lhs (tval tgt)     wordsize  (* branch reg *)
let b  ~tgt = PX.Nop, R.store pc_lhs (Up.const tgt) wordsize  (* branch     *)
@
%%
%%\paragraph{Conditional Branches}
%%
%%We have to set condition codes and make a conditional branch.
%%A conditional branch is represented by a guarded assignment to the PC.
%%We turn each condition into an ARM-specific test of the condition
%%code, where the ARM operators use the ARM assembly-language mnemonics.
<<ARM postexpander>>=
let cmp x y = rtl (subflags (tval x) (tval y) 32) 

let rec bc x (opr, ws as op) y ~ifso ~ifnot =
  assert (ws =*= [wordsize]);
  let cond c = R.app (R.opr c [32]) [R.fetch cc 32] in
  match opr with
  | "eq" | "ne" | "lt" | "le" | "gt" | "ge" | "leu" | "gtu" ->
      PX.Test (cmp x y, (cond (arm_cond opr), ifso, ifnot))
  | "ltu" -> bc y ("gtu", ws) x ~ifso ~ifnot
  | "geu" -> bc y ("leu", ws) x ~ifso ~ifnot
  | _ -> Impossible.impossible
          "non-comparison in ARM conditional branch (or overflow not implemented)"
and arm_cond = function
  | "eq"  -> "arm_eq"
  | "ne"  -> "arm_ne"
  | "lt"  -> "arm_lt"
  | "le"  -> "arm_le"
  | "gt"  -> "arm_gt"
  | "ge"  -> "arm_ge"
  | "leu" -> "arm_ls"
  | "gtu" -> "arm_hi"
  | "add_overflows"
  | "div_overflows"
  | "mul_overflows"
  | "mulu_overflows"
  | "sub_overflows" -> Impossible.unimp "ARM overflow tests"
  | "ltu" | "geu" -> Impossible.impossible "ARM comparison not reversed"
  | _ -> Impossible.impossible "non-comparison in ARM conditional branch"
@
%%[[bnegate]] inverts the condition in a conditional branch.
<<ARM postexpander>>=
let rec bnegate r = match Dn.rtl r with
| RP.Rtl [RP.App((cop, [32]), [RP.Fetch (bcodes, 32)]), RP.Store (pc, tgt, 32)]
  when RU.Eq.loc pc (Dn.loc pc_lhs) && RU.Eq.loc bcodes (Dn.loc cc) ->
    Up.rtl (RP.Rtl [RP.App((negate cop, [32]), [RP.Fetch (bcodes, 32)]),
                   RP.Store (pc, tgt, 32)])
| _ -> Impossible.impossible "ill-formed ARM conditional branch"
and negate = function
  | "ne"     -> "eq"
  | "eq"     -> "ne"
  | "ge"     -> "lt"
  | "gt"     -> "le"
  | "le"     -> "gt"
  | "lt"     -> "ge"
  | "geu"    -> "ltu"
  | "gtu"    -> "leu"
  | "leu"    -> "gtu"
  | "ltu"    -> "geu"
  | "arm_eq" -> "arm_ne"
  | "arm_ne" -> "arm_eq"
  | "arm_lt" -> "arm_ge"
  | "arm_le" -> "arm_gt"
  | "arm_gt" -> "arm_le"
  | "arm_ge" -> "arm_lt"
  | "arm_ls" -> "arm_hi"
  | "arm_hi" -> "arm_ls"
  | "arm_vs" -> "arm_vc"
  | "arm_vc" -> "arm_vs"
  | "feq"           -> unimp "floating-point comparison"
  | "fne"           -> unimp "floating-point comparison"
  | "flt"           -> unimp "floating-point comparison"
  | "fle"           -> unimp "floating-point comparison"
  | "fgt"           -> unimp "floating-point comparison"
  | "fge"           -> unimp "floating-point comparison"
  | "fordered"      -> unimp "floating-point comparison"
  | "funordered"    -> unimp "floating-point comparison"
  | _               -> impossible 
                        "bad comparison in expanded ARM conditional branch"
@ 
%%
%%\paragraph{Calls} 
%%In an indirect call the target is held in a register. 
<<ARM postexpander>>=
let effects = List.map Up.effect
let call  ~tgt ~others = 
  PX.Nop, R.par (R.store pc_lhs (Up.const tgt) wordsize :: effects others)
let callr ~tgt ~others = 
  PX.Nop, R.par (R.store pc_lhs (tval tgt) wordsize :: effects others)
@
%%
%%\paragraph{Cut-To}
<<ARM postexpander>>=
let cut_to effs = PX.Nop, R.par (effects effs)
@
%%
%%\paragraph{No sacred instructions}
<<ARM postexpander>>=
let don't_touch_me es = false
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Expander}
%%% ------------------------------------------------------------------ 
%%
<<arm.ml>>=
module X = Expander.IntFloatAddr(Post)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Spill and reload}
%%% ------------------------------------------------------------------ 
%%
%%The register allocator needs to spill and reload values; we have to
%%provide the instructions.
<<arm.ml>>=
let spill  p t l = [A.store l (Post.tval t) (Post.twidth t)]
let reload p t l = 
    let w = Post.twidth t in [R.store (Post.tloc t) (Automaton.fetch l w) w]
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Global Variables}
%%% ------------------------------------------------------------------ 
%%
%%When a Global {\PAL} variable names no hardware register to live in, the
%%variable is passed through to following automaton to obtain its
%%location.
%%
%%THIS AUTOMATON SEEMS QUITE UNIVERSAL FOR 32 BIT ARCHITECTURES. MOVE IT
%%TO Automaton.Standard32?
<<arm.ml>>=
let globals base = 
  let width w = if      w <= 8  then 8  
                else if w <= 16 then 16 
                else Auxfuns.round_up_to 32 w in
  let align = function 8 -> 1 | 16 -> 2 | _ -> 4 in
  A.at mspace ~start:base (A.widen width *> A.align_to align *>
  A.overflow ~growth:Memalloc.Up ~max_alignment:4)
@
%%% ------------------------------------------------------------------ 
\subsection{The target record}
%%% ------------------------------------------------------------------ 
%%
<<arm.ml>>=
let target : Ast2ir.tgt =
    let spaces = [ Spaces.m
                 ; Spaces.r
                 ; Spaces.t
                 ; Spaces.c
                 ] in
    { T.name                = "arm"
    ; T.memspace            = mspace
    ; T.max_unaligned_load  = R.C 1
    ; T.byteorder           = byteorder
    ; T.wordsize            = wordsize
    ; T.pointersize         = wordsize
    ; T.alignment           = 4  (* strange rotations occur on unaligned loads *)
    ; T.memsize             = 8
    ; T.spaces              = spaces
    ; T.reg_ix_map          = T.mk_reg_ix_map spaces
    ; T.distinct_addr_sp    = false
    ; T.float               = Float.none
    ; T.spill               = spill
    ; T.reload              = reload

    ; T.vfp                 = vfp
    ; T.bnegate             = F.bnegate cc
    ; T.goto                = F.goto
    ; T.jump                = F.jump
    ; T.call                = F.call
    ; T.return              = F.return
    ; T.branch              = F.branch
    
    ; T.cc_specs            = A.init_cc
    ; T.cc_spec_to_auto     = (fun _ _ -> assert false)
    ; T.is_instruction      = (fun _ -> false)  (* no back end yet *)
    ; T.capabilities        = T.incapable
(*
                              Armcall.cconv 
                                ~return_to:(fun ra -> (R.store pc ra wordsize))
                                (F.cutto (Rtl.reg sp))
*)                    
    ; T.globals             = globals
    ; T.rounding_mode       = R.reg (('?', Rtl.Identity, Cell.of_size 32), 99, R.C 1)
    ; T.named_locs          = Strutil.assoc2map []
    ; T.data_section        = "data"
    ; T.charset             = "latin1" (* REMOVE THIS FROM TARGET.T *)
    }    

@ 

\chapter{[[arch/mips]]}

\section{[[arch/mips/mips.nw]]}
<<arch/mips/mips.ml>>=
<<mips.ml>>
@

<<arch/mips/mips.mli>>=
<<mips.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%
%%% ------------------------------------------------------------------ 
\section{Back end for the MIPS}
%%% ------------------------------------------------------------------ 
%%
%%This module defines a 32 bit little-endian {\mips} architecture.
%%
<<mips.mli>>=
module Post : Postexpander.S
module X    : Expander.S

val target: Ast2ir.tgt
val placevars : Ast2ir.proc -> Automaton.t
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Name and storage spaces}
%%% ------------------------------------------------------------------ 
%%
%%A {\mips} architecture can be either little or big endian. For now, we
%%assume little endianness but expect to functorize the implementation
%%later.
<<mips.ml>>=
let arch        = "mips"                    (* architecture *)
let wordsize    = 32
@
%%We use the standard storage spaces, including the spaces for PC and
%%condition codes. For now I'll treat floating point as 32 bit; maybe we
%%need an additional spaces for 64-bit floating point values and
%%temporaries.
<<mips.ml>>=
module A  = Automaton
module PX = Postexpander
module R  = Rtl
module Rg = Mipsregs
module RP = Rtl.Private
module RU = Rtlutil
module Up = Rtl.Up
module Dn = Rtl.Dn
module S  = Space
module SS = Space.Standard32
module SM = Strutil.Map
module T  = Target

let rtl r = PX.Rtl r
let (<:>) = PX.(<:>)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Registers}
%%% ------------------------------------------------------------------ 
%%
<<mips.ml>>=
let vfp         = Vfp.mk wordsize

let dspace = ('d', Rtl.Identity, Cell.of_size 2)  (* rounding modes *)
let reg n       = (Rg.rspace,n,Rtl.C 1)
let sp          = reg 29        (* stack pointer    *)
let ra          = reg 31        (* return address   *)
let r0          = reg 0         (* register 0       *)
let rm_reg      = (dspace, 0, Rtl.C 1)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Utilities}
%%% ------------------------------------------------------------------  
%%
<<mips.ml>>=
let unimp               = Impossible.unimp
let impossible          = Impossible.impossible

let fetch_word l        = R.fetch l   wordsize
let store_word l e      = R.store l e wordsize
let (_, byteorder, mcell) as mspace = Rg.mspace
let mcount = Cell.to_count mcell
let mem w addr          = R.mem R.none mspace (mcount w) addr
@
%%% ------------------------------------------------------------------ 
\subsection{Control-flow {\rtl}s}
%%% ------------------------------------------------------------------ 
%%
%%We generate standard control-flow {\rtl}s. The \module{ast2ir.nw} module
%%inserts these into the {\cfg} it builds. 
<<mips.ml>>=
module F = Mflow.MakeStandard
    (struct
        let pc_lhs    = Rg.pc  (* should be PC, but recognizer is broken! *)
        let pc_rhs    = Rg.pc
        let ra_reg    = R.reg ra
        let ra_offset = 4               (* size of call instruction *)
     end)   
@
%%Module [[F]] does not provide a return instruction. A return is simply a
%%jump.
<<mips.ml>>=
let return = R.store Rg.pc (fetch_word (R.reg ra))
@
%%% ------------------------------------------------------------------ 
\subsection{Postexpander}
%%% ------------------------------------------------------------------ 
<<mips.ml>>=
module Post = struct
    <<MIPS postexpander>>
end
@ 
<<MIPS postexpander>>=
let byte_order  = byteorder
let exchange_alignment = 4
let wordsize    = wordsize

type temp       = Register.t
type rtl        = Rtl.rtl
type width      = Rtl.width
type assertion  = Rtl.assertion
type operator   = Rtl.Private.opr
@
%%The postexpander may need to allocate temporaries.
<<MIPS postexpander>>=
let talloc = Postexpander.Alloc.temp
@
%%\paragraph{Contexts}
%%There is no distinction between an integer and an address.
<<MIPS postexpander>>=
let icontext = Context.of_space Rg.Spaces.t
let fcontext = Context.of_space Rg.Spaces.u
let acontext = icontext
let rcontext = (fun x y -> unimp "unsupported soft rounding mode"), Register.eq rm_reg

let operators = Context.nonbool icontext fcontext rcontext []
let arg_contexts, result_context = Context.functions operators
let itempwidth = 32
let constant_context w = if w = wordsize then icontext else fcontext
@
%%\paragraph{Addressing modes}
<<MIPS postexpander>>=
module Address = struct
  type t    = Rtl.exp
  let reg r = R.fetch (R.reg r) (Register.width r)
end
include Postexpander.Nostack(Address)
@
%%% ------------------------------------------------------------------ 
%%\subsubsection{Load and Store}
%%% ------------------------------------------------------------------ 
%%
%%At the moment all temporaries are 32 bit wide but in the future we will
%%also have 64-bit floating point values. Therefore we want to avoid
%%hard coding [[wordsize]] into loads and stores.
<<MIPS postexpander>>=
let tloc t = Rtl.reg t
let tval t = R.fetch (tloc t) (Register.width t)
let twidth = Register.width

let load ~dst ~addr assn =
  let w = twidth dst in
  assert (w = wordsize); (* remove when we have 64-bit spaces *)
  rtl (R.store (tloc dst) (R.fetch (mem w addr) w) w)

let store ~addr ~src assn =
  let w = twidth src in
  assert (w = wordsize); (* remove when we have 64-bit spaces *)
  rtl (R.store (mem w addr) (tval src) w)

let block_copy ~dst dassn ~src sassn w =
  match w with
  | 32 -> let t = talloc 't' w in load t src sassn <:> store dst t dassn
  | _  -> Impossible.unimp "general block copies on Mips"
@
%%The {\mips} provides sign- and zero-extending load operations for
%%loading values smaller than [[wordsize]]. We only support operations on
%%[[wordsize]].
<<MIPS postexpander>>=
let extend  op n e = R.app (R.opr op       [n; wordsize]) [e]
let lobits     n e = R.app (R.opr "lobits" [wordsize; n]) [e]

let xload op ~dst ~addr n assn =
  let w = twidth dst in
  assert (w = wordsize); 
  rtl (R.store (tloc dst)
         (extend op n (R.fetch (R.mem assn mspace (mcount n) addr) n)) w)

let sxload = xload "sx"
let zxload = xload "zx"

let lostore ~addr ~src n assn =
  assert (Register.width src = wordsize);
  rtl (R.store (R.mem assn mspace (mcount n) addr) (lobits n (tval src)) n)
@
%%The general move operation only works between temporaries of the same
%%width. Load immediate loads a constant into a temorary.
<<MIPS postexpander>>=
let move ~dst ~src =
  assert (Register.width src = Register.width dst);
  if Register.eq src dst then PX.Nop
  else rtl (R.store (tloc dst) (tval src) (twidth src))
@ 
<<MIPS postexpander>>=
let extract ~dst ~lsb ~src = Impossible.unimp "extract"
let aggregate ~dst ~src = Impossible.unimp "aggregate"
@ 
<<MIPS postexpander>>=
let hwset ~dst ~src = Impossible.unimp "setting hardware register"
let hwget ~dst ~src = Impossible.unimp "getting hardware register"
@
%%Immediate load, and extended immediate load. An extended load-immediate
%%can take sums and differences of compile-time constants (including late
%%compile-time constants). 
<<MIPS postexpander>>=
let li  ~dst const = rtl (R.store (tloc dst) (Up.const const) (twidth dst))
let lix ~dst e     = rtl (R.store (tloc dst) e                (twidth dst))  
@
%%% ------------------------------------------------------------------ 
%%\subsubsection{Binary and unary operators}
%%% ------------------------------------------------------------------ 
<<MIPS postexpander>>=
let unop ~dst op x =
  rtl (R.store (tloc dst) (R.app (Up.opr op) [tval x]) (twidth dst))

let binop ~dst op x y =
  rtl (R.store (tloc dst) (R.app (Up.opr op) [tval x;tval y]) (twidth dst))

let unrm  ~dst op x rm   = Impossible.unimp "floating point with rounding mode"
let binrm ~dst op x y rm = Impossible.unimp "floating point with rounding mode"
let dblop ~dsthi ~dstlo op x y = Unsupported.mulx_and_mulux()
let wrdop  ~dst op x y z = Unsupported.singlebit ~op:(fst op)
let wrdrop ~dst op x y z = Unsupported.singlebit ~op:(fst op)
@
%%% ------------------------------------------------------------------ 
%%\subsubsection{Control Flow}
%%% ------------------------------------------------------------------ 
%%
%%On the {\mips}, the PC can be read and written.
%%Because the assembler hides delayed branches, we temporarily get away
%%with ignoring branch delays.
<<MIPS postexpander>>=
let pc_lhs = Rg.pc         (* PC as assigned by branch *)
let pc_rhs = Rg.pc         (* PC as captured by call   *)
@
%%\paragraph{Unconditional Branches}
<<MIPS postexpander>>=
let br ~tgt = PX.Nop, R.store pc_lhs (tval tgt)     wordsize  (* branch reg *)
let b  ~tgt = PX.Nop, R.store pc_lhs (Up.const tgt) wordsize  (* branch     *)
@
%%\paragraph{Conditional Branches}
%%
%%The {\mips} assembler implements conditional branches directly, that is,
%%without setting a condition code that a later branch uses.
%%(It's a cheat, because the hardware needs the SLT (set less than)
%%instruction, but it's a nice cheat.)
%%
%%The [[negate]] function implements the nagation for of a binary
%%operator.
<<MIPS postexpander>>=
let negate = function
  | "ne"            -> "eq"
  | "eq"            -> "ne"
  | "ge"            -> "lt"
  | "gt"            -> "le"
  | "le"            -> "gt"
  | "lt"            -> "ge"
  | "geu"           -> "ltu"
  | "gtu"           -> "leu"
  | "leu"           -> "gtu"
  | "ltu"           -> "geu"
  | "feq"           
  | "fne"           
  | "flt"           
  | "fle"           
  | "fgt"           
  | "fge"           
  | "fordered"      
  | "funordered"    -> unimp "floating-point comparison"
  | _               -> impossible 
                        "bad comparison in expanded MIPS conditional branch"
@ 
%%A conditional branch is implemented directly; the MIPS does not use
%%condition codes, and we let the assembler hide the occasional need for
%%a temporary register.
<<MIPS postexpander>>=
let bc x (opr, ws as op) y ~ifso ~ifnot =
  assert (ws =*= [wordsize]);
  PX.Test (PX.Nop, (R.app (Up.opr op) [tval x; tval y], ifso, ifnot))
@
%%[[bnegate]] inverts the condition in a conditional branch.
<<MIPS postexpander>>=
let bnegate r = match Dn.rtl r with
    |           RP.Rtl [ RP.App( (op,       [32]), [x; y]), RP.Store (pc, tgt, 32)]
      when RU.Eq.loc pc (Dn.loc pc_lhs) ->
        Up.rtl (RP.Rtl [ RP.App( (negate op,[32]), [x; y]), RP.Store (pc, tgt, 32)])
    | _ -> impossible "ill-formed MIPS conditional branch"
@
%%\paragraph{Calls} Direct and indirect calls. In an indirect call the
%%target is held in a register. I don't understand the [[others]]
%%parameter. 
<<MIPS postexpander>>=
let effects = List.map Up.effect
let call  ~tgt ~others = 
  PX.Nop, R.par (R.store pc_lhs (Up.const tgt) wordsize :: effects others)
let callr ~tgt ~others = 
  PX.Nop, R.par (R.store pc_lhs (tval tgt) wordsize :: effects others)
@
%%\paragraph{Cut-To}
<<MIPS postexpander>>=
let cut_to effs = PX.Nop, R.par (effects effs)
@
%%\paragraph{No sacred instructions}
<<MIPS postexpander>>=
let don't_touch_me es = false
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Expander}
%%% ------------------------------------------------------------------ 
<<mips.ml>>=
module X = Expander.IntFloatAddr(Post)
@
%%% ------------------------------------------------------------------ 
\subsection{Spill and reload}
%%% ------------------------------------------------------------------ 
%%
%%The register allocator needs to spill and reload values; we 
%%provide the instructions.
<<mips.ml>>=
let spill  p t l = [A.store l (Post.tval t) (Post.twidth t)]
let reload p t l = 
  let w = Post.twidth t in [R.store (Post.tloc t) (Automaton.fetch l w) w]
@
%%% ------------------------------------------------------------------ 
\subsection{Global Variables}
%%% ------------------------------------------------------------------ 
%%
%%When a Global {\PAL} variable names no hardware register to live in, the
%%variable is passed through to following automaton to obtain its
%%location.
%%
%%THIS AUTOMATON SEEMS QUITE UNIVERSAL FOR 32 BIT ARCHITECTURES. MOVE IT
%%TO Automaton.Standard32?
<<mips.ml>>=
let ( *> ) = A.( *> )
let globals base = 
  let width w = if      w <= 8  then 8  
                else if w <= 16 then 16 
                else Auxfuns.round_up_to 32 w in
  let align = function 8 -> 1 | 16 -> 2 | _ -> 4 in
  A.at ~start:base mspace 
    (A.widen width *> A.align_to align *>
     A.overflow ~growth:Memalloc.Up ~max_alignment:4)
@
%%This variable placer is a simplified version of the x86 placer.
<<mips.ml>>=
let placevars = 
  let is_float    w kind _ = w <= 32 && kind =$= "float" in
  let warn ~width:w ~alignment:a ~kind:k =
    if w > 32 then
      unimp (Printf.sprintf "%d-bit values (because no block copies)" w) in
  let mk_stage ~temps =
    A.choice
      [ is_float,               A.widen (Auxfuns.round_up_to ~multiple_of: 32); 
        (fun w h _ -> w <= 32), A.widen (fun _ -> 32) *> temps 't';
        A.is_any,               A.widen (Auxfuns.round_up_to ~multiple_of: 8);
      ] in
  Placevar.mk_automaton ~warn ~vfp ~memspace:mspace mk_stage     
@ 
%$
%%% ------------------------------------------------------------------ 
\subsection{The target record}
%%% ------------------------------------------------------------------ 
%%
<<mips.ml>>=
let target =
    let spaces = [ Rg.Spaces.m
                 ; Rg.Spaces.r
                 ; Rg.Spaces.f
                 ; Rg.Spaces.t
                 ; Rg.Spaces.u
                 ; Rg.Spaces.c
                 ] in
    { T.name                = "mips"
    ; T.memspace            = mspace
    ; T.max_unaligned_load  = R.C 1
    ; T.byteorder           = byteorder
    ; T.wordsize            = wordsize
    ; T.pointersize         = wordsize
    ; T.alignment           = 4             (* not sure *)
    ; T.memsize             = 8
    ; T.spaces              = spaces
    ; T.reg_ix_map          = T.mk_reg_ix_map spaces
    ; T.distinct_addr_sp    = false
    ; T.float               = Float.ieee754
    ; T.spill               = spill
    ; T.reload              = reload

    ; T.vfp                 = vfp
    ; T.bnegate             = F.bnegate Rg.cc
    ; T.goto                = F.goto
    ; T.jump                = F.jump
    ; T.call                = F.call
    ; T.return              = F.return
    ; T.branch              = F.branch
    
    ; T.cc_specs            = A.init_cc
    ; T.cc_spec_to_auto     = Mipscall.cconv 
                                ~return_to:(fun ra -> (R.store Rg.pc ra wordsize))
                                (F.cutto (Rtl.reg sp))
    ; T.is_instruction      = Mipsrec.is_instruction
    ; T.tx_ast = (fun secs -> secs)
    ; T.capabilities        = T.incapable
    ; T.globals             = globals
    ; T.rounding_mode       = Rtl.reg rm_reg
    ; T.named_locs          = Strutil.assoc2map
                              ["v0", Rtl.reg (reg 2) (* for SPIM *)
                              ]
    ; T.data_section        = "data"
    ; T.charset             = "latin1" (* REMOVE THIS FROM TARGET.T *)
    }    

@ 
\section{[[arch/mips/mipsasm.nw]]}
<<arch/mips/mipsasm.ml>>=
<<mipsasm.ml>>
@

<<arch/mips/mipsasm.mli>>=
<<mipsasm.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% ------------------------------------------------------------------ 
\section{{\mips} Assembler}
%%% ------------------------------------------------------------------ 
%%
%%This assembler emits assembly language for the {\mips} platform. It
%%implements the [[Asm.assembler]] interface.
%%
%%The {\mips} assembler uses register masks to specify registers that need
%%to be saved. I assume that we do not use these but emit code directly
%%that implements spilling.
%%
<<mipsasm.mli>>=
type node = Rtl.rtl Cfgx.M.node
val make : 
  ('cfg -> (node -> unit) -> (Rtl.rtl -> unit) -> (string -> unit) -> unit) ->
  out_channel -> ('a, 'cfg, 'b, 'c) Proc.t Asm.assembler
  (* pass Cfgutil.emit or Cfgutil.emit *)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Name Mangling}
%%% ------------------------------------------------------------------ 
%%
<<name mangler specification>>=
let spec =
    let reserved = [] in        (* list reserved words here so we can
                                   avoid them *)
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '_'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '_' 
        in    
            { Mangle.preprocess = (fun x -> x)  
            ; Mangle.replace    = replace
            ; Mangle.reserved   = reserved
            ; Mangle.avoid      = (fun x -> x ^ "_")
            }
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%No suprises here. See the sepecification of the interface in
%%\module{asm.nw} for the semantics of the public methods.
%%
<<mipsasm.ml>>=
module SM = Strutil.Map

type node = Rtl.rtl Cfgx.M.node

let fprintf = Printf.fprintf
let sprintf = Printf.sprintf
let unimp   = Impossible.unimp
let int64   = Bits.U.to_int64 

<<name mangler specification>>

class ['a, 'b, 'c, 'd] asm emitter fd : [('a, 'b, 'c, 'd) Proc.t] Asm.assembler = 
object (this)
    val         _fd       = fd
    val         _mangle  = (Mangle.mk spec)   
    val mutable _syms    = SM.empty 
    val mutable _section = "bogus section"
    
    method globals _ = ()
    method private new_symbol name =
        let s = Symbol.with_mangler _mangle name in
            _syms <- SM.add name s _syms;
            s

    method private print l = List.iter (output_string _fd) l

    <<assembly methods(mipsasm.nw)>>
end
let make emitter fd = new asm emitter fd
@ 
%%
%%% ------------------------------------------------------------------ 
\subsection{Public Methods}
%%% ------------------------------------------------------------------ 
%%
<<assembly methods(mipsasm.nw)>>=
method import s = this#new_symbol s
method local  s = this#new_symbol s

method export s =
    let sym = this#new_symbol s in
    Printf.fprintf _fd ".globl %s\n" sym#mangled_text;
    sym

method label (s: Symbol.t) = 
    fprintf _fd "%s:\n" s#mangled_text

method section name =
    _section <- name;
    fprintf _fd ".%s\n" name

method current  = _section
method org n    = unimp "no .org in mips assembler"

method align  n       = if n <> 1 then fprintf _fd ".align %d\n" n
method addloc n       = if n <> 0 then fprintf _fd ".space %d\n"  n
method zeroes (n:int) = fprintf _fd ".space %d, 0\n" n

method value (v:Bits.bits) = match Bits.width v with
    |  8 -> fprintf _fd ".byte %Ld\n"  (int64 v)
    | 16 -> fprintf _fd ".double %Ld\n" (int64 v)
    | 32 -> fprintf _fd ".word %Ld\n"  (int64 v)
    | w ->  unimp (sprintf "unsupprted width %d in mips assembler" w)

method addr a =
  match Reloc.if_bare a with
  | Some b -> this#value b
  | None -> let const bits = Printf.sprintf "0x%Lx" (Bits.U.to_int64 bits) in
            assert (Reloc.width a = 32);
            fprintf _fd ".word %s\n" (Asm.reloc_string const a)

method emit = ()
@
%%The SPIM {\mips} simulator expects comments to start with a [[#]], the
%%\textit{as}(1) assembler on IRIX uses the C~convention. To be on the
%%save side I disable comments for the moment.
<<assembly methods(mipsasm.nw)>>=
method comment s = fprintf _fd "#  %s   \n" s
method comment s = fprintf _fd "/* %s */\n" s
method comment s = ()

method const (s: Symbol.t) (b:Bits.bits) = 
    fprintf _fd "%s = %Lx" s#mangled_text (int64 b)

method longjmp_size () =
  Impossible.unimp "longjmp size not set for mips -- needed for alternate returns"

method private instruction rtl =
    output_string _fd (Mipsrec.to_string rtl);
    output_string _fd "\n"

method private call node =
  match Cfgx.M.to_executable node with
  | None   -> ()
  | Some i -> this#instruction i


method cfg_instr proc  = 
    let cfg    = proc.Proc.cfg
    and symbol = proc.Proc.symbol in
    let label l = this#label (try SM.find l _syms 
                              with Not_found -> this#local l) in
    Printf.fprintf _fd ".set noreorder  /* HACK! mipsasm.nw did this */\n";  
    Printf.fprintf _fd ".abicalls       /* HACK! NetBSD needs this */\n";
    this#label symbol;
    Printf.fprintf _fd ".cpload $25     /* HACK! NetBSD needs this */\n";
    (emitter cfg (this#call) (this#instruction) label : unit)
@
%$
%%
%%
\section{[[arch/mips/mipscall.nw]]}
<<arch/mips/mipscall.ml>>=
<<mipscall.ml>>
@

<<arch/mips/mipscall.mli>>=
<<mipscall.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% ------------------------------------------------------------------ 
\section{{\mips} calling conventions}
%%% ------------------------------------------------------------------ 
%%
%%\emph{Spreading the {\mips} backend across several files increases the
%%chance of inconsistencies. Each file defines the byteorder and certain
%%registers. Is this a real problem? It definitely makes it harder to define
%%a little and a big-endian {\mips} backend. --CL}
%%
%%This module implements calling conventions for the {\mips}. The
%%parameters represent the machine instructions to implement [[return]]
%%and [[cut to]]. The [[c']] convention is the same as the [[c]]
%%convention, but is implemented using the [[Callspec]] module. We keep
%%both until we are convinced the latter is correct. 
%%
<<mipscall.mli>>=
val cconv :
  return_to:(Rtl.exp -> Rtl.rtl) ->
  Mflow.cut_args Target.map ->
  string -> Automaton.cc_spec ->
  Call.t
@
%%The book \emph{mips Risc Architecture} by Gerry Kane, published by
%%Prentice Hall describes the calling convention. However, the calling
%%convention specification on page D-22 seens outdated in comparision to
%%what compiler expect.  A better source for the calling convention is the
%%LCC compiler, which implements it in this short function:
<<implementation of {\mips} calling convention in LCC>>=
static Symbol argreg(int argno, int offset, int ty, int sz, int ty0) {
        assert((offset&3) == 0);
        if (offset > 12)
                return NULL;
        else if (argno == 0 && ty == F)
                return freg2[12];
        else if (argno == 1 && ty == F && ty0 == F)
                return freg2[14];
        else if (argno == 1 && ty == F && sz == 8)
                return d6;  /* Pair! */
        else
                return ireg[(offset/4) + 4];
}
@
%%[[argno]] is the zero-based index of the parameter, and [[ty0]] the type
%%of argument zero. Offset is the total size of all preceding arguments,
%%each a multiple of 4 bytes. This is crucial, because the last line
%%chooses a register not by the argument index, but by the total size of
%%preceding arguments.
%%
\subsection{Implementation of {\mips} calling conventions}
%%
<<mipscall.ml>>=
module A  = Automaton
module C  = Call
module R  = Rtl
module Rg = Mipsregs
module RP = Rtl.Private
module RS = Register.Set
module RU = Rtlutil
module T  = Target

let impossf fmt = Printf.kprintf Impossible.impossible fmt
@
%%\paragraph{Registers}
%%
%%A non-volatile register can be used in a procedure if its initial value
%%is restored upon exit. Such a register is also called callee-saved. A
%%volatile register can be used without saving and restoring. Registers
%%that are neither volatile nor non-volatile are unavailable for register
%%allocation.
%%
%%The return address [[ra]] is volatile.
%%It can be used for register allocation, but the call instruction
%%always writes it (and it is live on entry).
<<mipscall.ml>>=
let r n     = (Rg.rspace, n, R.C 1)
let f n     = (Rg.fspace, n, R.C 1)
let vfp     = Vfp.mk 32
@
%%Calling conventions treat floating point registers specially; therefore
%%we have separate lists for them.
<<mipscall.ml>>=
let vol_int  = List.map r (Auxfuns.from 2  ~upto:15 @ [24;25;31])
let nvl_int  = List.map r (Auxfuns.from 16 ~upto:23 @ [30])
let vol_fp   = List.map f (Auxfuns.from 0  ~upto:18)
let nvl_fp   = List.map f (Auxfuns.from 20 ~upto:30)
@
%%Non-volatile registers are saved somewhere in the frame. Currently, we
%%cannnot provide dedicated locations.
<<mipscall.ml>>=
let saved_nvr temps =
    let t = Talloc.Multiple.loc temps 't' in
    let u = Talloc.Multiple.loc temps 'u' in
        function
        | (('r', _, _),_,_) as reg -> t (Register.width reg)
        | (('f', _, _),_,_) as reg -> u (Register.width reg)
        | ((s, _, _), i, _) -> impossf "cannot save $%c%d" s i
@
%$
%%And in Lua:
<<MIPS calling convention automata in Lua>>=
A            = Automaton
Mips         = Mips         or {}
Mips.cc      = Mips.cc      or {}
Mips.cc["C"] = Mips.cc["C"] or {}

Mips.sp_align  = 16
Mips.wordsize  = 32

function reg(sp,i,agg) 
  return Register.create { space = sp, index = i, cellsize = 32, agg=agg }
end
function f(i) return (reg("f", i, 'little')) end
function r(i) return (reg("r", i)) end

Mips.vol_fp  = (f(0) .. f(18))
Mips.vol_int = (r(2) .. r(15)) .. { r(24), r(25), r(31) }
@ 
%%\paragraph{Conventions}
%%
%%Stack pointer alignment is tricky. It is not mentioned in the
%%architecture manual and also seems to depend on the operating system.
%%The SGI IRIX 5.x requires 8-byte alignment, SGI IRIX 6.x 16-byte
%%alignment. LCC therefore always uses 16-byte alignment.
<<mipscall.ml>>=
let ra        = R.reg (r 31)            (* return address *)
let sp        = R.reg (r 29)            (* stack pointer  *)
let spval     = R.fetch sp 32
let growth    = Memalloc.Down           (* stack grows down *)
let sp_align  = 16                      (* SP always 16-byte aligned *)

let std_sp_location = 
    RU.add 32 vfp (R.late "minus frame size" 32)

let ( *> ) = A.( *> )

let badwidth (msg:string) (w:int) =
  impossf "unsupported (rounded) width %d in MIPS: %s" w msg

let fatal _ = impossf "fatal error in MIPS automaton"
@
%%\paragraph{C~return results}
%%
%%A C~function returns an integer (up to 64 bits wide) in [[$2]] and
%%[[$3]], a floating-point result (up to two double-precision values) in
%%[[$f0]] \dots [[$f3]].
%%
<<MIPS calling convention automata in Lua>>=
Mips.cc["C"].results =
  { A.widen  (32, "multiple")
  , A.widths { 32, 64 }
  , A.choice { "float" , A.useregs(f(0) .. f(3))
             , A.is_any, A.useregs(r(2) .. r(3))
             }
  }
@ 
%%\paragraph{C~procedure parameters}
%%
<<MIPS calling convention automata in Lua>>=
-- note that there's some postprocessing magic going on in mipscall.nw too
function Mips.alignf (size)
  if size == 64 then return 8 else return 4 end
end

Mips.cc["C"].call =
  { A.widen (32, "multiple")
  , A.widths { 32, 64 }
  , A.align_to(Mips.alignf)
  , A.bitcounter("bits")
  , A.pad("bits")
  , A.argcounter("args")
  , A.first_choice { 
      "float" , A.choice {
                  { "float", 64 }, A.regs_by_bits("bits", f(12)..f(15))
                , "float", A.regs_by_args("args", {f(12), f(14)})
                , A.is_any, {}
                },
      A.is_any, {}
    }
  , A.regs_by_bits("bits", r(4)..r(7))
  , A.overflow { growth = "up", max_alignment = Mips.sp_align }
  }
@
%%And now for postprocessing of both ML and Lua style automata specifications.
<<mipscall.ml>>=
let prefix16bytes result =
    let b = Block.relative vfp "16-byte block" Block.at ~size:16 ~alignment:4 
    in    
        { result with 
          A.overflow = Block.cathl result.A.overflow b
        }

let postprocess cconv =
    { cconv with A.call = A.postprocess cconv.A.call prefix16bytes }
@
%%\paragraph{C~cut-to parameters}
%%
%%Since this is strictly internal calling convention, we can use whatever
%%we like. We use all volatile registers.
<<MIPS calling convention automata in Lua>>=
Mips.cc["C"].cutto =
  { A.widen (32, "multiple")
  , A.choice { "float" , A.useregs(Mips.vol_fp)
             , A.is_any, A.useregs(Mips.vol_int)
             }
  , A.overflow { growth = "up", max_alignment = Mips.sp_align }
  }
@
\subsection{Putting it together} 
%%
%%Attention: the current implementation of [[Callspec]] cannot express the
%%{\mips} calling convention because of the reserved 16-byte block that is
%%part of the frame layout. The [[Callspec]] implementation assumes that
%%an overflow block is always at the extreme end of a frame, which is not
%%the case here.
<<transformations(mipscall.nw)>>=
let autoAt = A.at Rg.mspace in
let prolog =
  let autosp = (fun _  -> vfp) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in call parms" autoAt stage.A.call)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a) in

let epilog =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out ovfl results" autoAt stage.A.results)
    ~autosp:(fun r  -> std_sp_location)
    ~postsp:(fun _ _ -> vfp) in

let call_actuals =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out call parms" autoAt stage.A.call)
    ~autosp:(fun r    -> std_sp_location)
    ~postsp:(fun a sp -> std_sp_location) in

let call_results =
  let autosp = (fun r   -> std_sp_location) in
  C.incoming ~growth ~sp
    ~mkauto:(fun ()  -> Block.srelative vfp "in ovfl results" autoAt stage.A.results)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a) in

let also_cuts_to =
  let autosp = (fun r -> std_sp_location) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in cont parms" autoAt stage.A.cutto)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a) in

let cut_actuals base =
   C.outgoing ~growth ~sp ~mkauto:(fun () -> autoAt base stage.A.cutto)
     ~autosp:(fun r -> spval)
     ~postsp:(fun _ _ -> spval) in
@ 
%%
<<mipscall.ml>>=
let c ~return_to cut stage = 
    let stage = postprocess stage in
    <<transformations(mipscall.nw)>>
    let return k n ~ra =
        if k = 0 & n = 0 then return_to ra
        else impossf "alternate return using C calling convention" in
    { C.name            = "C"
    ; C.overflow_alloc  = { C.parameter_deallocator = C.Caller
                          ; C.result_allocator      = C.Caller
                          }
    ; C.call_parms      = { C.in' = prolog       ; C.out = call_actuals }
    ; C.cut_parms       = { C.in' = also_cuts_to ; C.out = cut_actuals  }
    ; C.results         = { C.in' = call_results ; C.out = epilog       }

    ; C.stack_growth    = growth
    ; C.stable_sp_loc   = std_sp_location
    ; C.replace_vfp     = Cfgx.Vfp.replace_with ~sp
    ; C.sp_align        = sp_align
    ; C.pre_nvregs      = RS.union (RS.of_list nvl_int) (RS.of_list nvl_fp)
    ; C.volregs         = RS.union (RS.of_list vol_int) (RS.of_list vol_fp)
    ; C.saved_nvr       = saved_nvr
    ; C.cutto           = cut
    ; C.return          = return
    ; C.ra_on_entry      = (fun _     -> R.fetch ra 32)
    ; C.where_to_save_ra = (fun _ t   -> Talloc.Multiple.loc t 't' 32)
    ; C.ra_on_exit       = (fun _ _ t -> ra)
    ; C.sp_on_unwind     = (fun e   -> RU.store sp e)
    ; C.sp_on_jump       = (fun _ _ -> Rtl.null)
    }
@
%%And in Lua:
<<MIPS calling convention automata in Lua>>=
-- register the new calling conventions!
A.register_cc(Backend.mips.target, "C" , Mips.cc["C"])
A.register_cc(Backend.mips.target, "C'", Mips.cc["C"])
A.register_cc(Backend.mips.target, "C--", Mips.cc["C"])
@ 
\subsection{Implementation using [[Callspec]]}
%%
<<mipscall.ml>>=
module CS = Callspec

let rtn return_to k n ~ra =
    if k = 0 & n = 0 then return_to ra
    else impossf "alternate return using C calling convention" 
@
<<callspec specification>>=
let spec = 
        { CS.name           = "C'"
        ; CS.stack_growth   = Memalloc.Down
        ; CS.overflow       = CS.overflow C.Caller C.Caller
        ; CS.sp             = r 29
        ; CS.sp_align       = sp_align
        ; CS.memspace       = Rg.mspace
        ; CS.all_regs       = RS.of_list (List.concat [nvl_int; nvl_fp;
                                                       vol_int; vol_fp])
        ; CS.nv_regs        = RS.of_list (nvl_int @ nvl_fp)
        ; CS.save_nvr       = saved_nvr
        ; CS.ra             = (ra, CS.ReturnAddress.SaveToTemp 't')
        }
@
<<mipscall.ml>>=
let c' ~return_to cut auto =
    <<callspec specification>>
    in
    let t = CS.to_call cut (rtn return_to) auto spec in
        { t with (* fix what callspec got wrong *)
            C.ra_on_exit   = (fun _ _ t -> ra)
        ;   C.sp_on_unwind = (fun e -> RU.store sp e)
        }
@
%%And finally our lookup function.
<<mipscall.ml>>=
let cconv ~return_to cut ccname stage = 
  let f =
    match ccname with
    | "C'" -> c'
    | _    -> c
  in f ~return_to cut stage
@ 
\section{[[arch/mips/mipsrec.nw]]}
<<arch/mips/mipsrec.mli>>=
<<mipsrec.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et:
%%
%%% ------------------------------------------------------------------ 
\section{MIPS Recognizer}
%%% ------------------------------------------------------------------ 
%%
%%This module provides a recognizer for {\mips} {\rtl}s. The recognizer
%%has two interfaces. The first is a predicate that is true, if an {\rtl}
%%is a {\mips} instruction. The second returns an assembly-language string
%%representation of the instruction.
%%
<<mipsrec.mli>>=
val is_instruction: Rtl.rtl -> bool
val to_string:      Rtl.rtl -> string
@
%%
%%It is a checked run-time error to pass an {\rtl} to [[to_string]] that
%%is not a {\mips} instruction.
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation is guided by the book \emph{\textsc{mips} Risc
%%Architecture} by Gerry Kane, published by Prentice Hall.
%%
%%The recognizer is generated from a {\burg} specification. The [[head]]
%%part precedes code generated from [[rules]], the [[tail]] part follows
%%it.
%%
<<mipsrec.mlb>>=
%head {: <<head>> :}
%tail {: <<tail>> :}
%term <<terminal types>>
%%
<<rules(mipsrec.nw)>>
@
%%
%%The usual abbreviations for modules go into the [[head]] clause.
%%
<<head>>=
module RP = Rtl.Private
module RU = Rtlutil
module Up = Rtl.Up
module Dn = Rtl.Dn
module SS = Space.Standard32
@
%%
%%We report a fatal error with [[error]]. We do not expect to recover from
%%such an error; it is something that should not happen and is caused by
%%an internal inconsistency.
%%
<<head>>=
exception Error of string
let error msg = raise (Error msg)   
let sprintf   = Printf.sprintf (* useful for formatting msg *)
@
%%
%%The [[guard]] function turns a predicate into a cost function that can
%%be used in a dynmaic cost expression.
%%
<<head>>=
let guard p = if p then 0 else Camlburg.inf_cost
@
%%
%%Some utilities for building strings.
%%
<<head>>=
let const32 b =
    assert (Bits.width b = 32);
    Nativeint.to_string (Bits.U.to_native b)

let const64 b =
    assert (Bits.width b = 64);
    Int64.to_string (Bits.U.to_int64 b)     (* signed or unsigned? *)

let cat     = String.concat ""
let printf  = Printf.printf
let sprintf = Printf.sprintf

let reg n   = "$"  ^ string_of_int n
let freg n  = "$f" ^ string_of_int n

let suffix = function
    | 8  -> "b"      
    | 16 -> "h"
    | 32 -> "w"
    | w  -> error (sprintf "not a MIPS width: %d" w)

let zx    = "u"  (* to construct op-code *) 
let sx    = ""
let width = string_of_int
@
%%
%%To load immediate 64-bit integers we split them into an upper and a
%%lower half of 32-bit each, using [[lo]] and [[hi]].
%%
<<head>>=
let lo b =
    assert (Bits.width b = 64);
    Bits.Ops.lobits 32 b

let b32 = Bits.U.of_int 32 64
let hi b =
    assert (Bits.width b = 64);
    Bits.Ops.lobits 32 (Bits.Ops.shrl b b32)
@    
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Recognizer Rules}
%%% ------------------------------------------------------------------ 
%%
%%Note that the {\mips} assembler provides pseudo instructions that
%%translate into multiple machine instructions. If we would emit binary
%%instructions we would have to implement these pseudo instructions here.
%%
%%\iffalse
%%\begin{quote}
%%\begin{tabularx}{\linewidth}{@{}>{\ttfamily}lX@{}}
%%    \emph{Nonterminal} & \emph{Meaning} \\ 
%%    \hline
%%    too lazy to keep this up to date\\
%%\end{tabularx}
%%\end{quote}
%%\fi
%%
%%We use [[x]] as an universal terminal type whenever we need one. 
%%
<<terminal types(mipsrec.nw)>>=
bits n x w
@
%%
<<rules(mipsrec.nw)>>=
const64:    Bits(bits) [{: guard (Bits.width bits = 64)  :}]{:         bits :}
const:      Bits(bits) [{: guard (Bits.width bits = 32)  :}]{: const32 bits :}
symbol:     Link(x, w:int)      {: x#mangled_text :}
@
%%
%%\paragraph{Registers}
%%
<<rules(mipsrec.nw)>>=
f:          Reg('f', n:int)  {: n :}
r:          Reg('r', n:int)  {: n :}

regl:       r   {: reg r  :}
fregl:      f   {: freg f :}

pcl:        Reg('c',  0) {: () :}
spl:        Reg('r', 29) {: () :}
ral:        Reg('r', 31) {: () :}

reg:        Fetch(regl,w:int)   {: regl   :}
freg:       Fetch(fregl,w:int)  {: fregl  :}

pc:         Fetch(pcl,32)       {: () :}
sp:         Fetch(spl,32)       {: () :}
ra:         Fetch(ral,32)       {: () :}
@
%%
%%\paragraph{Addresses}
%%
<<rules(mipsrec.nw)>>=
meml:       Mem(addr)     {: addr :}
mem:        Fetch(meml,w:int)   {: meml :}

addr:       reg                 {: cat ["(";reg;")"]     :}
addr:       imm                 {: imm                   :}
addr:       Add(imm,reg)        {: cat [imm;"(";reg;")"] :}
addr:       Add(reg,imm)        {: cat [imm;"(";reg;")"] :}
addr:       symbol              {: symbol                :}
@
%%
%%\paragraph{Constant Expressions}
%%
<<rules(mipsrec.nw)>>=
imm:        const               {: const                 :} 
imm:        symbol              {: symbol                :}
imm:        Add(symbol,imm)     {: cat [symbol;"+";imm]  :}
imm:        Add(imm,symbol)     {: cat [symbol;"+";imm]  :}
@
%%
%%\paragraph{Data Movement}
%%
%%Load register from memory. A load of a value smaller than 32 bits
%%implies a zero or sign extension.
%%zero 
%%
%%\emph{What is the difference between [[li]] and [[la]]? Maybe the
%%[[imm]] nonterminal is ill-defined. --CL}
%%
%%
<<rules(mipsrec.nw)>>=
inst:       Store(regl,imm,32)
            {: cat ["la"; " "; regl; ","; imm] :}

inst:       Store(regl,const,32)
            {: cat ["li"; " "; regl; ","; const] :}

inst:       Store(regl,mem,32)
            {: cat ["l"; suffix 32; " "; regl; ","; mem] :}

inst:       Store(regl, Sx(Fetch(mem,x:int)), w:int)
            {: cat ["l"; suffix w; sx; " "; regl; ","; mem] :}

inst:       Store(regl, Zx(Fetch(mem,x:int)), w:int) 
            {: cat ["l"; suffix w; zx; " "; regl; ","; mem] :}
@
%%
%%The following two rules load constants into floating-point registers.
%%However, the assembler expect the constant in floating-point syntax
%%which we cannot produce easily.
%%
<<rules we don't use>>=
inst:       Store(fregl,const,32)
            {: cat ["li.s"; " "; fregl; ","; const] :}

inst:       Store(fregl,const,64)
            {: cat ["li.d"; " "; fregl; ","; const] :}
@
%%
%%A [[li]] instruction is translated by the assembler into a [[lui]] and
%%an [[ori]] instruction that does \emph{not} use register 1 that is
%%reserved for the assembler. Therefore, we can use register 1 when we
%%move a 64-bit constant into a floating-point register.
%%
<<rules(mipsrec.nw)>>=
inst:       Store(fregl,const,32)
            {: sprintf "li $1, %s; mtc1 $1, %s" const fregl :} 
@
%%
%%To construct the proper rigister names we cannot use the string
%%provided by [[fregl]] but must use the integer provided by [[f]].
%%Analogously we need the bit vector and not its string representation.
%%
<<rules(mipsrec.nw)>>=
inst:       Store(f,b:const64,64)
            {: sprintf "li $1, %s; mtc1 $1, %s; li $1 %s; mtc1 $1, %s"
                       (const64 (lo b)) (freg f) (const64 (hi b)) (freg (f+1))
            :}           
@
%%
%%Store register to memory. No extension here; the 8, 16, or 32 bits are
%%simply written to memory.
%%
<<rules(mipsrec.nw)>>=
inst:       Store(meml, reg, w:int)
            {: cat ["s"; suffix w; " "; reg; ","; meml] :}

inst:       Store(meml, freg, w:int)
            {: cat ["s.s "; freg; ","; meml] :}
@
%%
%%Moves between registers. For the [[move]] and [[mov]] instruction, we
%%assume the destination is the first argument.
%%
<<rules(mipsrec.nw)>>=
inst:       Store(regl, reg, 32)
            {: cat ["move"; " "; regl; ","; reg] :}

inst:       Store(fregl, freg, 32)
            {: cat ["mov.s"; " "; fregl; ","; freg] :}

inst:       Store(fregl, freg, 64)
            {: cat ["mov.d"; " "; fregl; ","; freg] :}
@
%%
%%I'm not sure I need the [[nop]]. The IRIX assembler complained about the
%%lack of it and indeed it affects results. I guess it really needs to go
%%\emph{after} some operation.
%%
<<rules(mipsrec.nw)>>=
inst:       Store(fregl, reg, 32)
            {: cat ["nop; mtc1"; " "; reg; ","; fregl] :}

inst:       Store(regl, freg, 32)
            {: cat ["nop; mfc1"; " "; regl; ","; freg] :}


@
%%
%%
%%\paragraph{Control Flow}
%%
<<rules(mipsrec.nw)>>=
inst:       Goto(symbol)
            {: cat ["j"; " "; symbol] :}

inst:       Goto(reg)
            {: cat ["jr"; " "; reg] :}
@
%%
%%The [[next]] pattern covers the expression $PC + 4$ which denotes the
%%return address after a call.
%%
<<rules(mipsrec.nw)>>=
next:       Add(pc,const)       {: () :}
inst:       Par(Goto(addr),Store(ral,next,32))     -- s/addr/symbol/g ? 
            {: cat ["jal"; " "; addr] :} 
@
%%
%%Here is a special hack for the SPIM {\mips} simulator. A system call on
%%SPIM is not called like a procedure, but simply by [[syscall]].
%%
<<rules(mipsrec.nw)>>=
syscall:    Link(x, w:int) [{: guard (x#mangled_text =$= "syscall") :}] {: () :}
inst:       Par(Goto(syscall), Store(ral,pc,32))
            {: "syscall" :}
@
%$
%%
%%Here are conditional branches. The {\rtl} operator names fit the {\mips}
%%assembly branch op-codes. We cannot inline the [[Cmp]] constructor
%%because the [[op]] terminal symbol would be unaccessible. Only top-level
%%terminals are in scope for the semantic action.
%%
<<rules(mipsrec.nw)>>=
cmp:        Cmp(op:string,x:reg,y:reg)              {: (op,x,y) :}
cmp:        Cmp(op:string,x:reg,y:const)            {: (op,x,y) :}
inst:       Guarded(cmp,Goto(addr)) 
            {: match cmp with 
               | (op,x,y) -> cat ["b";op;" ";x;",";y;",";addr]
            :}   
@
%%            
%%\paragraph{Arithmetic}
%%
<<rules(mipsrec.nw)>>=
inst:       Store(dst:regl, Add(x:reg,y:reg), 32)
            {: cat ["add"; " "; dst; ","; x; ","; y] :}
     
inst:       Store(dst:regl, Add(x:reg,y:imm), 32)
            {: cat ["addi"; " "; dst; ","; x; ","; y] :}
     
inst:       Store(dst:fregl, D2S(x:freg), 32)
            {: cat ["cvt.s.d"; " "; dst; ","; x] :}

inst:       Store(dst:fregl, S2D(x:freg), 64)
            {: cat ["cvt.d.s"; " "; dst; ","; x] :}
@
%%\paragraph{Other Instructions}
%%
<<rules(mipsrec.nw)>>=
inst:       Nop() {: "nop" :}
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Debugging Support}
%%% ------------------------------------------------------------------ 
%%
%%Uncomment the next rule to get a printout of the tree burg tries to
%%match.
%%
<<rules(mipsrec.nw)>>=
inst: any [100]         {: cat ["<";any;">"] :}

any : True  ()          {: cat [ "True"  ] :}
any : False ()          {: cat [ "False" ] :}
any : Link(x, w:int)    {: cat [ "Link(";x#mangled_text;",";width w;")" ] :}
any : Late(string,w:int){: cat [ "Late(";string;",";width w;")" ] :}
any : Bits(bits)        {: cat [ "Bits(b)" ] :}

any : Fetch (any, w:int){: cat [ "Fetch(";any;",";width w;")" ] :}

any : Add(x:any, y:any) {: cat [ "Add(";x;", ";y;")" ] :}
any : Sub(x:any, y:any) {: cat [ "Sub(";x;", ";y;")" ] :}
any : Sx(any)           {: cat [ "Sx(";any;")" ] :}
any : Zx(any)           {: cat [ "Zx(";any;")" ] :}
any : Lobits(any)       {: cat [ "Lobits(";any;")" ] :}

any : Mem(any)   {: cat [ "Mem(";any;")" ] :}
any : Reg(char, n:int)  {: cat [ "Reg('";Char.escaped char;"',"; width n;")" ] :}

any : Store (dst:any, src:any, w:int)
                        {: cat [ "Store(";dst;",";src;",";width w;")" ] :}
any : Kill(any)         {: cat [ "Kill(";any;")" ] :}

any : Guarded(guard:any, any) 
                        {: cat [ "Guarded(";guard;",";any;")" ] :}
any : Cmp(op:string, x:any, y:any)    
                        {: cat [ "Cmp(";op;",";x;",";y;")" ] :}
any : Par(l:any, r:any) {: cat [ "Par(";l;",";r;")" ] :}
any : Goto(any)         {: cat [ "Goto(";any;")" ] :}
@
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
%%% ------------------------------------------------------------------ 
%%
%%The principle interface is easy: {\rtl} constructors are mapped to
%%constructor functions of the same name. Because some transformations are
%%difficult to express in {\burg}, several operators and effects are
%%matched as special cases in {\ocaml}.
%%
%%
<<tail(mipsrec.nw)>>=
let const = function
    | RP.Bool _                 -> error "boolean found"
    | RP.Link(s,_,w)            -> conLink s w
    | RP.Diff _                 -> error "PIC not supported"
    | RP.Bits(b)                -> conBits b
    | RP.Late(s,w)              -> error (sprintf "late constant %s found" s)
@ 
<<tail(mipsrec.nw)>>=
<<helpers for [[exp]] and [[loc]]>>
let rec exp = function
    | RP.Const(k)               -> const k
    | RP.Fetch(l,w)             -> conFetch (loc l) w
    <<special cases for [[App]]>>
    | RP.App((o,_),_)           -> error (sprintf "unknown operator %s" o)

and loc = function
    | RP.Reg((sp,_,_),i,w)      -> conReg sp i
    | RP.Mem(('m',_,_),w,e,ass) -> conMem (exp e)
    | RP.Mem((sp,_,_),_,_,_)    -> error (sprintf "mem-space space %c" sp)
    | RP.Var   (s,i,w)          -> error (sprintf "var %s found" s)
    | RP.Global(s,i,w)          -> error (sprintf "var %s found" s)
    | RP.Slice _                -> error "cannot handle slice"
@
%%
<<tail(mipsrec.nw)>>=
let effect = function
    <<special cases for [[Store]]>>
    | RP.Store(l,e,w)           -> conStore (loc l) (exp e) w
    | RP.Kill(l)                -> error "cannot handle kill"
@ 
%%
<<tail(mipsrec.nw)>>=
let guarded g stmt = match g with
    | RP.Const(RP.Bool b)       -> if b then effect stmt else conNop ()
    <<special cases for [[guarded]]>>
    | _                         -> conGuarded (exp g) (effect stmt)

let rec geffects = function
    | []                        -> conNop ()
    | [g, s]                    -> guarded g s
    | (g, s) :: t               -> conPar (guarded g s) (geffects t) 

let rtl (RP.Rtl es) = geffects es
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Special cases}
%%% ------------------------------------------------------------------ 
%%
<<special cases for [[Store]]>>=
| RP.Store(RP.Reg(('c',_,_),i,w),r,_)
  when i = SS.indices.SS.pc   -> conGoto (exp r)
@
%%
<<helpers for [[exp]] and [[loc]]>>=
let cmp = 
    Strutil.from_list ["eq";"ge";"geu";"gt";"gtu";"le";"leu";"lt";"ltu";"ne"] 
@ 
%%
<<special cases for [[App]]>>=
| RP.App(("add", [w]), [x; y])            -> conAdd (exp x) (exp y)
| RP.App(("sub", [w]), [x; y])            -> conSub (exp x) (exp y)
| RP.App(("f2f_implicit_round", [32;64]), [x])     -> conS2D (exp x) 
| RP.App(("f2f_implicit_round", [64;32]), [x])     -> conD2S (exp x) 

| RP.App((op, [w]), [x; y]) 
    when Strutil.Set.mem op cmp           -> conCmp op (exp x) (exp y)
@
%%
<<special cases for [[guarded]]>>=
@
%%
%%    
%%% ------------------------------------------------------------------ 
\subsection{The exported recognizers}
%%% ------------------------------------------------------------------ 
%%
%%If an error occurs, we emit the error message to [[stderr]] and include
%%it in the output. This will lead to errors with the assembler but makes
%%debugging easier because we do not abort after the first problem. Revise
%%this once the expander is more mature.
%%
<<tail(mipsrec.nw)>>=
let rtl_to_string = RU.ToString.rtl

let dump msg rtl =
    List.iter prerr_string
    [ "error in recognizer: "
    ; msg
    ; " on "
    ; rtl_to_string rtl
    ; "\n"
    ]

let to_string r =
    try 
        let plan = rtl (Dn.rtl r) in
        Printf.sprintf "\t%s" (plan.inst.Camlburg.action ())
    with
        | Camlburg.Uncovered -> cat ["not an instruction: "
                                    ; rtl_to_string r
                                    ]
        | Error msg          -> ( dump msg r 
                                ; sprintf "error: %s" (rtl_to_string r)
                                )

let is_instruction r =
    try 
        let plan = rtl (Dn.rtl r) in
        plan.inst.Camlburg.cost < 100
    with
        | Camlburg.Uncovered -> false
        | Error msg          -> ( dump msg r 
                                ; false
                                )
@        
\section{[[arch/mips/mipsregs.nw]]}
<<arch/mips/mipsregs.ml>>=
<<mipsregs.ml>>
@

<<arch/mips/mipsregs.mli>>=
<<mipsregs.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
\section{MIPS spaces and registers}
%%
%%This module exports central information used by several parts of the
%%MIPS back end.
<<mipsregs.mli>>=
module Spaces : sig
  val m : Space.t  (* memory *)
  val r : Space.t  (* integer regs *)
  val f : Space.t  (* floating regs *)
  val c : Space.t  (* special registers *)

  val t : Space.t  (* 32-bit integer temps *)
  val u : Space.t  (* 32-bit floating temps *)
end


val pc  : Rtl.loc
val npc : Rtl.loc
val cc  : Rtl.loc

val mspace : Rtl.space
val rspace : Rtl.space
val fspace : Rtl.space
@
<<mipsregs.ml>>=
module R  = Rtl
module S  = Space
module SS = Space.Standard32

let byteorder = Rtl.LittleEndian 
let mcell = Cell.of_size 8
let mspace = ('m', byteorder, mcell)
@ 
%%For now, register aggregation for floats but not ints.
<<mipsregs.ml>>=
let rspace = ('r', Rtl.Identity, Cell.of_size 32)
let fspace = ('f', byteorder,    Cell.of_size 32)
module Spaces = struct
    let id = Rtl.Identity
    let m  = SS.m byteorder [8; 16; 32]
    let r  = SS.r 32 id [32]
    let f  = SS.f 32 byteorder [32; 64]    
    let t  = SS.t    id  32
    let u  = SS.u    byteorder  32
    let c  = SS.c  6 id [32]    (* pc, npc, cc, _, fp_mode, fp_fcmp *)
end
@ 
<<mipsregs.ml>>=
let locations = SS.locations Spaces.c
let pc        = locations.SS.pc
let cc        = locations.SS.cc
let npc       = locations.SS.npc

@ 

\chapter{[[arch/ppc]]}

\section{[[arch/ppc/ppc.nw]]}
<<arch/ppc/ppc.ml>>=
<<ppc.ml>>
@

<<arch/ppc/ppc.mli>>=
<<ppc.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% $Id: ppc.nw,v 1.71 2007-06-18 20:17:22 dias Exp $
%%% ---------------------------------------------------------------------------
%%
%%Backend for PPC
%%
%%% ---------------------------------------------------------------------------
\section{Module Structure}
%%% ---------------------------------------------------------------------------
<<ppc.mli>>=
module Spaces : sig
  val m : Space.t
  val r : Space.t
  val t : Space.t
  val c : Space.t
  val f : Space.t
  val u : Space.t
end
module Post   : Postexpander.S
module X      : Expander.S
val target    : Ast2ir.tgt
val placevars : Ast2ir.proc -> Automaton.t
@ 
<<ppc.ml>>=
open Nopoly

module A  = Automaton
module B  = Bits
module BO = Bits.Ops
module DG = Dag
module PA = Preast2ir
module R  = Rtl
module RP = Rtl.Private
module RS = Register.Set
module Up = Rtl.Up
module Dn = Rtl.Dn
module RO = Rewrite.Ops
module RU = Rtlutil
module PX = Postexpander
module T  = Target

let rtl r = DG.Rtl r
let (<:>) = DG.(<:>)
<<spaces>>
let pc_lhs = nia
let pc_rhs = cia
module F = Mflow.MakeStandard (
  struct
    let pc_lhs = pc_lhs
    let pc_rhs = pc_rhs
    let ra_reg = creg 5
    let ra_offset = 4
  end)
<<registers>>
module Post = struct
  <<ppc postexpander>>
end
module X = Expander.IntFloatAddr (Post)
<<calling conventions>>
<<target spec>>
<<variable placer>>
@
%%% ---------------------------------------------------------------------------
\section{Spaces}
%%% ---------------------------------------------------------------------------
%%The PPC has 32 integer registers and 32 floating point registers.
<<spaces>>=
module Spaces = struct
  module S = Space
  module SS = Space.Standard32
  let bo = Rtl.BigEndian
  let id = Rtl.Identity
  let m = SS.m    bo [8;16;32]
  let r = SS.r 32 id [32]
  let t = SS.t    id  32
  let c = SS.c 7  id [32]

  let flt = { S.space = ('f', id, Cell.of_size 64)
            ; S.doc = "floating point registers"
            ; S.indexwidth = 5
            ; S.indexlimit = Some 32
            ; S.widths = [64]
            ; S.classification = S.Reg
            }
 let f = S.checked flt
 let u = S.checked { flt with
                     S.indexwidth = 31
                   ; S.space = ('u', id, Cell.of_size 64)
                   ; S.indexlimit = None
                   ; S.classification =
                      S.Temp { S.stands_for = S.stands_for 'f' id 64
                             ; S.set_doc = "floating point temporaries"
                             }
                   }
end
@ 
%%The power PC has 7 different control registers.
<<spaces>>=
let rspace = Spaces.r.Space.space
let fspace = Spaces.f.Space.space
let cspace = Spaces.c.Space.space
let (_, _, mcell) as mspace = Spaces.m.Space.space

let reg n  = R.reg (rspace,n,R.C 1)
let freg n = R.reg (fspace,n,R.C 1)
let creg n = R.reg (cspace,n,R.C 1)
let nia    = creg 0  (* new (next) instr address         *)
let cia    = creg 1  (* current instr address (pc)       *)
let cr     = creg 2  (* condition register               *)
let fpscr  = creg 3  (* flt point condition register     *)
let xer    = creg 4  (* XER register                     *)
let lr     = creg 5  (* link register                    *)
let ctr    = creg 6  (* counter register                 *)

(* what follows is true but doesn't work *)
let rmode = R.slice 2 ~lsb:30 fpscr

(* what follows is a lie but works *)
let dspace   = ('d', Rtl.Identity, Cell.of_size 2)
let rmode    = Rtl.reg (dspace, 0, R.C 1)
let rresults = Rtl.reg (dspace, 1, R.C 1)
@ 
%%Setting bits in the control registers is handled by this utility
%%function. The [[flag_map]] function shold convert the flag parameter
%%to a bit number.
<<spaces>>=
let set_flag reg flag_map v flag =
  R.store (R.slice 1 (flag_map flag) reg)
          (R.bits (Bits.U.of_int v 1) 1) 1
@ 
%%The condition register is divided into eight identical fields, and the
%%first eight bits have special names. The third bit is a copy of the
%%[[SO]] flag from the [[XER]] register. The bits 4-7 are copies of
%%flags from the [[FRSCR]] register.
<<spaces>>=
let crf    n = R.slice 4 (n*4) cr  (* CR field       *)
let crfval n = R.fetch (crf n) 4   (* CR field value *)

type cr_flag = LT | GT | EQ | SO | FX | FEX | VX | OX
let cr_flag_to_bit = function
    LT  -> 0 | GT  -> 1 | EQ  -> 2 | SO  -> 3
  | FX  -> 4 | FEX -> 5 | VX  -> 6 | OX  -> 7
let set_cr_flag = set_flag cr cr_flag_to_bit 1
let clr_cr_flag = set_flag cr cr_flag_to_bit 0
@ 
%%Almost all of the bits in the floating point status register have special
%%names. I omit their complete definitions for now.
<<spaces>>=
(*
type fpscr_flag =
    FX | FEX | VX | OX | UX | ZX | XX
  | VXSNAN | VXISI | VXIDI | VXZDZ | VXIMZ | VXVC
  | FR | FI | VXSOFT | VXSQRT | VXCVI
  | VE | OE | UE | ZE | XE | NI | RN
*)
@ 
%%Three bits in the [[XER]] register have special names. The [[XER_SO]]
%%bit is copied to the [[CR]] register whenever it is set.
<<spaces>>=
type xer_flag = XER_SO | OV | CA
let xer_flag_to_bit = function XER_SO -> 0 | OV -> 1 | CA -> 2
let set_xer' = set_flag xer xer_flag_to_bit
let set_xer_flag fl = function
    XER_SO -> R.par [ set_cr_flag SO ; set_xer' 1 fl ]
  | _      -> set_xer' 1 fl
let clr_xer_flag fl = function
    XER_SO -> R.par [ clr_cr_flag SO ; set_xer' 0 fl ]
  | _  -> set_xer' 0 fl
@ 
%%% ---------------------------------------------------------------------------
\section{Post Expander}
%%% ---------------------------------------------------------------------------
<<ppc postexpander>>=
let pc_lhs = pc_lhs
let pc_rhs = pc_rhs
let byte_order = R.BigEndian
let exchange_alignment = 4
let wordsize = 32
let memsize  = 8
module Address = struct
  type t = Rtl.exp
  let reg r = R.fetch (R.reg r) (Register.width r)
end
@ 
%%Two allocators.
<<ppc postexpander>>=
let talloc = PX.Alloc.temp
let salloc = PX.Alloc.slot
@ 
%%Contexts.
<<ppc postexpander>>=
module C  = Context
let itempwidth = 32
let icontext = C.of_space Spaces.t
let fcontext = C.of_space Spaces.u
let acontext = icontext
let rcontext = (fun x y -> Impossible.unimp "Unsupported soft rounding mode")
               ,(function (('d',_,_), 0, R.C 1) -> true | _ -> false)

let overrides = 
   ["i2f", [icontext;rcontext], fcontext;   (* legitimate exception *)
    "f2f", [icontext;rcontext], fcontext;   (* "wrong" exception *)
   ]
let operators = C.nonbool icontext fcontext rcontext overrides
let arg_contexts, result_context = C.functions operators
let constant_context w = if w > wordsize then fcontext else icontext
@ 
%%A few utility functions for building common RTLs.
<<ppc postexpander>>=
let tloc t  = Rtl.reg t
let twidth  = Register.width
let tval t  = R.fetch (tloc t) (twidth t)
let tstore tmp exp = rtl (R.store (tloc tmp) exp (twidth tmp))

let mem    assn w addr = R.mem assn mspace (Cell.to_count mcell w) addr
let memval assn w addr = R.fetch (mem assn w addr) w
@ 
<<ppc postexpander>>=
let set_xer2 opr x y = rtl (R.store xer (R.app opr [x; y]) 32)
@ 
%%The load and store instructions on the ppc cannot use register 0 as a
%%parameter. Right now this is avoided by not telling the register
%%allocator about register 0, so we don't have to worry about that here.
<<ppc postexpander>>=
let load ~dst ~addr assn =
  let w = twidth dst in
  assert (w = 8 || w = 16 || w = 32 || w = 64);
  rtl (R.store (tloc dst) (memval assn w addr) w)

let store ~addr ~src assn =
  let w = twidth src in
  assert (w = 8 || w = 16 || w = 32 || w = 64);
  rtl (R.store (mem assn w addr) (tval src) w)
@ 
%%The [[xload]] and [[xstore]] functions apply an operator to an
%%expression before loading or storing them in the final location. The
%%remaining postexpander load and store operations are defined in terms
%%of these two functions.
<<ppc postexpander>>=
let lostore ~addr ~src w assn =
  let ext = RO.lobits (twidth src) w (tval src) in
  rtl (R.store (mem assn w addr) ext w)

let zxload ~dst ~addr w assn =
  tstore dst (RO.zx w (twidth dst) (memval assn w addr))

let sxload ~dst ~addr w assn =
  zxload dst addr w assn <:>
  tstore dst (RO.sx 8 (twidth dst) (RO.lobits (twidth dst) 8 (tval dst)))
@ 
%%Registers are copied into registers with
%%[[tstore]].
<<ppc postexpander>>=
let move ~dst ~src = tstore dst (tval src)
@ 
%%Immediate values rewquire a two-instruction sequence in general.
<<ppc postexpander>>=
let lix ~dst exp =
  let {Rewrite.hi = hi; Rewrite.lo = lo} = Rewrite.splits 32 16 exp in
  tstore dst hi <:>
  tstore dst (RO.add 32 (tval dst) lo)

let li ~dst const = lix dst (Up.exp (RP.Const const))
@ 
<<ppc postexpander>>=
let extract ~dst ~lsb ~src = Impossible.unimp "extract"
let aggregate ~dst ~src = Impossible.unimp "aggregate"
@ 
<<ppc postexpander>>=
let hwset ~dst ~src = Impossible.unimp "setting hardware register"
let hwget ~dst ~src = Impossible.unimp "getting hardware register"
@ 
%%Machine Environment for PPC backend.
<<ppc postexpander>>=
let machine_env = 
  [ "NaN"                ,[52;64] (* float, [n] -> m              *)
  ; "add"                ,[32]    (* int,   [n; n] -> n           *)
  ; "addc"               ,[32]    (* int,   [n; n; 1] -> n        *)
  ; "add_overflows"      ,[32]    (* bool,  [n; n] -> bool        *)
  ; "and"                ,[32]    (* int,   [n; n] -> n           *)
  ; "bit"                ,[32]    (* int,   [bool] -> 1           *)
  ; "bool"               ,[32]    (* bool,  [1] -> bool           *)
  ; "borrow"             ,[32]    (* int,   [n; n; 1] -> 1        *)
  ; "carry"              ,[32]    (* int,   [n; n; 1] -> 1        *)
  ; "com"                ,[32]    (* int,   [n] -> n              *)
  ; "conjoin"            ,[  ]    (* bool,  [bool; bool] -> bool  *)
  ; "disjoin"            ,[  ]    (* bool,  [bool; bool] -> bool  *)
  ; "div"                ,[32]    (* int,   [n; n] -> n           *)
  ; "div_overflows"      ,[32]    (* bool,  [n; n] -> bool        *)
  ; "divu"               ,[32]    (* int,   [n; n] -> n           *)
  ; "eq"                 ,[32]    (* bool,  [n; n] -> bool        *)
  ; "f2f"                ,[32;64] (* float, [n; 2] -> m           *)
(*
  ; "f2f"                ,[64;32]
  ; "f2f_implicit_round" ,[64;32] (* float, [n] -> m              *)
*)
  ; "f2i"                ,[64;32] (* int,   [n; 2] -> m           *)
  ; "fabs"               ,[64]    (* float, [n] -> n              *)
  ; "fadd"               ,[64]    (* float, [n; n; 2] -> n        *)
  ; "fcmp"               ,[64]    (* code2, [n; n] -> 2           *)
  ; "fdiv"               ,[64]    (* float, [n; n; 2] -> n        *)
  ; "feq"                ,[64]    (* bool,  [n; n] -> bool        *)
  ; "fge"                ,[64]    (* bool,  [n; n] -> bool        *)
  ; "fgt"                ,[64]    (* bool,  [n; n] -> bool        *)
  ; "fle"                ,[64]    (* bool,  [n; n] -> bool        *)
  ; "float_eq"           ,[  ]    (* code2, [] -> 2               *)
  ; "float_gt"           ,[  ]    (* code2, [] -> 2               *)
  ; "float_lt"           ,[  ]    (* code2, [] -> 2               *)
  ; "flt"                ,[64]    (* bool,  [n; n] -> bool        *)
  ; "fmul"               ,[64]    (* float, [n; n; 2] -> n        *)
  ; "fmulx"              ,[64]    (* float, [n; n] -> 2n          *)
  ; "fne"                ,[64]    (* bool,  [n; n] -> bool        *)
  ; "fneg"               ,[64]    (* float, [n] -> n              *)
  ; "fordered"           ,[64]    (* bool,  [n; n] -> bool        *)
  ; "fsqrt"              ,[64]    (* float, [n; 2] -> n           *)
  ; "fsub"               ,[64]    (* float, [n; n; 2] -> n        *)
  ; "funordered"         ,[64]    (* bool,  [n; n] -> bool        *)
  ; "ge"                 ,[32]    (* bool,  [n; n] -> bool        *)
  ; "geu"                ,[32]    (* bool,  [n; n] -> bool        *)
  ; "gt"                 ,[32]    (* bool,  [n; n] -> bool        *)
  ; "gtu"                ,[32]    (* bool,  [n; n] -> bool        *)
  ; "i2f"                ,[32;64] (* float, [n; 2] -> m           *)
  ; "le"                 ,[32]    (* bool,  [n; n] -> bool        *)
  ; "leu"                ,[32]    (* bool,  [n; n] -> bool        *)
  ; "lobits"             ,[32; 8] (* int,   [n] -> m              *)
  ; "lobits"             ,[32;16]
  ; "lt"                 ,[32]    (* bool,  [n; n] -> bool        *)
  ; "ltu"                ,[32]    (* bool,  [n; n] -> bool        *)
  ; "minf"               ,[64]    (* float, [] -> n               *)
  ; "mod"                ,[32]    (* int,   [n; n] -> n           *)
  ; "modu"               ,[32]    (* int,   [n; n] -> n           *)
  ; "mul"                ,[32]    (* int,   [n; n] -> n           *)
(*
  ; "mulux"              ,[00]    (* int,   [n; n] -> 2n          *)
  ; "mulx"               ,[00]    (* int,   [n; n] -> 2n          *)
*)
  ; "mul_overflows"      ,[32]    (* bool,  [n; n] -> bool        *)
  ; "mulu_overflows"     ,[32]    (* bool,  [n; n] -> bool        *)
  ; "mzero"              ,[64]    (* float, [] -> n               *)
  ; "ne"                 ,[32]    (* bool,  [n; n] -> bool        *)
  ; "neg"                ,[32]    (* int,   [n] -> n              *)
  ; "not"                ,[32]    (* bool,  [bool] -> bool        *)
  ; "or"                 ,[32]    (* int,   [n; n] -> n           *)
  ; "pinf"               ,[64]    (* float, [] -> n               *)
  ; "popcnt"             ,[32]    (* int,   [n] -> 1              *)
  ; "pzero"              ,[64]    (* float, [] -> n               *)
  ; "quot"               ,[32]    (* int,   [n; n] -> n           *)
  ; "quot_overflows"     ,[32]    (* bool,  [n; n] -> bool        *)
  ; "rem"                ,[32]    (* int,   [n; n] -> n           *)
  ; "rotl"               ,[32]    (* int,   [n; n] -> n           *)
  ; "rotr"               ,[32]    (* int,   [n; n] -> n           *)
  ; "round_down"         ,[  ]    (* code2, [] -> 2               *)
  ; "round_nearest"      ,[  ]    (* code2, [] -> 2               *)
  ; "round_up"           ,[  ]    (* code2, [] -> 2               *)
  ; "round_zero"         ,[  ]    (* code2, [] -> 2               *)
  ; "shl"                ,[32]    (* int,   [n; n] -> n           *)
  ; "shra"               ,[32]    (* int,   [n; n] -> n           *)
  ; "shrl"               ,[32]    (* int,   [n; n] -> n           *)
  ; "sub"                ,[32]    (* int,   [n; n] -> n           *)
  ; "subb"               ,[32]    (* int,   [n; n; 1] -> n        *)
  ; "sub_overflows"      ,[32]    (* bool,  [n; n] -> bool        *)
  ; "sx"                 ,[8; 32] (* int,   [n] -> m              *)
  ; "sx"                 ,[16;32] (* int,   [n] -> m              *)
  ; "unordered"          ,[  ]    (* code2, [] -> 2               *)
  ; "xor"                ,[32]    (* int,   [n; n] -> n           *)
  ; "zx"                 ,[8; 32] (* int,   [n] -> m              *)
  ; "zx"                 ,[16;32] (* int,   [n] -> m              *)
(*
  ; "bitExtract"         ,[00]    (* int,   [n; n] -> m           *)
  ; "bitInsert"          ,[00]    (* int,   [n; n; m] -> n        *)
  ; "bitTransfer"        ,[00]    (* int,   [n; n; n; n; n] -> n  *)
*)
  ]
@
%%Implementation of RTL operators.
<<ppc postexpander>>=
let unimp_opr (op,ws) =
  let ws' = List.fold_left (fun s i -> string_of_int i ^ " ") "" ws in
  Impossible.unimp ("unimplemented operator " ^ op ^ ":" ^ ws')

let to_binop f = function
    [x;y] -> f 32 (tval x) (tval y)
  | _     -> Impossible.impossible "wrong number of args given to binop"

let rtlop ~dst op args =
  match op with
    "mod",  [32] -> PX.Expand.block (tstore dst (to_binop Rewrite.(mod) args))
  | "modu", [32] -> PX.Expand.block (tstore dst (to_binop Rewrite.modu  args))
  | "rem",  [32] -> PX.Expand.block (tstore dst (to_binop Rewrite.rem   args))
  | opr, ws ->
      if List.mem op machine_env
      then tstore dst (R.app (Up.opr op) (List.map tval args))
      else unimp_opr op

let unop  ~dst op x   = rtlop dst op [x]
let binop ~dst op x y = rtlop dst op [x;y]
let dblop ~dsthi ~dstlo op x y = Unsupported.mulx_and_mulux()
let wrdop  ~dst op x y z = Unsupported.singlebit ~op:(fst op)
let wrdrop ~dst op x y z = Unsupported.singlebit ~op:(fst op)
let unrm  ~dst op x rm   = Impossible.unimp "floating point"
let binrm ~dst op x y rm = Impossible.unimp "floating point"
@ 
%%Block Copy\ldots
<<ppc postexpander>>=
let block_copy ~dst assn1 ~src assn2 width =
  let tmp = talloc 't' 32 in
  let reg_sl = function
    | 32 -> tloc tmp
    | n  -> R.slice n (32-n) (tloc tmp) in
  let stx d w = rtl (R.store (mem assn1 w (RU.addk 16 dst d))
                             (R.fetch (reg_sl w) w) w)
  and ld32 d  = rtl (R.store (tloc tmp) (memval assn2 32 (RU.addk 16 src d)) 32) in
  let rec copy d =
    match width - d with
    | 1 -> ld32 d <:> stx d  8
    | 2 -> ld32 d <:> stx d 16
    | 3 -> ld32 d <:> stx d  8 <:> stx d 16  (* LOOKING VERY SUSPECT *)
    | 4 -> ld32 d <:> stx d 32
    | n -> assert(n > 0); ld32 d <:> stx d 32 <:> copy (d + 4) in
  copy 0
@ 
%%Branch and call rtls.
<<ppc postexpander>>=
let br ~tgt = rtl (R.store lr (tval tgt) wordsize),
              R.store pc_lhs (R.fetch lr wordsize) wordsize
let b ~tgt  = DG.Nop, R.store pc_lhs (Up.const tgt) wordsize
@
%%Conditional branches are encoded as a comparison against the
%%appropriate bit in the CR register. With this scheme, the opposite
%%condition can be derived by changing the guard operator.
%%I am using a bits value of 0 because using 1 gives the wrong number.
<<ppc postexpander>>=
let xer_condition = function
  | "eq" | "ne" | "lt" | "le" | "gt" | "ge" 
  | "ltu" | "leu" | "gtu" | "geu" -> None
  | "add_overflows" 
  | "div_overflows"
  | "mul_overflows"
  | "mulu_overflows"
  | "sub_overflows" -> Some "ppc_xer_ov_set"
  | opr -> Impossible.unimp ("conditional branch on " ^ opr)

let with_xer z x opr y =
  let opr' = "ppc_xer_" ^ opr in
  rtl (R.par [R.store (tloc z) (R.app (R.opr opr [32]) [tval x; tval y]) 32;
              R.store xer (R.app (R.opr opr' []) [tval x; tval y]) 32;
             ])

let bc_setup opr x y = match opr with
| "add_overflows"  -> with_xer (talloc 't' 32) x "add" y
| "sub_overflows"  -> with_xer (talloc 't' 32) x "sub" y
| "mul_overflows"  -> with_xer (talloc 't' 32) x "mul" y
| "mulu_overflows" -> with_xer (talloc 't' 32) x "mulu" y
| "div_overflows"  -> Impossible.unimp "%div_overflows"
| _ -> Impossible.impossible "bc_setup"

let bc x ((opr, ws) as op) y ~ifso ~ifnot =
  assert (ws =*= [wordsize]);
  let brtl cond tgt = R.guard cond (R.store pc_lhs tgt 32) in
  match xer_condition opr with
  | None -> DG.Test (DG.Nop, (brtl (R.app (Up.opr op) [tval x; tval y]), ifso, ifnot))
  | Some tst ->
      DG.Test (bc_setup opr x y, (brtl (R.app (R.opr tst []) [R.fetch xer wordsize]),
               ifso, ifnot))
let bc_guard x ((opr, ws) as op) y =
  assert (ws =*= [wordsize]);
  match xer_condition opr with
  | None     -> (DG.Nop,           (R.app (Up.opr op)    [tval x; tval y]))
  | Some tst -> (bc_setup opr x y, (R.app (R.opr tst []) [R.fetch xer wordsize]))
let bc_of_guard (setup, guard) ~ifso ~ifnot =
  let brtl cond tgt = R.guard cond (R.store pc_lhs tgt 32) in
  DG.Test (setup, (brtl guard, ifso, ifnot))
  
let negate = function
  | "ne"            -> "eq"
  | "eq"            -> "ne"
  | "ge"            -> "lt"
  | "gt"            -> "le"
  | "le"            -> "gt"
  | "lt"            -> "ge"
  | "geu"           -> "ltu"
  | "gtu"           -> "leu"
  | "leu"           -> "gtu"
  | "ltu"           -> "geu"
  | "feq"          
  | "fne"          
  | "flt"          
  | "fle"          
  | "fgt"          
  | "fge"          
  | "fordered"     
  | "funordered"    -> Impossible.unimp "floating-point comparison"
  | _               -> Impossible.impossible 
                        "bad comparison in expanded MIPS conditional branch"

let bnegate r = match Dn.rtl r with
    |           RP.Rtl [RP.App( (op,       [32]),[x;y]), RP.Store (pc,tgt,32)]
      when RU.Eq.loc pc (Dn.loc pc_lhs) ->
        Up.rtl (RP.Rtl [RP.App( (negate op,[32]),[x;y]), RP.Store (pc,tgt,32)])
    | _ -> Impossible.impossible "ill-formed MIPS conditional branch"
@ 
%%Call instructions are the same as branches with some additional effects.
<<ppc postexpander>>=
let call  = b
let callr = br

(* THIS IS SUSPECT -- WHY ARE WE SETTING THE LINK REGISTER? *)
let cut_to {Mflow.new_sp = sp'; Mflow.new_pc = pc'} =
  let effs = [R.store pc_lhs (R.fetch lr wordsize) wordsize; R.store sp sp' wordsize] in
  rtl (R.store lr pc' wordsize), R.par effs
@ 
%%The [[return]] instruction is standard, and we don't yet have the proper [[forbidden]]
%%instruction.
<<ppc postexpander>>=
let return = fmach.Mflow.return
let forbidden = Rtl.par [] (* BOGUS: NEEDS TO BE A REAL FAULTING INSTRUCTION *)
@
%%We want to prevent the expander from messing with the rtl [[pc := lr]]
%%which is a return from procedure call.
<<ppc postexpander>>=
let don't_touch_me _ = false
@ 
%%Stack operations...
<<ppc postexpander>>=
include Postexpander.Nostack(Address)
@ 
%%% ---------------------------------------------------------------------------
\section{Calling Conventions}
%%% ---------------------------------------------------------------------------
%%
%%Documentation for the linkage area is at
%%\url{http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-15.html#MARKER-2-300}
%%Here's a quick ASCII diagram:
%%\begin{verbatim}
%%   24
%%       +-------------------+
%%   20  | RTOC (by caller)  |
%%       +-------------------+
%%   16  |    reserved       |
%%       +-------------------+
%%   12  |    reserved       |
%%       +-------------------+
%%    8  |  LR (by callee)   |
%%       +-------------------+
%%    4  |  CR (by callee)   |
%%       +-------------------+
%%    0  |  SP (by callee)   |
%%       +-------------------+
%%\end{verbatim}
%%
<<calling conventions>>=
module C  = Call
@ 
%%Integer registers r0 is not used because of the restrictions on the arguments
%%of load/store instructions, r1 is the stack pointer,
%%r2 is reserved for position-independent code,
%%r3-r12 are volatile, and r13-r31 are non-volatile. For floating point,
%%registers f1-f13 are volatile, and f14-131 are not.
<<registers>>=
let sp_reg = (rspace, 1, R.C 1)
let sp     = R.reg sp_reg
let vfp    = Vfp.mk 32
let fmach = F.machine sp

let rreg n = (rspace, n, R.C 1)
let regset s l = RS.of_list (List.map (fun r-> (s,r,R.C 1)) l)
let vregs   = regset rspace [2;3;4;5;6;7;8;9;10;11;12]
let nvregs  = regset rspace [13;14;15;16;17;18;19;20;21;
                             22;23;24;25;26;27;28;29;30;31]
let fvregs  = regset fspace [0;1;2;3;4;5;6;7;8;9;10;11;12;13]
let fnvregs = regset fspace [14;15;16;17;18;19;20;21;22;
                             23;24;25;26;27;28;29;30;31]
let cvregs = regset cspace  [5(*lr*); 6(*ctr*); 4(*xer*); 2(*cr*)]

(* let volregs  = RS.union (RS.union vregs fvregs) cvregs *)
(* let nvolregs = RS.union nvregs fnvregs *)
let volregs  = RS.union vregs cvregs
let nvolregs = nvregs
@ 
%%A function to build a [[Call.t]]. This function is still cheating a
%%bit by using the dummy module. I have changed that fields that both
%%need to be different, and that I understand.
<<transformations(ppc.nw)>>=
let autoAt = A.at mspace in 
let linkage_base r = addk (Block.base r.A.overflow) (-24) in
let call_actuals  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out call parms" autoAt specs.A.call)
    ~autosp:linkage_base
    ~postsp:(fun _ sp -> sp)
and prolog  =
  let autosp = (fun _ -> vfp) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> autoAt (addk vfp 24) specs.A.call)
       (* specific address is redundant, but eqn solver should take in stride *)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a)
and call_results  =
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in ovfl results" autoAt specs.A.results)
    ~autosp:linkage_base
    ~postsp:(fun _ _ -> std_sp_location) (* irrelevant? *)
    ~insp:(fun a _ _ -> linkage_base a)
and epilog  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out ovfl results" autoAt specs.A.results)
    ~autosp:linkage_base
    ~postsp:(fun _ r -> r)
(*    ~postsp:(fun _ r -> vfp)*)  (* irrelevant *)
and also_cuts_to =
  let autosp = (fun r -> std_sp_location) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in cont parms" autoAt specs.A.cutto)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a)
and cut_actuals base  =
   C.outgoing ~growth ~sp ~mkauto:(fun () -> autoAt base specs.A.cutto)
     ~autosp:(fun r -> spval)
     ~postsp:(fun _ _ -> spval)
and saved_nvr temps =
  let t = Talloc.Multiple.loc temps 't' in
  fun r -> t (Register.width r)
@ 
<<calling conventions>>=
let cconv name specs =
  let ws              = Post.wordsize
  and growth          = Memalloc.Down
  and spval           = R.fetch sp 32
  and addk            = RU.addk 32
  and std_sp_location = RU.add  32 vfp (R.late "minus frame size" 32)
  in 
  <<transformations(ppc.nw)>>
  in
  { C.name             = name
  ; C.overflow_alloc   = { C.parameter_deallocator = C.Caller
                         ; C.result_allocator      = C.Caller
                         }
  ; C.call_parms       = { C.in' = prolog;       C.out = call_actuals}
  ; C.cut_parms        = { C.in' = also_cuts_to; C.out = cut_actuals}
  ; C.results          = { C.in' = call_results; C.out = epilog}
 
  ; C.stack_growth     = growth
  ; C.stable_sp_loc    = std_sp_location
  ; C.jump_tgt_reg     = R.reg (rreg 7)
  ; C.replace_vfp      = Vfp.replace_with ~sp
  ; C.sp_align         = 4
  ; C.pre_nvregs       = nvolregs
  ; C.volregs          = volregs
  ; C.saved_nvr        = saved_nvr
  ; C.return           = (fun k n ~ra -> R.store nia (R.fetch lr ws) ws)
  ; C.ra_on_entry      = (fun b     -> R.fetch lr ws)
(*  ; C.where_to_save_ra = (fun e t     -> Post.mem R.none ws sp_8) *)
  ; C.where_to_save_ra = (fun _ t   -> Talloc.Multiple.loc t 't' ws)
  ; C.ra_on_exit       = (fun l e t -> lr)
  ; C.sp_on_unwind     = (fun e     -> RU.store sp e)
  ; C.sp_on_jump       = (fun _ _   -> Rtl.null)
  }
@ 
%%The calling convention specs are written in Lua; they have no ML
%%counterpart.
<<PPC calling convention automata in Lua>>=
A                = Automaton
PPC              = PPC              or {}
PPC.cc           = PPC.cc           or {}
PPC.cc["C"     ] = PPC.cc["C"     ] or {}
PPC.cc["C--"   ] = PPC.cc["C--"   ] or {}
PPC.cc["notail"] = PPC.cc["notail"] or {}

function PPC.r(i) return({ space = "r", index = i, cellsize = 32, count = 1 }) end
function PPC.f(i) return({ space = "f", index = i, cellsize = 64, count = 1 }) end

PPC.overflow = A.overflow { growth = "up", max_alignment = 4 }
@ 
%%The C calling convention.
<<PPC calling convention automata in Lua>>=
PPC.cc["C"].call =
  { A.widen(32, "multiple")
  , A.bitcounter("bits")
  , A.choice 
      { "float", { A.widen(64),
                   A.useregs(
                    {PPC.f(1),PPC.f(2),PPC.f(3),PPC.f(4),PPC.f(5),
                     PPC.f(6),PPC.f(7),PPC.f(8),PPC.f(9),PPC.f(10),
                     PPC.f(11),PPC.f(12),PPC.f(13)} 
                    ,"reserve")
                 }
      , A.is_any, A.regs_by_bits("bits",
                   {PPC.r(3),PPC.r(4),PPC.r(5),PPC.r(6),
                    PPC.r(7),PPC.r(8),PPC.r(9),PPC.r(10)}, "reserve")
      }
  , PPC.overflow
  }

PPC.cc["C"].results =
  A.choice { "float" , { A.widen(64), A.useregs { PPC.f(1) }}
           , A.is_any, { A.widen(32), A.useregs { PPC.r(3), PPC.r(4) }}
           }

PPC.cc["C"].cutto = { A.widen(32), PPC.overflow }
@
%%The [[C--]] convention is the same as the [[C]] convention except that
%%we provide an overflow block for results.
<<PPC calling convention automata in Lua>>=
PPC.cc["C--"].call    = PPC.cc["C"].call
PPC.cc["C--"].results = { PPC.cc["C"].results, PPC.overflow }
PPC.cc["C--"].cutto   = PPC.cc["C"].cutto
@ 
%%Finally, register all of the conventions for the PPC.
<<PPC calling convention automata in Lua>>=
A.register_cc(Backend.ppc.target,"C"     ,PPC.cc["C"  ])
A.register_cc(Backend.ppc.target,"C'"    ,PPC.cc["C"  ])
A.register_cc(Backend.ppc.target,"C--"   ,PPC.cc["C--"])
A.register_cc(Backend.ppc.target,"notail",PPC.cc["C--"])
@ 
<<PPC stack layout in Lua>>=
PPC = PPC or {}
PPC.layout = { creates='no late consts' }
@ 
%%We have a nasty problem on the PowerPC: if we call a varargs function,
%%we have to be careful to reserve space on the stack to hold up to
%%eight parameter registers.
%%The documentation is unclear, but we believe this hack is \emph{not}
%%necessary for calling a non-varargs function.
%%It might be nice, at some time in the future, to scrutinize the
%%[[ccname]] and reserve the varargs area only when needed.
<<PPC stack layout in Lua>>=
function PPC.layout.fn(dummy,proc) --- dispatch on cc name
  local layout = PPC.layout[Stack.ccname(proc)]
  if not layout then
    error('Convention "' .. Stack.ccname(proc) .. '" does not have a frame layout')
  end
  return layout(dummy, proc, 'varargs')
    -- might one day optimize and not always pass 'varargs'
end

function PPC.layout["C"](dummy, proc, varargs)
  local blocks  = Stack.blocks(proc)

  local old, young = blocks.oldblocks, blocks.youngblocks
  old.callee   = Block.overlap_high(32, old.callee)
  old.caller   = Block.overlap_low (32, old.caller)
  young.callee = Block.overlap_high(32, young.callee)
  young.caller = Block.overlap_low (32, young.caller)

  local linkage =
      { caller = Block.relative(blocks.vfp, "caller's linkage area", 24, 16)
      , callee = Block.relative(blocks.sp , "our linkage area"     , 24, 16)
      }     -- Mach-O Runtime Conventions for PowerPC, pp47--48

  local youngparms = Block.cat(32, {young.caller, young.callee})
  if varargs then
    youngparms = Block.overlap_low(32, {youngparms,
                      Block.relative(blocks.vfp, "varargs flush area", 32, 4) })
  end

  local layout =
      { Block.cat (32, {old.caller, old.callee, linkage.caller})
      , blocks.vfp
      , blocks.spills
      , blocks.continuations
      , blocks.stackdata
      , Block.cat (32, {youngparms, linkage.callee})
      , blocks.sp
      }

  if Debug.stack then
      blocks.caller_linkage = linkage.caller
      blocks.callee_linkage = linkage.callee
      write('****** cc name = ', Stack.ccname(proc), '\n')
      Debug.showblocks (blocks, { 'oldblocks'
                                , 'caller_linkage'
                                , 'vfp'
                                , 'spills'
                                , 'continuations'
                                , 'stackdata'
                                , 'youngblocks'
                                , 'callee_linkage'
                                , 'sp'
                                })
  end

  local block = Block.cat(32, layout)
  block = Block.adjust(block)
  Stack.freeze(proc, block)
  return 1
end
PPC.layout["C--"] = PPC.layout["C"] -- flagrant waste
PPC.layout["notail"] = PPC.layout["C"] -- flagrant waste
@ 
%%
%%% ---------------------------------------------------------------------------
\section{Target Specification}
%%% ---------------------------------------------------------------------------
<<target spec>>=
@ 
%%We must provide an automaton for allocating globals, and functions for
%%spilling and reloading registers.
<<target spec>>=
let ( *> ) = A.( *> )
let globals base = 
  let width w = if w <= 8 then 8 else if w <= 16 then 16 else Auxfuns.round_up_to 32 w in
  let align = function 8 -> 1 | 16 -> 2 | _ -> 4 in
  A.at mspace ~start:base
   (A.widen width *> A.align_to align *>
    A.overflow ~growth:Memalloc.Up ~max_alignment:4)

let spill lookup reg loc =
  let w = Register.width reg in
  [ Automaton.store loc (Rtl.fetch (Rtl.reg reg) w) w ]
    
let reload lookup reg loc =
  let w = Register.width reg in
  [ Rtl.store (Rtl.reg reg) (Automaton.fetch loc w) w ]
@ 
%%The actual [[Target.t]] for the PPC backend.
<<target spec>>=
let target =
  let spaces = [ Spaces.m; Spaces.r; Spaces.t; Spaces.c; Spaces.f; Spaces.u ] in
  PA.T { T.name = "ppc"
       ; T.memspace = mspace
       ; T.max_unaligned_load  = R.C 1
      (* basic metrics and spaces are OK *)
       ; T.byteorder   = Post.byte_order  
       ; T.wordsize    = Post.wordsize
       ; T.pointersize = Post.wordsize
       ; T.vfp         = Space.Standard32.vfp
       ; T.alignment = 1
       ; T.memsize = Post.memsize
       ; T.spaces = spaces
       ; T.reg_ix_map          = T.mk_reg_ix_map spaces
       ; T.distinct_addr_sp = false
   
       (* Does the PPC really implement IEEE 754?  I think so *)
       ; T.float = Float.ieee754
   
       (* control flow is solid, except [[cutto]] is a lie *)
       ; T.machine = X.machine
       ; T.cc_specs         = []      (* added by lua code *)
       ; T.cc_spec_to_auto  = cconv
   
       ; T.is_instruction = Ppcrec.M.is_instruction
       ; T.tx_ast = (fun secs -> secs)
       ; T.capabilities   = { T.operators = List.map Up.opr Post.machine_env;
                              T.litops = [];
                              T.literals = [32;64]; T.memory = [8;32];
                              T.block_copy = false; T.itemps = [32]; T.ftemps = [];
                              T.iwiden = true; T.fwiden = false; }
       (* global or hardware registers *)
       ; T.globals  = globals
       ; T.rounding_mode = rmode
       ; T.named_locs   = Strutil.assoc2map 
                          ["IEEE 754 rounding mode", rmode
                          ;"IEEE 754 rounding results", rresults
                          ]
       
       (* bogosity *)
       ; T.data_section = "data" (* NOT REALLY A PROPERTY OF THE TARGET MACHINE... *)
       ; T.charset = "latin1" (* THIS IS NONSENSE!! NOT A PROPERTY OF THE MACHINE?? *)
       } 
@ 
%%% ---------------------------------------------------------------------------
\section{Variable Placer}
%%% ---------------------------------------------------------------------------
<<variable placer>>=
let unimp               = Impossible.unimp
let impossible          = Impossible.impossible

let placevars = 
  let is_float w kind _ = w <= 32 && kind =$= "float" in
  let warn ~width:w ~alignment:a ~kind:k =
    if w > 64 then unimp (Printf.sprintf "%d-bit values not supported"  w) in
  let mk_stage ~temps =
    A.choice
      [ is_float,               A.widen (Auxfuns.round_up_to ~multiple_of: 64); 
        (fun w _ _ -> w <= 32), A.widen (fun _ -> 32) *> temps 't';
        A.is_any,               A.widen (Auxfuns.round_up_to ~multiple_of: 8);
      ] in
  Placevar.mk_automaton ~warn ~vfp ~memspace:mspace mk_stage
@ 
%$
\section{[[arch/ppc/ppcasm.nw]]}
<<arch/ppc/ppcasm.ml>>=
<<ppcasm.ml>>
@

<<arch/ppc/ppcasm.mli>>=
<<ppcasm.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 et sw=4 
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{PPC Assembler}
%%% ------------------------------------------------------------------ 
%%
%%This is an assembler that emits ``AT\&T'' style assembly language for
%%the PPC platform.
%%It implements the
%%[[Asm.assembler]] interface for assemblers in the {\qcc} compiler.
%% 
%%The assembler constructor receives the output channel for the assembler. 
<<ppcasm.mli>>=
val make : 
  (('a, 'b, 'c, 'd) Proc.t -> 'cfg -> (Zipcfg.Rep.call -> unit) -> 
            (Rtl.rtl -> unit) -> (string -> unit) -> unit) ->
  out_channel -> ('cfg * ('a, 'b, 'c, 'd) Proc.t) Asm.assembler
  (* pass Cfgutil.emit *)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation provides no surprises. It builds up an {\AST} and
%%emits it to [[stdout]] when the [[emit]] method is called.
%%
<<ppcasm.ml>>=
open Nopoly

module G  = Zipcfg
module GR = Zipcfg.Rep
module SM = Strutil.Map
<<utilities(ppcasm.nw)>>
<<definitions(ppcasm.nw)>>
let make emitter fd = new asm emitter fd
@
<<utilities(ppcasm.nw)>>=
let fprintf = Printf.fprintf
@
%%
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Classes for symbols}
%%% ------------------------------------------------------------------ 
%%
%%We include name mangling into [[Symbol.t]] class because all assembler
%%symbols like labels will be derived from them. Since the mangler is
%%stateful, we have to create it outside the individual instance of a
%%symbol. For now, we pass it from the assembler to here.
%%This mangler is very conservative, accepting only symbols built with
%%alphanumerics, underscores, and dots.
%%Most assemblers, including the Gnu assembler, will accept many more
%%characters.  But this way we don't have to enumerate the reserved
%%words (e.g., names of registers).
%%
%%The manual says ``The name of a symbol representing a function that
%%conforms to standard C calling conventions is the name of the function with
%%an underscore prefix. Thus, the name of the symbol representing the
%%function [[main]] would be [[_main]].''
<<definition of [[manglespec]] (for the name mangler)(ppcasm.nw)>>=
let spec =
    let reserved = [] in        (* list reserved words here so we can avoid them *)
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '.'
        | '_'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '_' 
        in    
            { Mangle.preprocess = (fun x -> "_" ^ x)  
            ; Mangle.replace    = replace
            ; Mangle.reserved   = reserved
            ; Mangle.avoid      = (fun x -> x ^ "_")
            }
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{The assembler class}
%%% ------------------------------------------------------------------ 
%%
%%The assembler maintains mutable state for:
%%\begin{itemize}
%%\item the actual section the assembler is in,
%%\item exported symbols,
%%\item imported symbols,
%%\item completed sections in reverse order,
%%\item declarations in the current section in reverse order.
%%\end{itemize}
%%
%%Most methods append a declaration to the current section---[[append]]
%%provides a private method for this.
<<definitions(ppcasm.nw)>>=
<<definition of [[manglespec]] (for the name mangler)(ppcasm.nw)>>

class ['cfg, 'a, 'b, 'c, 'd] asm emitter fd
  : ['cfg * ('a, 'b, 'c, 'd) Proc.t] Asm.assembler = 
object (this)
    val         _fd       = fd
    val         _mangle  = (Mangle.mk spec)   
    val mutable _syms    = SM.empty 
    method globals _ = ()
    method private new_symbol name =
      let s = Symbol.with_mangler _mangle name in
      _syms <- SM.add name s _syms;
      s

    <<private assembly state(ppcasm.nw)>>
    method private print l = List.iter (output_string _fd) l

    <<assembly methods(ppcasm.nw)>>
end
@ 
%%Importing emits codes for indirect addressing;
%%identifiers that are otherwise undefined are automatically imported.
%%Maintaining the symbol table suffices.
<<assembly methods(ppcasm.nw)>>=
val imports = ref ([] : string list)

method import s =
  let sym  = this#new_symbol s in
  imports := ("_" ^ s)::(!imports);
  output_string  _fd ".picsymbol_stub\n";
  Printf.fprintf _fd "L_%s$stub:\n" s;
  Printf.fprintf _fd "\t.indirect_symbol _%s\n" s;
  output_string  _fd "\tmflr r0\n";
  Printf.fprintf _fd "\tbcl 20,31,L%s$pb\n" s;
  Printf.fprintf _fd "L%s$pb:\n" s;
  output_string  _fd "\tmflr r11\n";
  Printf.fprintf _fd "\taddis r11,r11,ha16(L%s$lz-L%s$pb)\n" s s;
  output_string  _fd "\tmtlr r0\n";
  Printf.fprintf _fd "\tlwz r12,lo16(L%s$lz-L%s$pb)(r11)\n" s s;
  output_string  _fd "\tmtctr r12\n";
  Printf.fprintf _fd "\taddi r11,r11,lo16(L%s$lz-L%s$pb)\n" s s;
  output_string  _fd "\tbctr\n";
  output_string  _fd ".lazy_symbol_pointer\n";
  Printf.fprintf _fd "L%s$lz:\n" s;
  Printf.fprintf _fd "\t.indirect_symbol _%s\n" s;
  output_string  _fd "\t.long dyld_stub_binding_helper\n";
  sym
@
%%Exporting requires announcing as global.
<<assembly methods(ppcasm.nw)>>=
method export s =
  let sym = this#new_symbol s in
  Printf.fprintf _fd ".globl %s\n" sym#mangled_text;
  sym
@ 
%%Locals also require no announcement.
<<assembly methods(ppcasm.nw)>>=
method local s = this#new_symbol s
@ 
%%\emph{Common seems to be missing from the Q\PAL\ version.}
<<PPC assembly interface procedures>>=
static AsmSymbol asm_common(name, size, align, section) 
  char *name; int size; int align; char *section;
{ 
  AsmSymbol s;
  assert(section == NULL);
  if (solaris)
    print(".common %s,%d,%d\n", name, size, align);
  else
    print(".common %s,%d\n", name, size);
  s = asm_sym_insert(asmtab, name, ASM_COMMON);
  s->u.common.size  = size;
  s->u.common.align = align;
  return s;
}
@ 
%%The symbol bound to a label should be made local if it isn't already.
%%The name of this method should probably change to [[define_label]].
<<assembly methods(ppcasm.nw)>>=
method label (s: Symbol.t) = fprintf _fd "%s:\n" s#mangled_text
@ 
%%Gcc does this:
<<PPC assembly interface procedures>>=
static void asm_function (name) char *name; { 
  print(".type %s,@function", name);
}
@ 
%%I have to keep track of the current section so I can implement
%%[[current_section]]. 
%%
%%The [[.section]] directive for the Mac OS X assembler
%%causes the assembler to begin assembling into the section given by
%%{\it segname} and {\it sectname}. Since the [[section]] method in
%%the [[Asm.assembler]] interface only gets one argument, I assumed
%%every section is in the [[__TEXT]] segment.
<<assembly methods(ppcasm.nw)>>=
method section name =
  _section <- name;
  if name =$= "text" then fprintf _fd ".text\n"
  else fprintf _fd ".section __DATA,%s\n" name
method current = _section
@ 
%$
<<private assembly state(ppcasm.nw)>>=
val mutable _section = "bogus section"
@ 
<<assembly methods(ppcasm.nw)>>=
method org n = fprintf _fd ".org %d\n" n
method align  n = 
  let rec lg = function
    | 0 -> 0
    | 1 -> 0
    | n -> 1 + (lg (n/2))
 in
  if n <> 1 then fprintf _fd ".align %d\n" (lg n)
method addloc n = 
  if n <> 0 then fprintf _fd ".space %d\n"  n
@ 
<<assembly methods(ppcasm.nw)>>=
method zeroes (n:int) = fprintf _fd ".space %d, 0\n" n
@ 
%%I use a dreadful hack to increase the likelihood of duplicating {\tt
%%lcc}'s 
%%assembly-language output for [[.word]] and [[.half]].
%%The PPC has no 8-byte emission unit, so I fake one, assuming big-endian order.
<<assembly methods(ppcasm.nw)>>=
method value (v:Bits.bits) = 
  let altfmt = Bits.to_hex_or_decimal_string ~declimit:256 in
  match Bits.width v with
  |  8 -> fprintf _fd ".byte %Ld\n" (Bits.S.to_int64 v)
  | 16 -> fprintf _fd ".short %s\n" (altfmt v)
  | 32 -> fprintf _fd ".long %s\n"  (altfmt v)
  | 64 ->
      let i = Bits.U.to_int64 v in
      fprintf _fd ".long 0x%Lx\n" (Int64.shift_right_logical i 32);
      fprintf _fd ".long 0x%Lx\n" (Int64.logand i mask32)
  | w -> Impossible.unimp ("emission width " ^ string_of_int w ^ " in ppc assembler")
@ 
<<utilities(ppcasm.nw)>>=
let mask32 = Int64.pred (Int64.shift_left Int64.one 32)
@ 
<<assembly methods(ppcasm.nw)>>=
method addr a =
  match Reloc.if_bare a with
  | Some b -> this#value b
  | None -> let const bits = Printf.sprintf "0x%Lx" (Bits.U.to_int64 bits) in
            assert (Reloc.width a = 32);
            fprintf _fd ".long %s\n" (Asm.reloc_string const a)
@ 
<<assembly methods(ppcasm.nw)>>=
method emit = ()
@
<<assembly methods(ppcasm.nw)>>=
method comment s = fprintf _fd "; %s\n" s

method const (s: Symbol.t) (b:Bits.bits) = 
  fprintf _fd ".set %s, 0x%Lx" s#mangled_text (Bits.U.to_int64 b)
@ 
<<assembly methods(ppcasm.nw)>>=
method private instruction rtl =
  output_string _fd "\t";
  output_string _fd (Ppcrec.M.to_asm rtl (!imports));
  output_string _fd "\n"

method longjmp_size () = 4
method private call node =
  let longjmp edge = fprintf _fd "\tb %s\n" (_mangle (snd edge.G.node)) in
  let rec output_altret_jumps n edges = (* emit n jumps *)
    if n > 0 then
      match edges with
      | edge :: edges -> (longjmp edge; output_altret_jumps (n-1) edges) 
      | [] -> Impossible.impossible "contedge count" in
  begin
    fprintf _fd "%s\n" (Ppcrec.M.to_asm node.GR.cal_i []);  (* NOTE BOGUS ARG [] *)
    output_altret_jumps node.GR.cal_altrets (List.tl node.GR.cal_contedges);
  end

method cfg_instr (cfg, proc) = 
  let symbol = proc.Proc.symbol in
  let label l = this#label (try SM.find l _syms with Not_found -> this#local l) in
  this#label symbol;
  (emitter proc cfg (this#call) (this#instruction) label : unit)
@
\section{[[arch/ppc/ppcrec.nw]]}
<<arch/ppc/ppcrec.mli>>=
<<ppcrec.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sw=4 et:
%%% ------------------------------------------------------------------ 
\section{PPC Recognizer} \label{ppcrec.sec}
%%% ------------------------------------------------------------------ 
%%
%%This module provides functions that recognize a PPC RTL. The level of
%%indirection is an artifact from the old days. We keep it because in
%%the future, the recognizer might want to take a module parameter.
%%N.B.~A~recognizer takes two forms: one to say if we have an
%%instruction, and one to convert to an assembly-language string.
<<ppcrec.mli>>=
module M : sig
  val is_instruction : Rtl.rtl -> bool
  val to_asm         : Rtl.rtl -> string list -> string
end
@ 
%%
<<ppcrec.mlb>>=
%head {: 
    <<modules(ppcrec.nw)>>
         module M = struct
           <<code to precede the labeler(ppcrec.nw)>>
      :}
%tail {:   
    <<code to follow the labeler(ppcrec.nw)>>
         end (* of M *) 
      :}

%term 
  <<names of types of terminals(ppcrec.nw)>>
%%
<<rules(ppcrec.nw)>>
@
%%
%%A few abbreviations.
<<modules(ppcrec.nw)>>=
open Nopoly
module BO   = Bits.Ops
module RP   = Rtl.Private
module RU   = Rtlutil
module SS   = Space.Standard32
module Down = Rtl.Dn      (* Convert Down  to private repr. *)
module Up   = Rtl.Up      (* Convert Up    to abstract repr. *)

exception Error of string
let error msg = raise (Error msg)
let sprintf = Printf.sprintf
@ 
%%% ------------------------------------------------------------------ 
\subsection{Utilities}
%%% ------------------------------------------------------------------ 
<<code to precede the labeler(ppcrec.nw)>>=
let s = Printf.sprintf
@   
%%The [[guard]] function turns a predicate into a cost.
<<code to precede the labeler(ppcrec.nw)>>=
let infinity = Camlburg.inf_cost
let guard b = if b then 0 else infinity
@ 
%%Utilities for instructions.
<<code to precede the labeler(ppcrec.nw)>>=
let imports = ref ([] : string list)

let ind_addr name =
  if List.exists ((=$=) name) (!imports) then "L" ^ name ^ "$stub" else name

let ppc_op = function
  | "ltu" -> ("l", "lt")
  | "leu" -> ("l", "le")
  | "gtu" -> ("l", "gt")
  | "geu" -> ("l", "ge")
  | op    -> ("" , op  )
@
%%% ------------------------------------------------------------------ 
\subsection{Recognizer Rules}
%%% ------------------------------------------------------------------ 
%%In a {\burg} pattern, a name denotes either a polymorphic nonterminal
%%symbol or a monomorphic terminal symbol. 
%%We distinguish terminals from nonterminals by name, so we have to
%%announce the names of the nonterminals.
<<names of types of terminals(ppcrec.nw)>>=
n w bits symbol
@ 
%%Terminals [[n]] and [[w]] are an index and width; both are integers.
%%Terminal [[bits]] is a constant of types [[Bits.bits]]; terminal
%%[[symbol]] is a string.
%%
%%Nonterminal [[const16]] always appears in contexts
%%where it is sign-extended.
<<rules(ppcrec.nw)>>=
const16:  Bits(bits) [{: guard (Bits.S.fits 16 bits) :}]
                     {: Bits.to_decimal_string bits :}

k15 : Bits(bits)
        [{: guard (Bits.width bits > 5 &&
                   Bits.eq bits (Bits.U.of_int 15 (Bits.width bits))) :}]
        {: () :}

k16 : Bits(bits)
        [{: guard (Bits.width bits > 5 &&
                   Bits.eq bits (Bits.U.of_int 16 (Bits.width bits))) :}]
        {: () :}

k4 : Bits(bits)
        [{: guard (Bits.width bits > 5 &&
                   Bits.eq bits (Bits.U.of_int 4 (Bits.width bits))) :}]
        {: () :}

lconst: Link(symbol, w:int)        {: symbol#mangled_text :}
pic:    Diff(c1:lconst, c2:lconst) {: s "%s-%s" c1 c2 :}
pic:    Fetch(Mem(Diff(c1:lconst, c2:lconst)), w2:int) {: s "%s-%s" c1 c2 :}
@ 
%%\paragraph{Registers}
<<rules(ppcrec.nw)>>=
pcl:  Reg('c', 0) {: () :}
cial: Reg('c', 1) {: () :}
crl:  Reg('c', 2) {: () :}
xerl: Reg('c', 4) {: () :}
lrl:  Reg('c', 5) {: () :}
spl:  Reg('r', 14) {: () :}

pc:   Fetch(pcl,  32) {: () :}
cia:  Fetch(cial, 32) {: () :}
cr:   Fetch(crl,  32) {: () :}
lr:   Fetch(lrl,  32) {: () :}
sp:   Fetch(spl,  32) {: () :}

regl: Reg('r', n:int) [{: guard (n<>0) :}] {: s "r%d" n :}
reg:  Fetch(regl, 32) {: regl :}
@
%%\paragraph{Addresses}
<<rules(ppcrec.nw)>>=
addr: const16                 {: s "%s(r0)" const16     :}
addr: reg                     {: s  "0(%s)" reg         :}
addr: Add(reg, const16)       {: s "%s(%s)" const16 reg :}

ndx_addr: Add(reg1:reg, reg2:reg) {: s "%s,%s" reg1 reg2 :}
@
%%\paragraph{Data Movement}
<<rules(ppcrec.nw)>>=
inst: Store(regl, reg, w:int) {: s "mr %s,%s" regl reg :}
inst: Store(regl,  lr, w:int) {: s "mflr %s" regl :}
inst: Store(lrl,  reg, w:int) {: s "mtlr %s" reg  :}
inst: Store(regl,  cr, w:int) {: s "mfcr %s" regl :}

inst: Store(regl, const16, 32) {: s "addi %s,0,%s" regl const16 :}

inst: Store (regl, Fetch(Mem(addr    ),32), 32)     {: s "lwz %s,%s" regl addr  :}
inst: Store (regl, Fetch(Mem(ndx_addr),32), 32)     {: s "lwzx %s,%s" regl ndx_addr :}
inst: Store (regl, Zx(Fetch(Mem(addr),8)), 32)      {: s "lbz %s,%s" regl addr  :}
inst: Store (regl, Zx(Fetch(Mem(ndx_addr),8)), 32)  {: s "lbzx %s,%s" regl ndx_addr  :}
inst: Store (regl, Zx(Fetch(Mem(addr),16)), 32)     {: s "lhz %s,%s" regl addr  :}
inst: Store (regl, Zx(Fetch(Mem(ndx_addr),16)), 32) {: s "lhzx %s,%s" regl ndx_addr  :}
inst: Store (regl, Sxlo(reg,  8), 32)               {: s "extsb %s,%s" regl reg :}
inst: Store (regl, Sxlo(reg, 16), 32)               {: s "extsh %s,%s" regl reg :}
inst: Store (regl, Sx(Fetch(Mem(addr),16)), 32)     {: s "lha %s,%s" regl addr  :}
inst: Store (regl, Sx(Fetch(Mem(ndx_addr),16)), 32) {: s "lhax %s,%s" regl ndx_addr  :}

inst: Store (Mem(addr    ), reg, 32)           {: s "stw %s,%s" reg addr  :}   
inst: Store (Mem(ndx_addr), reg, 32)           {: s "stwx %s,%s" reg ndx_addr :}
inst: Store (Mem(addr    ), Lobits(reg, 8), 8) {: s "stb %s,%s" reg addr  :}
inst: Store (Mem(ndx_addr), Lobits(reg, 8), 8) {: s "stbx %s,%s" reg ndx_addr  :}
inst: Store (Mem(addr    ), Lobits(reg,16),16) {: s "sth %s,%s" reg addr  :}
inst: Store (Mem(ndx_addr), Lobits(reg,16),16) {: s "sthx %s,%s" reg ndx_addr  :}
@ 
%%\paragraph{Position-independent Code}
<<rules(ppcrec.nw)>>=
inst : Store(regl, Add(reg, ha16), 32) {: s "addis %s,%s,%s" regl reg ha16 :}
inst : Store(regl, ha16, 32)           {: s "addis %s,0,%s" regl ha16 :}

inst : Store(regl, Add(reg, Sxlo(pic,16)),32) {: s "addi %s,%s,lo16(%s)" regl reg pic :}
inst : Store(regl, Sxlo(pic, 16), 32)         {: s "addi %s,0,lo16(%s)" regl pic :}

ha16: Ha16(pic) {: s "ha16(%s)" pic :}
@
%%\paragraph{Control Flow}
<<rules(ppcrec.nw)>>=
inst:  Goto(lconst) {: s "b %s" (ind_addr lconst) :}
inst:  Goto(lr)     {: "blr"                      :}
@
%%The [[cut to]] is supposed to look atomic, but it is a sequence of two
%%instructions. 
<<rules(ppcrec.nw)>>=
inst : Par(Goto(lr),Store(regl,reg,w:int)) {: sprintf "mr %s, %s; blr" regl reg :}
@
%%The [[next]] pattern covers the expression $PC + 4$ which denotes the
%%instruction following the branch instruction.
<<rules(ppcrec.nw)>>=
next:  Add(cia,k4) {: () :}
inst:  Par(Goto(lr    ), Store(lrl,next,32)) {: "blrl" :}
inst:  Par(Goto(lconst), Store(lrl,next,32)) {: s "bl %s" (ind_addr lconst) :}
@
%%Here are conditional branches. The {\rtl} operator names fit the {\mips}
%%assembly branch op-codes. We cannot inline the [[Cmp]] constructor
%%because the [[op]] terminal symbol would be unaccessible. Only top-level
%%terminals are in scope for the semantic action.
<<rules(ppcrec.nw)>>=
cmp:   Cmp(op:string, x:reg, y:reg)     {: ("",  ppc_op op,x,y) :}
cmp:   Cmp(op:string, x:reg, y:const16) {: ("i", ppc_op op,x,y) :}
inst:  Guarded(cmp,Goto(lconst)) 
       {: let (i_, (l_, op), x, y) = cmp in
          s "cmp%sw%s cr0,%s,%s\n\tb%s %s"  l_ i_ x y op lconst
       :}
inst : Guarded(OvSet(Fetch(xerl,32)), Goto(lconst))
       {: s "bo %s" lconst :}
@ 
%%\paragraph{Instructions}
<<rules(ppcrec.nw)>>=
inst: Store(regl,  Add(x:reg, y:reg), 32)       {: s "add %s,%s,%s" regl x y :}
inst: Store(regl,  Add(x:reg, y:const16), 32)   {: s "addi %s,%s,%s" regl x y :}

inst: Store(regl, Unop (opr:string,x:reg),      32) {: s "%s  %s,%s"    opr regl x :}
inst: Store(regl, Binop(opr:string,x:reg,y:reg),32) {: s "%s  %s,%s,%s" opr regl x y :}
inst: Store(regl, Binop(opr:string,x:reg,y:const16), 32)
    {: s "%si %s,%s,%s" opr regl x y :}
@
%%\paragraph{Support for debugging}
%%If an RTL should fail to match, one can uncomment the following rule
%%and get a printout of exactly how that RTL is represented using {\burg}
%%constructors. 
<<rules(ppcrec.nw)>>=
inst : any [100] {: s "<%s>" any :}

any : True  () {: "True"  :}
any : False () {: "False" :}
any : Link(symbol, w:int) {: s "Link(%s,%d)" (symbol#mangled_text) w :}
any : Diff(c1:any, c2:any) {: s "Diff(%s, %s)" c1 c2 :}
any : Bits(bits)     {: sprintf "Bits(%s)" (Bits.to_string bits) :}

any : Fetch (any, w:int) {: s "Fetch(%s,%d)" any w :}

any : Sx(any)           {: s "Sx(%s)" any  :}
any : Zx(any)           {: s "Zx(%s)" any  :}
any : Sxlo(any,w:int)   {: s "Sxlo(%s,%d)" any w :}
any : Zxlo(any,w:int)   {: s "Zxlo(%s,%d)" any w :}
any : Add(x:any, y:any) {: s "Add(%s, %s)" x y :}

any: Ha16(any) {: s "Ha16(%s)" any :}


any : Unop (op:string, x:any)         {: s "Unop(%s,%s)" op x  :}
any : Binop(op:string, x:any, y:any)  {: s "Binop(%s,%s,%s)" op x y  :}

any : Nop () {: "nop" :}

any : Lobits(any, w:int) {: s "Lobits(%s, %d)" any w :}
any : BitExtract(lsb:any, y:any, n:int) {: sprintf "BitExtract(%s, %s, %d)" lsb y n :}

any : Slice(w:int, n:int, y:any) {: sprintf "Slice(%d, %d, %s)" w n y :}

any : Mem(any) {: s "Mem(%s)" any :}
any : Reg(char, n:int) {: sprintf "Reg(%s, %d)" (Char.escaped char) n :}

any : Store (dst:any, src:any, w:int) {: s "Store(%s,%s,%d)" dst src w :}
any : Kill(any) {: s "Kill(%s)" any :}

any : Guarded(guard:any, any) {: s "Guarded(%s,%s)" guard any :}
any : Cmp(op:string, x:any, y:any) {: s "Cmp(%s,%s,%s)" op x y :}
any : Par(l:any, r:any) {: s "Par(%s,%s)" l r :}
any : Goto(any) {: s "Goto(%s)" any :}
@
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
%%% ------------------------------------------------------------------ 
%%
%%The code in this section walks an RTL and calls suitable \burg\
%%constructors. 
<<code to follow the labeler(ppcrec.nw)>>=
let rec const = function
  | RP.Bool(true)             -> conTrue  ()
  | RP.Bool(false)            -> conFalse ()
  | RP.Link(s,_,w)            -> conLink s w
  | RP.Diff(c1,c2)            -> conDiff (const c1) (const c2)
  | RP.Late(s,w)              -> Impossible.impossible "Late constant in recognizer"
  | RP.Bits(b)                -> conBits(b)
@
<<code to follow the labeler(ppcrec.nw)>>=
let is_cmp (opr,ws) =
  let cmp = ["eq";"ge";"geu";"gt";"gtu";"le";"leu";"lt";"ltu";"ne"] in
  if not (List.mem opr cmp) then false
  else match ws with
    [32]  -> true
  | _     -> error "comparison not at 32 bits in PPC recognizer"

let rtl2ppc = function
  | "and"  -> "and"
  | "divu" -> "divwu"
  | "quot" -> "divw"
  | "mul"  -> "mullw"
  | "neg"  -> "neg"
  | "or"   -> "or"
  | "shl"  -> "slw"
  | "shrl" -> "srw"
  | "sub"  -> "sub"
  | "xor"  -> "xor"
  | opr    -> error (sprintf "Unsupported RTL operator \"%s\"" opr)

let rec exp = function
  | RP.Const(k)                  -> const (k)
  | RP.Fetch(l,w)                -> conFetch (loc l) w
  <<case for [[ha16(e)]]>>
  | RP.App(("sx", [n; _]), [RP.App (("lobits", [_;_]), [x])]) -> conSxlo (exp x) n
  | RP.App(("zx", [n; _]), [RP.App (("lobits", [_;_]), [x])]) -> conZxlo (exp x) n
  | RP.App(("sx", [8 ;32]), [x]) -> conSx (exp x)
  | RP.App(("sx", [16;32]), [x]) -> conSx (exp x)
  | RP.App(("zx", [8 ;32]), [x]) -> conZx (exp x)
  | RP.App(("zx", [16;32]), [x]) -> conZx (exp x)
  | RP.App(("add",[16]), [x; y]) -> conAdd  (exp x) (exp y)
  | RP.App(("add",[32]), [x; y]) -> conAdd  (exp x) (exp y)


  | RP.App(("ppc_xer_ov_set", []), [x])        -> conOvSet (exp x)
  | RP.App(("bitExtract", [_; n]), [lsb; src]) -> conBitExtract (exp lsb) (exp src) n

  | RP.App(("lobits", [32;w]), [x]) -> conLobits (exp x) w

  | RP.App((opr, ws), [x])          -> conUnop (rtl2ppc opr) (exp x)
  | RP.App((opr, ws), [x;y])        -> if is_cmp(opr,ws) then conCmp opr (exp x) (exp y)
                                       else conBinop (rtl2ppc opr) (exp x) (exp y)

  | RP.App((o,_),_) -> error (sprintf "unknown operator %s" o)
@ 
%%This job can't be done in BURG because the expression in question
%%appears in two places.
<<case for [[ha16(e)]]>>=
| RP.App (("shl", [32]), [
   <<pic_hi16 + pic_15>>
   ; RP.Const (RP.Bits k16)]) 
   when Bits.eq k16 (Bits.U.of_int 16 32) && Bits.eq k16' (Bits.U.of_int 16 32)
     && Bits.eq k15 (Bits.U.of_int 15 32) && RU.Eq.exp e e' ->
     conHa16 (exp e)
@ 
<<pic_hi16 + pic_15>>=
RP.App(("add", [32]), [
  <<pic_hi16>>
  ; 
  <<pic15>>
  ])
@ 
<<pic_hi16>>=
RP.App(("shrl", [32]), [e; RP.Const (RP.Bits k16')])
@ 
<<pic15>>=
RP.App(("zx", [1;32]),
       [RP.App (("lobits", [32;1]),
                [RP.App(("shrl", [32]), [e'; RP.Const (RP.Bits k15)])])])
@ 
<<code to follow the labeler(ppcrec.nw)>>=
and loc l = match l with
  | RP.Mem(('m',_,_), Rtl.C c, e, ass) -> conMem (exp e)
  | RP.Reg((sp, _,_), i, w)            -> conReg sp i 
  | RP.Mem(_, _, _, _)                 -> error "non-mem, non-reg cell"
  | RP.Var _ | RP.Global _             -> error "var found"
  | RP.Slice(w,i,l)                    -> conSlice w i (loc l)

and effect = function
  | RP.Store(RP.Reg(('c',_,_),i,_),r,_)
    when i = SS.indices.SS.pc          -> conGoto (exp r)
  | RP.Store(l,e,w)                    -> conStore (loc l) (exp e) w
  | RP.Kill(l)                         -> conKill (loc l)

and guarded g eff =
  match g with
  | RP.Const(RP.Bool b) -> if b then effect eff else conNop()
  | _                   -> conGuarded (exp g) (effect eff)

and geffects = function
    | []          -> conNop()
    | [g, s]      -> guarded g s
    | (g, s) :: t -> conPar (guarded g s) (geffects t)
and rtl (RP.Rtl es) = geffects es
@
%%
\subsection{The exported recognizers}
%%
%%The only tricky bits here are what we do when something goes wrong.
%%In a production compiler, we should always halt the compiler.
%%But here, it is more informative to drop an error message into the
%%assembly language and to allow the assembler to barf downstream.
<<code to follow the labeler(ppcrec.nw)>>=
let errmsg r msg =
  List.iter prerr_string
    [ "recognizer error: "; msg; " on "; RU.ToString.rtl r; "\n" ]

let to_asm r i =
  try
    let _ = imports := i in
    let plan = rtl (Down.rtl r) in
    plan.inst.Camlburg.action ()
  with 
  | Camlburg.Uncovered -> " not an instruction: " ^ RU.ToString.rtl r
  | Error msg -> (errmsg r msg; " error in recognizer: " ^ msg)

let is_instruction r =
  try
    let plan = rtl (Down.rtl r) in
    plan.inst.Camlburg.cost < 100
  with
  | Camlburg.Uncovered -> false
  | Error msg -> (errmsg r msg; false)
@                        

\chapter{[[arch/x86]]}

\section{[[arch/x86/x86.nw]]}
<<arch/x86/x86.ml>>=
<<x86.ml>>
@

<<arch/x86/x86.mli>>=
<<x86.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Please add grades for this module below. The line must start with % "%%".
%%% 
%%
%%%%Grades: I Peripheral Immediate
%%
\section{Back end for a Intel x86 (32-bit subset)}
%%
%%\label{x86.sec}
%%
%%As of November 2004, this is the most complete and best documented of
%%our back ends.
%%
%%There's a lot of goo behind this thin interface:
<<x86.mli>>=
module X      : Expander.S
val target    : Ast2ir.tgt
val placevars : Ast2ir.proc -> Automaton.t
@ 
\section{Implementation}
%%
%%Here are some abbreviations.
%%Note especially the use of the [[X86regs]] module, internally known as~[[Rg]].
<<x86.ml>>=
open Nopoly

module A  = Automaton
module C  = Context
module DG = Dag
module PA = Preast2ir
module PX = Postexpander
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module Up = Rtl.Up
module Dn = Rtl.Dn
module Rg = X86regs
module RO = Rewrite.Ops
module T  = Target

let impossf fmt = Printf.kprintf Impossible.impossible fmt
let unimpf  fmt = Printf.kprintf Impossible.unimp      fmt
@ 
%%At initialization, we register the x86 machine invariant as a property
%%for the optimization backplane.
<<x86.ml>>=
(* pad: don't need lua *)
(*
let _ = Backplane.M.register "x86 invariant"
    ["The x86 machine invariant.  For more explanation, see '<machine> invariant'."]
*)
@ 
\subsection{Storage spaces}
%%
%%We use the standard storage spaces, with the PC and
%%condition codes in their standard locations from [[Space.Standard32]].
%%We can't use the standard \texttt{f} space because Pentium
%%floating-point values are 80~bits wide.
%%We pretend that the machine is a 32-bit machine, which simplifies a lot.
<<x86.ml>>=
module SS = Space.Standard32
module Spaces = struct
  let bo = Rtl.LittleEndian
  let id = Rtl.Identity
  let m  = SS.m bo [8; 16; 32]
  let r  = SS.r 7 id [32]
  let t  = SS.t   id  32
  let c  = SS.c 3 id [32]
end
@
\subsection{Postexpander}
%%
%%Program counter and condition codes (called [[eflags]] on the Pentium)
%%are standard.
%%The rounding mode is a standard register. 
<<x86.ml>>=
let {SS.pc = pc; SS.cc = eflags} = SS.locations Spaces.c
let rounding_model = R.regx Rg.fpround
let rounding_mode  = R.fetch rounding_model 2
@
%%We begin with some utility functions.
%%It might be nice to place these functions in the postexpander, but they're useful
%%  for invoking [[MFlow]], which we use to help define the postexpander.
<<x86.ml>>=
let tempwidth     = Register.width
let temploc t     = R.reg t
let tempval t     = R.fetch (temploc t) (tempwidth t)
@
%%Here is information about memory.
%%We ought to find a good way to tie this information into the target
%%metrics, so as to avoid duplication and potential inconsistency.
<<x86.ml>>=
let byte_order = Spaces.bo
let mcell  = Cell.of_size 8
let mcount = Cell.to_count mcell
let mspace = ('m', byte_order, mcell)
let mem addr      = R.mem R.none mspace (R.C 4) addr  (* single word in memory *)
let exchange_alignment = 4  (* not required, but faster *)

let pc        = pc
let esp       = temploc Rg.esp
let espval    = tempval Rg.esp
let add       = Rtlutil.add 32
let sub x y   = RO.sub 32 x y
let const n   = RO.signed 32 n
let fetch l   = R.fetch l 32
let store' l r = R.store l r 32
let pop_with f = (* rtl got by popping (f e), where e is top of stack *)
  let top = fetch (mem espval) in
  R.par [ f top; store' esp (add espval (const 4)) ]

let push' e = (* effect of pushing e *)
  let next_sp = sub espval (const 4) in
  R.par [ store' (mem next_sp) e; store' esp next_sp ]
@ 
%%We now build the standard control flow.
<<x86.ml>>=
module TY = Types
let (-->) = TY.proc 
module FS = Mflow.MakeStandard (
  struct
     let pc_lhs = pc
     let pc_rhs = pc
     let ra_reg =
       temploc (('?', Rtl.Identity, Cell.of_size 0), 99, R.C 1) (* not used *)
     let ra_offset = 33                       (* not used *)
  end)
module F = struct
  include FS
  let fmach = FS.machine esp
  let call =
    { T.embed = (fun _ e -> (DG.Nop, R.par [R.store pc e 32; push' (fetch pc)]))
    ; T.project = (fun r -> match Dn.rtl r with
                   | RP.Rtl [(_, RP.Store(_, e, _)); _; _] -> Up.exp e
                   | _ -> Impossible.impossible (Printf.sprintf "projected non-call: %s"
                                                                (RU.ToString.rtl r)))
    }
  let return = pop_with (fun ra -> store' pc ra)
end
@
%%The postexpander is defined below.
<<x86.ml>>=
module Post = struct
  <<x86 postexpander>>
end
@ 
%%These synonyms, which are required by the postexpander interface, are a nuisance.
<<x86 postexpander>>=
type temp      = Register.t
type rtl       = Rtl.rtl
type address   = Rtl.exp
type width     = Rtl.width
type assertion = Rtl.assertion
type operator  = Rtl.Private.opr
@
%%Some of the values used for [[MFlow]] need to be copied into the postexpander.
<<x86 postexpander>>=
let byte_order         = byte_order
let exchange_alignment = exchange_alignment
@
%%The postexpander sometimes needs to allocate a temporary.
<<x86 postexpander>>=
let talloc = Postexpander.Alloc.temp
@ 
%%\paragraph {Important note about hardware registers}
%%
%%This postexpander assumes the right to clobber EAX, EBX, ECX,
%%and EDX at will.
%%It is therefore unsafe for any of these registers to be used as a
%%global register.
%%Among other restrictions, this means these registers must not be
%%exposed to {\PAL} source programs by name.
%%(That is, they must not appear in the [[named_locs]] field of the
%%[[target]] record.)
%%
%%An alternative would be to save and restore each register before using it,
%%but at present we don't have an optimization pass capable of
%%eliminating all those dead saves and restores.
%%Even if we did, one might question the wisdom.
%% 
%%\paragraph{Contexts}
%%Addresses go in the integer registers.
%%The floating-point registers are treated as a stack, so anything that
%%actually gets allocated through a context should go in the integer
%%registers as well, even if it would be in a floating-point register on
%%an ordinary machine.
%%Hence there is only one context: the integer context.
<<x86 postexpander>>=
let icontext = C.of_space Spaces.t
let itempwidth = 32
let fcontext = icontext  (* oddity documented above *)
let acontext = icontext
let rcontext = icontext
let constant_context w = icontext
let overrides = []
let arg_contexts, result_context =
  C.functions (C.nonbool icontext fcontext rcontext overrides)
@ 
%%IT WOULD BE GOOD TO RESTRUCTURE THE CONTEXTS AND THE
%%[[Talloc.Multiple]] INTERFACE SO THAT REQUESTING A BAD WIDTH COULD
%%MAKE A SUITABLE CALL INTO [[Unsupported]].  
%%AN EVEN MORE AMBITIOUS PLAN MIGHT MAKE THE WIDTHS EXPLICIT IN THE
%%CONTEXT.
%% 
%%\subsubsection{Basic locations, flags, and helper functions}
%%
%%The rest of the compiler deals in locations, expressions, and RTLs.
%%But the postexpander deals primarily with temporaries and blocks.
%%Here are some functions to help smooth over the differences.
%%Here are some utility functions for computing locations, values, and widths.
<<x86 postexpander>>=
let (<:>) = DG.(<:>)
let rtl r = DG.Rtl r
let tempstore t e = rtl (R.store (temploc t) e (tempwidth t))
@ 
%%And another for doing shifts.  Parameter [[op]] should be, e.g., [[RO.shl]].
%%N.B.~This is actually acceptable as an instruction, since the Pentium
%%does a shift-immediate em{without} touching condition codes.
<<x86 postexpander>>=
let shift dst op n = tempstore dst (op 32 (tempval dst) (RO.unsigned 32 n))
@ 
%%Here are some important locations and values.
<<x86 postexpander>>=
let eax = temploc Rg.eax
let ecx = temploc Rg.ecx
let edx = temploc Rg.edx
let esp = temploc Rg.esp
let esi = temploc Rg.esi
let edi = temploc Rg.edi

let ah_val = R.fetch Rg.ah 8
let carrybit = R.app (R.opr "x86_carrybit" []) [RU.fetch eflags]
@ 
%%In order to write code that transfers flags between [[eflags]] and
%%[[ah]],  
%%we invent a couple of machine-specific operators.
%%EVENTUALLY, WE WILL WANT TO TELL THE SIMPLIFIER THAT THESE OPERATORS
%%ARE HALF-INVERSES (I.E.,
%%$\mathtt{x86\_flags2ah}(\mathtt{x86\_ah2flags}(b)) = b$).
%%IT WOULD BE GOOD TO BE ABLE TO WRITE THE CODE HERE AND REGISTER IT
%%SOMEHOW. 
<<x86 postexpander>>=
let sahf = rtl (R.store eflags (R.app (R.opr "x86_ah2flags" []) [ah_val]) 16)
let lahf = rtl (R.store Rg.ah  (R.app (R.opr "x86_flags2ah" []) [R.fetch eflags 16]) 8)
@ 
%%Here are more invented operators, this time to hide the real truth
%%about what 
%%happens to the flags.
%%It's up to the recognizer to know such facts as
%%$\mathtt{x86\_adcflags}(x, y, 0) = \mathtt{x86\_addflags}(x, y)$.
%%\nextchunklabel{x86.flagfuns}
%%(N.B.~We have an explicit width because we might one day want to apply
%%these operators to 8-~or 16-bit operands.)
<<x86 postexpander>>=
let c = carrybit
let addflags   x y w = R.store eflags (R.app (R.opr "x86_addflags"   [w]) [x; y])    32
let adcflags   x y w = R.store eflags (R.app (R.opr "x86_adcflags"   [w]) [x; y; c]) 32
let logicflags exp w = R.store eflags (R.app (R.opr "x86_logicflags" [w]) [exp])     32
let mulflags   x y w = R.store eflags (R.app (R.opr "x86_mulflags"   [w]) [x; y])    32
let muluxflags x y w = R.store eflags (R.app (R.opr "x86_muluxflags" [w]) [x; y])    32
let mulxflags  x y w = R.store eflags (R.app (R.opr "x86_mulxflags"  [w]) [x; y])    32
let negflags   x   w = R.store eflags (R.app (R.opr "x86_negflags"   [w]) [x])       32
let subflags   x y w = R.store eflags (R.app (R.opr "x86_subflags"   [w]) [x; y])    32
let sbbflags   x y w = R.store eflags (R.app (R.opr "x86_sbbflags"   [w]) [x; y; c]) 32
let undefflags       = R.store eflags (R.app (R.opr "x86_undefflags" [])  [])        32
let shflags sh x y w =
  let flagsop = "x86_" ^ sh ^ "flags" in
  R.store eflags (R.app (R.opr flagsop [w]) [x; y]) 32
@ 
%%\subsubsection{Data movement}
%%Most data movement is simple assignment; the MOV instruction is quite powerful.
%%Because the only temporaries that can be allocated are 32-bit
%%temporaries, we just assume the width is~32.
<<x86 postexpander>>=
let load ~dst ~addr assn =
  tempstore dst (R.fetch (R.mem assn mspace (R.C 4) addr) 32)
let store ~addr ~src assn =
  rtl (R.store (R.mem assn mspace (R.C 4) addr) (tempval src) 32)
@ 
%%The Pentium provides sign-extending loads and stores.
%%It's a bit bogus to use EAX to do the [[lostore]], but we have no easy
%%way of asking for a temporary that supports low-store instructions.
<<x86 postexpander>>=
let sxload ~dst ~addr n assn =
  tempstore dst (RO.sx n 32 (R.fetch (R.mem assn mspace (mcount n) addr) n)) 
let zxload ~dst ~addr n assn =
  tempstore dst (RO.zx n 32 (R.fetch (R.mem assn mspace (mcount n) addr) n))
let lostore ~addr ~src n assn =
  rtl (R.store eax (tempval src) 32) <:>
  rtl (R.store (R.mem assn mspace (mcount n) addr) (RO.lobits 32 n (R.fetch eax n)) n)
@ 
%%Register-register moves involve only integer registers, so life is
%%easy and good.  Because [[move]] is used a lot inside the postexpander,
%%we do a little premature optimization.
<<x86 postexpander>>=
let move ~dst ~src = if Register.eq dst src then DG.Nop else tempstore dst (tempval src)
@ 
%%Because there's only one size of temporary in this back end, we don't
%%need [[extract]] or [[aggregate]].
<<x86 postexpander>>=
let extract   ~dst ~lsb ~src = impossf "extract on x86"
let aggregate ~dst      ~src = impossf "aggregate on x86"
@ 
%%Load immediate is also a simple move.
<<x86 postexpander>>=
let li  ~dst const = tempstore dst (Up.const const)
let lix ~dst e     = tempstore dst e
@ 
%%\subsubsection{Operator implementations (with flags)}
%%Operator hell (or heaven).
%%Here are three functions that help combine useful effects with side
%%effects on flags (from functions defined in
%%chunk~\subpageref{x86.flagfuns}. 
%%These functions don't cover all cases; sometimes we have to get down
%%and dirty with the raw effects.
<<x86 postexpander>>=
let exp_with_flags setflags dst exp x y w =
  rtl (R.par [R.store (temploc dst) exp w; setflags x y w])

let with_flags setflags dst op x y w =
  let x = tempval x in
  let y = tempval y in
  let exp = R.app op [x; y] in
  exp_with_flags setflags dst exp x y w

let with_lflags dst op x y w =
  let exp = R.app op [x; y] in
  rtl (R.par [R.store (temploc dst) exp w; logicflags exp w])
@ 
%%Unfortunately, [[with_flags]] is sometimes passed a literal, so
%%unlike [[with_flags]], it can't assume its arguments are temporaries.
%%Therefore [[tempval]] is applied at (most) call sites.
%%
%%We insist on using most operators at their natural 32-bit width, and
%%this function is the forcing function that makes it so.
%%Because in principle we ought to support 8- and 16-bit operators,
%%widths other than 32~bits are ``unimplemented,'' not ``impossible.''
<<x86 postexpander>>=
let at32 = function
  | opr, [32] -> opr
  | opr, [n]  -> unimpf "operator %%%s%d(...)" opr n
  | opr, ws   -> impossf "operator %%%s specialized to %d widths" opr (List.length ws)
@ 
%%\paragraph{Binary operators}
%%
%%On the Pentium, most binary operators are usable only
%%in $L \mathrel{:=} L \oplus R$ form, which is implemented by the
%%[[llr]] function.
%%The exception is division: because it uses so many special registers,
%%it's just as easy to implement the $D \mathrel{:=} L \oplus R$ form.
<<x86 postexpander>>=
<<definition of function [[llr]]>>
let binop ~dst op x y = match at32 op with
<<cases in [[binop]] to handle integer division>>
| _ -> move dst x <:> llr op dst y
@ 
<<definition of function [[llr]]>>=
let llr op x y = match at32 op with
| "add" -> with_flags addflags x (Up.opr op) x y 32
| "sub" -> with_flags subflags x (Up.opr op) x y 32
| "mul" -> with_flags mulflags x (Up.opr op) x y 32
<<more cases for [[llr]]>>
@
%%Division is slightly painful.
%%The dividend must go the EDX:EAX register pair, the value of which is
%%written as [[regpair]].
%%To set EDX appropriately we use [[sethi]].
%%The instruction itself is [[div]];
%%the effect of this instruction is that quotient and remainder go into
%%EAX and EDX. 
%%We then follow up with [[finish]], which takes some combination of EAX
%%and EDX and
%%does the right thing.
%%
%%Since the destination register is hard-wired, there's no need to make
%%division an LLR instruction.
%%Instead, division is part of the general [[binop]], with operands in
%%[[x]]~and~[[y]] and result in [[dst]].
<<cases in [[binop]] to handle integer division>>=
| "mod" ->
    PX.Expand.block (tempstore dst (Rewrite.(mod) 32 (tempval x) (tempval y)))
| ("div" | "divu" | "quot" | "modu" | "rem") as opname ->
    let unsigned = opname =$= "divu" || opname =$= "modu" in
    let w = 32 in
    let sethi hreg lreg = (* set hreg to make divide come out right *)
      if unsigned then
        tempstore hreg (RO.unsigned w 0)
      else
        tempstore hreg (tempval lreg) <:> shift hreg RO.shra (w-1) in
    let regpair = Rewrite.regpair ~hi:(tempval Rg.edx) ~lo:(tempval Rg.eax) in
    let q, r    = if unsigned then "divu", "modu" else "quot", "rem" in
    let div     = R.par [R.store eax (R.app (R.opr q [w]) [regpair; tempval y]) w;
                         R.store edx (R.app (R.opr r [w]) [regpair; tempval y]) w;
                         undefflags] in
    let finish = match opname with
    | "quot" | "divu" -> move dst Rg.eax
    | "rem"  | "modu" -> move dst Rg.edx
    | "div" -> let d = Rewrite.div' w ~dst:(R.reg dst) (tempval x) (tempval y)
                         ~quot:(tempval Rg.eax) ~rem:(tempval Rg.edx) in
               PX.Expand.block d
    | _ -> impossf "division operator %%%s?" opname in
    move Rg.eax x <:> sethi Rg.edx Rg.eax <:> rtl div <:> finish
@ 
%%N.B. THE DIVISION ABOVE IS NOT WELL TYPED.
%%
%%Shifts and rotates use register~CL.
%%One awkward property of the machine: immediate shifts don't set the
%%flags, which means a simple peephole optimizer is incapable of
%%substituting immediate values for shifts (because a simple optimizer
%%doesn't know the effect on the flags is dead).
<<more cases for [[llr]]>>=
| ("shl" | "shrl" | "shra" | "rotl" | "rotr") as shop ->
    let cl = RO.zx 8 32 (R.fetch Rg.cl 8) in
    let sh = exp_with_flags (shflags shop) x (R.app (Up.opr op) [tempval x; cl])
              (tempval x) cl 32 in
    move Rg.ecx y <:> sh
@ 
%%Because it's an unchecked run-time error to pass $\mathtt y \ge 32$,
%%we don't have to generate code to check that [[y]]~fits in 8~bits.
%%
<<more cases for [[llr]]>>=
| ("and"|"or"|"xor") -> with_lflags x (Up.opr op) (tempval x) (tempval y) 32 
@ 
%%The list above should exhaust the x86 binary operators.
<<more cases for [[llr]]>>=
| op  -> impossf "non-binary operator %%%s in x86 binop" op
@ 
%%\paragraph{Unary operators}
%%Unary operators are done in place, except for [[popcnt]], which must
%%be synthesized using a rewrite rule.
<<x86 postexpander>>=
let inplace op op32 x = match op32 with
| "neg"    -> rtl (R.par [R.store (temploc x) (R.app (Up.opr op) [tempval x]) 32;
                          negflags (tempval x) 32])
| "com"    -> tempstore x (R.app (Up.opr op) [tempval x])
| op       -> impossf "non-unary operator %%%s in x86 unop" op

let unop ~dst op x = match at32 op with
| "popcnt" -> PX.Expand.block (Rewrite.popcnt 32 ~dst:(temploc dst) (tempval x))
| op32     -> move dst x <:> inplace op op32 dst
@ 
%%Floating-point operations use the stack, not registers, so these
%%functions should never be called.
<<x86 postexpander>>=
let unrm  ~dst op x   = impossf "operator %%%s in register" (fst op)
let binrm ~dst op x y = impossf "operator %%%s in register" (fst op)
@ 
%%\paragraph{Extended multiply}
%%
%%An x86 extended-multiply instruction takes arguments in EAX and~[[y]]
%%and returns the double-width result in the EDX:EAX pair.
%%Flags are set.
<<x86 postexpander>>=
let extended_multiply op y =
  let opfun, flagfun = match op with
  | "mulx"  -> RO.mulx,  mulxflags
  | "mulux" -> RO.mulux, muluxflags
  | _ -> impossf "non-multiplying dblop" in
  let product = opfun 32 (tempval Rg.eax) (tempval y) in
  rtl (R.par [R.store edx (Rewrite.slice 64 32 ~lsb:32 product) 32;
              R.store eax (Rewrite.slice 64 32 ~lsb:0  product) 32;
              flagfun (tempval Rg.eax) (tempval y) 32])
@               
%%Given [[extended_multiply]], we need only move arguments and results
%%to the right places.
<<x86 postexpander>>=
let dblop ~dsthi ~dstlo op x y =
  move Rg.eax x <:>
  extended_multiply (at32 op) y <:>
  move dsthi Rg.edx <:>
  move dstlo Rg.eax
@ 
%%\paragraph{Add with carry, subtract with borrow}
%%
%%Function [[weird_tmp]] returns a register that holds a weird value,
%%plus the instructions needed to get the value into the register.
%%COULD THIS FUNCTION BE A CANDIDATE FOR A GENERAL POSTEXPANDER UTILITY?
<<x86 postexpander>>=
let weird_tmp tmp z = match z with
| PX.WTemp (Register.Reg t)             -> t, DG.Nop
| PX.WTemp (Register.Slice (w, 0, t))   -> t, DG.Nop
| PX.WTemp (Register.Slice (w, lsb, t)) -> 
    tmp, move tmp t <:> tempstore tmp (RO.shrl 32 (tempval tmp) (RO.unsigned 32 lsb))
| PX.WBits b -> tmp, tempstore tmp (R.bits (Bits.Ops.zx 32 b) 32)
@ 
%%I don't want to model the details of the flags, so I provide a
%%function to insert a new carry bit.
%%For performance, the simplifier has to know that
%%[[x86_carrybit (x86_setcarry (eflags, c)) = c]].
%%Unfortunately, that code lurks in the simplifier.
%%It would be good to find a way to put the rewrite rule here in this
%%module and to register it with the simplifier.
<<x86 postexpander>>=
let set_carry ~tmp z =
  let t, is = weird_tmp tmp z in
  let bit0 = RO.lobits 32 1 (tempval t) in
  is <:>
  rtl (R.store eflags (R.app (R.opr "x86_setcarry" []) [RU.fetch eflags; bit0]) 32)
@ 
%%Add with carry and subtract with borrow use essentially the same code.
%%By using the general [[set_carry]], 
%%we're missing a chance to optimize when we know the carry in is a
%%literal~0.
%%But the peephole optimizer takes care of it.
<<x86 postexpander>>=
let wrdop ~dst op x y z =
  let dv, yv = tempval dst, tempval y in
  let is_add =
    match at32 op with "addc" -> true | "subb" -> false | _ -> impossf "wrdop" in
  let flags  = (if is_add then adcflags else sbbflags) dv yv 32 in
  let arith  = R.store (temploc dst) (R.app (Up.opr op) [dv; yv; carrybit]) 32 in
  set_carry ~tmp:dst z <:> move dst x <:> rtl (R.par [arith; flags])
@ 
%%Getting the carry bit out is a real trip.
%%We start with the instruction above, then play games with flags.
%%And we have to fill the result as requested by the generic expander.
%%We don't use [[Rewrite]] for the fills,  because we would miss
%%the opportunity to use the Pentium's special immediate-shifst instructions.
<<x86 postexpander>>=
let wrdrop ~dst:(fill, dt) op x y z =
  let is_add =
    match at32 op with "carry" -> true | "borrow" -> false | _ -> impossf "wrdrop" in
  let t = talloc 't' 32 in
  wrdop ~dst:t ((if is_add then "addc" else "subb"), [32]) x y z <:> (* sets carry *)
  lahf <:>                           (* load ah from flags; carry is now lsb of ah *) 
  shift Rg.eax RO.shrl 8 <:>         (* shift carry into bit 0 of eax *)
  tempstore dt (R.fetch eax 32) <:>
  match fill with
  | PX.HighAny -> DG.Nop
  | PX.HighZ   -> shift dt RO.shl 31 <:> shift dt RO.shrl 31  (* zxlo *)
  | PX.HighS   -> shift dt RO.shl 31 <:> shift dt RO.shra 31  (* sxlo *)
@ 
%%\paragraph{Hardware registers}
%%Setting the rounding mode is an experience.
%%To get an idea what to do, we disassembled the relevant function from
%%GNU libc:
%%\begin{verbatim}
%%  ar x /usr/lib/libm.a fesetround.o
%%  objdump -d fesetround.o
%%\end{verbatim}
%%The assembly code gave us some hints what to do.
%%\begin{verbatim}
%%  fnstcw stackslot
%%  movzwl stackslot,%eax ; %eax is a temporary here
%%  and    $0xfffff3ff,%eax
%%  ... ; set %edx by shifting mode bits left 10
%%  or     %edx,%eax
%%  mov    %ax,stackslot
%%  fldcw  stackslot
%%\end{verbatim}
%%(Unlike the GNU code, we do \emph{not} set the rounding mode in the
%%MMX unit.)
%% 
%%We begin with some useful constants and operators.
<<x86 postexpander>>=
let rmask_clear = R.bits (Bits.Ops.com (Bits.U.of_int 0xc00 32)) 32  (* 0xfffff3ff *)
let rmask_set   = R.bits (Bits.U.of_int 0xc00 32)  32
let and32 = R.opr "and" [32]
let or32  = R.opr "or"  [32]
@ 
%%Get the status word by moving it onto the stack, then loading it.
%%Then shift the rounding mode into least significant position, filling
%%as requested.
<<x86 postexpander>>=
let hwget ~dst:(fill,dt) ~src =
  if Register.eqx src Rg.fpround then
    let slot = PX.Alloc.slot 16 2 in
    rtl (slot.A.store (tempval Rg.fpuctl) 16)    <:>  (* fnstcw *)
    tempstore dt (RO.zx 16 32 (slot.A.fetch 16)) <:>  (* movzwl *)
    match fill with
    | PX.HighAny -> shift dt RO.shrl 10
    | PX.HighZ   -> shift dt RO.shl 20 <:> shift dt RO.shrl 30
    | PX.HighS   -> shift dt RO.shl 20 <:> shift dt RO.shra 30
  else
    impossf "getting unexposed hardware register"
@ 
%%To set the rounding mode, we get the status word, mask out bits, shift the
%%rounding mode into position, or into the status word, then set the
%%status word.
<<x86 postexpander>>=
let hwset ~dst ~src =
  if Register.eqx dst Rg.fpround then
    let slot      = PX.Alloc.slot 16 2 in
    let t         = PX.Alloc.temp 't' 32 in
    let t2, ldsrc = weird_tmp (PX.Alloc.temp 't' 32) src in
    rtl (slot.A.store (tempval Rg.fpuctl) 16)      <:> (* fnstcw *)
    tempstore t (RO.zx 16 32 (slot.A.fetch 16))    <:> (* movzwl *)
    with_lflags t and32 (tempval t) rmask_clear 32 <:>      (* mask out round bits *)
    ldsrc <:>
    shift t2 RO.shl 10 <:>
    with_lflags t or32 (tempval t) (tempval t2) 32 <:>
    rtl (slot.A.store (RO.lobits 32 16 (tempval t)) 16) <:>      
    tempstore Rg.fpuctl (slot.A.fetch 16)                   (* fldcw *)
  else
    impossf "setting unexposed hardware register"
@ 
%%\subsubsection{Control flow}
%%There's just one PC on the Pentium.
<<x86 postexpander>>=
let pc_lhs = pc
let pc_rhs = pc
@ 
%%There are some hairy semantics attached to some Pentium jump
%%instructions, but I~think we can stick with the simple ones for now. 
<<x86 postexpander>>=
let br ~tgt = DG.Nop, R.store pc_lhs (tempval tgt) 32
let b  ~tgt = DG.Nop, R.store pc_lhs (Up.const tgt) 32
@ 
%%The call instructions have an extra effect: pushing the program counter.
<<x86 postexpander>>=
let effects = List.map Up.effect
let call  ~tgt =
  DG.Nop, R.par [R.store pc_lhs (Up.const tgt) 32 ; push' (fetch pc)]
let callr ~tgt =
  DG.Nop, R.par [R.store pc_lhs (tempval tgt)  32 ; push' (fetch pc)]
@ 
%%The [[cut to]] is our own little conspiracy:
%%it encapsulates two instructions, and the recognizer emits them as an
%%atomic pair. 
<<x86 postexpander>>=
let cut_to cut_args = F.fmach.T.cutto.T.embed () cut_args
@
<<x86 postexpander>>=
let return    = F.return

let interrupt n = (* very approximate *)
  let handler = R.app (R.opr "x86_idt_pc" []) [RO.unsigned 32 n] in
  R.par [store' pc handler; push' (R.fetch pc 32)]
let () = Rtlop.add_operator ~name:"x86_idt_pc" ~result_is_float:false
                            ([TY.fixbits 32] --> TY.fixbits 32)
let forbidden = interrupt 3
@
<<x86 postexpander>>=
let don't_touch_me _ = false
@
%%To implement comparisons, we define new operators that are private
%%to the $x$86 architecture. 
%%\begin{itemize}
%%\item [[x86_subflags]] returns what goes into the flags after a
%%[[sub]] or [[cmp]]
%%instruction.
%%\item [[x86_addflags]] returns what goes into the flags after a
%%[[add]] or [[adc]]
%%instruction.
%%\item [[x86_mulflags]] returns what goes into the flags after an
%%[[imul]] instruction.
%%\item [[x86_divflags]] returns what goes into the flags after an
%%[[idiv]] instruction.
%%\item
%%Operators [[x86_a]], [[x86_ae]], and so on, accept one argument, the
%%flags, and return a Boolean value that tells whether [[JA]], [[JAE]],
%%and so one, would jump.
%%\end{itemize}
<<x86 postexpander>>=
<<important functions on $x$86 operators>>
let cmp x y =
  R.store eflags (R.app (R.opr "x86_subflags" [32]) [tempval x; tempval y]) 32

let brtl cond tgt = R.guard cond (R.store pc_lhs tgt 32)
let bc_x86_cond x86opname = R.app (R.opr x86opname [32]) [R.fetch eflags 32]
let bc_x86 x86opname ~ifso ~ifnot = (brtl (bc_x86_cond x86opname), ifso, ifnot)

let bc x (opr, ws) y ~ifso ~ifnot =
  assert (ws =*= [32]);
  match opr with
  | "div_overflows" | "quot_overflows" ->
      let ov = Rewrite.div_overflows 32 (tempval x) (tempval y) in
      (*PX.Expand.cbranch DG.Test (DG.Nop, (ov, ifso, ifnot)))*)
      PX.Expand.cbranch' ov ifso ifnot
  | _ -> DG.Test (cmpfun opr x y, bc_x86 (cmpopr opr) ifso ifnot)
let bc_guard x (opr, ws) y =
  assert (ws =*= [32]);
  match opr with
  | "div_overflows" | "quot_overflows" ->
      (DG.Nop, R.app (R.opr opr ws) [tempval x; tempval y])
  | _ -> (cmpfun opr x y, bc_x86_cond (cmpopr opr))
let bc_of_guard (setup, guard) ~ifso ~ifnot =
  match Dn.exp guard with
  | RP.App ((("div_overflows" | "quot_overflows"), _), [x;y]) ->
      let ov = Rewrite.div_overflows 32 (Up.exp x) (Up.exp y) in
      PX.Expand.cbranch' ov ifso ifnot
  | _ -> DG.Test (setup, (brtl guard, ifso, ifnot))

let bnegate r = match Dn.rtl r with
| RP.Rtl [RP.App((cop, [32]), [RP.Fetch (flags, 32)]), RP.Store (pc, tgt, 32)]
  when RU.Eq.loc pc (Dn.loc pc_lhs) && RU.Eq.loc flags (Dn.loc eflags) ->
    Up.rtl (RP.Rtl [RP.App((cmpneg cop, [32]), [RP.Fetch (flags, 32)]),
                   RP.Store (pc, tgt, 32)])
| _ -> impossf "ill-formed x86 conditional branch"
@ 
%%The first ``important'' function converts a {\PAL} operator into the
%%corresponding Intel operator.
<<important functions on $x$86 operators>>=
let cmpopr = function
  | "eq"  -> "x86_e" 
  | "ne"  -> "x86_ne"
  | "lt"  -> "x86_l" 
  | "le"  -> "x86_le"
  | "gt"  -> "x86_g" 
  | "ge"  -> "x86_ge"
  | "ltu" -> "x86_b" 
  | "leu" -> "x86_be"
  | "gtu" -> "x86_a" 
  | "geu" -> "x86_ae"
  | "add_overflows"
  | "div_overflows"
  | "mul_overflows"
  | "mulu_overflows"
  | "sub_overflows" -> "x86_o"
  | _ -> impossf "non-comparison in x86 conditional branch"
@ 
%%The second important function negates an Intel operator.
<<important functions on $x$86 operators>>=
let cmpneg = function
  | "x86_ne" -> "x86_e"
  | "x86_e"  -> "x86_ne"
  | "x86_ge" -> "x86_l"
  | "x86_g"  -> "x86_le"
  | "x86_le" -> "x86_g"
  | "x86_l"  -> "x86_ge"
  | "x86_ae" -> "x86_b"
  | "x86_a"  -> "x86_be"
  | "x86_be" -> "x86_a"
  | "x86_b"  -> "x86_ae"
  | "x86_np" -> "x86_p"
  | "x86_p"  -> "x86_np"
  | "x86_nc" -> "x86_c"
  | "x86_c"  -> "x86_nc"
  | "x86_nz" -> "x86_z"
  | "x86_z"  -> "x86_nz"
  | "x86_o"  -> "x86_no"
  | "x86_no" -> "x86_o"
  | _ -> impossf "bad comparison in expanded x86 conditional branch"
@ 
%%The third important function returns the ``flag set'' function for an
%%operator. This is normally just [[cmp]], but in the case of overflow,
%%we need to emit arithmetic instructions to set the flags. 
%%
%%Division can't be done this way since a division overflow causes a
%%fault, so it is rewritten in the [[bc]] function above.
<<important functions on $x$86 operators>>=
let cmpfun =
  let set_flags op x y = binop (talloc 't' 32) (op, [32]) x y
  and cmp x y = rtl (subflags (tempval x) (tempval y) 32) in
  function
  | "eq"
  | "ne"
  | "lt"
  | "le"
  | "gt"
  | "ge"
  | "ltu"
  | "leu"
  | "gtu"
  | "geu"            -> cmp
  | "add_overflows"  -> set_flags "add"
  | "mul_overflows"  -> set_flags "mul"
  | "mulu_overflows" ->
      (fun x y ->
        if Register.eq Rg.eax y then
          extended_multiply "mulux" x
        else
          move Rg.eax x <:> extended_multiply "mulux" y)
  | "sub_overflows"  -> set_flags "sub"
  | ("div_overflows" | "quot_overflows" as o) ->
      impossf "operator %%%s not rewritten in x86 postexpander" o
  | o -> impossf "non-comparison %%%s in x86 conditional branch" o
@ 
\subsection{Stack operations}
%%
%%Regarding floating-point division, don't be fooled by wrongness in
%%the Pentium manual.
%%Full explanation is found in the recognizer.
<<x86 postexpander>>=
let opclass (op, _) =
  match op with
  | "i2f" | "f2f" | "f2f_implicit_round" | "f2i" | "fabs" | "fneg" | "fsqrt" ->
      PX.Stack(PX.LeftFirst, 1)
  | "fadd" | "fcmp" | "fdiv" | "fmul" | "fmulx" | "fsub"    
  | "feq" | "fge" | "fgt" | "fne"      
  | "fordered" | "funordered" -> PX.Stack(PX.RightFirst, 2)
  | "fle" | "flt"  -> PX.Stack(PX.LeftFirst, 2)  (* computed by swapping *)
  | _ ->
      PX.Register

let converts_stack_to_temp (op, _) = op =$= "f2i" || op =$= "f2f"
@ 
<<x86 postexpander>>=
let stspace = ('F', Rtl.Identity, Cell.of_size 3)
let fspace  = ('f', Rtl.Identity, Cell.of_size 80)
let st = temploc (stspace, 0, R.C 1)
let stval = R.fetch st 3
let freg_at a = R.mem R.none fspace (R.C 1) a
let streg = freg_at stval
let stadd = Rtlutil.addk 3 stval
let stsub n = RO.sub 3 stval (RO.unsigned 3 n)
let stregplus n = freg_at (stadd n)
let ffetch l = R.fetch l 80
@
<<x86 postexpander>>=
let st_pop_with f = (* rtl got by popping (f e), where e is top of floating-pt stack *)
  let top = ffetch streg in
  R.par [ f top; R.store st (stadd 1) 3 ]

let st_push e = (* effect of pushing e *)
  let next_st = stsub 1 in
  R.par [ R.store (freg_at next_st) e 80; R.store st next_st 3 ]

let stack_depth = 8
let stack_width = 80
let stack_top_proxy_reg = X86call.stack_top_proxy_reg
let stack_top_proxy = R.reg stack_top_proxy_reg
let is_stack_top_proxy = function
  | RP.Reg r -> Register.eq r stack_top_proxy_reg
  | _ -> false
@ 
<<x86 postexpander>>=
let push ~addr assn = impossf "push 80-bit float without conversion"

let store_pop ~addr assn = 
  let store regval = R.store (R.mem assn mspace (mcount 80) addr) regval 80 in
  rtl (st_pop_with store) (* bound to break *)

let push_cvt op w ~addr assn =
  assert (Cell.divides mcell w);
  let memval = R.fetch (R.mem assn mspace (mcount w) addr) w in
  let regval = R.app (Up.opr op) [memval; rounding_mode] in
  rtl (st_push regval)

let store_pop_cvt op w ~addr assn =
  assert (Cell.divides mcell w);
  let memval regval = R.app (Up.opr op) [regval; rounding_mode] in
  let store regval = R.store (R.mem assn mspace (mcount w) addr) (memval regval) w in
  rtl (st_pop_with store)
@ 
<<x86 postexpander>>=
module SlotTemp = struct
  let unimpf fmt = Printf.kprintf Impossible.unimp fmt
  let is _ = false
  let push src = impossf "push 80-bit float without conversion"
  let store_pop dst = unimpf "store-pop"
  let push_cvt op w src = unimpf "push-cvt"
  let store_pop_cvt op w dst = unimpf "store-pop-cvt"
  let push_cvt_rm op rm w src = unimpf "push-cvt"
  let store_pop_cvt_rm op rm w dst = unimpf "store-pop-cvt"
end
@
<<x86 postexpander>>=
let pushk _ = impossf "load 80-bit floating-point constant"
let pushk_cvt _ _ _ = Impossible.unimp "load floating-point constant"
@ 
<<x86 postexpander>>=
let stack_op op = match opclass op with
| PX.Register -> impossf "passed register operator to stack_op"
| PX.Stack(first, depth) -> (* by lucky accident, depth is arity *)
    let positions = Auxfuns.from 0 (depth-1) in
    let positions = match first with PX.RightFirst -> positions
                                   | PX.LeftFirst  -> List.rev positions in
    let argvals = List.map (fun n -> ffetch (stregplus n)) positions in
    let argvals = match op with
    | ("fadd"|"fsub"|"fdiv"|"fmul"|"f2f"|"f2i"|"i2f"), _ ->
        argvals @ [rounding_mode]
    | _ -> argvals in
    let result = R.app (Up.opr op) argvals in
    let next_st = stadd (depth-1) in
    if depth = 1 then
      rtl ( R.store (freg_at next_st) result 80)
    else
      rtl (R.par [ R.store (freg_at next_st) result 80; R.store st next_st 3])
@ 
%%All the instructions above use the hardware rounding mode.
%%Here are the explicit versions:
<<x86 postexpander>>=
let with_rm rm block = PX.with_hw ~hard:Rg.fpround ~soft:rm ~temp:(talloc 't' 32) block

let push_cvt_rm op rm w ~addr assn = with_rm rm (push_cvt op w ~addr assn)
let store_pop_cvt_rm op rm w ~addr assn =
  with_rm rm (store_pop_cvt op w ~addr assn)
let stack_op_rm op rm = with_rm rm (stack_op op)
@ 
%%The machine from hell:
%%\begin{itemize}
%%\item
%%The result of a floating point comparison goes in C0--C3,
%%which are respectively bits 8--10 and~11 of the FPU status word, where
%%bit~0 is the least significant bit.
%%\item
%%The \texttt{fstsw} instruction moves the FPU status word into AX,
%%which is the least significant 16~bits of EAX.
%%\item
%%The \texttt{sahf} instruction moves AH~into the flags:
%%\begin{quote}
%%\begin{tabular}{|llll|cccc|}
%%\hline
%%Flag& AH bit& FPU bit&FPU code&$\parallel$&$>$&$<$&$=$\\
%%\hline
%%SF&7&15& B (FPU busy)&&&&\\
%%ZF&6&14& C3& 1&0&0&1\\
%%AF&4&12& middle bit of TOP&&&&\\
%%PF&2&10& C2& 1& 0&0&0\\
%%CF&0&8& C0& 1&0&1&0\\
%%\hline
%%\end{tabular}
%%\end{quote}
%%Apparently it suffices to test ZF and CF.
%%\item
%%Therefore
%%\begin{quote}
%%\def\f#1{\mathord{\mbox{\uppercase{#1F}}}}
%%\begin{tabular}{lll}
%%\emph{Comparison}& \emph{Test}& \emph{Instruction}\\
%%Float $\parallel$& $\f p = 1$& JP\\
%%Float $\not\parallel$&$\f p = 0$& JNP\\
%%Float $<$& ugly & swap and compute $>$\\
%%Float $\le$& ugly & swap and compute $\ge$\\
%%Float $>$& $\f c = 0 \land \f z = 0$& JA \\
%%Float $\ge$& $\f c = 0$& JNC \\
%%Float $=$&$\f p = 0 \land \f z = 1$& ANDB AH,0x44; XORB AH, 0x40; JZ\\
%%Float $\ne$&$\lnot(\f p = 0 \land \f z = 1)$& ANDB AH,0x44; XORB AH, 0x40; JNZ\\
%%\end{tabular}
%%\end{quote}
%%\end{itemize}
<<x86 postexpander>>=
let fpcmpopr = function
  | "feq"  -> "x86_z"  (* AH is    zero when xor'ed with the flag pattern for feq *)
  | "fne"  -> "x86_nz" (* AH is nonzero when xor'ed with the flag pattern for feq *)
  | "flt" | "fgt" -> "x86_a"   (* flt is swapped fgt *)
  | "fle" | "fge" -> "x86_nc"  (* fle is swapped fge *)
  | "fordered"    -> "x86_np"
  | "funordered"  -> "x86_p"
  | _ -> impossf "floating-point comparison operator"

let bc_stack op ~ifso ~ifnot = match op with
| ("fordered"|"funordered"|"flt"|"fgt"|"fle"|"fge"|"feq"|"fne") as opname, [w] ->
    let positions = Auxfuns.from 0 1 in
    let argvals = List.map (fun n -> ffetch (stregplus n)) positions in
    let result = R.app (R.opr "x86_fcmp" [w]) argvals in
    let next_st = stadd 2 in
    let setcc = rtl (R.par [R.store Rg.fpcc result 2; R.store st next_st 3]) in
    let fstsw = rtl (R.store Rg.ax (R.fetch Rg.fpustatus 16) 16) in
    (match opname with
    | "feq" | "fne" ->
        let int8            = RO.unsigned 8 in
        let logic f l r     = rtl (R.par [f l r 8; logicflags r 8]) in
        let clear_extra     = logic R.store Rg.ah (RO._and 8 ah_val (int8 0x45)) in
        let xor_with_eq_pat = logic R.store Rg.ah (RO.xor  8 ah_val (int8 0x40)) in
        (* at this point, ZF = 0 iff the flags showed floating eq *)
       DG.Test (setcc <:> fstsw <:> clear_extra <:> xor_with_eq_pat,
                 bc_x86 (fpcmpopr opname) ifso ifnot)
    | _ ->
       DG.Test (setcc <:> fstsw <:> sahf, bc_x86 (fpcmpopr opname) ifso ifnot))
| _ -> impossf "strange operator in x86 bc_stack"
@ 
%%The general block copy is implemented with the ``[[x86_repmovs]]''
%%operator which translates to and [[rep movs]] in the recognizer. This
%%implementation assumes that the direction flag is set properly. The
%%emitted code could be improved by using [[movsw]] or [[movsd]] if the
%%number of bytes to copy is a multiple of 2 or 4 respectively. However,
%%I am not sure where this optimization should take place. -PG
%%HOW DO WE KNOW THE SIDE EFFECT ON THE FLOATING-POINT STACK IS SAFE?
<<x86 postexpander>>=
let i2f_64_80 = ("i2f", [64; 80])
let f2i_80_64 = ("f2i", [80; 64])
let block_copy ~dst dassn ~src sassn w =
  match w with
  | 16 | 8 ->
      let t = talloc 't' 32 in
      zxload t src w sassn <:> lostore dst t w dassn
  | 32 ->
      let t = talloc 't' 32 in
      load t src sassn <:> store dst t dassn
  | 64 ->
      push_cvt i2f_64_80 64 src sassn <:> store_pop_cvt f2i_80_64 64 dst dassn
  | n ->
      let bytes     = n / 8
      and const n   = RO.signed 32 n
      and sub r c   = RO.sub 32 (R.fetch r 32) c
      and byte_at r = R.mem R.none mspace (R.C 1) (R.fetch r 32) in
      let repmovsb =
        R.par [ R.store ecx (sub ecx (const 1)) 32
              ; R.store esi (sub esi (const bytes)) 32
              ; R.store edi (sub edi (const bytes)) 32
              ; R.store (byte_at esi) (R.fetch (byte_at edi) 8) 8
              ; R.guard (R.fetch ecx 32) (R.store pc (R.fetch pc 32) 32)
              ] in
      rtl (R.store esi src 32) <:>
      rtl (R.store edi dst 32) <:>
      rtl (R.store ecx (const bytes) 32) <:>
      rtl repmovsb
@
\subsection{Building the target}
%%With the postexpander in place, we can build a target.
%%There's no science here---just a lot of goo.
%%The [[Target.t]] abstraction could use some thought.
<<x86.ml>>=
module P = Post
module X = Expander.IntFloatAddr (Post)
(* expansion here once caused infinite loop *)
let spill_expand p r = [r]
let spill  p t l =
  spill_expand p (Automaton.store l (tempval t) (tempwidth t))
let reload p t l =
  spill_expand p (R.store (temploc t) (Automaton.fetch l (tempwidth t)) (tempwidth t))
@ 
%%Parts of the target record are reasonable.
%%Parts are lies.
%%Parts are baffling---why is character set characterized by the target?
<<x86.ml>>=
let downrtl = Dn.rtl
let uploc   = Up.loc
let upexp   = Up.exp

let ( *> ) = A.( *> )
let globals base = 
  let width w = if w <= 8 then 8 else if w <= 16 then 16 else Auxfuns.round_up_to 32 w in
  let align = function 8 -> 1 | 16 -> 2 | _ -> 4 in
  A.at mspace ~start:base 
    (A.widen width *> A.align_to align *>
     A.overflow ~growth:Memalloc.Up ~max_alignment:4)

let fmach = F.machine esp
let tgt =
  let spaces = [Spaces.m; Spaces.r; Spaces.t; Spaces.c] in
  { T.name = "x86"
  ; T.memspace = mspace
  ; T.max_unaligned_load = R.C 4
  (* basic metrics and spaces are OK *)
  ; T.byteorder   = P.byte_order  
  ; T.wordsize    = 32
  ; T.pointersize = 32
  ; T.vfp         = SS.vfp
  ; T.alignment = 1
  ; T.memsize   = Cell.to_width mcell (R.C 1)
  ; T.spaces = spaces
  ; T.reg_ix_map          = T.mk_reg_ix_map spaces
  ; T.distinct_addr_sp = false

  (* Does the Pentium really implement IEEE 754?  I think so *)
  ; T.float = Float.ieee754

  (* control flow is solid, except [[cutto]] is a lie *)
  ; T.machine = X.machine

  ; T.cc_specs         = A.init_cc
  ; T.cc_spec_to_auto  = X86call.cconv 
                           ~return_to:(fun ra -> pop_with (fun ra -> store' pc ra))
                           { T.embed = fmach.T.cutto.T.embed
                           ; T.project = fmach.T.cutto.T.project}

  ; T.is_instruction = X86rec.M.is_instruction
  ; T.tx_ast = (fun secs -> secs)
  ; T.capabilities =   {T.memory = [8;16;32]; T.block_copy = true;
                        T.itemps = [32]; T.ftemps = [32; 64];
                        T.iwiden = true; T.fwiden = true;
                        T.operators = List.map Up.opr [
                         "sx",      [ 8; 32]
                       ; "sx",      [ 1; 32]
                       ; "sx",      [16; 32]
                       ; "zx",      [ 1; 32]
                       ; "zx",      [ 8; 32]
                       ; "zx",      [16; 32]
                       ; "lobits",  [32;  1]
                       ; "lobits",  [32;  8]
                       ; "lobits",  [32; 16]
                       ; "lobits",  [32; 32]
                       ; "add",     [32]
                       ; "addc",    [32]
                       ; "and",     [32]
                       ; "borrow",  [32]
                       ; "carry",   [32]
                       ; "com",     [32]
                       ; "div",     [32]
                       ; "divu",    [32]
                       ; "false", []
                       ; "mod",     [32]
                       ; "modu",    [32]
                       ; "mul",     [32]
                       ; "mulx",    [32]
                       ; "mulux",   [32]
                       ; "neg",     [32]
                       ; "or",      [32]
                       ; "quot",    [32]
                       ; "popcnt",  [32]
                       ; "rem",     [32]
                       ; "rotl",    [32]
                       ; "rotr",    [32]
                       ; "shl",     [32]
                       ; "shra",    [32]
                       ; "shrl",    [32]
                       ; "sub",     [32]
                       ; "subb",    [32]
                       ; "true", []
                       ; "xor",     [32]
                       ; "eq",      [32]
                       ; "ge",      [32]
                       ; "geu",     [32]
                       ; "gt",      [32]
                       ; "gtu",     [32]
                       ; "le",      [32]
                       ; "leu",     [32]
                       ; "lt",      [32]
                       ; "ltu",     [32]
                       ; "ne",      [32]
                       ; "fabs", [32]
                       ; "fadd", [32]
                       ; "fdiv", [32]
                       ; "feq", [32]
                       ; "fge", [32]
                       ; "fgt", [32]
                       ; "fle", [32]
                       ; "flt", [32]
                       ; "fne", [32]
                       ; "fordered", [32]
                       ; "fmul", [32]
                       ; "fneg", [32]
                       ; "funordered", [32]
                       ; "fsqrt", [32]
                       ; "fsub", [32]
                       ; "fabs", [64]
                       ; "fadd", [64]
                       ; "fdiv", [64]
                       ; "feq", [64]
                       ; "fge", [64]
                       ; "fgt", [64]
                       ; "fle", [64]
                       ; "flt", [64]
                       ; "fne", [64]
                       ; "fordered", [64]
                       ; "fmul", [64]
                       ; "fneg", [64]
                       ; "funordered", [64]
                       ; "fsqrt", [64]
                       ; "fsub", [64]
                       ; "f2f", [32; 64]
                       ; "f2f", [64; 32]
                       ; "i2f", [32; 64]
                       ; "f2i", [64; 32]
                       ; "minf", [32]  (* from simplifier *)
                       ; "minf", [64]  (* from simplifier *)
                       ; "pinf", [32]  (* from simplifier *)
                       ; "pinf", [64]  (* from simplifier *)
                       ; "mzero", [32]  (* from simplifier *)
                       ; "mzero", [64]  (* from simplifier *)
                       ; "pzero", [32]  (* from simplifier *)
                       ; "pzero", [64]  (* from simplifier *)
                       ; "round_up", []  (* from simplifier *)
                       ; "round_down", []  (* from simplifier *)
                       ; "round_zero", []  (* from simplifier *)
                       ; "round_nearest", []  (* from simplifier *)
                       ; "NaN",   [23; 32]  (* from simplifier *)
                       ;  "add_overflows",  [32]
                       ;  "div_overflows",  [32]
                       ;  "mul_overflows",  [32]
                       ;  "mulu_overflows", [32]
                       ;  "quot_overflows", [32]
                       ;  "sub_overflows",  [32]
                       ; "not",     []
                       ; "bool",    []
                       ; "disjoin", []
                       ; "conjoin", []
                       ; "bit",     []
                   ]; T.litops = List.map Up.opr [
                        "NaN",   [52; 64]  (* from simplifier *)
                      ];
                        T.literals = [32;64]}

  (* global or hardware registers *)
  ; T.globals  = globals
  ; T.rounding_mode = rounding_model
  ; T.named_locs   = Strutil.assoc2map 
                     ["IEEE 754 rounding mode",    rounding_model]
  
  (* bogosity *)
  ; T.data_section = "data" (* NOT REALLY A PROPERTY OF THE TARGET MACHINE... *)
  ; T.charset = "latin1" (* THIS IS NONSENSE!! NOT A PROPERTY OF THE MACHINE?? *)
  } 
let target = PA.T tgt

type tgt  = Ast2ir.tgt
@ 
\subsection{Variable placement}
%%The machine accepts only three widths of floating-point variables: 32,
%%64, and 80~bits.
%%Any 80-bit value is seen as a float (this might be wrong in the case
%%of an 80-bit structure variable, so the decision should be revisited).
%%A~32-bit or 64-bit value would have to be suitably kinded to be seen
%%as a float.
%%Because floating-point registers are organized as a stack, we can't
%%use the registers effectively for variables, so floats go in memory.
%%
%%Any other value of width at most~32 goes into a temporary.
%%Larger values go straight to memory.
%%
%%FOR WARNINGS, IT MIGHT BE USEFUL TO INCLUDE A VARIABLE NAME SOMEWHERE,
%%SOMEHOW.
<<x86.ml>>=
let warning s = Printf.eprintf "backend warning: %s\n" s
let placevars = 
  let is_float      w kind _ = w = 80 || (kind=$="float" && (w = 32 || w = 64)) in
  let strange_float w kind   = w = 80 && Pervasives.(<>) kind "float" in
  let strange_int   w kind   = kind =$= "float" && not (is_float w kind ()) in
  let warn ~width:w ~alignment:a ~kind:k =
      if strange_float w k then
        warning "80-bit variable not kinded float but will go as float anyway"
      else if strange_int w k then
        warning
          (Printf.sprintf "%d-bit variable kinded float but will go as integer" w) in
  let mk_stage ~temps =
    A.choice
      [ is_float,               A.widen (Auxfuns.round_up_to ~multiple_of: 32); 
        (fun w k a -> w <= 32), A.widen (fun _ -> 32) *> temps 't';
        A.is_any,               A.widen (Auxfuns.round_up_to ~multiple_of: 8);
      ] in
  Placevar.mk_automaton ~warn ~vfp:tgt.T.vfp ~memspace:mspace mk_stage
@ 
\section{Tentative example Lua code}
%%
%%An automaton needs a ``base'' argument.
%%This argument must somehow be handled behind the scenes.
<<example Lua>>=
X86.Regs = { r = Register.space('r', 8, 32), f = Register.space('f', 8, 80),
             c = Register.space('c', 4, 32) }
Register.addnames(X86.Regs, X86.Regs.r, 
  { 'eax', 'ecx', 'edx', 'ebx', 'esp', 'ebp', 'esi', 'edi' })

X86.CC = Call.make(X86.target)

function X86.CC.results(rs) 
  local CC = X86.CC
  return 
      CC.choice ( 'float',  { CC.widen(CC.multiple_of(80))
                            , CC.widths(80, "x86 FP too wide")
                            , CC.useregs(X86.Regs.f[0], "internal error")
                            }
                , {},       { CC.widen(CC.multiple_of(32))
                            , CC.widths(32, "x86 return too wide")
                            , CC.useregs(rs, "internal error")
                            }
                )
end

function X86.setccs() 
  local vfp = Vfp.mk(32)
  local R = X86.Regs
  local eax, ecx, edx, ebx, esi, edi, ebp =
    R.eax, R.ecx, R.edx, R.ebx, R.esi, R.edi, R.ebp

  local allregs = {eax, ecx, edx, ebx, esi, edi, ebp}
  local volregs = {eax, ecx, edx}
  local nvregs  = {ebx, esi, edi, ebp}

  local CC = X86.CC
  local c_results   = CC.results(eax)
  local cmm_results = CC.results(volregs)
  local c_args    = { CC.widen(CC.multiple_of(32)), CC.overflow("up", 4)}
  local cut_args  =
    { CC.widen(CC.multiple_of(32))
    , CC.widths(32, "at most 32 bits in cut-to argument")
    , CC.useregs(allregs)
    , CC.overflow("up", 4)
    }
  local cmm_args = 
    { CC.widen(CC.multiple_of(32))
    , CC.useregs(allregs)
    , CC.overflow("up", 4)
    }
end  


@ 
\section{[[arch/x86/x86all.nw]]}
%%\documentclass{article} \usepackage{noweb} \usepackage{tabularx,array} 
%%\usepackage{hyperref} \usepackage{path} \usepackage[dvips]{graphicx}
%%\pagestyle{noweb}  \input{../config/macros.tex} 
%%\title{An overview of a Quick~{\PAL} Back End}
%%\author{Norman Ramsey}
%%\begin{document} 
%%
%%\providecommand\citeN[1]{\texttt{[#1]}}
%%
%%\maketitle
%%
%%This document provides an overview of a back end that uses the generic
%%code expander.
%%The parts that are especially worth reading are the expander overview
%%and postexpander interface (Sections
%%\ref{expander.sec}~and~\ref{expander.sec:Postexpander.S}) and 
%%the implmentations of the postexpander, recognizer, and target
%%(Sections
%%\ref{x86.sec}~and~\ref{x86rec.sec}). 
%%I've also include some related modules, some of which need review.
%%These modules include \texttt{Mflow}, \texttt{Target}, \texttt{Space},
%%and \texttt{Proc}. 
%%
%%\clearpage
%%\tableofcontents
%%
%%\newcommand\loadfile{\clearpage\input}
%%
%%\loadfile{ast2ir.inc}
%%\loadfile{target.inc}
%%\loadfile{cfg.inc}
%%\loadfile{expander.inc}
%%\loadfile{x86.inc}
%%\loadfile{x86rec.inc}
%%\loadfile{x86call.inc}
%%\loadfile{mflow.inc}
%%\loadfile{space.inc}
%%\loadfile{proc.inc}
%%
%%\end{document}
\section{[[arch/x86/x86asm.nw]]}
<<arch/x86/x86asm.ml>>=
<<x86asm.ml>>
@

<<arch/x86/x86asm.mli>>=
<<x86asm.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{X86 Assembler}
%%% ------------------------------------------------------------------ 
%%
%%This is an assembler that emits ``AT\&T'' style assembly language for
%%the $x$86 platform.
%%It implements the
%%[[Asm.assembler]] interface for assemblers in the {\qcc} compiler.
%%
%%
%%The assembler constructor receives the output channel for the assembler. 
<<x86asm.mli>>=
val make : 
  (('a, 'b, 'c, 'd) Proc.t -> 'cfg -> (Zipcfg.Rep.call -> unit) -> (Rtl.rtl -> unit) -> (string -> unit) -> unit) ->
  out_channel -> ('cfg * ('a, 'b, 'c, 'd) Proc.t) Asm.assembler
  (* pass Cfgutil.emit *)
@
%%
%%% ------------------------------------------------------------------ 
\subsection{Implementation}
%%% ------------------------------------------------------------------ 
%%
%%The implementation provides no surprises. It builds up an {\AST} and
%%emits it to [[stdout]] when the [[emit]] method is called.
%%
<<x86asm.ml>>=
module G  = Zipcfg
module GR = Zipcfg.Rep
module SM = Strutil.Map
<<utilities(x86asm.nw)>>
<<definitions(x86asm.nw)>>
let make emitter fd = new asm emitter fd
@
<<utilities(x86asm.nw)>>=
let fprintf = Printf.fprintf
@
%%
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{Classes for symbols}
%%% ------------------------------------------------------------------ 
%%
%%We include name mangling into [[Symbol.t]] class because all assembler
%%symbols like labels will be derived from them. Since the mangler is
%%stateful, we have to create it outside the individual instance of a
%%symbol. For now, we pass it from the assembler to here.
%%This mangler is very conservative, accepting only symbols built with
%%alphanumerics, underscores, and dots.
%%Most assemblers, including the Gnu assembler, will accept many more
%%characters.  But this way we don't have to enumerate the reserved
%%words (e.g., names of registers).
<<definitions(x86asm.nw)>>=
@ 
%%
<<definition of [[manglespec]] (for the name mangler)(x86asm.nw)>>=
let spec =
    let reserved = [] in        (* list reserved words here so we can avoid them *)
    let id = function
        | 'a'..'z'
        | '0'..'9'
        | 'A'..'Z'
        | '.'
        | '_'      -> true
        | _        -> false in
    let replace = function
        | x when id x -> x
        | _           -> '_' 
        in    
            { Mangle.preprocess = (fun x -> x)  
            ; Mangle.replace    = replace
            ; Mangle.reserved   = reserved
            ; Mangle.avoid      = (fun x -> x ^ "_")
            }
@
%%
%%% ------------------------------------------------------------------ 
%%\subsubsection{The assembler class}
%%% ------------------------------------------------------------------ 
%%
%%The assembler maintains mutable state for:
%%\begin{itemize}
%%\item the actual section the assembler is in,
%%\item exported symbols,
%%\item imported symbols,
%%\item completed sections in reverse order,
%%\item declarations in the current section in reverse order.
%%\end{itemize}
%%
%%Most methods append a declaration to the current section---[[append]]
%%provides a private method for this.
<<definitions(x86asm.nw)>>=
<<definition of [[manglespec]] (for the name mangler)(x86asm.nw)>>

class ['cfg, 'a, 'b, 'c, 'd] asm emitter fd
  : ['cfg * ('a, 'b, 'c, 'd) Proc.t] Asm.assembler = 
object (this)
    val         _fd       = fd
    val         _mangle  = (Mangle.mk spec)   
    val mutable _syms    = SM.empty 
    method globals _ = ()
    method private new_symbol name =
      let s = Symbol.with_mangler _mangle name in
      _syms <- SM.add name s _syms;
      s

    <<private assembly state(x86asm.nw)>>
    method private print l = List.iter (output_string _fd) l

    <<assembly methods(x86asm.nw)>>
end
@ 
%%Importing emits nothing; identifiers that are otherwise undefined are
%%automatically imported.
%%Maintaining the symbol table suffices.
<<assembly methods(x86asm.nw)>>=
method import s = this#new_symbol s
@
%%Exporting requires announcing as global.
<<assembly methods(x86asm.nw)>>=
method export s =
  let sym = this#new_symbol s in
  Printf.fprintf _fd ".globl %s\n" sym#mangled_text;
  sym
@ 
%%Locals also require no announcement.
<<assembly methods(x86asm.nw)>>=
method local s = this#new_symbol s
@ 
%%\emph{Common seems to be missing from the Q\PAL\ version.}
<<X86 assembly interface procedures>>=
static AsmSymbol asm_common(name, size, align, section) 
  char *name; int size; int align; char *section;
{ 
  AsmSymbol s;
  assert(section == NULL);
  if (solaris)
    print(".common %s,%d,%d\n", name, size, align);
  else
    print(".common %s,%d\n", name, size);
  s = asm_sym_insert(asmtab, name, ASM_COMMON);
  s->u.common.size  = size;
  s->u.common.align = align;
  return s;
}
@ 
%%The symbol bound to a label should be made local if it isn't already.
%%The name of this method should probably change to [[define_label]].
<<assembly methods(x86asm.nw)>>=
method label (s: Symbol.t) = fprintf _fd "%s:\n" s#mangled_text
@ 
%%Gcc does this:
<<X86 assembly interface procedures>>=
static void asm_function (name) char *name; { 
  print(".type %s,@function", name);
}
@ 
%%I have to keep track of the current section so I can implement
%%[[current_section]]. 
<<assembly methods(x86asm.nw)>>=
method section name =
  _section <- name;
  fprintf _fd ".section .%s\n" name
method current = _section
@ 
<<private assembly state(x86asm.nw)>>=
val mutable _section = "bogus section"
@ 
%%There was no [[.org]] in the SPARC, and we haven't bothered to learn
%%if $x$86 supports one.
<<assembly methods(x86asm.nw)>>=
method org n = Impossible.unimp "no .org in x86 assembler"
@ 
<<assembly methods(x86asm.nw)>>=
method align  n = 
  if n <> 1 then fprintf _fd ".align %d\n" n
method addloc n = 
  if n <> 0 then fprintf _fd ".skip %d\n"  n
@ 
%%
<<assembly methods(x86asm.nw)>>=
method zeroes (n:int) = fprintf _fd ".skip %d, 0\n" n
@ 
%%I use a dreadful hack to increase the likelihood of duplicating {\tt
%%lcc}'s 
%%assembly-language output for [[.word]] and [[.half]].
%%The x86 has no 8-byte emission unit, so I fake one, assuming little-endian order.
%%
<<assembly methods(x86asm.nw)>>=
method value (v:Bits.bits) = 
  let altfmt = Bits.to_hex_or_decimal_string ~declimit:256 in
  match Bits.width v with
  |  8 -> fprintf _fd ".byte %Ld\n" (Bits.S.to_int64 v)
  | 16 -> fprintf _fd ".word %s\n" (altfmt v)
  | 32 -> fprintf _fd ".long %s\n" (altfmt v)
  | 64 ->
      let i = Bits.U.to_int64 v in
      fprintf _fd ".long 0x%Lx\n" (Int64.logand i mask32);
      fprintf _fd ".long 0x%Lx\n" (Int64.shift_right_logical i 32)
  | w -> Impossible.unimp ("emission width " ^ string_of_int w ^ " in x86 assembler")
@ 
<<utilities(x86asm.nw)>>=
let mask32 = Int64.pred (Int64.shift_left Int64.one 32)
@ 
<<assembly methods(x86asm.nw)>>=
method addr a =
  match Reloc.if_bare a with
  | Some b -> this#value b
  | None -> let const bits = Printf.sprintf "0x%Lx" (Bits.U.to_int64 bits) in
            assert (Reloc.width a = 32);
            fprintf _fd ".long %s\n" (Asm.reloc_string const a)
@ 
<<assembly methods(x86asm.nw)>>=
method emit = ()
@
<<assembly methods(x86asm.nw)>>=
method comment s = fprintf _fd "/* %s */\n" s

method const (s: Symbol.t) (b:Bits.bits) = 
  fprintf _fd ".set %s, 0x%Lx" s#mangled_text (Bits.U.to_int64 b)
@ 
%%On the x86, we can represent a long jump using a 5-byte instruction.
%%A call instruction is 4 bytes long.
<<assembly methods(x86asm.nw)>>=
method longjmp_size () = 5
val    call_size       = 4
@ 
%%This almost certainly doesn't work---we must linearize the flow graph
%%and know to emit labels.
%%This code belongs elsewhere; assemblers shouldn't have to know more
%%than simple instructions. 
%%This means layering the abstraction with a common subtype for
%%instruction-based assemblers.
<<assembly methods(x86asm.nw)>>=
method private instruction rtl =
  output_string _fd "\t";
  output_string _fd (X86rec.M.to_asm rtl);
  output_string _fd "\n"
@
%%For a call node, we first emit the call.
%%Then, we emit jumps to any alternate returns.
<<assembly methods(x86asm.nw)>>=
method private call node =
  let longjmp edge = fprintf _fd "\t.byte 0xe9\n\t.long %s-.-%d\n"
                                    (_mangle (snd edge.G.node)) call_size in
  let rec output_altret_jumps n edges = (* emit n jumps *)
    if n > 0 then
      match edges with
      | edge :: edges -> (longjmp edge; output_altret_jumps (n-1) edges) 
      | [] -> Impossible.impossible "contedge count" in
  begin
    output_string _fd "\t";
    output_string _fd (X86rec.M.to_asm node.GR.cal_i);
    output_string _fd "\n";
    output_altret_jumps node.GR.cal_altrets (List.tl node.GR.cal_contedges);
  end

method cfg_instr (cfg,proc)  = 
    (* We have to emit a label/whatever for the procedure's 
       entry point. This is what symbol is for. Simply use this#label?  *)
    let symbol = proc.Proc.symbol in
    let label l = this#label (try SM.find l _syms with Not_found -> this#local l) in
    this#label symbol;
    (emitter proc cfg (this#call) (this#instruction) label : unit)
@ 
%%
<<unused utilities>>=
module Asm = X86rec.M
@
%%
\section{[[arch/x86/x86call.nw]]}
<<arch/x86/x86call.ml>>=
<<x86call.ml>>
@

<<arch/x86/x86call.mli>>=
<<x86call.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
\section{X86 calling conventions}
%%
%%My goal here is to avoid knowing anything about instructions.
%%The parameters represent the machine instructions to implement
%%[[return]] and [[cut to]].
<<x86call.mli>>=
val cconv :
  return_to:(Rtl.exp -> Rtl.rtl) ->
  (unit, Mflow.cut_args) Target.map ->
  string -> Automaton.cc_spec ->
  Call.t
@ 
%%To help ensure consistency with floating-point returns and the code
%%expander, we export the proxy register for the stack top.
<<x86call.mli>>=
val stack_top_proxy_reg : Register.t
@
%%
\section{Implementation of X86 calling conventions}
%%We use these abbreviations:
<<x86call.ml>>=
module A  = Automaton
module C  = Call
module R  = Rtl
module RO = Rewrite.Ops
module RP = Rtl.Private
module RS = Register.Set
module RU = Rtlutil
module T  = Target
let impossf fmt = Printf.kprintf Impossible.impossible fmt
@
%%And in Lua we need to:
<<x86 calling convention automata in Lua>>=
A                = Automaton
X86              = X86              or {}
X86.cc           = X86.cc           or {}
X86.cc["C"     ] = X86.cc["C"     ] or {}
X86.cc["C--"   ] = X86.cc["C--"   ] or {}
X86.cc["notail"] = X86.cc["notail"] or {}
X86.cc["gc"]     = X86.cc["gc"]     or {}
X86.cc["C-- thread"] = X86.cc["C-- thread"] or {}
@ 
%%\paragraph{General information}
%%Information on the C~calling convention is from the SYSV ABI, Third
%%Edition, ISBN 0-13-104670-5. 
%%
%%Values are aligned on 1-, 2-, or 4-byte boundaries.
%%Doubles and long doubles are 4-byte aligned; others have the alignment
%%of their size.
%%
%%Structures, arrays, and unions take the alignment of their most
%%aligned component.
%%
%%From Figure 3-14,
%%the return register is [[eax]], and the non-volatile
%%registers are [[ebp]], [[ebx]], [[esi]], and [[edi]].
%% 
%%\paragraph{X86 registers and their conventional uses}
%%Calling conventions refer to registers frequently, so it is
%%appropriate to be able to refer to them by name.
%%Lua code would do something similar.
<<x86call.ml>>=
let rspace = X86regs.rspace
let eax = X86regs.eax 
let ecx = X86regs.ecx 
let edx = X86regs.edx 
let ebx = X86regs.ebx 
let esp = X86regs.esp 
let ebp = X86regs.ebp 
let esi = X86regs.esi 
let edi = X86regs.edi 
let vfp = Vfp.mk 32
@ 
%%Here are the volatile and nonvolatile registers.
%%N.B. In position-independent code, [[ebx]] is reserved to point to the
%%global offset table.
%%Flags are also volatile, except that the direction flag must be set to
%%``forward'' (that is, zero) on entry and exit.
<<x86call.ml>>=
let volregs = RS.of_list [eax; ecx; edx]
let nvregs  = RS.of_list [ebx; esi; edi; ebp]
let allregs = RS.union volregs nvregs
@  
%%N.B. We omit all floating-point registers.
%%These are all volatile and available for allocation, although
%%[[%st(0)]] can used to return a floating-point result.
%%The ABI says that all these registers ``must be empty'' at entry and
%%exit (except that [[%st(0)]] need not be empty if it holds a result).
%%Understanding ``empty'' requires understanding $x$86 floating-point.
%% 
%%For now, we save a nonvolatile register anywhere.
%%Later, we may want mechanisms for saving them in conventional locations.
<<x86call.ml>>=
let saved_nvr temps =
  let t = Talloc.Multiple.loc temps 't' in fun r -> t (Register.width r)
@
%%And in Lua:
<<x86 calling convention automata in Lua>>=
X86.sp_align  = 4
X86.wordsize  = 32

function reg(sp, i, w)
   return { space = sp, cellsize = w, index = i, count = 1 }
end
function r(i) return reg("r", i, X86.wordsize) end

X86.eax = r(0)  X86.ecx = r(1)  X86.edx = r(2)
X86.ebx = r(3)  X86.esp = r(4)  X86.ebp = r(5)
X86.esi = r(6)  X86.edi = r(7)

X86.stack_top_proxy_reg = reg("\0", 0, 80)
X86.all_regs = {X86.eax, X86.ecx, X86.edx, X86.ebx, X86.esi, X86.edi, X86.ebp}
@ 
%%
%%\paragraph{Conventions governing the stack}
%%Page 3-10.  The stack is word-aligned.
%%The stack pointer points at the last item on the stack, \emph{not} at
%%an empty slot.
<<x86call.ml>>=
let sp       = R.reg esp
let spval    = R.fetch sp 32
let sp_align = 4
let growth   = Memalloc.Down
let bo       = R.LittleEndian
let memsize  = 8
@
%%\paragraph{Generic automaton support}
%%The two infix operators both represent the basic composition operator,
%%which must instantiated at two types:
%%stage followed by stage is stage,
%%and 
%%stage followed by implementation is implementation.
<<x86call.ml>>=
let ( *> ) = A.( *> )
@ 
%%We provide error parameters to automata.
<<x86call.ml>>=
let badwidth what w = impossf "Unsupported (rounded) width %d in x86 %s" w what
let imp _ = Impossible.impossible "grave miscalculation in automaton"
@ 
%%
%%\paragraph{Automata for passing values---C~convention}
%%
%%For results,
%%we cheat a bit: this convention is
%%strictly more permissive than~C, as it permits returning one integer
%%\emph{and} one floating result.
%%Any floating-point result is automatically widened to 80~bits, and
%%an integer result is widened to 32~bits.
<<x86call.ml>>=
let stack_top_proxy_reg = (('\000', Rtl.Identity, Cell.of_size 80), 0, Rtl.C 1)
@ 
<<x86 calling convention automata in Lua>>=
X86.cc["C"].results =
  A.choice { "float" , { A.widen(80)
                       , A.useregs { X86.stack_top_proxy_reg }
                       }
           , A.is_any, { A.widen(32, 'multiple')
                       , A.useregs { X86.eax, X86.edx }
                       }
           }
@
%%When passing procedure parameters, we put
%%earlier arguments in lower addresses, so even though the
%%stack grows down, the overflow block grows up.
%%An argument's size is increased, if necessary, to make it a multiple
%%of words.  The ABI specifies padding, but we'll use [[widen]] because
%%the machine is little-endian.
<<x86 calling convention automata in Lua>>=
X86.cc["C"].call =
  { A.widen(32, "multiple")
  , A.overflow { growth = "up", max_alignment = X86.sp_align }
  }
@ 
%%When passing cut-to parameters, we leave two registers open -- we must
%%so that we can use some registers for the cut instruction.
<<x86 calling convention automata in Lua>>=
X86.cc["C"].cutto =
  { A.widen(32)
  , A.useregs({X86.edx, X86.ebx, X86.esi, X86.edi, X86.ebp})
  , A.overflow { growth = "up", max_alignment = X86.sp_align }
  }
@ 
%%It's worth studying these automata to see what's likely to remain
%%unchanged across conventions:
%%memsize, byte order, stack alignment, and growth direction are good
%%candidates for defaulting.
%%
%%\paragraph{Automata for passing values---{\PAL}~convention}
%%N.B. YOU CANNOT AFFORD TO TAKE \emph{ALL} THE SCRATCH REGISTERS AWAY
%%FROM THE ALLOCATOR.
%%In fact, you should leave two registers available.
%%WE NEED A BETTER WAY OF DETECTING THIS ERROR OTHER THAN HAVING THE
%%REGISTER ALLOCATOR DUMP CORE.
<<x86 calling convention automata in Lua>>=
-- for now it appears that the C-- results automaton looks like the C one
-- with an overflow stage tagged on the end (although ecx was
-- commented out as an additional results register)
X86.cc["C--"].results = 
  { X86.cc["C"].results
  , A.overflow { growth = "down", max_alignment = X86.sp_align }
  } 

X86.cc["C--"].call =
  { A.widen(32, "multiple")
  , A.useregs { X86.eax }
  , A.overflow { growth = "up", max_alignment = X86.sp_align }
  }
-- all the calling conventions share the same cutto automaton specs.
X86.cc["C--"].cutto = X86.cc["C"].cutto
@
%%\paragraph{Automata for starting a thread}
%%
%%The thread convention may only receive parameters.
%%It may never return or cut.
<<x86 calling convention automata in Lua>>=
X86.cc["C-- thread"].results = { }
X86.cc["C-- thread"].call = A.overflow { growth = "up", max_alignment = 4 }
X86.cc["C-- thread"].cutto = { }
@
%%\paragraph{Automata for calling a garbage
%%collection---\texttt{gc}~convention} We want to make the call for the
%%caller as cheap as possible because a garbage collection will dominate
%%all efforts by the callee. This means: we are not using any register
%%such that the caller is free to use them as temporaries. There is one
%%exception: we use [[eax]] for return values because the GC routine
%%returns a pointer.
%%
<<x86 calling convention automata in Lua>>=
X86.cc["gc"].results = 
  { A.choice { "float" , { A.widen(80)
                         , A.useregs { X86.stack_top_proxy_reg }
                         }
             , A.is_any, { A.widen(32, 'multiple')
                         , A.useregs { X86.eax }
                         }
             }
  , A.overflow { growth = "down", max_alignment = X86.sp_align }
  } 

X86.cc["gc"].call =
  { A.widen(32, "multiple")
  , A.overflow { growth = "up", max_alignment = X86.sp_align }
  }

X86.cc["gc"].cutto =
  { A.widen(32)
  , A.overflow { growth = "up", max_alignment = X86.sp_align }
  }

X86.layout["gc"] = X86.layout["C"]
@
%%The code below can be used to override the above defintions when [[gc]]
%%is really a synonym for an existing convention.
<<x86 calling convention automata in Lua>>=
-- uncomment the next two lines to make "gc" a synonym for "C--"
-- X86.cc["gc"]                = X86.cc["C"]
-- X86.layout["gc"]            = X86.layout["C"]
@
%%
%%\paragraph{Managing the stack pointer and return address}
%%On entry, the stack pointer points to the return address.
%%This needs some aliasing info?
<<x86call.ml>>=
let mspace = ('m', bo, Cell.of_size 8)
let amem = R.mem (R.aligned 4) mspace (R.C 4)
let ra = amem vfp
let const x _ = x
@ 
%%The ``normal'' location for the stack pointer is at the bottom of the
%%frame. 
%%This line of code should be the \emph{only} place in the compiler
%%where the constant [["minus frame size"]] is mentioned.
%%Clients should use the base of the appropriate block in the calling convention.
<<x86call.ml>>=
let addk = RU.addk 32
let add  = RU.add  32
let std_sp_location = add vfp (R.late "minus frame size" 32)
@ 
%%TROUBLESOME STUFF: [[~autosp]] SEEMS TO BE USED ONLY TO SET
%%[[Call.insp]], WHICH ONE THINKS WOULD BE USEFUL ONLY FOR INCOMING GOO.
%%IT'S UNCLEAR WHETHER THE [[~postsp]] WOULD BE USED ONLY FOR OUTGOING
%%OR FOR BOTH.
%%
%%N.B. the call instruction moves the stack pointer.
<<functions to transform automata>>=
let autoAt = A.at mspace in
let call_actuals  =
  C.outgoing ~growth ~sp
   ~mkauto:(fun () -> Block.srelative vfp "out call parms" autoAt specs.A.call)
   ~autosp:(fun r -> Block.base r.A.overflow)
   ~postsp:(fun _ sp -> sp) in  (* was ~postsp:(fun _ -> std_sp_location) *)
let prolog  =
  let autosp = (fun _ -> vfp) in
  C.incoming ~growth ~sp
   ~mkauto:(fun () -> autoAt (addk vfp 4) specs.A.call)
   ~autosp
   ~postsp:(fun _ _ -> std_sp_location)
   ~insp:(fun a _ _ -> autosp a) in
   (* alternate: ~mkauto:Block.relative vfp "in call parms" specs.A.call *)
   (*   ~autosp:(fun r -> addk (Block.base r.A.overflow) (-4)) *)
@ 
<<functions to transform automata>>=
let c_call_results  =
  let autosp = (fun r -> Block.base r.A.overflow) in
  C.incoming ~growth ~sp
   ~mkauto:(fun () -> Block.srelative vfp "in ovfl results" autoAt specs.A.results)
   ~autosp
   ~postsp:(fun _ _ -> std_sp_location)     (* irrelevant? *)
   ~insp:(fun a _ _ -> autosp a) in
let c_returns_struct_call_results  =
  let autosp = (fun r -> addk (Block.base r.A.overflow) 4) in
  C.incoming ~growth ~sp
   ~mkauto:(fun () -> Block.srelative vfp "in ovfl results" autoAt specs.A.results)
   ~autosp
   ~postsp:(fun _ _ -> std_sp_location)     (* irrelevant? *)
   ~insp:(fun a _ _ -> autosp a) in
let cmm_call_results  =
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in ovfl results" autoAt specs.A.results)
    ~autosp:(fun r -> Block.base r.A.overflow)
    ~postsp:(fun _ _ -> std_sp_location)     (* irrelevant? *)
    ~insp:(fun a _ out_parm_block -> Block.base a.A.overflow) in
let epilog  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out ovfl results" autoAt specs.A.results)
    ~autosp:(fun r -> Block.base r.A.overflow)
    ~postsp:(fun _ r -> addk r (-4)) in
let epilog_returns_struct  =
  C.outgoing ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "out ovfl results" autoAt specs.A.results)
    ~autosp:(fun r -> addk (Block.base r.A.overflow) 4)
    ~postsp:(fun _ r -> addk r (-4)) in
@ 
%%We need an assertion here!
<<functions to transform automata>>=
let also_cuts_to =
  let autosp = (fun _ -> std_sp_location) in
  C.incoming ~growth ~sp
    ~mkauto:(fun () -> Block.srelative vfp "in cont parms" autoAt specs.A.cutto)
    ~autosp
    ~postsp:(fun _ _ -> std_sp_location)
    ~insp:(fun a _ _ -> autosp a) in

let cut_actuals cont  =
  C.outgoing ~growth ~sp
     ~mkauto:(fun () -> autoAt (Contn.ovblock_exp cont 8 32 sp_align) specs.A.cutto)
     ~autosp:(fun r -> spval)  (* should this be std_sp_location? *)
     ~postsp:(fun _ _ -> spval) in
@ 
%%\paragraph{Putting together the whole convention}
<<x86call.ml>>=
let rtn return_to k n ~ra =
  if k > n then impossf "Return <k/n> has k:%d > n:%d\n" k n
  else return_to ra

let conv ~preserved ~jump ~struct' ~altret name specs ~return_to cut =
  <<functions to transform automata>>
  let return k n ~ra =
    if altret then rtn return_to k n ~ra
    else if k = 0 & n = 0 then return_to ra
    else impossf "alternate return not allowed in %s calling convention" name in
  let nvregs  = preserved in
  let volregs = RS.diff allregs preserved in
  { C.name       = name
  ; C.overflow_alloc  = 
      { C.parameter_deallocator = if jump then C.Callee else C.Caller
      ; C.result_allocator      = C.Caller
      }
  ; C.call_parms = { C.in' = prolog;       C.out = call_actuals}
  ; C.cut_parms  = { C.in' = also_cuts_to; C.out = cut_actuals}
  ; C.results    = { C.in' = if jump then cmm_call_results
                             else if struct' then c_returns_struct_call_results
                             else c_call_results
                   ; C.out = if struct' then epilog_returns_struct else epilog}

  ; C.stack_growth     = Memalloc.Down
  ; C.stable_sp_loc    = std_sp_location
  ; C.jump_tgt_reg     = Rtl.reg edx
  ; C.replace_vfp      = Vfp.replace_with ~sp
  ; C.sp_align         = 4               (* alignment of stack pointer at call/cut *)
  ; C.ra_on_entry      = const (R.fetch ra 32)   (* where return address is on entry *)
  ; C.where_to_save_ra = (fun _ t -> Talloc.Multiple.loc t 't' 32)
      (* can't afford to leave ra where it is, even for the C convention,
         because we might make a tail call from C to C-- *)
  ; C.ra_on_exit       = 
        (let adjust = if struct' then 0 else -4 in
        (fun _ b _ -> amem (addk (Block.base b) adjust)))
  ; C.sp_on_unwind     = (fun exp -> RU.store sp exp)
  ; C.sp_on_jump       =
      if jump then (fun b _ -> RU.store sp (addk (Block.base b) (-4)))
      else (fun _ _ ->impossf "tail calls not supported by %s calling convention" name)
  ; C.pre_nvregs       = nvregs          (* registers preserved across calls *)
  ; C.volregs          = volregs         (* registers not preserved across calls *)
  ; C.saved_nvr        = saved_nvr
  ; C.return           = return
  } 
@ 
%%We could even just eliminate the automaton here and compute stuff directly.
<<x86call.ml>>=
let thread cut specs =
  let outgoing _ _ = impossf "called out using thread convention" in
  let nocut    _ _ = impossf "cut to or continuation using thread convention" in
  let noreturn _ _ = impossf "return using thread convention" in
  let incoming types formals = match types, formals with
    | [_; _], [_; _] ->
        let a = A.at mspace vfp specs.A.call in
        let crank effects' (w, k, al) formal =
          let l = A.allocate a w k al in
          A.store formal (A.fetch l w) w :: effects' in
        let shuffle = R.par (List.rev (List.fold_left2 crank [] types formals)) in
        let a = A.freeze a in
        let _autosp = vfp in
        let postsp = std_sp_location in
        let _insp   = vfp in
        let setsp  = RU.store sp postsp in
        { C.overflow = a.A.overflow
        ; C.insp     = (fun b -> RU.store sp vfp)
        ; C.regs     = a.A.regs_used
        ; C.shuffle  = shuffle
        ; C.post_sp  = R.guard (RO.ne 32 spval postsp) setsp
        ; C.pre_sp   = R.guard (RO.gt 32 spval postsp) setsp
        }
    | _ -> impossf "thread convention with %d parameters" (List.length formals) in
  let _nvregs  = RS.empty in
  let _volregs = allregs in
  { C.name  = "C-- thread"
  ; C.overflow_alloc  = 
      { C.parameter_deallocator = C.Caller
      ; C.result_allocator      = C.Caller
      }
  ; C.call_parms = { C.in' = incoming; C.out = outgoing}
  ; C.cut_parms  = { C.in' = nocut;    C.out = (fun _ -> nocut)}
  ; C.results    = { C.in' = noreturn; C.out = noreturn }
  ; C.stack_growth     = Memalloc.Down
  ; C.stable_sp_loc    = std_sp_location
  ; C.jump_tgt_reg     = Rtl.reg edx
  ; C.replace_vfp      = Vfp.replace_with ~sp
  ; C.sp_align         = 4               (* alignment of stack pointer at call/cut *)
  ; C.ra_on_entry      = const (R.fetch ra 32)   (* where return address is on entry *)
  ; C.where_to_save_ra = (fun _ t -> Talloc.Multiple.loc t 't' 32)
  ; C.ra_on_exit       = (fun _ _ t -> Talloc.Multiple.loc t 't' 32)
  ; C.sp_on_unwind     = (fun exp -> RU.store sp exp)
  ; C.sp_on_jump       = (fun _ _ ->impossf "tail calls not supported by C-- thread calling convention")
  ; C.pre_nvregs       = RS.empty        (* registers preserved across calls *)
  ; C.volregs          = allregs         (* registers not preserved across calls *)
  ; C.saved_nvr        = saved_nvr
  ; C.return           = (fun _ _ ~ra -> impossf "return in C-- thread convention")
  } 
@
%%And in Lua: register the new calling conventions. From the perspective
%%of automata, some calling conventions are identical. Despite this, they
%%may differ because of the additional OCaml code that defines the calling
%%convention.
<<x86 calling convention automata in Lua>>=
X86.cc["paranoid C"]        = X86.cc["C"]
X86.layout["paranoid C"]    = X86.layout["C"]
X86.cc["C returns struct"]  = X86.cc["C"]
X86.layout["C returns struct"]  = X86.layout["C"]

-- layout for "notail" is defined in luacompile.nw (uses the "C" layout)
X86.cc["notail"]            = X86.cc["C--"]

A.register_cc(Backend.x86.target,"C"     ,    X86.cc["C"     ])
A.register_cc(Backend.x86.target,"paranoid C",X86.cc["paranoid C"])
A.register_cc(Backend.x86.target,"C returns struct", X86.cc["C returns struct"])
A.register_cc(Backend.x86.target,"C'"    ,    X86.cc["C"     ])
A.register_cc(Backend.x86.target,"C--"   ,    X86.cc["C--"   ])
A.register_cc(Backend.x86.target,"C-- thread",    X86.cc["C-- thread"])
A.register_cc(Backend.x86.target,"notail",    X86.cc["notail"])
A.register_cc(Backend.x86.target,"gc",        X86.cc["gc"])
@ 
%%And finally, our lookup function; parameter [[preserved]] takes the list
%%of registers preserved accross calls, i.e. non-volatile or callee-saved
%%registers.
<<x86call.ml>>=
let cconv ~return_to cut ccname stage =
  let cconv = conv ~struct':false in
  let f =
    match ccname with
    | "C--"         -> cconv ~jump:true  ~altret:true  ~preserved:nvregs
    | "C-- thread"  -> (fun ccname stage ~return_to cut -> thread cut stage)
    | "lightweight" -> cconv ~jump:true  ~altret:true  ~preserved:nvregs
    | "notail"      -> cconv ~jump:false ~altret:true  ~preserved:nvregs
    | "paranoid C"  -> cconv ~jump:false ~altret:false ~preserved:RS.empty
    | "C"           -> cconv ~jump:false ~altret:false ~preserved:nvregs
    | "C returns struct" -> conv ~struct':true ~jump:false ~altret:false ~preserved:nvregs
    | "gc"          -> cconv ~jump:false ~altret:false 
                            ~preserved:(RS.of_list [ecx;edx;ebx;esi;edi;ebp])
    | _ -> Unsupported.calling_convention ccname
  in f ccname stage ~return_to cut
@
%%% ------------------------------------------------------------------ 
\subsection{Remove? Implementation using [[Callspec]]}
%%% ------------------------------------------------------------------ 
%%
%%Nobody seems to use the one convention [[C']] that is defined using this
%%code. Therefore I suggest to remove it. As a first step, this code is no
%%longer compiled.
%%
<<move before [[cconv]] to use again>>=
module CS = Callspec
let template = (* conservative spec *)
        { CS.name           = "callspec"    (* override this! *)
        ; CS.stack_growth   = Memalloc.Down
        ; CS.overflow       = CS.overflow C.Caller C.Caller
        ; CS.memspace       = mspace
        ; CS.sp             = esp
        ; CS.sp_align       = 4
        ; CS.all_regs       = RS.union volregs nvregs
        ; CS.nv_regs        = nvregs
        ; CS.save_nvr       = saved_nvr
        ; CS.ra             = (ra, CS.ReturnAddress.KeepInPlace)
        }

let cc auto return_to cut spec =
    let t    = CS.to_call cut (rtn return_to) auto spec            in  
    let jump = spec.CS.overflow.C.parameter_deallocator = C.Callee in 
        { t with (* fix what Callspec got wrong *)
            C.ra_on_exit = if jump 
                           then (fun _ b _ -> amem (addk (Block.base b) (-4)))
                           else (fun _ _ _ -> ra)
        ;   C.sp_on_unwind = (fun e -> RU.store sp e)
        }

let c' ccname auto ~return_to cut = cc auto return_to cut
    { template with CS.name = ccname }
@
%%\paragraph{Stack Layout} 
<<stack-frame layout functions>>=
X86 = X86 or {}
X86.layout = { creates='no late consts' }

function X86.layout.fn(dummy,proc) --- dispatch on cc name
  return X86.layout[Stack.ccname(proc)](dummy, proc)
end
@ 
<<stack-frame layout functions>>=
function X86.layout["C"](dummy,proc) --- really for a C convention only
    local blocks = Stack.blocks(proc)
    local slots
    -- proc, slots = Stack.replace_slot_temporaries(proc)
    blocks.ra          = Block.relative(blocks.vfp, "return address", 4, 4)

		-- We need to leave space for the return address on each tail call.
    local i, block = 1, blocks.oldblocks.callee[1]
    while block do
      local tailcall_ra =
        Block.relative(blocks.vfp, "tail call return address" .. i, 4, 4)
      blocks.oldblocks.callee[i] = Block.cat(32, {blocks.oldblocks.callee[i],
                                                  tailcall_ra}) 
      i = i + 1
      block = blocks.oldblocks.callee[i]
    end

    
    -- OVERLAP_HIGH CONSIDERED SUSPECT
    blocks.oldblocks.callee   = Block.overlap_high(32, blocks.oldblocks.callee)
    blocks.oldblocks.caller   = Block.overlap_low (32, blocks.oldblocks.caller)
    blocks.youngblocks.callee = Block.overlap_high(32, blocks.youngblocks.callee)
    blocks.youngblocks.caller = Block.overlap_low (32, blocks.youngblocks.caller)

    -- It is _vital_ that there be no padding inserted between the stack pointer
    -- and the overflow areas. If there is padding, then the callee has no hope
    -- of matching the caller's expectations.
    -- Hence, we concatenate these blocks before attaching them to the rest of the
    -- procedure, which might introduce strange alignment requirements.
    local pre_ra_tail = Block.cat(32, { blocks.ra, blocks.vfp })
    local ra_tail     = Block.overlap_high(32, {pre_ra_tail, blocks.oldblocks.callee})
    local old_end     = Block.cat(32, { blocks.oldblocks.caller
                                      , ra_tail
                                      })
    local young_end = Block.cat(32, { blocks.youngblocks.caller
                                    , blocks.sp
                                    , blocks.youngblocks.callee
                                    })
    local layout = 
                { old_end                       -- <-- high addresses
    --            , slots.confined
    --            , slots.unconfined
                , blocks.stackdata
                , blocks.continuations
                , blocks.spills
                , young_end                     -- <-- low addresses
                }
    if Debug.stack then
      write('======= using stack layout for C/notail =======\n')
      write('****** cc name = ', Stack.ccname(proc), '\n')
      Debug.showblocks (blocks, {'oldblocks', 'ra', 'vfp',
                                 'stackdata', 'continuations', 'spills',
                                 'youngblocks', 'sp'})
    end
    local block = Block.cat(32, layout)
    if Debug.stack then
      Debug.showblocks({frame=block}, {'frame'})
    end
    if Debug.framesize then Debug.showframesize(block,proc) end
        
    proc = Stack.freeze(proc,block)
    return proc, 1
end    

X86.layout["notail"] = X86.layout["C"]
@ 
%%
<<stack-frame layout functions>>=
function X86.layout["C--"](dummy,proc)
    local blocks = Stack.blocks(proc)

    if Debug.stack then
      write('======= using stack layout for C-- with tail calls =======\n')
      local i = 1
      local keys = { }
      while blocks.oldblocks.callee[i] do keys[i] = i; i = i + 1 end
      write('oldblocks.callee (before ra is added):\n')
      Debug.showblocks(blocks.oldblocks.callee, keys)
      write('................\n')
    end

    blocks.ra = Block.relative(blocks.vfp, "return address", 4, 4)

    -- first old block is always the incoming parms
    blocks.oldblocks.callee[1] =
                    Block.cat(32, {blocks.oldblocks.callee[1], blocks.ra, blocks.vfp})

		-- We need to leave space for the return address on each tail call.
    local i, block = 2, blocks.oldblocks.callee[2]
    while block do
      local tailcall_ra =
        Block.relative(blocks.vfp, "tail call return address" .. i, 4, 4)
      blocks.oldblocks.callee[i] = Block.cat(32, {blocks.oldblocks.callee[i],
                                                  tailcall_ra}) 
      i = i + 1
      block = blocks.oldblocks.callee[i]
    end

    blocks.oldblocks.caller    = Block.overlap_low (32, blocks.oldblocks.caller)
    blocks.oldblocks.callee    = Block.overlap_high(32, blocks.oldblocks.callee)
    blocks.youngblocks.caller  = Block.overlap_low (32, blocks.youngblocks.caller)
    blocks.youngblocks.callee  = Block.overlap_high(32, blocks.youngblocks.callee)

    -- It is _vital_ that there be no padding inserted between the stack pointer
    -- and the overflow areas. If there is padding, then the callee has no hope
    -- of matching the caller's expectations.
    -- Hence, we concatenate these blocks before attaching them to the rest of the
    -- procedure, which might introduce strange alignment requirements.
    local old_end   = Block.cat(32, { blocks.oldblocks.caller
                                    -- On return, the ra must end up here,
                                    -- immediately followed by the sp
                                    , blocks.oldblocks.callee
                                    -- , blocks.ra  -- joined to incoming block
                                    -- , blocks.vfp
                                    })
    local young_end = Block.cat(32, { blocks.youngblocks.caller
                                    , blocks.sp
                                    , blocks.youngblocks.callee
                                    })
    local layout = 
                { old_end               -- <-- high addresses
                , blocks.stackdata
                , blocks.continuations
                , blocks.spills
                , young_end             -- <-- low addresses
                }
    if Debug.stack then
      Debug.showblocks (blocks, {'oldblocks', 'ra', 'vfp',
                                 'stackdata', 'continuations', 'spills',
                                 'youngblocks', 'sp'})
    end
    local block = Block.cat(32, layout)
    if Debug.framesize then Debug.showframesize(block,proc) end
    proc = Stack.freeze(proc,block)
    return proc, 1
end    
@ 
%%
<<stack-frame layout functions>>=
function X86.layout["C-- thread"](dummy,proc)
    local blocks = Stack.blocks(proc)

    if Debug.stack then
      write('======= using stack layout for C-- thread =======\n')
      local i = 1
      local keys = { }
      while blocks.oldblocks.callee[i] do keys[i] = i; i = i + 1 end
      write('oldblocks.callee (before ra is added):\n')
      Debug.showblocks(blocks.oldblocks.callee, keys)
      write('................\n')
    end 

    -- first old block is always the incoming parms
    blocks.oldblocks.caller[1] =
                    Block.cat(32, {blocks.oldblocks.caller[1], blocks.vfp})
    blocks.oldblocks.caller    = Block.overlap_low (32, blocks.oldblocks.caller)
    blocks.oldblocks.callee    = Block.overlap_high(32, blocks.oldblocks.callee)
    blocks.youngblocks.caller  = Block.overlap_low (32, blocks.youngblocks.caller)
    blocks.youngblocks.callee  = Block.overlap_high(32, blocks.youngblocks.callee)
    local old_end   = Block.cat(32, { blocks.oldblocks.caller
                                    , blocks.oldblocks.callee
                                    })
    local young_end = Block.cat(32, { blocks.youngblocks.caller
                                    , blocks.sp
                                    , blocks.youngblocks.callee
                                    })
    local layout = 
                { old_end               -- <-- high addresses
                , blocks.stackdata
                , blocks.continuations
                , blocks.spills
                , young_end             -- <-- low addresses
                }
    if Debug.stack then
      Debug.showblocks (blocks, {'oldblocks', 'ra', 'vfp',
                                 'stackdata', 'continuations', 'spills',
                                 'youngblocks', 'sp'})
    end
    local block = Block.cat(32, layout)
    if Debug.framesize then Debug.showframesize(block,proc) end
    proc = Stack.freeze(proc,block)
    return proc, 1
end    
@ 
\section{[[arch/x86/x86rec.nw]]}
<<arch/x86/x86rec.mli>>=
<<x86rec.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{Intel $x$86 Recognizer} \label{x86rec.sec}
%%% ------------------------------------------------------------------ 
%%
%%%%Grades: B Subsystem Later
%%
%%This module provides functions that recognize an Intel
%%$x$86 RTL.
%%As an experiment, the recognizer is implemented using BURG rules.
%%If the instruction is recognized, it is coverable with small cost.
%%(Perhaps one day, the cost could be bytes of code.)
%%If it is not recognized, there is a catchall rule that recognizes
%%anything with cost~100 (I~hope).
%%
%%WARNING: THIS RECOGNIZER DOES NOT (YET) RECOGNIZE KILLS.
%%
%%The level of indirection is an artifact from the old days.
%%We keep it because in the future, the recognizer might want to take a
%%module parameter.
%%N.B.~A~recognizer takes two forms: one to say if we have an
%%instruction, and one to convert to an assembly-language string.
<<x86rec.mli>>=
module M : sig
  val is_instruction : Rtl.rtl -> bool
  val to_asm         : Rtl.rtl -> string
end
@ 
<<x86rec.mlb>>=
%head {: 
  <<modules(x86rec.nw)>>
  module M = struct
    <<code to precede the labeler(x86rec.nw)>>
:}
%tail {:
    <<code to follow the labeler(x86rec.nw)>>
  end (* of M *) 
:}

%term 
 <<names of types of terminals(x86rec.nw)>>

%type ah {: string :}
%type ahval {: string :}
%type any {: string :}
%type ax {: string :}
%type const {: string :}
%type const8 {: string :}
%type disp {: string :}
%type eaddr {: string :}
%type eaddri {: string :}
%type eaddrl {: string :}
%type eaddr_shr_k {: string * int :}
%type eax {: unit :}
%type ecx {: unit :}
%type edx {: unit :}
%type edx_eax {: unit :}
%type edi {: unit :}
%type eflags {: unit :}
%type eight {: unit :}
%type eip {: unit :}
%type esi {: unit :}
%type esp {: unit :}
%type espl {: unit :}
%type fiadd {: int * string :}
%type i2f_mem {: int * string :}
%type four {: unit :}
%type fpccl {: unit :}
%type fppop {: unit :}
%type fppop2 {: unit :}
%type fppush {: unit :}
%type fpsp {: unit :}
%type fpstack1 {: unit :}
%type fpstack1l {: unit :}
%type fpstacknext {: unit :}
%type fpstacknextl {: unit :}
%type fpstacktop {: unit :}
%type fpstacktopl {: unit :}
%type fpuctl  {: unit :}
%type fpuctll {: unit :}
%type fpustatus {: unit :}
%type fpustatusl {: unit :}
%type immed {: string :}
%type immed8 {: string :}
%type inst {: string :}
%type inthandler {: string :}
%type lconst {: string :}
%type lateconst {: string :}
%type mem {: string :}
%type meml {: string :}
%type minusfour {: unit :}
%type one3 {: unit :}
%type pop {: unit :}
%type push {: unit :}
%type reg {: string :}
%type reg8 {: string :}
%type regabcd {: string :}
%type regabcdl {: string :}
%type regl {: string :}
%type regl8 {: string :}
%type regpair {: string :}
%type regpairl {: string :}
%type shamt {: int :}
%type slot {: string :}
%type slotaddr {: string :}
%type stacknext {: unit :}
%type stacktop {: unit :}
%type target {: string :}
%type two3 {: unit :}
%type vfp {: unit :}
%type vfpl {: unit :}
%type zero {: unit :}


%%
<<rules(x86rec.nw)>>
@
%%A few abbreviations.
<<modules(x86rec.nw)>>=
open Nopoly

module Rg = X86regs
module RP = Rtl.Private
module RU = Rtlutil
module SS = Space.Standard32
module Dn = Rtl.Dn      (* Convert Dn  to private repr. *)
module Up = Rtl.Up      (* Convert Up    to abstract repr. *)

let ( =/  ) = RU.Eq.loc
let ( =// ) = RU.Eq.exp
@ 
%%At one time, we used this to try to debug a problem in our code.
<<unused code for logging the results of comparisons>>=
let fd = open_out "qc--.log"
let () = at_exit (fun () -> close_out fd)
let log eq s x y=
  let answer = eq x y in
  Printf.fprintf fd "%s %s %s\n" (s x) (if answer then "==" else "!=") (s y);
  answer

let ( =/  ) = log RU.Eq.loc (fun l -> RU.ToString.loc (Up.loc l))
let ( =// ) = log RU.Eq.exp (fun e -> RU.ToString.exp (Up.exp e))
@
%%If something goes wrong during recognition, we raise this exception.
%%It's different from merely ``unrecognized;'' it means something
%%happened that shouldn't have.
<<code to precede the labeler(x86rec.nw)>>=
exception Error of string
let error msg = raise (Error msg)
@
%%We should be using [[sprintf]] more.
<<code to precede the labeler(x86rec.nw)>>=
let sprintf = Printf.sprintf
let s       = Printf.sprintf
@ 
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Utilities}
%%% ------------------------------------------------------------------ 
%%
%%We've had some mystery problems; in particular, we've seen the integer
%%$-4$ get converted to 32~bits with its sign bit clear.
<<code to precede the labeler(x86rec.nw)>>=
let weirdb = Bits.S.of_int (-4) 32
let weird = Nativeint.to_string (Bits.S.to_native weirdb)
 (* let _ = List.iter prerr_string ["Weird integer is "; weird; "\n"] *)
let native' w b = 
  assert (Bits.width b = w);
  Nativeint.to_string (Bits.U.to_native b)
let native = native' 32
let cat = String.concat ""
let is_shamt b =
  let w = Bits.width b in
  w >= 5 && Bits.Ops.lt (Bits.zero w) b && Bits.Ops.lt b (Bits.U.of_int 32 w)
@   
%%The [[guard]] function turns a predicate into a cost.
<<code to precede the labeler(x86rec.nw)>>=
let infinity = Camlburg.inf_cost
let guard b = if b then 0 else infinity
@ 
%%The $x$86 uses a suffix to denote width.
<<code to precede the labeler(x86rec.nw)>>=
let suffix w = match w with
| 8  -> "b"
| 16 -> "w"
| 32 -> "l"
| _ -> Impossible.impossible "width in x86 not 8/16/32"
let fsuffix w = match w with
| 32 -> "s"
| 64 -> "l"
| 80 | 96 -> "t"
| _ -> Impossible.impossible "floating-point width in x86 not 32/64/80"
let fisuffix w = match w with
| 16 -> "w"
| 32 -> "l"
| 64 -> "q"
| _ -> Impossible.impossible "int to/from fpregs width in x86 not 16/32/64"
@
%%% ------------------------------------------------------------------ 
\subsection{Register names}
%%% ------------------------------------------------------------------ 
<<code to precede the labeler(x86rec.nw)>>=
let r8_names  = [| "%al"; "%cl"; "%dl"; "%bl"; "%ah"; "%ch"; "%dh"; "%bh" |]
let r16_names = [| "%ax"; "%cx"; "%dx"; "%bx"; "%sp"; "%bp"; "%si"; "%di" |]
let r32_names = [| "%eax"; "%ecx"; "%edx"; "%ebx"; "%esp"; "%ebp"; "%esi"; "%edi" |]
let reg_names w = match w with
| 8  -> r8_names
| 16 -> r16_names
| 32 -> r32_names
| _  -> Impossible.impossible "x86 register width not 8/16/32"
let regname w = Array.get (reg_names w)
let hregname r = sprintf "%%%ch" r.[2]  (* pass %eax, get back %ah *)
@ 
\subsection{Other machine info}
<<code to precede the labeler(x86rec.nw)>>=
let fpcc      = Dn.loc Rg.fpcc
let fpustatus = Dn.loc Rg.fpustatus
let fpuctl    = RP.Reg Rg.fpuctl
@     
%%
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Recognizer terminals, nonterminals, and constructors}
%%% ------------------------------------------------------------------ 
%%
%%In a {\burg} pattern, a name denotes either a polymorphic nonterminal
%%symbol or a monomorphic terminal symbol. 
%%We distinguish terminals from nonterminals by name, so we have to
%%announce the names of the nonterminals.
<<names of types of terminals(x86rec.nw)>>=
n w c bits symbol
@ 
%%Terminals [[n]] and [[w]] are an index and width; both are integers.
%%Terminal [[c]] is an integer count (of cells).
%%Terminal [[bits]] is a constant of types [[Bits.bits]]; terminal
%%[[symbol]] is a string.
%%
%%The recognizer uses these nonterminals:
%%\begin{quote}
%%\begin{tabularx}{\linewidth}{@{}>{\ttfamily}lX@{}}
%%    \emph{Nonterminal} & \emph{Meaning} \\ 
%%regl& A location corresponding to a register\\
%%regpairl& A location corresponding to a register pair\\
%%reg& A value corresponding to a register\\
%%regpair& A value corresponding to a register pair\\
%%meml& A location in memory\\
%%mem& A value in memory\\
%%eaddrl& An effective address in an lvalue context (a location to be
%%assigned to)\\
%%eaddr& An effective address in an rvalue context (a value)\\
%%lconst& A link-time constant\\
%%const& A compile-time constant\\
%%immed& An ``immediate'' constant expression as supported in the
%%assembly language\\
%%disp& An expression of the form $r+k$ or $k+r$ (displacement address)\\
%%inst& An instruction\\
%%any& Any tree (used for debugging)\\
%%\end{tabularx}
%%\end{quote}
%%
%%The recognizer uses constructors that correspond to RTL
%%operations, including [[Fetch]], [[Store]], [[Guarded]], and [[Par]].
%%It also uses a separate, eponymous constructor for each RTL operator.
%%Finally, it uses these special constructors:
%%\begin{quote}
%%\begin{tabularx}{\linewidth}{@{}>{\ttfamily}lX@{}}
%%    \emph{Nonterminal} & \emph{Meaning} \\ 
%%Withaflags& An operation that sets flags using the arithmetic flag
%%convention (with two operands)\\
%%Withlflags& An operation that sets flags using the logical flag
%%convention (with one result)\\
%%Setflags& Assign the flags\\
%%Llr& An effect of the form $L \mathrel{:=} L \oplus R$\\
%%Jcc& A jump conditional on the condition codes (flags)\\
%%Nop& A no-op\\
%%\end{tabularx}
%%\end{quote}
%%It's tempting to eliminate [[Fetch]], which would simplify rules, but
%%which would mean including widths on at least some operators.
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Recognizer Rules}
%%% ------------------------------------------------------------------ 
%%
%%\paragraph{Constants}
%%First, constants of various sorts.
%%The constant~4 plays a key role because it is used to adjust the stack
%%pointer. 
<<rules(x86rec.nw)>>=
lconst : Link(symbol, w) {: symbol#mangled_text :}
pic    : Diff(c1:lconst,c2:lconst) {: c1 ^ " - " ^ c2 :}
const  : Bits(b:bits)  [{: guard (Bits.width b = 32) :}]  {: native b :}
const8 : Bits(b:bits)  [{: guard (Bits.width b = 8) :}]  {: native' 8 b :}
shamt  : Bits(b:bits)  [{: guard (is_shamt b) :}] {: Bits.U.to_int b :}
four   : Bits(b:bits)
    [{: guard (Bits.width b > 3 && Bits.Ops.eq (Bits.U.of_int 4 (Bits.width b)) b) :}] {: () :}
minusfour : Bits(b:bits)
    [{: guard (Bits.width b > 3 && Bits.Ops.eq (Bits.S.of_int (-4) (Bits.width b)) b) :}] {: () :}
@ 
%%\paragraph{Locations and effective addresses}
%%Here are the basic locations.
%%We can't refer to just any location in memory, but only to one that is
%%accessible using the standard addressing modes.
%%We've omitted the indexed modes, which use two registers.
<<rules(x86rec.nw)>>=
bare_reg : Reg('r', n) {: n :}
regl : bare_reg {: regname 32 bare_reg :}
bare_regabcd : Reg('r', n) [{: guard (n < 4) :}] {: n :}
regabcdl : bare_regabcd {: regname 32 bare_regabcd :}
regl8: Slice(w, i:n, bare_regabcd) [{: guard (w=8) :}] {: Rg.regname8 i bare_regabcd :}
regl8H  : Slice(w, i:n, regabcdl) [{: guard (w=8 && i=8) :}] {: hregname regabcdl :}
regl_ecx: Reg('r', n) [{: guard (n=1) :}] {: () :}
regpairl : RegPair(reg1:regl,reg2:regl) {: reg2 :}
meml : Mem(reg,  c)   {: "(" ^ reg ^ ")" :}  -- indir
meml : Mem(disp, c)   {: disp :}
meml : Mem(lconst, c) {: lconst :}
disp : Add(reg, const) {:  const ^ "(" ^ reg ^ ")" :}
disp : Add(const, reg) {:  const ^ "(" ^ reg ^ ")" :}
@ 
<<rules(x86rec.nw)>>=
regl : Reg('t', n) {: sprintf "temporary register %d" n :}
vfpl : Reg('V', n) [{: guard (n=0) :}] {: () :}
esp  : Fetch(espl, w)  {: espl   :}
vfp  : Fetch(vfpl, w)  {: vfpl   :}
@ 
%%An effective address is either a register or a memory location.
<<rules(x86rec.nw)>>=
eaddrl : regl {: regl :}
eaddrl : meml {: meml :}
@
%%To get a value for any of these, we fetch.
%%We can also use a link-time constant as an effective address.
<<rules(x86rec.nw)>>=
reg     : Fetch(regl    , w) {: regl     :}
regabcd : Fetch(regabcdl, w) {: regabcdl :}
reg8    : Lobits(Fetch(regl8, w), nw:w) [{: guard (nw=8) :}] {: regl8     :}
reg8H   : BitExtract(eight, regabcd, w) [{: guard (w=8) :}] {: hregname regabcd :}
reg8H   : Fetch(regl8H, w) {: regl8H :}
reg_cl  : Lobits(Fetch(regl_ecx, w), nw:w) [{: guard (nw=8) :}] {: () :}
reg_cll : Slice(sw:w, n, regl_ecx) [{: guard (sw=8 && n=0) :}] {: () :}
reg_cl  : Fetch(reg_cll, w)  {: () :}
regpair : Fetch(regpairl, w) {: regpairl :}
mem     : Fetch(meml    , w) {: meml     :}
eaddr   : Fetch(eaddrl  , w) {: eaddrl   :}
eaddri  : eaddr              {: eaddr    :}
eaddri  : immed              {: immed    :}
-- eaddr : lconst {: lconst :} -- absolute addressing mode
-- indexed modes to come
@ 
%%I'm not at all sure about the rules for immediate constants, but here
%%goes a guess.  One problem is that I think the assembly-language
%%syntax for an immediate address depends on the context in which it
%%appears. 
<<rules(x86rec.nw)>>=
-- immed : lconst {: lconst :}
immed  : const   {: "$" ^ const :}
immed8 : const8  {: "$" ^ const8 :}
-- immed : Add(lconst, const) {:  lconst ^ "+" ^ const :}
-- immed : Add(const, lconst) {:  lconst ^ "+" ^ const :}
@ 
%%\paragraph{RTLs to recognize before code generation}
<<rules(x86rec.nw)>>=
slotaddr : Add(vfp, const) {: sprintf "%%vfp+%s" const :}
slotaddr : vfp {: "%vfp" :}

const: Late(string, w) {: string :}
const: Add(l:const, r:const) {: sprintf "%s+%s" l r :}

inst: Guarded(Cmp(string, esp, slotaddr), Store(espl, s2:slotaddr, w)) 
         {: "adjust %esp" :}
inst: Store(dst:regl, slotaddr, w) {: sprintf "%s := %s" dst slotaddr :}

slot : Mem(slotaddr, c) {: slotaddr :}

inst: Store(slot, Lobits(reg, lw:w), nw:w)
  {: s "bits%d[%s] := %%lobits%d(%s)" nw slot nw reg :}

-- inst: Store(dst:eaddrl, lateconst, w) {: sprintf "%s := %s" dst lateconst :}

disp : Add(vfp, const) {:  const ^ "(%vfp)" :}
disp : Add(const, vfp) {:  const ^ "(%vfp)" :}
@ 
%%
%%\paragraph{Data movement}
%%Move, load, and store instructions.
%%Because the machine can do eaddr/reg
%%and reg/eaddr but not eaddr/eaddr, there are two varieties of each.
<<rules(x86rec.nw)>>=
-- pic code
inst : Store(dst:eaddrl, pic, w)
  {: s "mov%s %s,%s" (suffix w) pic dst :}

inst : Store(dst:eaddrl, src:immed, w) 
  {: s "mov%s %s,%s" (suffix w) src dst :}

inst : Store(dst:regl, src:lconst, w) 
  {: s "lea%s %s,%s" (suffix w) src dst :}

-- straight load/store/move
inst : Store(dst:eaddrl, src:reg, w) 
  {: s "mov%s %s,%s" (suffix w) src dst :}

inst : Store(dst:regl, src:eaddri, w) 
  {: s "mov%s %s,%s" (suffix w) src dst :}

-- sign extension
inst : Store(dst:eaddrl, Sx(Fetch(src:regl, nw:w)), w)
  {: s "movs%s%s %s,%s" (suffix nw) (suffix w) src dst :}

inst : Store(dst:regl, Sx(Fetch(src:eaddrl, nw:w)), w)
  {: s "movs%s%s %s,%s" (suffix nw) (suffix w) src dst :}

-- zero extension
inst : Store(dst:eaddrl, Zx(Fetch(src:regl, nw:w)), w)
  {: s "movz%s%s %s,%s" (suffix nw) (suffix w) src dst :}

inst : Store(dst:regl, Zx(Fetch(src:eaddrl, nw:w)), w)
  {: s "movz%s%s %s,%s" (suffix nw) (suffix w) src dst :}

-- moving low bits (relies on proper name of source)
inst : Store(dst:eaddrl, Lobits(Fetch(Reg('r', n), fw:w), lw:w), nw:w)
  {: s "mov%s %s,%s" (suffix nw) (regname nw n) dst :}

inst : Store(dst:regl, Lobits(src:mem, sw:w), nw:w)
  {: s "mov%s %s,%s" (suffix nw) src dst :}

-- block copy
inst : Par(Llr(ecx1:ecx, "sub", n0:const, w1:w),
       Par(Llr(esi1:esi, "sub", n1:const, w2:w),
       Par(Llr(edi1:edi, "sub", n2:const, w3:w),
       Par(Store(Mem(Fetch(esi2:esi, w4:w), c11:c),
                 Fetch(Mem(Fetch(edi2:edi, w5:w), c6:c),w7:w),w8:w),
           Guarded(Fetch(ecx2:ecx,w9:w),Goto(Fetch(eip, w10:w)))
          ))))
  {: "rep movsb" :}

@ 
%%\paragraph{Simple arithmetic}
%%These are the well-behaved instructions, which don't require hairy
%%special registers.
<<rules(x86rec.nw)>>=
inst : Store(dst:regl, disp, w) [{:guard (w = 32):}]
  {: s "leal %s, %s" disp dst :}

inst : Llr(dst:regl, "add", const, w) [{:guard (w=32):}]
  {: s "leal %s(%s), %s" const dst dst :}

inst : Withcarryflags(dst:eaddrl, "addc", src:reg, w, "x86_adcflags")
  {: s "adc%s %s,%s" (suffix w) src dst :}

inst : Withcarryflags(dst:eaddrl, "subb", src:reg, w, "x86_sbbflags")
  {: s "sbb%s %s,%s" (suffix w) src dst :}

inst : Withcarryzero(dst:eaddrl, "addc", src:reg, w, "x86_adcflags")
  {: s "add%s %s,%s" (suffix w) src dst :}

inst : Withaflags(dst:eaddrl, "add", src:reg, w, "x86_addflags")
  {: s "add%s %s,%s" (suffix w) src dst :}

inst : Withaflags(dst:regl, "add", src:eaddri, w, "x86_addflags")
  {: s "add%s %s,%s" (suffix w) src dst :}

inst : Withaflags(dst:eaddrl, "sub", src:reg, w, "x86_subflags")
  {: s "sub%s %s,%s" (suffix w) src dst :}

inst : Withaflags(dst:regl, "sub", src:eaddri, w, "x86_subflags")
  {: s "sub%s %s,%s" (suffix w) src dst :}

inst : Withaflagsunary("neg", dst:eaddrl, w, "x86_negflags")
  {: s "neg%s %s" (suffix w) dst :}

inst : Withaflags(dst:eaddrl, "mul", src:reg, w, "x86_mulflags")
  {: s "imul %s %s, %s" (suffix w) src dst :}

inst : Withaflags(dst:regl, "mul", src:eaddri, w, "x86_mulflags")
  {: s "imul%s %s,%s" (suffix w) src dst :}

inst : Pairdestwithflags(edx, eax, Fetch(eax,w), "mulx", eaddr, "x86_mulxflags")
  {: s "imull %s" eaddr :}

inst : Pairdestwithflags(edx, eax, Fetch(eax,w), "mulux", eaddr, "x86_muluxflags")
  {: s "mull %s" eaddr :}

edx_eax : RegPair(edx, eax) {: () :}

inst : Withundefflags(dst:edx_eax, "quot", "rem", src:eaddr, w)
  {: sprintf "idiv%s %s, %%eax" (suffix w) src :}

-- suffix w looks wrong
inst : Withundefflags(dst:edx_eax, "divu", "modu", src:eaddr, w)
  {: sprintf "div%s %s, %%eax" (suffix w) src :}

inst : Withaflags(dst:regl, "shl", Zx(reg_cl), w, "x86_shlflags")
  {: sprintf "shl%s %%cl, %s" (suffix w) dst :}

inst : Withaflags(dst:regl, "shra", Zx(reg_cl), w, "x86_shraflags")
  {: sprintf "sar%s %%cl, %s" (suffix w) dst :}

inst : Withaflags(dst:regl, "shrl", Zx(reg_cl), w, "x86_shrlflags")
  {: sprintf "shr%s %%cl, %s" (suffix w) dst :}

inst : Withaflags(dst:regl, "rotl", Zx(reg_cl), w, "x86_rotlflags")
  {: sprintf "rol%s %%cl, %s" (suffix w) dst :}

inst : Withaflags(dst:regl, "rotr", Zx(reg_cl), w, "x86_rotrflags")
  {: sprintf "ror%s %%cl, %s" (suffix w) dst :}

inst : Llr(dst:regl, "shl", immed, w)
  {: sprintf "shl%s %s, %s" (suffix w) immed dst :}

inst : Llr(dst:regl, "shra", immed, w)
  {: sprintf "sar%s %s, %s" (suffix w) immed dst :}

inst : Llr(dst:regl, "shrl", immed, w)
  {: sprintf "shr%s %s, %s" (suffix w) immed dst :}

@ 
%%N.B. The crazy AT\&T assembly language does comparisons backward.
<<rules(x86rec.nw)>>=
inst : Setflags(X86_subflags(l:eaddr, r:reg))
  {: s "cmp%s %s,%s" (suffix 32) r l :} -- POSSIBLE BUG IN WIDTH
inst : Setflags(X86_subflags(l:reg, r:eaddri))
  {: s "cmp%s %s,%s" (suffix 32) r l :} -- POSSIBLE BUG IN WIDTH

inst : UnaryInPlace(dst:regl, "com", w) {: s "not%s %s" (suffix w) dst :} 

inst : Withlflags(dst:eaddrl, logical:string, src:reg, w, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: s "%s%s %s,%s" logical (suffix w) src dst :}

inst : Withlflags(dst:regl, logical:string, src:eaddri, w, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: s "%s%s %s,%s" logical (suffix w) src dst :}

inst : Withlflags(dst:regl8H, logical:string, src:immed8, w, "x86_logicflags")
  [{: (guard (w=8)) + match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: sprintf "%s%s %s,%s" logical (suffix 8)  src dst :}

inst : Withlflags8H(dst:regabcdl, logical:string, src:reg8H, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: sprintf "%s%s %s,%s" logical (suffix 8)  src (hregname dst) :}

inst : Withlflags8H(dst:regabcdl, logical:string, src:immed8, "x86_logicflags")
  [{: match logical with "and" | "or" | "xor" -> 0 | _ -> infinity :}]
  {: sprintf "%s%s %s,%s" logical (suffix 8) src (hregname dst) :}
@ 
%%\paragraph{Arithmetic with the carry flag}
<<rules(x86rec.nw)>>=
eflags : Reg('c', n) [{: guard (n = SS.indices.SS.cc):}] {: () :}
eaddrbit0 : Lobits(eaddr, w) [{: guard (w=1) :}] {: eaddr :}
eaddrbitk : Lobits(eaddr_shr_k, w) [{: guard (w=1) :}] {: eaddr_shr_k :}
eaddr_shr_k : Shift("shra", eaddr, shamt)    {: eaddr, shamt :}
eaddr_shr_k : Shift("shrl", eaddr, shamt)    {: eaddr, shamt :}
inst : Llr(eflags, "x86_setcarry", eaddrbit0, w)
  {: sprintf "bt%s $0,%s" (suffix 32) eaddrbit0 :}

inst : Llr(eflags, "x86_setcarry", zero, w) {: "clc" :}
@ 
%$
%%\paragraph{Control flow}
%%The simple jumps are easy.
<<rules(x86rec.nw)>>=
target : Fetch(eaddrl, w) {: "*" ^ eaddrl :}
target : lconst {: lconst :} 
inst : Goto(target)            {: "jmp " ^ target :}
inst : Jcc(cc:string, lconst) {: "j" ^ cc ^ " " ^ lconst :}
@ 
%%Call, [[cut to]],  and return require manipulating the stack pointer
%%[[esp]] and 
%%program counter [[eip]].
<<rules(x86rec.nw)>>=
espl : Reg('r', n) [{: guard (n = 4):}]                {: () :}
eip  : Reg('c', n) [{: guard (n = SS.indices.SS.pc):}] {: () :}
@ 
%%The [[cut to]] is supposed to look atomic, but it is a sequence of two
%%instructions. 
<<rules(x86rec.nw)>>=
inst : Par(Goto(target),Store(espl,frame:eaddri,w))
  {: s "movl %s, %%esp; jmp %s" frame target :}
@ 
%%There are two ways to recognize a pop, depending on whether the ML
%%code sees it as an $L \mathrel{:=} L \oplus R$ instruction.
<<rules(x86rec.nw)>>=
pop  : Store(espl, Add(esp, four), sw:w) {: () :}
pop  :  Llr(espl, "add", four, w) {: () :}
push : Llr(espl, "sub", four, w) {: () :}
push : Llr(espl, "add", minusfour, w) {: () :}
stacktop  : Mem(esp, mc:c)            [{:guard (mc = 4):}] {: () :}
stacknext : Mem(Sub(esp, four), mc:c) [{:guard (mc = 4):}] {: () :}
inst : Par(Goto(Fetch(stacktop, w)),pop) 
        {: "ret" :}
inst : Par(Goto(eaddr),Par(Store(stacknext, Fetch(eip, x:w), y:w), push))
        {: "call *" ^ eaddr :}
inst : Par(Goto(lconst),Par(Store(stacknext, Fetch(eip, x:w), y:w), push))
        {: "call " ^ lconst :}
@ 
%%An interrupt is forbidden.
<<rules(x86rec.nw)>>=
inst : Par(Goto(inthandler),Par(Store(stacknext, Fetch(eip, x:w), y:w), push))
        {: "int " ^ inthandler :}

inthandler : X86IdtPc(immed) {: immed :}
@ 
%%\paragraph{Floating point}
<<rules(x86rec.nw)>>=
one3  : Bits(b:bits)
    [{: guard (Bits.width b = 3 && Bits.Ops.eq (Bits.U.of_int 1 3) b) :}]
    {: () :}
two3  : Bits(b:bits)
    [{: guard (Bits.width b = 3 && Bits.Ops.eq (Bits.U.of_int 2 3) b) :}]
    {: () :}
zero  : Bits(b:bits) [{: guard (Bits.Ops.eq (Bits.U.of_int 0 (Bits.width b)) b) :}]
             {: () :}
eight : Bits(b:bits) [{: guard (Bits.width b > 3 &&
                                Bits.Ops.eq (Bits.U.of_int 8 (Bits.width b)) b) :}]
             {: () :}
fpsp   : Reg('F', n) [{: guard (n = 0):}] {: () :}
fppop  : Llr(fpsp, "add", one3, w) {: () :}
fppop2 : Llr(fpsp, "add", two3, w) {: () :}
fppush : Llr(fpsp, "sub", one3, w) {: () :}
@ 
<<rules(x86rec.nw)>>=
fpstacktopl  : Fpreg(Fetch(fpsp, w))            {: () :}
fpstacktopl  : Fpreg(Add(Fetch(fpsp, w), zero)) {: () :}
fpstack1l    : Fpreg(Add(Fetch(fpsp, w), one3)) {: () :}
fpstacknextl : Fpreg(Sub(Fetch(fpsp, w), one3)) {: () :}

fpstacktop  : Fetch(fpstacktopl,  w) [{: guard (w=80) :}] {: fpstacktopl :}
fpstack1    : Fetch(fpstack1l,    w) [{: guard (w=80) :}] {: fpstack1l :}
fpstacknext : Fetch(fpstacknextl, w) [{: guard (w=80) :}] {: fpstacknextl :}
@ 
<<rules(x86rec.nw)>>=
inst : Par(Store(fpstacknextl, F2f(s:w, d:w, mem), w2:w), fppush)
  {: sprintf "fld%s %s" (fsuffix s) mem :}
inst : Par(Store(dst:meml, F2f(s:w, d:w, fpstacktop), w2:w), fppop)
  {: sprintf "fstp%s %s" (fsuffix d) dst :}
@ 
<<rules(x86rec.nw)>>=
inst : Par(Store(fpstacknextl, I2f(s:w, d:w, mem), w2:w), fppush)
  {: sprintf "fild%s %s" (fisuffix s) mem :}
inst : Par(Store(dst:meml, F2i(s:w, d:w, fpstacktop), w2:w), fppop)
  {: sprintf "fistp%s %s" (fisuffix d) dst :}
@ 
%%Some editions of the Pentium manual have a dangerously misleading bug
%%regarding FDIV and FDIVR.
%%For FDIV, 
%%the informal English says that ``The division instructions divide the
%%stack top by the other operand and return the quotient to the
%%destination.''
%%The informal English is correct; i.e., it is consistent with results
%%obtained from generating real code.
%%But the manual also says, in a box at the top,
%%\begin{quote}
%%Replace $ST(1)$ with $ST(1) \div ST$\qquad \textbf{Wrong!}
%%\end{quote}
%%and this box is wrong (arguments are in the opposite order).
%%A~similar problem obtains for FDIVR.
<<rules(x86rec.nw)>>=
inst : Par(Store(fpstack1l, Fadd(fpstacktop, fpstack1), w), fppop)
  {: "faddp" :}
inst : Par(Store(fpstack1l, Fsub(fpstacktop, fpstack1), w), fppop)
  {: "fsubp" :}
inst : Par(Store(fpstack1l, Fdiv(fpstacktop, fpstack1), w), fppop)
  {: "fdivp" :}
inst : Par(Store(fpstack1l, Fdiv(fpstack1, fpstacktop), w), fppop)
  {: "fdivrp" :}
inst : Par(Store(fpstack1l, Fmul(fpstacktop, fpstack1), w), fppop)
  {: "fmulp" :}
@ 
<<rules(x86rec.nw)>>=
inst : UnaryInPlace(fpstacktopl, "fabs",  w) {: "fabs" :}
inst : UnaryInPlace(fpstacktopl, "fsqrt", w) {: "fsqrt" :}
inst : UnaryInPlace(fpstacktopl, "fneg",  w) {: "fchs" :}
inst : Store(fpstacktopl, Frnd(fpstacktop), w) {: "frndint" :}
@ 
%%It will be good to remove the ugly wart on ocamlburg that makes it
%%impossible to nest constructors and get to the free variables.
<<rules(x86rec.nw)>>=
i2f_mem : I2f(s:w, d:w, mem) [{: guard (s = 32 || s = 16) :}] {: s, mem :}
fiadd : Fadd(fpstacktop, i2f_mem) {: i2f_mem :}
inst : Store(fpstacktopl, fiadd, w)
   {: let s, mem = fiadd in sprintf "fiadd%s %s" (suffix s) mem :}
@ 
<<rules(x86rec.nw)>>=
fpccl : Fpccl() {: () :}
fpustatusl : Fpustatusl() {: () :}
fpustatus : Fetch(fpustatusl, w) {: () :}
fpuctll : Fpuctll() {: () :}
fpuctl : Fetch(fpuctll, w) {: () :}
inst : Store(fpccl, Fcmp(fpstacktop, fpstack1), w)
  {: "fcom" :}
inst : Par(Store(fpccl, Fcmp(fpstacktop, fpstack1), w), fppop)
  {: "fcomp" :}
inst : Par(Store(fpccl, Fcmp(fpstacktop, fpstack1), w), fppop2)
  {: "fcompp" :}

inst : Store(meml, fpuctl, w)    {: s "fnstcw %s" meml :}
inst : Store(fpuctll, mem, w)    {: s "fldcw %s"  mem  :}
@ 
<<rules(x86rec.nw)>>=
eax : Reg('r', n) [{: guard (n = 0):}]  {: () :}
ecx : Reg('r', n) [{: guard (n = 1):}]  {: () :}
edx : Reg('r', n) [{: guard (n = 2):}]  {: () :}
esi : Reg('r', n) [{: guard (n = 6):}]  {: () :}
edi : Reg('r', n) [{: guard (n = 7):}]  {: () :}
ax  : Slice(w, lsb:n, eax) [{: guard (w = 16 && lsb = 0):}]  {: "%ax" :}
ah  : Slice(w, lsb:n, eax) [{: guard (w = 8  && lsb = 8):}]  {: "%ah" :}
ahval : BitExtract(eight, Fetch(eax, fw:w), w) [{: guard (w = 8) :}] {: "%ah" :}
ahval : Fetch(ah, w) [{: guard (w=8) :}] {: ah :}

inst : Store(eax, BitInsert(zero, Fetch(eax, w), fpustatus), sw:w) {: "fstsw %ax" :}
inst : Store(ax,  fpustatus, w) [{: guard (w = 16) :}] {: s "fstsw %s" ax :}
inst : Setflags(Ah2flags(ahval)) {: "sahf" :}
inst : Store(ah,  Flags2ah(Fetch(eflags, fw:w)), w) {: "lahf" :}
@ 
%%\paragraph{Other instructions}
<<rules(x86rec.nw)>>=
inst : Nop() {: "nop" :}
@ 
%%\paragraph{Support for debugging}
%%If an RTL should fail to match, one can uncomment the following rule
%%and get a printout of exactly how that RTL is represented using {\burg}
%%constructors. 
<<rules(x86rec.nw)>>=
inst: any [100] {: "<" ^ any ^ ">" :}

any : True  () {: "True"  :}
any : False () {: "False" :}
any : Link(symbol, w) {: "Link(" ^ symbol#mangled_text ^ "," ^ string_of_int w ^ ")" :}
any : Late(string, w) {: "Late(" ^ string ^ "," ^ string_of_int w ^")" :}
any : Diff(c1:any,c2:any) {: "Diff(" ^ c1 ^ "," ^ c2 ^ ")" :}
any : Bits(bits)     {: sprintf "Bits(%s)" (Bits.to_string bits) :}

any : Fetch (any, w) {: "Fetch(" ^ any ^ "," ^ string_of_int w ^ ")" :}

any : And(x:any, y:any) {: "And(" ^ x ^ ", " ^ y ^ ")" :}
any : Or(x:any, y:any)  {: "Or("  ^ x ^ ", " ^ y ^ ")" :}
any : Xor(x:any, y:any) {: "Xor(" ^ x ^ ", " ^ y ^ ")" :}
any : Com(x:any) {: "Com(" ^ x ^ ")" :}


any : Add(x:any, y:any) {: "Add(" ^ x ^ ", " ^ y ^ ")" :}
any : Mul(x:any, y:any) {: "Mul(" ^ x ^ ", " ^ y ^ ")" :}
any : Fadd(x:any, y:any) {: sprintf "Fadd(%s, %s)" x y :}
any : Fsub(x:any, y:any) {: sprintf "Fsub(%s, %s)" x y :}
any : Fmul(x:any, y:any) {: sprintf "Fmul(%s, %s)" x y :}
any : Fdiv(x:any, y:any) {: sprintf "Fdiv(%s, %s)" x y :}

any : Singlebit(string, x:any, y:any, z:any)
    {: sprintf "Singlebit(%s, %s, %s, %s)" string x y z :}

any : Fneg(any) {: sprintf "Fneg(%s)" any :}
any : Fabs(any) {: sprintf "Fabs(%s)" any :}

any : Fpccl() {: "Fpcc()" :}
any : Fpustatusl() {: "Fpustatus()" :}
any : Fpuctll() {: "Fpuctl()" :}
any : BitInsert(x:any, y:any, z:any) {: sprintf "BitInsert(%s, %s, %s)" x y z :}
any : BitExtract(lsb:any, y:any, n:w) {: sprintf "BitExtract(%s, %s, %d)" lsb y n :}
any : Slice(n:w, lsb:n, y:any) {: sprintf "Slice(%d, %d, %s)" n lsb y :}
any : Ah2flags(any) {: sprintf "Ah2flags(%s)" any :}
any : Flags2ah(any) {: sprintf "Flags2ah(%s)" any :}

any : Sx(any) {: "Sx(" ^ any ^ ")" :}
any : Zx(any) {: "Zx(" ^ any ^ ")" :}
any : F2f(n:w, w, any) {: sprintf "F2f(%d, %d, %s)" n w any :}
any : F2i(n:w, w, any) {: sprintf "F2i(%d, %d, %s)" n w any :}
any : I2f(n:w, w, any) {: sprintf "I2f(%d, %d, %s)" n w any :}
any : Lobits(any, w) {: "Lobits(" ^ any ^ ", " ^ string_of_int w ^ ")" :}
any : X86_subflags(l:any, r:any) {: "X86_subflags(" ^ l ^ ", " ^ r ^ ")" :}
any : X86_addflags(l:any, r:any) {: "X86_addflags(" ^ l ^ ", " ^ r ^ ")" :}
any : X86ccop(string, cc:any) {: "X86ccop(" ^ string ^ ", " ^ cc ^ ")" :}
any : X86op(string) {: "X86op(" ^ string ^ ")" :}

any : NonLlrOp(string) {: "NonLlrOp(" ^ string ^ ")" :}
any : Shift(string, x:any, y:any) {: sprintf "Shift(%s, %s, %s)" string x y :}

any : Mem(any, c) {: "Mem(" ^any ^ "," ^ string_of_int c ^ ")" :}
any : Reg  (char, n) {: sprintf "Reg(%s, %d)"   (Char.escaped char) n :}
any : Fpreg(any) {: sprintf "Fpreg(%s)" any :}

any : Store (dst:any, src:any, w)
 {: "Store(" ^ dst ^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}
any : Kill(any) {: "Kill(" ^ any ^ ")" :}

any : Repmovs(esi:any, edi:any, ecx:any)
 {: "Repmovs(" ^ esi ^ "," ^ edi ^ "," ^ ecx ^ ")" :}

any : Guarded(guard:any, any) {: "Guarded(" ^ guard ^ "," ^ any ^ ")" :}
any : Par(l:any, r:any) {: "Par(" ^ l ^ "," ^ r ^ ")" :}
any : Goto(any) {: "Goto(" ^ any ^ ")" :}
any : Setflags(any) {: "Setflags(" ^ any ^ ")" :}
any : Llr(dst:any, string, src:any, w) 
  {: "Llr(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ ")" :}
any : UnaryInPlace(dst:any, string, w) 
  {: "UnaryInPlace(" ^ dst ^","^string^ "," ^ string_of_int w ^ ")" :}

any : Withaflags(dst:any, string, src:any, w, fo:string) 
  {: "Withaflags(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ 
      ","^ fo ^ ")" :}

any : Withlflags(dst:any, string, src:any, w, fo:string) 
  {: "Withlflags(" ^ dst ^","^string^ "," ^ src ^ "," ^ string_of_int w ^ 
      ","^ fo ^ ")" :}

any : Withlflags8H(dst:any, string, src:any, fo:string) 
  {: "Withlflags8H(" ^ dst ^","^string^ "," ^ src ^ "," ^ fo ^ ")" :}

any : Jcc(string, any) {: "Jcc(" ^ string ^ "," ^ any ^ ")" :}
@
%%
%%
%%% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
%%% ------------------------------------------------------------------ 
%%
%%The code in this section walks an RTL and calls suitable \burg\
%%constructors. 
%%The most interesting code is probably the code that maps the
%%general representation of application into one that uses a unique
%%constructor for each operator.
<<special cases for particular operators>>=
| RP.App(("and", [w]), [x; y]) -> conAnd (exp x) (exp y)
| RP.App(("or",  [w]), [x; y]) -> conOr (exp x) (exp y)
| RP.App(("xor", [w]), [x; y]) -> conXor (exp x) (exp y)
| RP.App(("com", [w]), [x])    -> conCom (exp x)
| RP.App(("add", [w]), [x; y]) -> conAdd (exp x) (exp y)
| RP.App(("sub", [w]), [x; y]) -> conSub (exp x) (exp y)
| RP.App((("addc"|"subb"|"carry"|"borrow") as op, [w]), [x; y; z]) ->
    conSinglebit op (exp x) (exp y) (exp z)
(*| RP.App(("neg", [w]), [x])    -> conNeg (exp x)*)
| RP.App(("mul", [w]), [x; y]) -> conMul (exp x) (exp y)
| RP.App(("sx",  [n;w]), [x])   -> conSx  (exp x)
| RP.App(("zx",  [n;w]), [x])   -> conZx  (exp x)
| RP.App(("f2f", [n;w]), [x; rm])   -> conF2f n w (exp x) (* need to assert rm *)
| RP.App(("f2i", [n;w]), [x; rm])   -> conF2i n w (exp x) (* need to assert rm *)
| RP.App(("i2f", [n;w]), [x; rm])   -> conI2f n w (exp x) (* need to assert rm *)
| RP.App(("fadd", [w]), [x; y; rm]) -> conFadd (exp x) (exp y) (* need to assert rm *)
| RP.App(("fsub", [w]), [x; y; rm]) -> conFsub (exp x) (exp y) (* need to assert rm *)
| RP.App(("fmul", [w]), [x; y; rm]) -> conFmul (exp x) (exp y) (* need to assert rm *)
| RP.App(("fdiv", [w]), [x; y; rm]) -> conFdiv (exp x) (exp y) (* need to assert rm *)
| RP.App(("fneg", [w]), [x]) -> conFneg (exp x)
| RP.App(("fabs", [w]), [x]) -> conFabs (exp x)
| RP.App(("x86_fcmp", [w]), [x; y]) -> conFcmp (exp x) (exp y)
| RP.App((("x86_e" | "x86_ne" | "x86_l" | "x86_le" | "x86_g" | "x86_ge"
          | "x86_b" | "x86_be" | "x86_a" | "x86_ae") as o, _), [x]) ->
              conX86ccop o (exp x)
| RP.App(("lobits", [w;n]), [x])   -> conLobits (exp x) n
| RP.App(("x86_subflags", [w]), [x; y]) -> conX86_subflags (exp x) (exp y)
| RP.App(("x86_addflags", [w]), [x; y]) -> conX86_addflags (exp x) (exp y)
| RP.App(("x86_ah2flags", []), [x]) -> conAh2flags (exp x)
| RP.App(("x86_flags2ah", []), [x]) -> conFlags2ah (exp x)
| RP.App(("x86_repmovs",   [w]), [x;y;z]) -> conRepmovs (exp x) (exp y) (exp z)
| RP.App(("bitInsert", [w; n]), [lsb; dst; src]) ->
    conBitInsert (exp lsb) (exp dst) (exp src)
| RP.App(("bitExtract", [w; n]), [lsb; src]) -> conBitExtract (exp lsb) (exp src) n
| RP.App((("gt"|"lt"|"ge"|"le"|"eq"|"ne"), [w]) as op, [l; r]) ->
    conCmp op (exp l) (exp r)
| RP.App((("shra"|"shrl"|"shl"|"rotl"|"rotr") as op, [w]), [x; y]) -> conShift op (exp x) (exp y)
| RP.App((("quot"|"rem"|"div"|"mod"|"divu"|"modu"|"mulx"|"mulux") as op, [w]), [x; y])->
    conNonLlrOp op
| RP.App((("neg") as op, [w]), [x]) -> conNonLlrOp op
| RP.App(("x86_idt_pc", []), [x]) -> conX86IdtPc (exp x)
| RP.App((("add"|"sub"|"mul"|"sx"|"zx"|"lobits"|"x86_subflags"|"bitInsert"|
           "bitExtract"|"fabs"|"fneg"|"fdiv"|"fmul"|"fsub"|"fadd"|"f2f"|"f2i"|
           "i2f"|"and"|"or"|"xor"|"com") as op, ws), xs)->
    Impossible.impossible
      (Printf.sprintf
         "operator %%%s specialized to %d widths & applied to %d arguments"
         op (List.length ws) (List.length xs))
@ 
%%Here is the rest of the mapping.  
<<code to follow the labeler(x86rec.nw)>>=
let rec const = function
  | RP.Bool(true)             -> conTrue  ()
  | RP.Bool(false)            -> conFalse ()
  | RP.Link(s,_,w)            -> conLink s w
  | RP.Diff(c1,c2)            -> conDiff (const c1) (const c2)
  | RP.Late(s,w)              -> conLate s w
  | RP.Bits(b)                -> conBits(b)
@ 
<<code to follow the labeler(x86rec.nw)>>=
let rec exp = function
  | RP.Const(k)               -> const (k)
  | RP.Fetch(l,w)             -> conFetch (loc l) w
  <<special cases for particular operators>>
  | RP.App((o,_),_) when String.length o > 4 && String.sub o 0 4 =$= "x86_" ->
      conX86op(o)
  | RP.App((o,_),_)           -> error ("unknown operator " ^ o)
@ 
%$
<<code to follow the labeler(x86rec.nw)>>=
and loc l = match l with
  | RP.Mem(('m',_,_), (RP.C c), e, ass) -> conMem (exp e) c
  | RP.Mem(('f',_,_), c, e, ass) -> conFpreg (exp e)
  | (RP.Reg(_, _, _) | RP.Slice(_, _, _)) when RU.Eq.loc l fpcc -> conFpccl ()
  | RP.Reg(sp, i, w) when RU.Eq.loc l fpustatus -> conFpustatusl()
  | RP.Reg(sp, i, w) when RU.Eq.loc l fpuctl    -> conFpuctll()
  | RP.Reg((sp,_,_), i, _) -> conReg sp i
  | RP.Mem(_, _, _, _)     -> error "non-mem, non-reg cell"
  | RP.Var _ | RP.Global _ -> error "var found"
  | RP.Slice(w,i,l)        -> conSlice w i (loc l)
@ 
%%Things start to get a bit baroque here, as we recognize different
%%special forms a single effect can take.
<<code to follow the labeler(x86rec.nw)>>=
and effect = function
  | RP.Store(l, RP.App((o, _), [RP.Fetch(l',_); r]), w) 
    when l =/ l'                      -> conLlr (loc l) o (exp r) w
  | RP.Store(l, RP.App((o, [w']), [RP.Fetch(l',_)]), w)
    when l =/ l' && w = w'            -> conUnaryInPlace (loc l) o w
  | RP.Store(RP.Reg(('c',_,_),i, w),r,_) 
    when (i = SS.indices.SS.pc)       -> conGoto (exp r)
  | RP.Store(RP.Reg(('c', _, _), i, w),r,_)
    when (i = SS.indices.SS.cc)       -> conSetflags (exp r)
  | RP.Store(RP.Reg(('c', _, _), i, _), r, w) -> error ("set $c["^string_of_int i^"]")
  | RP.Store(l,e,w)                   -> conStore (loc l) (exp e) w
  | RP.Kill(l)                        -> conKill (loc l)
@
%$
%%We attempt to recognize register pairs.
<<code to follow the labeler(x86rec.nw)>>=
and regpair = function
  | RP.App(("or",_),[ RP.App(("shl",_), [RP.App(("zx",_), [RP.Fetch(msw,_)]);_])
                    ; RP.App(("zx",_),                    [RP.Fetch(lsw,_)])])
      -> conRegPair (loc msw) (loc lsw)
  | x -> Impossible.impossible "Argument is not a register pair"
@
%%The truly ghastly stuff is the stuff that recognizes multiple
%%effects that set flags.
<<code to follow the labeler(x86rec.nw)>>=
and rtl (RP.Rtl es) = geffects es
and geffects = function
    | [] -> conNop ()
    | [g, s] -> guarded g s
    <<horrible pattern match for [[Pairdestwithflags]]>>
    <<horrible pattern match for [[Withflags]]>>
    <<horrible pattern match for [[addc]] and [[subb]]>>
    | (g, s) :: t -> conPar (guarded g s) (geffects t)
and is8 b =
  Bits.width b > 3 & Bits.Ops.eq b (Bits.U.of_int 8  (Bits.width b))
and is32 b =
  Bits.width b > 5 & Bits.Ops.eq b (Bits.U.of_int 32 (Bits.width b))
@ 
%%Dealing with a guard is straightforward.
%%Either it's trivial, it's a conditional branch, or we pass it off to
%%the recognizer (which currently falls on the floor).
<<code to follow the labeler(x86rec.nw)>>=
and guarded g eff = match g with
| RP.Const(RP.Bool b) -> if b then effect eff else conNop()
| RP.App((compare, [32]), [RP.Fetch(RP.Reg(('c', _, _), n, _), _)])
    when n = SS.indices.SS.cc && begins_x86_ compare ->
      (match eff with
      | RP.Store(RP.Reg(('c', _, _), i, _), r, w)
        when (i = SS.indices.SS.pc) ->
          conJcc (String.sub compare 4 (String.length compare - 4)) (exp r)
      | _ -> error "guard on x86 non-branch")
| _ -> conGuarded (exp g) (effect eff)
and begins_x86_ s =
  String.length s >= 4 &&
  s.[0] =<= 'x' && s.[1] =<= '8' && s.[2] =<= '6' && s.[3] =<= '_'
@
%%Oh, the joy of the flags\ldots
<<truepat>>=
RP.Const(RP.Bool true)
@ 
%%
<<horrible pattern match for [[Pairdestwithflags]]>>=
| [ (
    <<truepat>>
    , 
    <<pattern for [[hi]] := hi32([[l]] [[o]] [[r]] at 32)>>
    )
  ; (
    <<truepat>>
     , 
    <<pattern for [[lo]] := lo32([[l']] [[o']] [[r']] at 32)>>
     )
  ; (
    <<truepat>>
    , 
    <<pattern for flags := [[fo]] ([[l'']], [[r'']])>>
    )
  ] when l =// l' && o =$= o' && r =// r' && l =// RP.Fetch(l'', 32) && r =// r''
      && is32 k32 && flag_index = SS.indices.SS.cc ->
        conPairdestwithflags (loc hi) (loc lo) (exp l) o (exp r) fo
@ 
%$
<<horrible pattern match for [[Withflags]]>>=
| [ (
    <<truepat>>
    , 
    <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>
    )
  ; (
    <<truepat>>
    , 
    <<pattern for [[l2]] := [[l2']] [[o2]] [[r2]] at [[w2]]>>
    )
  ; (
    <<truepat>>
    ,  
    <<pattern for flags := [[%x86_undefflags()]]>>
    )
  ] when l =/ l' && l2 =/ l2' && w = w2 && flag_index = SS.indices.SS.cc ->
      conWithundefflags (loc l) o o2 (exp r) w
@ 
<<horrible pattern match for [[Withflags]]>>=
| [ (
    <<truepat>>
    , 
    <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>
    )
  ; (
    <<truepat>>
   , 
   <<pattern for flags := [[fo]] ([[l'']], [[r']])>>
    )
  ] when l =/ l' && l =/ l'' && r =// r' && flag_index = SS.indices.SS.cc ->
      conWithaflags (loc l) o (exp r) w fo
| [ (
    <<truepat>>
    , 
    <<pattern for [[l]] := [[l']] at [[w]]>>
    )
  ; (
    <<truepat>>
    , 
    <<pattern for flags := [[fo]] ([[l'']], [[Const b]])>>
     )
  ] when l =/ l' && l =/ l'' && Bits.is_zero b && flag_index = SS.indices.SS.cc ->
        conWithaflags (loc l) "add" (exp (RP.Const (RP.Bits b))) w fo
| [ (
    <<truepat>>
    , 
    <<pattern for [[l]] := [[o]] [[l']] at [[w]]>>
    )
  ; (
    <<truepat>>
    , 
    <<pattern for flags := [[fo]] [[l'']])>>
    )
  ] when l =/ l' && l =/ l'' && flag_index = SS.indices.SS.cc ->
      conWithaflagsunary o (loc l) w fo
| [ (
    <<truepat>>
    , 
    <<pattern for [[d]] := rp:[[l1/l2]] [[o]] [[r]] at [[w]]>>
    )
  ; (
    <<truepat>>
    , 
    <<pattern for flags := [[fo]] ([[l1'/l2']], [[r']])>>
    )
  ] when l1 =/ l1' && l2 =/ l2' && r =// r' && flag_index = SS.indices.SS.cc ->
      conWithaflags (regpair rp) o (exp r) w fo
| [ (
    <<truepat>>
    , 
    <<pattern for [[d]] := rp:[[l1/l2]] [[o]] [[r]] at [[w]]>>
    )
  ; (
    <<truepat>>
    , 
    <<pattern for [[d']] := rp':[[l1'/l2']] [[o']] [[r']] at [[w']]>>
    )
  ; (
    <<truepat>>
    , 
    <<pattern for flags := [[%x86_undefflags()]]>>
    )
  ] when w = w' && r =// r' && rp =// rp' && flag_index = SS.indices.SS.cc ->
      conWithundefflags (regpair rp) o o' (exp r) w
| [ (
     <<truepat>>
     , 
     <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>
     )
  ; (
    <<truepat>>
    , 
    <<pattern for flags := [[fo]] ([[l'']] [[o']] [[r']])>>
     )
  ] when l =/ l' && l =/ l'' && r =// r' && o =$= o'
    && flag_index = SS.indices.SS.cc ->
      conWithlflags (loc l) o (exp r) w fo
| [ (
    <<truepat>>
   , 
   <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]] at H register>>
    )
  ; (
    <<truepat>>
    , 
    <<pattern for flags := [[fo]] [[flag_left']]>>
    )
  ] when is8 eightbits && is8 eightbits' && l =/ l' && l =/ l''
      && flag_left =// flag_left' && flag_index = SS.indices.SS.cc ->
      conWithlflags8H (loc l) o (exp r) fo

| [ (
    <<truepat>>
   , 
   <<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]] at H register>>
    )
  ; _
  ] when is8 eightbits && is8 eightbits' && l =/ l' && l =/ l'' ->
      conWithlflags8H (loc l) o (exp r) "x86_mumbojumbo"
(*
  $r[0] := %%bitInsert(8, $r[0], %%and(%%bitExtract(8, $r[0]), 69)) 
| $c[2] := %%x86_logicflags(%%and(%%bitExtract(8, $r[0]), 69))
*)
@ 
%%
<<horrible pattern match for [[addc]] and [[subb]]>>=
| [ (
     <<truepat>>
     , 
     <<pattern for [[l]] := [[o(l',r,CF)]] at [[w]]>>
     )
  ; (
    <<truepat>>
    , 
    <<pattern for flags := [[fo]] ([[l'', r', CF]])>>
     )
  ] when l =/ l' && l =/ l'' && r =// r' && flag_index = SS.indices.SS.cc &&
         cf_index1 = flag_index && cf_index2 = flag_index ->
      conWithcarryflags (loc l) o (exp r) w fo
@ 
%%
<<horrible pattern match for [[addc]] and [[subb]]>>=
| [ (
    <<truepat>>
    , 
    <<pattern for [[l]] := [[o(l',r,z1)]] at [[w]]>>
    )
  ; (
    <<truepat>>
    , 
    <<pattern for flags := [[fo]] ([[l'', r', z2]])>>
    )
  ] when l =/ l' && l =/ l'' && r =// r' && flag_index = SS.indices.SS.cc &&
         Bits.is_zero z1 && Bits.is_zero z2 ->
      conWithcarryzero (loc l) o (exp r) w fo
@ 
<<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]] at H register>>=
RP.Store(l, RP.App(("bitInsert", [32; 8]),
                   [RP.Const (RP.Bits eightbits);
                    RP.Fetch(l', _);
                    RP.App((o, _),
                        [ RP.App(("bitExtract", [32; 8]),
                                   [RP.Const (RP.Bits eightbits'); RP.Fetch(l'',_)]);
                            r]) as flag_left]),
         w)
@ 
<<pattern for flags := [[%x86_undefflags()]]>>=
RP.Store(RP.Reg(('c', _, _), flag_index, _), RP.App(("x86_undefflags", _), []), _)
@ 
<<pattern for flags := [[fo]] [[flag_left']]>>=
RP.Store(RP.Reg(('c', _, _), flag_index, _), RP.App((fo, _), [flag_left']), _)
@ 
<<pattern for [[l]] := [[l']] [[o]] [[r]] at [[w]]>>=
RP.Store(l, RP.App((o, _), [RP.Fetch(l',_); r]), w) 
@ 
<<pattern for [[l]] := [[o(l',r,CF)]] at [[w]]>>=
RP.Store(l, RP.App((o, _), [RP.Fetch(l',_); r; 
    <<cfpat 1>>
   ]), w) 
@ 
<<pattern for [[l]] := [[o(l',r,z1)]] at [[w]]>>=
RP.Store(l, RP.App((o, _), [RP.Fetch(l',_); r; RP.Const (RP.Bits z1)]), w) 
@ 
<<pattern for [[l2]] := [[l2']] [[o2]] [[r2]] at [[w2]]>>=
RP.Store(l2, RP.App((o2, _), [RP.Fetch(l2',_); r2]), w2) 
@ 
<<pattern for [[l]] := [[l']] at [[w]]>>=
RP.Store(l, RP.Fetch(l',_), w) 
@ 
<<pattern for flags := [[fo]] ([[l'']], [[r']])>>=
RP.Store(RP.Reg(('c', _, _), flag_index, _),
         RP.App((fo, _), [RP.Fetch(l'',_); r']), _)
@ 
<<pattern for flags := [[fo]] ([[l'', r', CF]])>>=
RP.Store(RP.Reg(('c', _, _), flag_index, _),
         RP.App((fo, _), [RP.Fetch(l'',_); r';
      <<cfpat 2>>
    ]), _)
@ 
<<pattern for flags := [[fo]] ([[l'', r', z2]])>>=
RP.Store(RP.Reg(('c', _, _), flag_index, _),
         RP.App((fo, _), [RP.Fetch(l'',_); r';RP.Const (RP.Bits z2)]), _)
@ 
<<pattern for flags := [[fo]] ([[l'']], [[Const b]])>>=
RP.Store(RP.Reg(('c', _, _), flag_index, _),
         RP.App((fo, _), [RP.Fetch(l'',_); RP.Const (RP.Bits b)]), _)
@ 
<<pattern for flags := [[fo]] ([[l'']], [[r'']])>>=
RP.Store(RP.Reg(('c', _, _), flag_index, _),
         RP.App((fo, _), [RP.Fetch(l'',_); r'']), _)
@ 
<<pattern for [[l]] := [[o]] [[l']] at [[w]]>>=
RP.Store(l, RP.App((o, _), [RP.Fetch(l',_)]), w) 
@ 
<<pattern for [[hi]] := hi32([[l]] [[o]] [[r]] at 32)>>=
RP.Store(hi, RP.App (("lobits", [64;32]),
                     [RP.App (("shrl", [64]), 
                              [RP.App((o, _), [l; r]);
                               RP.Const (RP.Bits k32)])]), 32)
@ 
<<pattern for [[lo]] := lo32([[l']] [[o']] [[r']] at 32)>>=
RP.Store(lo, RP.App (("lobits", [64;32]), [RP.App((o', _), [l'; r'])]), 32)
@ 
<<pattern for flags := [[fo]] [[l'']])>>=
RP.Store(RP.Reg(('c', _, _), flag_index, _),
         RP.App((fo, _), [RP.Fetch(l'',_)]), _)
@ 
<<pattern for [[d]] := rp:[[l1/l2]] [[o]] [[r]] at [[w]]>>=
RP.Store(d, RP.App((o, _),
  [ (RP.App(("or",_), [ RP.App(("shl",_),
                               [RP.App(("zx",_), [RP.Fetch(l1,_)]);_]);
                                RP.App(("zx",_), [RP.Fetch(l2,_)])]) as rp);
    r]), w)
@ 
<<pattern for [[d']] := rp':[[l1'/l2']] [[o']] [[r']] at [[w']]>>=
RP.Store(d', RP.App((o', _),
  [ (RP.App(("or",_), [ RP.App(("shl",_),
                               [RP.App(("zx",_), [RP.Fetch(l1',_)]);_]);
                                RP.App(("zx",_), [RP.Fetch(l2',_)])]) as rp');
    r']), w')
@ 
<<pattern for flags := [[fo]] ([[l1'/l2']], [[r']])>>=
RP.Store(RP.Reg(('c', _, _), flag_index, _),
         RP.App((fo, _), 
              [ RP.App(("or",_), [ RP.App(("shl",_),
                                     [RP.App(("zx",_), [RP.Fetch(l1',_)]);_])
                     ;                RP.App(("zx",_), [RP.Fetch(l2',_)])])
              ; r']), _)
@ 
<<pattern for flags := [[fo]] ([[l'']] [[o']] [[r']])>>=
RP.Store(RP.Reg(('c', _, _), flag_index, _),
         RP.App((fo, _), [RP.App ((o', _), [RP.Fetch(l'',_); r'])]), _)

@ 
<<cfpat 1>>=
RP.App (("x86_carrybit", _), [RP.Fetch(RP.Reg(('c', _, _), cf_index1, _), _)])
@ 
<<cfpat 2>>=
RP.App (("x86_carrybit", _), [RP.Fetch(RP.Reg(('c', _, _), cf_index2, _), _)])
@
\subsection{The exported recognizers}
%%
%%The only tricky bits here are what we do when something goes wrong.
%%In a production compiler, we should always halt the compiler.
%%But here, it is more informative to drop an error message into the
%%assembly language and to allow the assembler to barf downstream.
<<code to follow the labeler(x86rec.nw)>>=
let errmsg r msg =
  List.iter prerr_string
    [ "recognizer error: "; msg; " on "; RU.ToString.rtl r; "\n" ]

let to_asm r =
  try
    let plan = rtl (Dn.rtl r) in
    plan.inst.Camlburg.action ()
  with 
  | Camlburg.Uncovered -> s " not an instruction: %s"  (RU.ToString.rtl r)
  | Error msg -> (errmsg r msg; " error in recognizer: " ^ msg)

let () = Debug.register "x86rec" "diagnose rejected instructions in x86 recognizer"

let is_instruction r =
  try
    let plan = rtl (Dn.rtl r) in
    if plan.inst.Camlburg.cost < 100 then  (* should be true, but shade this... *)
      true
    else
      (if Debug.on "x86rec" then
         Printf.eprintf "x86rec: rejected RTL %s\n" (plan.inst.Camlburg.action());
       false)
  with 
  | Camlburg.Uncovered -> false
  | Error msg -> (errmsg r msg; false)
@                        
\section{[[arch/x86/x86regs.nw]]}
<<arch/x86/x86regs.ml>>=
<<x86regs.ml>>
@

<<arch/x86/x86regs.mli>>=
<<x86regs.mli>>
@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%
\section{X86 registers}
%%
%%This module exports central information used by several parts of the
%%x86 back end.
%%First we have general-purpose registers.
<<x86regs.mli>>=
val rspace : Register.space
val eax : Register.t
val ecx : Register.t
val edx : Register.t
val ebx : Register.t
val esp : Register.t
val ebp : Register.t
val esi : Register.t
val edi : Register.t
@ 
%%Some important 16-bit and 8-bit registers.
%%These are slices,
%% so they can be exported either as [[Register.x]] or
%%[[Rtl.loc]].\footnote
%%{You might wonder why we don't simply make the cell size 8~bits so
%%  that everything can be type [[Register.t]].
%%  There are several reasons: 32-bit registers seem more natural,
%%  using 32-bit cells makes the register numbering come out in a
%%  relatively safe and sane fashion, and most importantly, not all
%%  parts of all registers have 8-bit pieces.
%%  For example, only some of the ABCD registers, and none of the
%%  others, can be broken into 8-bit pieces.}
%%[[Rtl.loc]] is more convenient.
<<x86regs.mli>>=
val ah : Rtl.loc
val ax : Rtl.loc
val cl : Rtl.loc
@ 
%%To help the recognizer emit assembly language, we give a way to name
%%an 8-bit register.
<<x86regs.mli>>=
val regname8 : lsb:int -> base:int -> string
@ 
%%Floating-point control, status, condition codes, rounding mode, and so on.
<<x86regs.mli>>=
val fpuctl : Register.t
val fputag : Rtl.loc
val fpustatus : Rtl.loc
val fpcc      : Rtl.loc
val fpround   : Register.x
@
\section{Implementation}
<<x86regs.ml>>=
module R = Rtl
let rspace = ('r', Rtl.Identity, Cell.of_size 32)
let eax = (rspace, 0, Register.C 1)
let ecx = (rspace, 1, Register.C 1)
let edx = (rspace, 2, Register.C 1)
let ebx = (rspace, 3, Register.C 1)
let esp = (rspace, 4, Register.C 1)
let ebp = (rspace, 5, Register.C 1)
let esi = (rspace, 6, Register.C 1)
let edi = (rspace, 7, Register.C 1)

let ah = R.slice  8 ~lsb:8 (R.reg eax)
let ax = R.slice 16 ~lsb:0 (R.reg eax)
let cl = R.slice  8 ~lsb:0 (R.reg ecx)
@ 
%%The floating-point condition codes actually occupy four bits.
%%But because these bits are not contiguous, we let just three bits
%%stand proxy for all four. 
%%The alternative would be to use an [[Automaton.loc]], but the gain in
%%realism isn't worth the extra complexity (especially in the recognizer).
<<x86regs.ml>>=
let espace = ('e', Rtl.Identity, Cell.of_size 16)
let fpuc n = (espace, n, Rtl.C 1)
let fpuctl    = fpuc 0
let fputag    = Rtl.reg (fpuc 2)
let fpustatus = Rtl.reg (fpuc 1)
let fpcc    = Rtl.slice 3 ~lsb:8 fpustatus (* ignores bit 14 == C3 [probably OK] *)
let fpround = Register.Slice (2, 10, fpuctl)
@ 
<<x86regs.ml>>=
let r8_lo  = [| "%al"; "%cl"; "%dl"; "%bl"|]
let r8_hi  = [| "%ah"; "%ch"; "%dh"; "%bh"|]

let regname8 ~lsb ~base = match lsb with
| 0 -> Array.get r8_lo base
| 8 -> Array.get r8_hi base
| _ -> Impossible.impossible "bad lsb in slice denoting 8-bit register"

@ 

\chapter{[[.]]}

\section{[[driver.nw]]}

<<driver.ml>>=
<<driver.ml content>>
@

%<<./driver.mli>>=
%<<driver.mli>>
%@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 sts=4 sw=4 et
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%
%%% ------------------------------------------------------------------ 
\section{Driver}
%%% ------------------------------------------------------------------ 
%%
%%This module presents the compiler as a compositional collection of
%%abstract values and functions. These functions and values are exported
%%as primitives to a Lua interpreter, giving the user a way to customize
%%the compiler.
%%
%%In case of an error, all functions raise [[Error.ErrorExn]]. An error
%%message is typically printed to [[stderr]] before the exception is
%%raised.
%%
%%\begin{itemize}
%%\item [[version]]: print a version information to [[stdout]]. This is
%%      intentionally not a string such it is harder to abuse.
%%\item [[scan]]: scans a file and prints all tokens together with their
%%      source code position. Only useful to debug the scanner.
%%\item [[parse]]: returns the abstract syntax of a {\PAL} file.
%%\item [[emit_asdl]]: writes the {\AST} in {\small ASDL} syntax to
%%      [[stdout]].
%%%pad: where is check ??
%%\item [[check]]: checks the static semantics of a file and returns 
%%      an environment [[env]] value upon success. 
%%\item [[compile]]: compiles an {\AST} to assembly code. The function
%%      calls the Lua function [[optimize]] for every function and passed
%%      the functions control-flow graph [[cfg]] and its [[stack]] to it.
%%\item [[assemble]]: emits an assembler program.
%%\item [[print]]: prints a [[doc]] value to [[stdout]], formatting the
%%      output for a line width of [[width]] characters.       
%%\item [[reinit]]: re-initializes any mutable state.
%%\end{itemize}
%%
%%The compiler is controlled by a Lua interpreter that is build in the
%%\module{main2} module. It takes several user-defined types to extend it.
%%This module provides new Lua types like [[asm]] and [[ast]] for the
%%interpreter, and a library that uses them. 
<<driver.mli>>=

(* the lexer *)
val scan      : string -> unit

(* the parser *)
val parse     : string -> Srcmap.map * Ast.program

(* sexp-based AST printer *)
val emit_asdl : Srcmap.map * Ast.program -> unit

(* basic pretty printer *)
val pretty    : Srcmap.map * Ast.program -> Pp.doc
val print     : Pp.doc -> int -> out_channel -> unit



val elab : 
  swap:bool -> 
  (Rtl.rtl -> string option) -> 
  Srcmap.map * Ast.program ->
 'proc Asm.assembler ->
 ('proc Fenv.Dirty.env' * 'proc Nelab.compunit) Error.error

val compile :
  Ast2ir.tgt -> 
  (Ast2ir.proc -> unit) -> 
  exportglobals:bool -> 
  src:(Srcmap.map * Ast.program) -> 
  asm:Ast2ir.proc Asm.assembler -> 
  validate:bool -> 
  swap:bool -> 
  unit
   (* raises Error.ErrorExn *)

val version   : unit -> unit


val metrics_ok : Metrics.t -> ('a, 'b, 'c) Target.t -> bool


@
%%
%%% ------------------------------------------------------------------ 
\subsection{Caml Implementation}
%%% ------------------------------------------------------------------ 
%%
<<driver.ml content>>=
module E  = Error
module M  = Metrics
module PA = Preast2ir
module T  = Target
@ 
%%
<<driver.ml content>>=
let version () =
    ( This.name     stdout 
    ; output_string stdout " "
    ; This.version  stdout 
    ; output_string stdout 
        " (see also http://www.cminusminus.org)\n"
    )
@ 
%%
<<driver.ml content>>=
let scan file =
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.mk ()                          in
    let scanner     = Scan.scan map                         in
    let location lb = Srcmap.location map (Lexing.lexeme_start lb) in
    let rec loop lb =
        match scanner lb with
            | Parse.EOF -> ()
            | tok       ->
                let (file,line,col) = location lb           in
                let tok             = Scan.tok2str tok      in
                    ( Printf.printf "%-16s %3d %2d %s\n" file line col tok
                    ; loop lb
                    )
    in
        ( Srcmap.sync map 0 (file,1,1)
        ; loop lexbuf
        ; finally ()
        )
@ 
%%
<<driver.ml content>>=
let parse (file:string) = 
    let fd          = try open_in file
                      with Sys_error(msg) -> E.error msg    in
    let finally ()  = close_in fd                           in
    let lexbuf      = Lexing.from_channel fd                in
    let map         = Srcmap.mk ()                          in
    let scanner     = Scan.scan map                         in
        try
            ( Srcmap.sync map 0 (file,1,1)
            ; (map, Parse.program scanner lexbuf) 
            )
        with
            | Parsing.Parse_error ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) "parse error"
              ; E.error "parse error - compilation aborted"
              )
            | E.ErrorExn msg ->
              ( finally()
              ; E.errorPointPrt (map, Lexing.lexeme_start lexbuf) msg
              ; E.error "parse error - compilation aborted"
              )
            | e ->
              ( finally()
              ; raise e
              )
@ 
%%
<<driver.ml content>>=
let emit_asdl (map,ast) =
        AstUtil.sexp_wr_program ast stdout
@
<<driver.ml content>>=
let pretty (map,ast) = Astpp.program ast
let print doc width channel = Pp.ppToFile channel width doc
@ 
%%
\subsection{Driver support for the new front end}
%%
%%Metrics check.  Perhaps the [[Target.t]] should have a [[Metrics.t]] inside.
%%PERHAPS THIS CHECK SHOULD BE MOVED INTO ELAB, WHICH SHOULD ALSO CHECK FOR
%%THINGS LIKE CORRECT CALLING CONVENTIONS AND HARDWARE REGISTERS.
<<driver.ml content>>=
let metrics_ok src tgt =
  let int i = string_of_int i in
  let string s = s in
  let outcome = ref true in
  let unequal property to_string source target = 
    outcome := false;
    Printf.eprintf "source code specifies %s %s, but target %s specifies %s %s\n"
      property (to_string source) tgt.T.name property (to_string target) in
  let (<>) = Pervasives.(<>) in
  if src.M.byteorder <> tgt.T.byteorder then
    unequal "byteorder" Rtlutil.ToUnreadableString.agg src.M.byteorder tgt.T.byteorder;
  if src.M.wordsize <> tgt.T.wordsize then
    unequal "wordsize" int src.M.wordsize tgt.T.wordsize;
  if src.M.pointersize <> tgt.T.pointersize then
    unequal "pointersize" int src.M.pointersize tgt.T.pointersize;
  if src.M.memsize <> tgt.T.memsize then
    unequal "memsize" int src.M.memsize tgt.T.memsize;
  if src.M.float <> Float.name tgt.T.float then
    unequal "float" string src.M.float (Float.name tgt.T.float);
  if src.M.charset <> tgt.T.charset then
    unequal "charset" string src.M.charset tgt.T.charset;
  !outcome
@ 
<<driver.ml content>>=
let elab ~swap validate (map,ast) asm =
  Nelab.program ~swap validate map asm (Nast.program ast)

let compile (PA.T target) opt ~exportglobals ~src ~asm ~validate ~swap =
  (* old: failwith "TODO: pad: Driver.compile and mvaludate" *)

  let validate = if validate then Mvalidate.rtl target else (fun _ -> None) in
  let abort () = Error.error "compilation aborted because of errors" in
  let as_ok = function Error.Ok x -> x | Error.Error -> abort () in
  as_ok (Error.ematch (elab swap validate src asm) (fun (env,compunit) ->
    if metrics_ok (Fenv.Dirty.metrics env) target then
      if Fenv.Dirty.errorFlag env then
        abort ()
      else
        Ast2ir.translate (PA.T target) (Fenv.clean env) opt exportglobals compunit
    else
      Error.error "metrics of source code don't match the target"))
@
\section{[[main2.nw]]}

%<<./this.mli>>=
%<<this.mli>>
%@

%<<./main.ml>>=
%<<main.ml>>
%@

%%% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
%%% vim: ts=8 et sw=4 sts=4
%%% Grades     ::=    "%%Grades:" Quality Importance Urgency
%%% Quality    ::=    A|B|C|D|E
%%% Importance ::=    Central|Subsystem|Peripheral
%%% Urgency    ::=    Immediate|Soon|Later
%%%
%%% Example (at beginning of line): %%Grades: B Central Soon
%%% $Id: main.nw,v 1.57 2006-03-14 02:01:36 nr Exp $
%%
%%% ------------------------------------------------------------------ 
\section{Main}\label{sect:main}
%%% ------------------------------------------------------------------ 
%%
%%This module contains the [[main]] function that is executed when the
%%\C~compiler starts.  It basically just grabs the command line arguments
%%and hands them to the Lua interpreter. 
%%
%%Nothing gets exported from here because this is the top-most module of
%%the hierarchy.
%%
<<main.mli>>=
@
%%
%%We export command-line arguments to the Lua values
%%[[Sys.cmd]] and [[Sys.argv]]. The
%%[[Sys]] table is created if it does not exist. 
%%
<<main.ml>>=
module E = Error
module I = Lualink.I
module V = I.Value

let export_argv g strings =
  I.register_module "Sys"
    ["argv", (V.list V.string).V.embed (List.tl strings);
     "cmd",  V.string.V.embed          (List.hd strings);
    ] g
@
%%At start-up, we load the file [[qc--.lua]] into the interpreter. It
%%defines commonly used functions. The file is searched along a search
%%path. Typically, the [[qc--.lua]] file that is compiled into the table
%%[[Boot]] is found.
%%
%%string into the compiler such that it is always available. During
%%development it is easier to have an external file.
<<main.ml>>=
let main () =
    let argv        = Array.to_list Sys.argv in
    let state       = I.mk () in (* fresh Lua state *)       
    let evaluate e  = ignore (I.dostring state e) in
    let bootscript  = "Util.dosearchfile('qc--.lua', Boot)" in
        try          
            ( export_argv state argv    (* export cmd line  *)
            ; evaluate bootscript       (* boot interpreter *) 
            ; exit 0                    (* success *)
            )
        with
            E.ErrorExn msg as e -> 
                ( E.errorPrt ("uncaught Error exn: " ^ msg)
                ; raise e
                )
@                
%%In \ocaml~no [[main]] function like in C exists but simply all values
%%in a module are evaluated.  However, we simulate this by evaluating
%%[[main ()]]. 
<<main.ml>>=
let _ = main ()
@
%%During development bugs are easier to find with the debugger if we
%%don't catch exceptions on the top-level. Shipping code, however,
%%should use instead the following:
<<main.ml unused>>=
let _ = try main () with e -> 
        ( Printf.eprintf "%s\n" (Printexc.to_string e)
        ; Printf.eprintf "Please report this problem to bugs@cminusminus.org\n"
        ; Printf.eprintf "Exit with exit code 2\n"
        ; exit 2
        )
@
%%      
%%% ------------------------------------------------------------------  
\section{This}
%%% ------------------------------------------------------------------  
%%
%%To include some version information into the main binary we provide the
%%[[This]] module.  Its source code [[this.ml]] is created during the
%%build process from [[this.in]].  Currently only the version information
%%stays here but it is a useful place for other informations that change
%%frequently.  Note, that version informations  should \emph{not} be used
%%to control the behavior of the program.  We therefore write all these
%%informations to a stream to emphasize this.
%%
%%At startup the compiler executes a file [[qc--.lua]] in the Lua
%%interpreter. One version of this file is compiled into the binary as
%%[[This.boot]].
%%
<<this.mli>>=
val name        : out_channel -> unit
val version     : out_channel -> unit 
(* pad: TODO
val boot        : string (* contents of "qc--.lua" *)
val manual      : string (* manual page qc--(1)    *)
val byteorder   : string (* "big" | "little" *)
val arch_os     : string (* "x86-linux" *)
val install_dir : string (* "/usr/local" *)
*)

@
%%
%%Here is the implementation. The golory details are also in the [[mk]]
%%file in this directory.
%%
<<this.in>>=
(* Do not edit - this file is created from this.in through mk(1) 
 * If this file does not compile, check the following files:
 * (1) main2.nw - this.in is defined here
 * (2) mkfile target this.ml - constructs the boot string
 *)

let system          = "@this@"
@
%%
%%The functions [[name]] and [[version]] decompose the [[system]]
%%string to get its name and version. 
%%
<<this.in>>=
let name channel = 
    let s = try let minus = String.rindex system '-' in
                String.sub system 0 minus
            with Not_found -> "not configured"
    in
         output_string channel s
@ 
%%
<<this.in>>=
let version channel = 
    let s = try let minus = String.rindex system '-' in
                String.sub system (minus+1) (String.length system - minus - 1)
            with Not_found -> "not configured"
    in
        output_string channel s
@
